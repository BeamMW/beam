// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: messages-crypto.proto

#ifndef PROTOBUF_INCLUDED_messages_2dcrypto_2eproto
#define PROTOBUF_INCLUDED_messages_2dcrypto_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3007000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3007000 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_messages_2dcrypto_2eproto

// Internal implementation detail -- do not use these members.
struct TableStruct_messages_2dcrypto_2eproto {
  static const ::google::protobuf::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::google::protobuf::internal::ParseTable schema[11]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::google::protobuf::internal::FieldMetadata field_metadata[];
  static const ::google::protobuf::internal::SerializationTable serialization_table[];
  static const ::google::protobuf::uint32 offsets[];
};
void AddDescriptors_messages_2dcrypto_2eproto();
namespace hw {
namespace trezor {
namespace messages {
namespace crypto {
class CipherKeyValue;
class CipherKeyValueDefaultTypeInternal;
extern CipherKeyValueDefaultTypeInternal _CipherKeyValue_default_instance_;
class CipheredKeyValue;
class CipheredKeyValueDefaultTypeInternal;
extern CipheredKeyValueDefaultTypeInternal _CipheredKeyValue_default_instance_;
class CosiCommit;
class CosiCommitDefaultTypeInternal;
extern CosiCommitDefaultTypeInternal _CosiCommit_default_instance_;
class CosiCommitment;
class CosiCommitmentDefaultTypeInternal;
extern CosiCommitmentDefaultTypeInternal _CosiCommitment_default_instance_;
class CosiSign;
class CosiSignDefaultTypeInternal;
extern CosiSignDefaultTypeInternal _CosiSign_default_instance_;
class CosiSignature;
class CosiSignatureDefaultTypeInternal;
extern CosiSignatureDefaultTypeInternal _CosiSignature_default_instance_;
class ECDHSessionKey;
class ECDHSessionKeyDefaultTypeInternal;
extern ECDHSessionKeyDefaultTypeInternal _ECDHSessionKey_default_instance_;
class GetECDHSessionKey;
class GetECDHSessionKeyDefaultTypeInternal;
extern GetECDHSessionKeyDefaultTypeInternal _GetECDHSessionKey_default_instance_;
class IdentityType;
class IdentityTypeDefaultTypeInternal;
extern IdentityTypeDefaultTypeInternal _IdentityType_default_instance_;
class SignIdentity;
class SignIdentityDefaultTypeInternal;
extern SignIdentityDefaultTypeInternal _SignIdentity_default_instance_;
class SignedIdentity;
class SignedIdentityDefaultTypeInternal;
extern SignedIdentityDefaultTypeInternal _SignedIdentity_default_instance_;
}  // namespace crypto
}  // namespace messages
}  // namespace trezor
}  // namespace hw
namespace google {
namespace protobuf {
template<> ::hw::trezor::messages::crypto::CipherKeyValue* Arena::CreateMaybeMessage<::hw::trezor::messages::crypto::CipherKeyValue>(Arena*);
template<> ::hw::trezor::messages::crypto::CipheredKeyValue* Arena::CreateMaybeMessage<::hw::trezor::messages::crypto::CipheredKeyValue>(Arena*);
template<> ::hw::trezor::messages::crypto::CosiCommit* Arena::CreateMaybeMessage<::hw::trezor::messages::crypto::CosiCommit>(Arena*);
template<> ::hw::trezor::messages::crypto::CosiCommitment* Arena::CreateMaybeMessage<::hw::trezor::messages::crypto::CosiCommitment>(Arena*);
template<> ::hw::trezor::messages::crypto::CosiSign* Arena::CreateMaybeMessage<::hw::trezor::messages::crypto::CosiSign>(Arena*);
template<> ::hw::trezor::messages::crypto::CosiSignature* Arena::CreateMaybeMessage<::hw::trezor::messages::crypto::CosiSignature>(Arena*);
template<> ::hw::trezor::messages::crypto::ECDHSessionKey* Arena::CreateMaybeMessage<::hw::trezor::messages::crypto::ECDHSessionKey>(Arena*);
template<> ::hw::trezor::messages::crypto::GetECDHSessionKey* Arena::CreateMaybeMessage<::hw::trezor::messages::crypto::GetECDHSessionKey>(Arena*);
template<> ::hw::trezor::messages::crypto::IdentityType* Arena::CreateMaybeMessage<::hw::trezor::messages::crypto::IdentityType>(Arena*);
template<> ::hw::trezor::messages::crypto::SignIdentity* Arena::CreateMaybeMessage<::hw::trezor::messages::crypto::SignIdentity>(Arena*);
template<> ::hw::trezor::messages::crypto::SignedIdentity* Arena::CreateMaybeMessage<::hw::trezor::messages::crypto::SignedIdentity>(Arena*);
}  // namespace protobuf
}  // namespace google
namespace hw {
namespace trezor {
namespace messages {
namespace crypto {

// ===================================================================

class CipherKeyValue final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:hw.trezor.messages.crypto.CipherKeyValue) */ {
 public:
  CipherKeyValue();
  virtual ~CipherKeyValue();

  CipherKeyValue(const CipherKeyValue& from);

  inline CipherKeyValue& operator=(const CipherKeyValue& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  CipherKeyValue(CipherKeyValue&& from) noexcept
    : CipherKeyValue() {
    *this = ::std::move(from);
  }

  inline CipherKeyValue& operator=(CipherKeyValue&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const CipherKeyValue& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CipherKeyValue* internal_default_instance() {
    return reinterpret_cast<const CipherKeyValue*>(
               &_CipherKeyValue_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  void Swap(CipherKeyValue* other);
  friend void swap(CipherKeyValue& a, CipherKeyValue& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline CipherKeyValue* New() const final {
    return CreateMaybeMessage<CipherKeyValue>(nullptr);
  }

  CipherKeyValue* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<CipherKeyValue>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const CipherKeyValue& from);
  void MergeFrom(const CipherKeyValue& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CipherKeyValue* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated uint32 address_n = 1;
  int address_n_size() const;
  void clear_address_n();
  static const int kAddressNFieldNumber = 1;
  ::google::protobuf::uint32 address_n(int index) const;
  void set_address_n(int index, ::google::protobuf::uint32 value);
  void add_address_n(::google::protobuf::uint32 value);
  const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      address_n() const;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable_address_n();

  // optional string key = 2;
  bool has_key() const;
  void clear_key();
  static const int kKeyFieldNumber = 2;
  const ::std::string& key() const;
  void set_key(const ::std::string& value);
  #if LANG_CXX11
  void set_key(::std::string&& value);
  #endif
  void set_key(const char* value);
  void set_key(const char* value, size_t size);
  ::std::string* mutable_key();
  ::std::string* release_key();
  void set_allocated_key(::std::string* key);

  // optional bytes value = 3;
  bool has_value() const;
  void clear_value();
  static const int kValueFieldNumber = 3;
  const ::std::string& value() const;
  void set_value(const ::std::string& value);
  #if LANG_CXX11
  void set_value(::std::string&& value);
  #endif
  void set_value(const char* value);
  void set_value(const void* value, size_t size);
  ::std::string* mutable_value();
  ::std::string* release_value();
  void set_allocated_value(::std::string* value);

  // optional bytes iv = 7;
  bool has_iv() const;
  void clear_iv();
  static const int kIvFieldNumber = 7;
  const ::std::string& iv() const;
  void set_iv(const ::std::string& value);
  #if LANG_CXX11
  void set_iv(::std::string&& value);
  #endif
  void set_iv(const char* value);
  void set_iv(const void* value, size_t size);
  ::std::string* mutable_iv();
  ::std::string* release_iv();
  void set_allocated_iv(::std::string* iv);

  // optional bool encrypt = 4;
  bool has_encrypt() const;
  void clear_encrypt();
  static const int kEncryptFieldNumber = 4;
  bool encrypt() const;
  void set_encrypt(bool value);

  // optional bool ask_on_encrypt = 5;
  bool has_ask_on_encrypt() const;
  void clear_ask_on_encrypt();
  static const int kAskOnEncryptFieldNumber = 5;
  bool ask_on_encrypt() const;
  void set_ask_on_encrypt(bool value);

  // optional bool ask_on_decrypt = 6;
  bool has_ask_on_decrypt() const;
  void clear_ask_on_decrypt();
  static const int kAskOnDecryptFieldNumber = 6;
  bool ask_on_decrypt() const;
  void set_ask_on_decrypt(bool value);

  // @@protoc_insertion_point(class_scope:hw.trezor.messages.crypto.CipherKeyValue)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > address_n_;
  ::google::protobuf::internal::ArenaStringPtr key_;
  ::google::protobuf::internal::ArenaStringPtr value_;
  ::google::protobuf::internal::ArenaStringPtr iv_;
  bool encrypt_;
  bool ask_on_encrypt_;
  bool ask_on_decrypt_;
  friend struct ::TableStruct_messages_2dcrypto_2eproto;
};
// -------------------------------------------------------------------

class CipheredKeyValue final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:hw.trezor.messages.crypto.CipheredKeyValue) */ {
 public:
  CipheredKeyValue();
  virtual ~CipheredKeyValue();

  CipheredKeyValue(const CipheredKeyValue& from);

  inline CipheredKeyValue& operator=(const CipheredKeyValue& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  CipheredKeyValue(CipheredKeyValue&& from) noexcept
    : CipheredKeyValue() {
    *this = ::std::move(from);
  }

  inline CipheredKeyValue& operator=(CipheredKeyValue&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const CipheredKeyValue& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CipheredKeyValue* internal_default_instance() {
    return reinterpret_cast<const CipheredKeyValue*>(
               &_CipheredKeyValue_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  void Swap(CipheredKeyValue* other);
  friend void swap(CipheredKeyValue& a, CipheredKeyValue& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline CipheredKeyValue* New() const final {
    return CreateMaybeMessage<CipheredKeyValue>(nullptr);
  }

  CipheredKeyValue* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<CipheredKeyValue>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const CipheredKeyValue& from);
  void MergeFrom(const CipheredKeyValue& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CipheredKeyValue* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bytes value = 1;
  bool has_value() const;
  void clear_value();
  static const int kValueFieldNumber = 1;
  const ::std::string& value() const;
  void set_value(const ::std::string& value);
  #if LANG_CXX11
  void set_value(::std::string&& value);
  #endif
  void set_value(const char* value);
  void set_value(const void* value, size_t size);
  ::std::string* mutable_value();
  ::std::string* release_value();
  void set_allocated_value(::std::string* value);

  // @@protoc_insertion_point(class_scope:hw.trezor.messages.crypto.CipheredKeyValue)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr value_;
  friend struct ::TableStruct_messages_2dcrypto_2eproto;
};
// -------------------------------------------------------------------

class IdentityType final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:hw.trezor.messages.crypto.IdentityType) */ {
 public:
  IdentityType();
  virtual ~IdentityType();

  IdentityType(const IdentityType& from);

  inline IdentityType& operator=(const IdentityType& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  IdentityType(IdentityType&& from) noexcept
    : IdentityType() {
    *this = ::std::move(from);
  }

  inline IdentityType& operator=(IdentityType&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const IdentityType& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const IdentityType* internal_default_instance() {
    return reinterpret_cast<const IdentityType*>(
               &_IdentityType_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  void Swap(IdentityType* other);
  friend void swap(IdentityType& a, IdentityType& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline IdentityType* New() const final {
    return CreateMaybeMessage<IdentityType>(nullptr);
  }

  IdentityType* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<IdentityType>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const IdentityType& from);
  void MergeFrom(const IdentityType& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(IdentityType* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string proto = 1;
  bool has_proto() const;
  void clear_proto();
  static const int kProtoFieldNumber = 1;
  const ::std::string& proto() const;
  void set_proto(const ::std::string& value);
  #if LANG_CXX11
  void set_proto(::std::string&& value);
  #endif
  void set_proto(const char* value);
  void set_proto(const char* value, size_t size);
  ::std::string* mutable_proto();
  ::std::string* release_proto();
  void set_allocated_proto(::std::string* proto);

  // optional string user = 2;
  bool has_user() const;
  void clear_user();
  static const int kUserFieldNumber = 2;
  const ::std::string& user() const;
  void set_user(const ::std::string& value);
  #if LANG_CXX11
  void set_user(::std::string&& value);
  #endif
  void set_user(const char* value);
  void set_user(const char* value, size_t size);
  ::std::string* mutable_user();
  ::std::string* release_user();
  void set_allocated_user(::std::string* user);

  // optional string host = 3;
  bool has_host() const;
  void clear_host();
  static const int kHostFieldNumber = 3;
  const ::std::string& host() const;
  void set_host(const ::std::string& value);
  #if LANG_CXX11
  void set_host(::std::string&& value);
  #endif
  void set_host(const char* value);
  void set_host(const char* value, size_t size);
  ::std::string* mutable_host();
  ::std::string* release_host();
  void set_allocated_host(::std::string* host);

  // optional string port = 4;
  bool has_port() const;
  void clear_port();
  static const int kPortFieldNumber = 4;
  const ::std::string& port() const;
  void set_port(const ::std::string& value);
  #if LANG_CXX11
  void set_port(::std::string&& value);
  #endif
  void set_port(const char* value);
  void set_port(const char* value, size_t size);
  ::std::string* mutable_port();
  ::std::string* release_port();
  void set_allocated_port(::std::string* port);

  // optional string path = 5;
  bool has_path() const;
  void clear_path();
  static const int kPathFieldNumber = 5;
  const ::std::string& path() const;
  void set_path(const ::std::string& value);
  #if LANG_CXX11
  void set_path(::std::string&& value);
  #endif
  void set_path(const char* value);
  void set_path(const char* value, size_t size);
  ::std::string* mutable_path();
  ::std::string* release_path();
  void set_allocated_path(::std::string* path);

  // optional uint32 index = 6 [default = 0];
  bool has_index() const;
  void clear_index();
  static const int kIndexFieldNumber = 6;
  ::google::protobuf::uint32 index() const;
  void set_index(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:hw.trezor.messages.crypto.IdentityType)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr proto_;
  ::google::protobuf::internal::ArenaStringPtr user_;
  ::google::protobuf::internal::ArenaStringPtr host_;
  ::google::protobuf::internal::ArenaStringPtr port_;
  ::google::protobuf::internal::ArenaStringPtr path_;
  ::google::protobuf::uint32 index_;
  friend struct ::TableStruct_messages_2dcrypto_2eproto;
};
// -------------------------------------------------------------------

class SignIdentity final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:hw.trezor.messages.crypto.SignIdentity) */ {
 public:
  SignIdentity();
  virtual ~SignIdentity();

  SignIdentity(const SignIdentity& from);

  inline SignIdentity& operator=(const SignIdentity& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  SignIdentity(SignIdentity&& from) noexcept
    : SignIdentity() {
    *this = ::std::move(from);
  }

  inline SignIdentity& operator=(SignIdentity&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const SignIdentity& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SignIdentity* internal_default_instance() {
    return reinterpret_cast<const SignIdentity*>(
               &_SignIdentity_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  void Swap(SignIdentity* other);
  friend void swap(SignIdentity& a, SignIdentity& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline SignIdentity* New() const final {
    return CreateMaybeMessage<SignIdentity>(nullptr);
  }

  SignIdentity* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<SignIdentity>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const SignIdentity& from);
  void MergeFrom(const SignIdentity& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SignIdentity* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bytes challenge_hidden = 2;
  bool has_challenge_hidden() const;
  void clear_challenge_hidden();
  static const int kChallengeHiddenFieldNumber = 2;
  const ::std::string& challenge_hidden() const;
  void set_challenge_hidden(const ::std::string& value);
  #if LANG_CXX11
  void set_challenge_hidden(::std::string&& value);
  #endif
  void set_challenge_hidden(const char* value);
  void set_challenge_hidden(const void* value, size_t size);
  ::std::string* mutable_challenge_hidden();
  ::std::string* release_challenge_hidden();
  void set_allocated_challenge_hidden(::std::string* challenge_hidden);

  // optional string challenge_visual = 3;
  bool has_challenge_visual() const;
  void clear_challenge_visual();
  static const int kChallengeVisualFieldNumber = 3;
  const ::std::string& challenge_visual() const;
  void set_challenge_visual(const ::std::string& value);
  #if LANG_CXX11
  void set_challenge_visual(::std::string&& value);
  #endif
  void set_challenge_visual(const char* value);
  void set_challenge_visual(const char* value, size_t size);
  ::std::string* mutable_challenge_visual();
  ::std::string* release_challenge_visual();
  void set_allocated_challenge_visual(::std::string* challenge_visual);

  // optional string ecdsa_curve_name = 4;
  bool has_ecdsa_curve_name() const;
  void clear_ecdsa_curve_name();
  static const int kEcdsaCurveNameFieldNumber = 4;
  const ::std::string& ecdsa_curve_name() const;
  void set_ecdsa_curve_name(const ::std::string& value);
  #if LANG_CXX11
  void set_ecdsa_curve_name(::std::string&& value);
  #endif
  void set_ecdsa_curve_name(const char* value);
  void set_ecdsa_curve_name(const char* value, size_t size);
  ::std::string* mutable_ecdsa_curve_name();
  ::std::string* release_ecdsa_curve_name();
  void set_allocated_ecdsa_curve_name(::std::string* ecdsa_curve_name);

  // optional .hw.trezor.messages.crypto.IdentityType identity = 1;
  bool has_identity() const;
  void clear_identity();
  static const int kIdentityFieldNumber = 1;
  const ::hw::trezor::messages::crypto::IdentityType& identity() const;
  ::hw::trezor::messages::crypto::IdentityType* release_identity();
  ::hw::trezor::messages::crypto::IdentityType* mutable_identity();
  void set_allocated_identity(::hw::trezor::messages::crypto::IdentityType* identity);

  // @@protoc_insertion_point(class_scope:hw.trezor.messages.crypto.SignIdentity)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr challenge_hidden_;
  ::google::protobuf::internal::ArenaStringPtr challenge_visual_;
  ::google::protobuf::internal::ArenaStringPtr ecdsa_curve_name_;
  ::hw::trezor::messages::crypto::IdentityType* identity_;
  friend struct ::TableStruct_messages_2dcrypto_2eproto;
};
// -------------------------------------------------------------------

class SignedIdentity final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:hw.trezor.messages.crypto.SignedIdentity) */ {
 public:
  SignedIdentity();
  virtual ~SignedIdentity();

  SignedIdentity(const SignedIdentity& from);

  inline SignedIdentity& operator=(const SignedIdentity& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  SignedIdentity(SignedIdentity&& from) noexcept
    : SignedIdentity() {
    *this = ::std::move(from);
  }

  inline SignedIdentity& operator=(SignedIdentity&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const SignedIdentity& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SignedIdentity* internal_default_instance() {
    return reinterpret_cast<const SignedIdentity*>(
               &_SignedIdentity_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  void Swap(SignedIdentity* other);
  friend void swap(SignedIdentity& a, SignedIdentity& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline SignedIdentity* New() const final {
    return CreateMaybeMessage<SignedIdentity>(nullptr);
  }

  SignedIdentity* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<SignedIdentity>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const SignedIdentity& from);
  void MergeFrom(const SignedIdentity& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SignedIdentity* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string address = 1;
  bool has_address() const;
  void clear_address();
  static const int kAddressFieldNumber = 1;
  const ::std::string& address() const;
  void set_address(const ::std::string& value);
  #if LANG_CXX11
  void set_address(::std::string&& value);
  #endif
  void set_address(const char* value);
  void set_address(const char* value, size_t size);
  ::std::string* mutable_address();
  ::std::string* release_address();
  void set_allocated_address(::std::string* address);

  // optional bytes public_key = 2;
  bool has_public_key() const;
  void clear_public_key();
  static const int kPublicKeyFieldNumber = 2;
  const ::std::string& public_key() const;
  void set_public_key(const ::std::string& value);
  #if LANG_CXX11
  void set_public_key(::std::string&& value);
  #endif
  void set_public_key(const char* value);
  void set_public_key(const void* value, size_t size);
  ::std::string* mutable_public_key();
  ::std::string* release_public_key();
  void set_allocated_public_key(::std::string* public_key);

  // optional bytes signature = 3;
  bool has_signature() const;
  void clear_signature();
  static const int kSignatureFieldNumber = 3;
  const ::std::string& signature() const;
  void set_signature(const ::std::string& value);
  #if LANG_CXX11
  void set_signature(::std::string&& value);
  #endif
  void set_signature(const char* value);
  void set_signature(const void* value, size_t size);
  ::std::string* mutable_signature();
  ::std::string* release_signature();
  void set_allocated_signature(::std::string* signature);

  // @@protoc_insertion_point(class_scope:hw.trezor.messages.crypto.SignedIdentity)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr address_;
  ::google::protobuf::internal::ArenaStringPtr public_key_;
  ::google::protobuf::internal::ArenaStringPtr signature_;
  friend struct ::TableStruct_messages_2dcrypto_2eproto;
};
// -------------------------------------------------------------------

class GetECDHSessionKey final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:hw.trezor.messages.crypto.GetECDHSessionKey) */ {
 public:
  GetECDHSessionKey();
  virtual ~GetECDHSessionKey();

  GetECDHSessionKey(const GetECDHSessionKey& from);

  inline GetECDHSessionKey& operator=(const GetECDHSessionKey& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  GetECDHSessionKey(GetECDHSessionKey&& from) noexcept
    : GetECDHSessionKey() {
    *this = ::std::move(from);
  }

  inline GetECDHSessionKey& operator=(GetECDHSessionKey&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const GetECDHSessionKey& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const GetECDHSessionKey* internal_default_instance() {
    return reinterpret_cast<const GetECDHSessionKey*>(
               &_GetECDHSessionKey_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  void Swap(GetECDHSessionKey* other);
  friend void swap(GetECDHSessionKey& a, GetECDHSessionKey& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline GetECDHSessionKey* New() const final {
    return CreateMaybeMessage<GetECDHSessionKey>(nullptr);
  }

  GetECDHSessionKey* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<GetECDHSessionKey>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const GetECDHSessionKey& from);
  void MergeFrom(const GetECDHSessionKey& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetECDHSessionKey* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bytes peer_public_key = 2;
  bool has_peer_public_key() const;
  void clear_peer_public_key();
  static const int kPeerPublicKeyFieldNumber = 2;
  const ::std::string& peer_public_key() const;
  void set_peer_public_key(const ::std::string& value);
  #if LANG_CXX11
  void set_peer_public_key(::std::string&& value);
  #endif
  void set_peer_public_key(const char* value);
  void set_peer_public_key(const void* value, size_t size);
  ::std::string* mutable_peer_public_key();
  ::std::string* release_peer_public_key();
  void set_allocated_peer_public_key(::std::string* peer_public_key);

  // optional string ecdsa_curve_name = 3;
  bool has_ecdsa_curve_name() const;
  void clear_ecdsa_curve_name();
  static const int kEcdsaCurveNameFieldNumber = 3;
  const ::std::string& ecdsa_curve_name() const;
  void set_ecdsa_curve_name(const ::std::string& value);
  #if LANG_CXX11
  void set_ecdsa_curve_name(::std::string&& value);
  #endif
  void set_ecdsa_curve_name(const char* value);
  void set_ecdsa_curve_name(const char* value, size_t size);
  ::std::string* mutable_ecdsa_curve_name();
  ::std::string* release_ecdsa_curve_name();
  void set_allocated_ecdsa_curve_name(::std::string* ecdsa_curve_name);

  // optional .hw.trezor.messages.crypto.IdentityType identity = 1;
  bool has_identity() const;
  void clear_identity();
  static const int kIdentityFieldNumber = 1;
  const ::hw::trezor::messages::crypto::IdentityType& identity() const;
  ::hw::trezor::messages::crypto::IdentityType* release_identity();
  ::hw::trezor::messages::crypto::IdentityType* mutable_identity();
  void set_allocated_identity(::hw::trezor::messages::crypto::IdentityType* identity);

  // @@protoc_insertion_point(class_scope:hw.trezor.messages.crypto.GetECDHSessionKey)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr peer_public_key_;
  ::google::protobuf::internal::ArenaStringPtr ecdsa_curve_name_;
  ::hw::trezor::messages::crypto::IdentityType* identity_;
  friend struct ::TableStruct_messages_2dcrypto_2eproto;
};
// -------------------------------------------------------------------

class ECDHSessionKey final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:hw.trezor.messages.crypto.ECDHSessionKey) */ {
 public:
  ECDHSessionKey();
  virtual ~ECDHSessionKey();

  ECDHSessionKey(const ECDHSessionKey& from);

  inline ECDHSessionKey& operator=(const ECDHSessionKey& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ECDHSessionKey(ECDHSessionKey&& from) noexcept
    : ECDHSessionKey() {
    *this = ::std::move(from);
  }

  inline ECDHSessionKey& operator=(ECDHSessionKey&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const ECDHSessionKey& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ECDHSessionKey* internal_default_instance() {
    return reinterpret_cast<const ECDHSessionKey*>(
               &_ECDHSessionKey_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  void Swap(ECDHSessionKey* other);
  friend void swap(ECDHSessionKey& a, ECDHSessionKey& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ECDHSessionKey* New() const final {
    return CreateMaybeMessage<ECDHSessionKey>(nullptr);
  }

  ECDHSessionKey* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ECDHSessionKey>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ECDHSessionKey& from);
  void MergeFrom(const ECDHSessionKey& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ECDHSessionKey* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bytes session_key = 1;
  bool has_session_key() const;
  void clear_session_key();
  static const int kSessionKeyFieldNumber = 1;
  const ::std::string& session_key() const;
  void set_session_key(const ::std::string& value);
  #if LANG_CXX11
  void set_session_key(::std::string&& value);
  #endif
  void set_session_key(const char* value);
  void set_session_key(const void* value, size_t size);
  ::std::string* mutable_session_key();
  ::std::string* release_session_key();
  void set_allocated_session_key(::std::string* session_key);

  // @@protoc_insertion_point(class_scope:hw.trezor.messages.crypto.ECDHSessionKey)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr session_key_;
  friend struct ::TableStruct_messages_2dcrypto_2eproto;
};
// -------------------------------------------------------------------

class CosiCommit final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:hw.trezor.messages.crypto.CosiCommit) */ {
 public:
  CosiCommit();
  virtual ~CosiCommit();

  CosiCommit(const CosiCommit& from);

  inline CosiCommit& operator=(const CosiCommit& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  CosiCommit(CosiCommit&& from) noexcept
    : CosiCommit() {
    *this = ::std::move(from);
  }

  inline CosiCommit& operator=(CosiCommit&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const CosiCommit& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CosiCommit* internal_default_instance() {
    return reinterpret_cast<const CosiCommit*>(
               &_CosiCommit_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  void Swap(CosiCommit* other);
  friend void swap(CosiCommit& a, CosiCommit& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline CosiCommit* New() const final {
    return CreateMaybeMessage<CosiCommit>(nullptr);
  }

  CosiCommit* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<CosiCommit>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const CosiCommit& from);
  void MergeFrom(const CosiCommit& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CosiCommit* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated uint32 address_n = 1;
  int address_n_size() const;
  void clear_address_n();
  static const int kAddressNFieldNumber = 1;
  ::google::protobuf::uint32 address_n(int index) const;
  void set_address_n(int index, ::google::protobuf::uint32 value);
  void add_address_n(::google::protobuf::uint32 value);
  const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      address_n() const;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable_address_n();

  // optional bytes data = 2;
  bool has_data() const;
  void clear_data();
  static const int kDataFieldNumber = 2;
  const ::std::string& data() const;
  void set_data(const ::std::string& value);
  #if LANG_CXX11
  void set_data(::std::string&& value);
  #endif
  void set_data(const char* value);
  void set_data(const void* value, size_t size);
  ::std::string* mutable_data();
  ::std::string* release_data();
  void set_allocated_data(::std::string* data);

  // @@protoc_insertion_point(class_scope:hw.trezor.messages.crypto.CosiCommit)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > address_n_;
  ::google::protobuf::internal::ArenaStringPtr data_;
  friend struct ::TableStruct_messages_2dcrypto_2eproto;
};
// -------------------------------------------------------------------

class CosiCommitment final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:hw.trezor.messages.crypto.CosiCommitment) */ {
 public:
  CosiCommitment();
  virtual ~CosiCommitment();

  CosiCommitment(const CosiCommitment& from);

  inline CosiCommitment& operator=(const CosiCommitment& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  CosiCommitment(CosiCommitment&& from) noexcept
    : CosiCommitment() {
    *this = ::std::move(from);
  }

  inline CosiCommitment& operator=(CosiCommitment&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const CosiCommitment& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CosiCommitment* internal_default_instance() {
    return reinterpret_cast<const CosiCommitment*>(
               &_CosiCommitment_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  void Swap(CosiCommitment* other);
  friend void swap(CosiCommitment& a, CosiCommitment& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline CosiCommitment* New() const final {
    return CreateMaybeMessage<CosiCommitment>(nullptr);
  }

  CosiCommitment* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<CosiCommitment>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const CosiCommitment& from);
  void MergeFrom(const CosiCommitment& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CosiCommitment* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bytes commitment = 1;
  bool has_commitment() const;
  void clear_commitment();
  static const int kCommitmentFieldNumber = 1;
  const ::std::string& commitment() const;
  void set_commitment(const ::std::string& value);
  #if LANG_CXX11
  void set_commitment(::std::string&& value);
  #endif
  void set_commitment(const char* value);
  void set_commitment(const void* value, size_t size);
  ::std::string* mutable_commitment();
  ::std::string* release_commitment();
  void set_allocated_commitment(::std::string* commitment);

  // optional bytes pubkey = 2;
  bool has_pubkey() const;
  void clear_pubkey();
  static const int kPubkeyFieldNumber = 2;
  const ::std::string& pubkey() const;
  void set_pubkey(const ::std::string& value);
  #if LANG_CXX11
  void set_pubkey(::std::string&& value);
  #endif
  void set_pubkey(const char* value);
  void set_pubkey(const void* value, size_t size);
  ::std::string* mutable_pubkey();
  ::std::string* release_pubkey();
  void set_allocated_pubkey(::std::string* pubkey);

  // @@protoc_insertion_point(class_scope:hw.trezor.messages.crypto.CosiCommitment)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr commitment_;
  ::google::protobuf::internal::ArenaStringPtr pubkey_;
  friend struct ::TableStruct_messages_2dcrypto_2eproto;
};
// -------------------------------------------------------------------

class CosiSign final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:hw.trezor.messages.crypto.CosiSign) */ {
 public:
  CosiSign();
  virtual ~CosiSign();

  CosiSign(const CosiSign& from);

  inline CosiSign& operator=(const CosiSign& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  CosiSign(CosiSign&& from) noexcept
    : CosiSign() {
    *this = ::std::move(from);
  }

  inline CosiSign& operator=(CosiSign&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const CosiSign& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CosiSign* internal_default_instance() {
    return reinterpret_cast<const CosiSign*>(
               &_CosiSign_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  void Swap(CosiSign* other);
  friend void swap(CosiSign& a, CosiSign& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline CosiSign* New() const final {
    return CreateMaybeMessage<CosiSign>(nullptr);
  }

  CosiSign* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<CosiSign>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const CosiSign& from);
  void MergeFrom(const CosiSign& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CosiSign* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated uint32 address_n = 1;
  int address_n_size() const;
  void clear_address_n();
  static const int kAddressNFieldNumber = 1;
  ::google::protobuf::uint32 address_n(int index) const;
  void set_address_n(int index, ::google::protobuf::uint32 value);
  void add_address_n(::google::protobuf::uint32 value);
  const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      address_n() const;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable_address_n();

  // optional bytes data = 2;
  bool has_data() const;
  void clear_data();
  static const int kDataFieldNumber = 2;
  const ::std::string& data() const;
  void set_data(const ::std::string& value);
  #if LANG_CXX11
  void set_data(::std::string&& value);
  #endif
  void set_data(const char* value);
  void set_data(const void* value, size_t size);
  ::std::string* mutable_data();
  ::std::string* release_data();
  void set_allocated_data(::std::string* data);

  // optional bytes global_commitment = 3;
  bool has_global_commitment() const;
  void clear_global_commitment();
  static const int kGlobalCommitmentFieldNumber = 3;
  const ::std::string& global_commitment() const;
  void set_global_commitment(const ::std::string& value);
  #if LANG_CXX11
  void set_global_commitment(::std::string&& value);
  #endif
  void set_global_commitment(const char* value);
  void set_global_commitment(const void* value, size_t size);
  ::std::string* mutable_global_commitment();
  ::std::string* release_global_commitment();
  void set_allocated_global_commitment(::std::string* global_commitment);

  // optional bytes global_pubkey = 4;
  bool has_global_pubkey() const;
  void clear_global_pubkey();
  static const int kGlobalPubkeyFieldNumber = 4;
  const ::std::string& global_pubkey() const;
  void set_global_pubkey(const ::std::string& value);
  #if LANG_CXX11
  void set_global_pubkey(::std::string&& value);
  #endif
  void set_global_pubkey(const char* value);
  void set_global_pubkey(const void* value, size_t size);
  ::std::string* mutable_global_pubkey();
  ::std::string* release_global_pubkey();
  void set_allocated_global_pubkey(::std::string* global_pubkey);

  // @@protoc_insertion_point(class_scope:hw.trezor.messages.crypto.CosiSign)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > address_n_;
  ::google::protobuf::internal::ArenaStringPtr data_;
  ::google::protobuf::internal::ArenaStringPtr global_commitment_;
  ::google::protobuf::internal::ArenaStringPtr global_pubkey_;
  friend struct ::TableStruct_messages_2dcrypto_2eproto;
};
// -------------------------------------------------------------------

class CosiSignature final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:hw.trezor.messages.crypto.CosiSignature) */ {
 public:
  CosiSignature();
  virtual ~CosiSignature();

  CosiSignature(const CosiSignature& from);

  inline CosiSignature& operator=(const CosiSignature& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  CosiSignature(CosiSignature&& from) noexcept
    : CosiSignature() {
    *this = ::std::move(from);
  }

  inline CosiSignature& operator=(CosiSignature&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const CosiSignature& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CosiSignature* internal_default_instance() {
    return reinterpret_cast<const CosiSignature*>(
               &_CosiSignature_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  void Swap(CosiSignature* other);
  friend void swap(CosiSignature& a, CosiSignature& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline CosiSignature* New() const final {
    return CreateMaybeMessage<CosiSignature>(nullptr);
  }

  CosiSignature* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<CosiSignature>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const CosiSignature& from);
  void MergeFrom(const CosiSignature& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CosiSignature* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bytes signature = 1;
  bool has_signature() const;
  void clear_signature();
  static const int kSignatureFieldNumber = 1;
  const ::std::string& signature() const;
  void set_signature(const ::std::string& value);
  #if LANG_CXX11
  void set_signature(::std::string&& value);
  #endif
  void set_signature(const char* value);
  void set_signature(const void* value, size_t size);
  ::std::string* mutable_signature();
  ::std::string* release_signature();
  void set_allocated_signature(::std::string* signature);

  // @@protoc_insertion_point(class_scope:hw.trezor.messages.crypto.CosiSignature)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr signature_;
  friend struct ::TableStruct_messages_2dcrypto_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// CipherKeyValue

// repeated uint32 address_n = 1;
inline int CipherKeyValue::address_n_size() const {
  return address_n_.size();
}
inline void CipherKeyValue::clear_address_n() {
  address_n_.Clear();
}
inline ::google::protobuf::uint32 CipherKeyValue::address_n(int index) const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.crypto.CipherKeyValue.address_n)
  return address_n_.Get(index);
}
inline void CipherKeyValue::set_address_n(int index, ::google::protobuf::uint32 value) {
  address_n_.Set(index, value);
  // @@protoc_insertion_point(field_set:hw.trezor.messages.crypto.CipherKeyValue.address_n)
}
inline void CipherKeyValue::add_address_n(::google::protobuf::uint32 value) {
  address_n_.Add(value);
  // @@protoc_insertion_point(field_add:hw.trezor.messages.crypto.CipherKeyValue.address_n)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
CipherKeyValue::address_n() const {
  // @@protoc_insertion_point(field_list:hw.trezor.messages.crypto.CipherKeyValue.address_n)
  return address_n_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
CipherKeyValue::mutable_address_n() {
  // @@protoc_insertion_point(field_mutable_list:hw.trezor.messages.crypto.CipherKeyValue.address_n)
  return &address_n_;
}

// optional string key = 2;
inline bool CipherKeyValue::has_key() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CipherKeyValue::clear_key() {
  key_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::std::string& CipherKeyValue::key() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.crypto.CipherKeyValue.key)
  return key_.GetNoArena();
}
inline void CipherKeyValue::set_key(const ::std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:hw.trezor.messages.crypto.CipherKeyValue.key)
}
#if LANG_CXX11
inline void CipherKeyValue::set_key(::std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  key_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:hw.trezor.messages.crypto.CipherKeyValue.key)
}
#endif
inline void CipherKeyValue::set_key(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:hw.trezor.messages.crypto.CipherKeyValue.key)
}
inline void CipherKeyValue::set_key(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000001u;
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:hw.trezor.messages.crypto.CipherKeyValue.key)
}
inline ::std::string* CipherKeyValue::mutable_key() {
  _has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_mutable:hw.trezor.messages.crypto.CipherKeyValue.key)
  return key_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* CipherKeyValue::release_key() {
  // @@protoc_insertion_point(field_release:hw.trezor.messages.crypto.CipherKeyValue.key)
  if (!has_key()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return key_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void CipherKeyValue::set_allocated_key(::std::string* key) {
  if (key != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  key_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), key);
  // @@protoc_insertion_point(field_set_allocated:hw.trezor.messages.crypto.CipherKeyValue.key)
}

// optional bytes value = 3;
inline bool CipherKeyValue::has_value() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CipherKeyValue::clear_value() {
  value_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000002u;
}
inline const ::std::string& CipherKeyValue::value() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.crypto.CipherKeyValue.value)
  return value_.GetNoArena();
}
inline void CipherKeyValue::set_value(const ::std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  value_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:hw.trezor.messages.crypto.CipherKeyValue.value)
}
#if LANG_CXX11
inline void CipherKeyValue::set_value(::std::string&& value) {
  _has_bits_[0] |= 0x00000002u;
  value_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:hw.trezor.messages.crypto.CipherKeyValue.value)
}
#endif
inline void CipherKeyValue::set_value(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000002u;
  value_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:hw.trezor.messages.crypto.CipherKeyValue.value)
}
inline void CipherKeyValue::set_value(const void* value, size_t size) {
  _has_bits_[0] |= 0x00000002u;
  value_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:hw.trezor.messages.crypto.CipherKeyValue.value)
}
inline ::std::string* CipherKeyValue::mutable_value() {
  _has_bits_[0] |= 0x00000002u;
  // @@protoc_insertion_point(field_mutable:hw.trezor.messages.crypto.CipherKeyValue.value)
  return value_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* CipherKeyValue::release_value() {
  // @@protoc_insertion_point(field_release:hw.trezor.messages.crypto.CipherKeyValue.value)
  if (!has_value()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  return value_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void CipherKeyValue::set_allocated_value(::std::string* value) {
  if (value != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  value_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set_allocated:hw.trezor.messages.crypto.CipherKeyValue.value)
}

// optional bool encrypt = 4;
inline bool CipherKeyValue::has_encrypt() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CipherKeyValue::clear_encrypt() {
  encrypt_ = false;
  _has_bits_[0] &= ~0x00000008u;
}
inline bool CipherKeyValue::encrypt() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.crypto.CipherKeyValue.encrypt)
  return encrypt_;
}
inline void CipherKeyValue::set_encrypt(bool value) {
  _has_bits_[0] |= 0x00000008u;
  encrypt_ = value;
  // @@protoc_insertion_point(field_set:hw.trezor.messages.crypto.CipherKeyValue.encrypt)
}

// optional bool ask_on_encrypt = 5;
inline bool CipherKeyValue::has_ask_on_encrypt() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void CipherKeyValue::clear_ask_on_encrypt() {
  ask_on_encrypt_ = false;
  _has_bits_[0] &= ~0x00000010u;
}
inline bool CipherKeyValue::ask_on_encrypt() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.crypto.CipherKeyValue.ask_on_encrypt)
  return ask_on_encrypt_;
}
inline void CipherKeyValue::set_ask_on_encrypt(bool value) {
  _has_bits_[0] |= 0x00000010u;
  ask_on_encrypt_ = value;
  // @@protoc_insertion_point(field_set:hw.trezor.messages.crypto.CipherKeyValue.ask_on_encrypt)
}

// optional bool ask_on_decrypt = 6;
inline bool CipherKeyValue::has_ask_on_decrypt() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void CipherKeyValue::clear_ask_on_decrypt() {
  ask_on_decrypt_ = false;
  _has_bits_[0] &= ~0x00000020u;
}
inline bool CipherKeyValue::ask_on_decrypt() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.crypto.CipherKeyValue.ask_on_decrypt)
  return ask_on_decrypt_;
}
inline void CipherKeyValue::set_ask_on_decrypt(bool value) {
  _has_bits_[0] |= 0x00000020u;
  ask_on_decrypt_ = value;
  // @@protoc_insertion_point(field_set:hw.trezor.messages.crypto.CipherKeyValue.ask_on_decrypt)
}

// optional bytes iv = 7;
inline bool CipherKeyValue::has_iv() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CipherKeyValue::clear_iv() {
  iv_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000004u;
}
inline const ::std::string& CipherKeyValue::iv() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.crypto.CipherKeyValue.iv)
  return iv_.GetNoArena();
}
inline void CipherKeyValue::set_iv(const ::std::string& value) {
  _has_bits_[0] |= 0x00000004u;
  iv_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:hw.trezor.messages.crypto.CipherKeyValue.iv)
}
#if LANG_CXX11
inline void CipherKeyValue::set_iv(::std::string&& value) {
  _has_bits_[0] |= 0x00000004u;
  iv_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:hw.trezor.messages.crypto.CipherKeyValue.iv)
}
#endif
inline void CipherKeyValue::set_iv(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000004u;
  iv_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:hw.trezor.messages.crypto.CipherKeyValue.iv)
}
inline void CipherKeyValue::set_iv(const void* value, size_t size) {
  _has_bits_[0] |= 0x00000004u;
  iv_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:hw.trezor.messages.crypto.CipherKeyValue.iv)
}
inline ::std::string* CipherKeyValue::mutable_iv() {
  _has_bits_[0] |= 0x00000004u;
  // @@protoc_insertion_point(field_mutable:hw.trezor.messages.crypto.CipherKeyValue.iv)
  return iv_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* CipherKeyValue::release_iv() {
  // @@protoc_insertion_point(field_release:hw.trezor.messages.crypto.CipherKeyValue.iv)
  if (!has_iv()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000004u;
  return iv_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void CipherKeyValue::set_allocated_iv(::std::string* iv) {
  if (iv != nullptr) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  iv_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), iv);
  // @@protoc_insertion_point(field_set_allocated:hw.trezor.messages.crypto.CipherKeyValue.iv)
}

// -------------------------------------------------------------------

// CipheredKeyValue

// optional bytes value = 1;
inline bool CipheredKeyValue::has_value() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CipheredKeyValue::clear_value() {
  value_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::std::string& CipheredKeyValue::value() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.crypto.CipheredKeyValue.value)
  return value_.GetNoArena();
}
inline void CipheredKeyValue::set_value(const ::std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  value_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:hw.trezor.messages.crypto.CipheredKeyValue.value)
}
#if LANG_CXX11
inline void CipheredKeyValue::set_value(::std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  value_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:hw.trezor.messages.crypto.CipheredKeyValue.value)
}
#endif
inline void CipheredKeyValue::set_value(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  value_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:hw.trezor.messages.crypto.CipheredKeyValue.value)
}
inline void CipheredKeyValue::set_value(const void* value, size_t size) {
  _has_bits_[0] |= 0x00000001u;
  value_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:hw.trezor.messages.crypto.CipheredKeyValue.value)
}
inline ::std::string* CipheredKeyValue::mutable_value() {
  _has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_mutable:hw.trezor.messages.crypto.CipheredKeyValue.value)
  return value_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* CipheredKeyValue::release_value() {
  // @@protoc_insertion_point(field_release:hw.trezor.messages.crypto.CipheredKeyValue.value)
  if (!has_value()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return value_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void CipheredKeyValue::set_allocated_value(::std::string* value) {
  if (value != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  value_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set_allocated:hw.trezor.messages.crypto.CipheredKeyValue.value)
}

// -------------------------------------------------------------------

// IdentityType

// optional string proto = 1;
inline bool IdentityType::has_proto() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void IdentityType::clear_proto() {
  proto_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::std::string& IdentityType::proto() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.crypto.IdentityType.proto)
  return proto_.GetNoArena();
}
inline void IdentityType::set_proto(const ::std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  proto_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:hw.trezor.messages.crypto.IdentityType.proto)
}
#if LANG_CXX11
inline void IdentityType::set_proto(::std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  proto_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:hw.trezor.messages.crypto.IdentityType.proto)
}
#endif
inline void IdentityType::set_proto(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  proto_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:hw.trezor.messages.crypto.IdentityType.proto)
}
inline void IdentityType::set_proto(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000001u;
  proto_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:hw.trezor.messages.crypto.IdentityType.proto)
}
inline ::std::string* IdentityType::mutable_proto() {
  _has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_mutable:hw.trezor.messages.crypto.IdentityType.proto)
  return proto_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* IdentityType::release_proto() {
  // @@protoc_insertion_point(field_release:hw.trezor.messages.crypto.IdentityType.proto)
  if (!has_proto()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return proto_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void IdentityType::set_allocated_proto(::std::string* proto) {
  if (proto != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  proto_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), proto);
  // @@protoc_insertion_point(field_set_allocated:hw.trezor.messages.crypto.IdentityType.proto)
}

// optional string user = 2;
inline bool IdentityType::has_user() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void IdentityType::clear_user() {
  user_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000002u;
}
inline const ::std::string& IdentityType::user() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.crypto.IdentityType.user)
  return user_.GetNoArena();
}
inline void IdentityType::set_user(const ::std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  user_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:hw.trezor.messages.crypto.IdentityType.user)
}
#if LANG_CXX11
inline void IdentityType::set_user(::std::string&& value) {
  _has_bits_[0] |= 0x00000002u;
  user_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:hw.trezor.messages.crypto.IdentityType.user)
}
#endif
inline void IdentityType::set_user(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000002u;
  user_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:hw.trezor.messages.crypto.IdentityType.user)
}
inline void IdentityType::set_user(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000002u;
  user_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:hw.trezor.messages.crypto.IdentityType.user)
}
inline ::std::string* IdentityType::mutable_user() {
  _has_bits_[0] |= 0x00000002u;
  // @@protoc_insertion_point(field_mutable:hw.trezor.messages.crypto.IdentityType.user)
  return user_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* IdentityType::release_user() {
  // @@protoc_insertion_point(field_release:hw.trezor.messages.crypto.IdentityType.user)
  if (!has_user()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  return user_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void IdentityType::set_allocated_user(::std::string* user) {
  if (user != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  user_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), user);
  // @@protoc_insertion_point(field_set_allocated:hw.trezor.messages.crypto.IdentityType.user)
}

// optional string host = 3;
inline bool IdentityType::has_host() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void IdentityType::clear_host() {
  host_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000004u;
}
inline const ::std::string& IdentityType::host() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.crypto.IdentityType.host)
  return host_.GetNoArena();
}
inline void IdentityType::set_host(const ::std::string& value) {
  _has_bits_[0] |= 0x00000004u;
  host_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:hw.trezor.messages.crypto.IdentityType.host)
}
#if LANG_CXX11
inline void IdentityType::set_host(::std::string&& value) {
  _has_bits_[0] |= 0x00000004u;
  host_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:hw.trezor.messages.crypto.IdentityType.host)
}
#endif
inline void IdentityType::set_host(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000004u;
  host_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:hw.trezor.messages.crypto.IdentityType.host)
}
inline void IdentityType::set_host(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000004u;
  host_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:hw.trezor.messages.crypto.IdentityType.host)
}
inline ::std::string* IdentityType::mutable_host() {
  _has_bits_[0] |= 0x00000004u;
  // @@protoc_insertion_point(field_mutable:hw.trezor.messages.crypto.IdentityType.host)
  return host_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* IdentityType::release_host() {
  // @@protoc_insertion_point(field_release:hw.trezor.messages.crypto.IdentityType.host)
  if (!has_host()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000004u;
  return host_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void IdentityType::set_allocated_host(::std::string* host) {
  if (host != nullptr) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  host_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), host);
  // @@protoc_insertion_point(field_set_allocated:hw.trezor.messages.crypto.IdentityType.host)
}

// optional string port = 4;
inline bool IdentityType::has_port() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void IdentityType::clear_port() {
  port_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000008u;
}
inline const ::std::string& IdentityType::port() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.crypto.IdentityType.port)
  return port_.GetNoArena();
}
inline void IdentityType::set_port(const ::std::string& value) {
  _has_bits_[0] |= 0x00000008u;
  port_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:hw.trezor.messages.crypto.IdentityType.port)
}
#if LANG_CXX11
inline void IdentityType::set_port(::std::string&& value) {
  _has_bits_[0] |= 0x00000008u;
  port_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:hw.trezor.messages.crypto.IdentityType.port)
}
#endif
inline void IdentityType::set_port(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000008u;
  port_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:hw.trezor.messages.crypto.IdentityType.port)
}
inline void IdentityType::set_port(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000008u;
  port_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:hw.trezor.messages.crypto.IdentityType.port)
}
inline ::std::string* IdentityType::mutable_port() {
  _has_bits_[0] |= 0x00000008u;
  // @@protoc_insertion_point(field_mutable:hw.trezor.messages.crypto.IdentityType.port)
  return port_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* IdentityType::release_port() {
  // @@protoc_insertion_point(field_release:hw.trezor.messages.crypto.IdentityType.port)
  if (!has_port()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000008u;
  return port_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void IdentityType::set_allocated_port(::std::string* port) {
  if (port != nullptr) {
    _has_bits_[0] |= 0x00000008u;
  } else {
    _has_bits_[0] &= ~0x00000008u;
  }
  port_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), port);
  // @@protoc_insertion_point(field_set_allocated:hw.trezor.messages.crypto.IdentityType.port)
}

// optional string path = 5;
inline bool IdentityType::has_path() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void IdentityType::clear_path() {
  path_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000010u;
}
inline const ::std::string& IdentityType::path() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.crypto.IdentityType.path)
  return path_.GetNoArena();
}
inline void IdentityType::set_path(const ::std::string& value) {
  _has_bits_[0] |= 0x00000010u;
  path_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:hw.trezor.messages.crypto.IdentityType.path)
}
#if LANG_CXX11
inline void IdentityType::set_path(::std::string&& value) {
  _has_bits_[0] |= 0x00000010u;
  path_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:hw.trezor.messages.crypto.IdentityType.path)
}
#endif
inline void IdentityType::set_path(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000010u;
  path_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:hw.trezor.messages.crypto.IdentityType.path)
}
inline void IdentityType::set_path(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000010u;
  path_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:hw.trezor.messages.crypto.IdentityType.path)
}
inline ::std::string* IdentityType::mutable_path() {
  _has_bits_[0] |= 0x00000010u;
  // @@protoc_insertion_point(field_mutable:hw.trezor.messages.crypto.IdentityType.path)
  return path_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* IdentityType::release_path() {
  // @@protoc_insertion_point(field_release:hw.trezor.messages.crypto.IdentityType.path)
  if (!has_path()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000010u;
  return path_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void IdentityType::set_allocated_path(::std::string* path) {
  if (path != nullptr) {
    _has_bits_[0] |= 0x00000010u;
  } else {
    _has_bits_[0] &= ~0x00000010u;
  }
  path_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), path);
  // @@protoc_insertion_point(field_set_allocated:hw.trezor.messages.crypto.IdentityType.path)
}

// optional uint32 index = 6 [default = 0];
inline bool IdentityType::has_index() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void IdentityType::clear_index() {
  index_ = 0u;
  _has_bits_[0] &= ~0x00000020u;
}
inline ::google::protobuf::uint32 IdentityType::index() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.crypto.IdentityType.index)
  return index_;
}
inline void IdentityType::set_index(::google::protobuf::uint32 value) {
  _has_bits_[0] |= 0x00000020u;
  index_ = value;
  // @@protoc_insertion_point(field_set:hw.trezor.messages.crypto.IdentityType.index)
}

// -------------------------------------------------------------------

// SignIdentity

// optional .hw.trezor.messages.crypto.IdentityType identity = 1;
inline bool SignIdentity::has_identity() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void SignIdentity::clear_identity() {
  if (identity_ != nullptr) identity_->Clear();
  _has_bits_[0] &= ~0x00000008u;
}
inline const ::hw::trezor::messages::crypto::IdentityType& SignIdentity::identity() const {
  const ::hw::trezor::messages::crypto::IdentityType* p = identity_;
  // @@protoc_insertion_point(field_get:hw.trezor.messages.crypto.SignIdentity.identity)
  return p != nullptr ? *p : *reinterpret_cast<const ::hw::trezor::messages::crypto::IdentityType*>(
      &::hw::trezor::messages::crypto::_IdentityType_default_instance_);
}
inline ::hw::trezor::messages::crypto::IdentityType* SignIdentity::release_identity() {
  // @@protoc_insertion_point(field_release:hw.trezor.messages.crypto.SignIdentity.identity)
  _has_bits_[0] &= ~0x00000008u;
  ::hw::trezor::messages::crypto::IdentityType* temp = identity_;
  identity_ = nullptr;
  return temp;
}
inline ::hw::trezor::messages::crypto::IdentityType* SignIdentity::mutable_identity() {
  _has_bits_[0] |= 0x00000008u;
  if (identity_ == nullptr) {
    auto* p = CreateMaybeMessage<::hw::trezor::messages::crypto::IdentityType>(GetArenaNoVirtual());
    identity_ = p;
  }
  // @@protoc_insertion_point(field_mutable:hw.trezor.messages.crypto.SignIdentity.identity)
  return identity_;
}
inline void SignIdentity::set_allocated_identity(::hw::trezor::messages::crypto::IdentityType* identity) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete identity_;
  }
  if (identity) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      identity = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, identity, submessage_arena);
    }
    _has_bits_[0] |= 0x00000008u;
  } else {
    _has_bits_[0] &= ~0x00000008u;
  }
  identity_ = identity;
  // @@protoc_insertion_point(field_set_allocated:hw.trezor.messages.crypto.SignIdentity.identity)
}

// optional bytes challenge_hidden = 2;
inline bool SignIdentity::has_challenge_hidden() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SignIdentity::clear_challenge_hidden() {
  challenge_hidden_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::std::string& SignIdentity::challenge_hidden() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.crypto.SignIdentity.challenge_hidden)
  return challenge_hidden_.GetNoArena();
}
inline void SignIdentity::set_challenge_hidden(const ::std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  challenge_hidden_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:hw.trezor.messages.crypto.SignIdentity.challenge_hidden)
}
#if LANG_CXX11
inline void SignIdentity::set_challenge_hidden(::std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  challenge_hidden_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:hw.trezor.messages.crypto.SignIdentity.challenge_hidden)
}
#endif
inline void SignIdentity::set_challenge_hidden(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  challenge_hidden_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:hw.trezor.messages.crypto.SignIdentity.challenge_hidden)
}
inline void SignIdentity::set_challenge_hidden(const void* value, size_t size) {
  _has_bits_[0] |= 0x00000001u;
  challenge_hidden_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:hw.trezor.messages.crypto.SignIdentity.challenge_hidden)
}
inline ::std::string* SignIdentity::mutable_challenge_hidden() {
  _has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_mutable:hw.trezor.messages.crypto.SignIdentity.challenge_hidden)
  return challenge_hidden_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* SignIdentity::release_challenge_hidden() {
  // @@protoc_insertion_point(field_release:hw.trezor.messages.crypto.SignIdentity.challenge_hidden)
  if (!has_challenge_hidden()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return challenge_hidden_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void SignIdentity::set_allocated_challenge_hidden(::std::string* challenge_hidden) {
  if (challenge_hidden != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  challenge_hidden_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), challenge_hidden);
  // @@protoc_insertion_point(field_set_allocated:hw.trezor.messages.crypto.SignIdentity.challenge_hidden)
}

// optional string challenge_visual = 3;
inline bool SignIdentity::has_challenge_visual() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SignIdentity::clear_challenge_visual() {
  challenge_visual_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000002u;
}
inline const ::std::string& SignIdentity::challenge_visual() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.crypto.SignIdentity.challenge_visual)
  return challenge_visual_.GetNoArena();
}
inline void SignIdentity::set_challenge_visual(const ::std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  challenge_visual_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:hw.trezor.messages.crypto.SignIdentity.challenge_visual)
}
#if LANG_CXX11
inline void SignIdentity::set_challenge_visual(::std::string&& value) {
  _has_bits_[0] |= 0x00000002u;
  challenge_visual_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:hw.trezor.messages.crypto.SignIdentity.challenge_visual)
}
#endif
inline void SignIdentity::set_challenge_visual(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000002u;
  challenge_visual_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:hw.trezor.messages.crypto.SignIdentity.challenge_visual)
}
inline void SignIdentity::set_challenge_visual(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000002u;
  challenge_visual_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:hw.trezor.messages.crypto.SignIdentity.challenge_visual)
}
inline ::std::string* SignIdentity::mutable_challenge_visual() {
  _has_bits_[0] |= 0x00000002u;
  // @@protoc_insertion_point(field_mutable:hw.trezor.messages.crypto.SignIdentity.challenge_visual)
  return challenge_visual_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* SignIdentity::release_challenge_visual() {
  // @@protoc_insertion_point(field_release:hw.trezor.messages.crypto.SignIdentity.challenge_visual)
  if (!has_challenge_visual()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  return challenge_visual_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void SignIdentity::set_allocated_challenge_visual(::std::string* challenge_visual) {
  if (challenge_visual != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  challenge_visual_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), challenge_visual);
  // @@protoc_insertion_point(field_set_allocated:hw.trezor.messages.crypto.SignIdentity.challenge_visual)
}

// optional string ecdsa_curve_name = 4;
inline bool SignIdentity::has_ecdsa_curve_name() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void SignIdentity::clear_ecdsa_curve_name() {
  ecdsa_curve_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000004u;
}
inline const ::std::string& SignIdentity::ecdsa_curve_name() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.crypto.SignIdentity.ecdsa_curve_name)
  return ecdsa_curve_name_.GetNoArena();
}
inline void SignIdentity::set_ecdsa_curve_name(const ::std::string& value) {
  _has_bits_[0] |= 0x00000004u;
  ecdsa_curve_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:hw.trezor.messages.crypto.SignIdentity.ecdsa_curve_name)
}
#if LANG_CXX11
inline void SignIdentity::set_ecdsa_curve_name(::std::string&& value) {
  _has_bits_[0] |= 0x00000004u;
  ecdsa_curve_name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:hw.trezor.messages.crypto.SignIdentity.ecdsa_curve_name)
}
#endif
inline void SignIdentity::set_ecdsa_curve_name(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000004u;
  ecdsa_curve_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:hw.trezor.messages.crypto.SignIdentity.ecdsa_curve_name)
}
inline void SignIdentity::set_ecdsa_curve_name(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000004u;
  ecdsa_curve_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:hw.trezor.messages.crypto.SignIdentity.ecdsa_curve_name)
}
inline ::std::string* SignIdentity::mutable_ecdsa_curve_name() {
  _has_bits_[0] |= 0x00000004u;
  // @@protoc_insertion_point(field_mutable:hw.trezor.messages.crypto.SignIdentity.ecdsa_curve_name)
  return ecdsa_curve_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* SignIdentity::release_ecdsa_curve_name() {
  // @@protoc_insertion_point(field_release:hw.trezor.messages.crypto.SignIdentity.ecdsa_curve_name)
  if (!has_ecdsa_curve_name()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000004u;
  return ecdsa_curve_name_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void SignIdentity::set_allocated_ecdsa_curve_name(::std::string* ecdsa_curve_name) {
  if (ecdsa_curve_name != nullptr) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  ecdsa_curve_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ecdsa_curve_name);
  // @@protoc_insertion_point(field_set_allocated:hw.trezor.messages.crypto.SignIdentity.ecdsa_curve_name)
}

// -------------------------------------------------------------------

// SignedIdentity

// optional string address = 1;
inline bool SignedIdentity::has_address() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SignedIdentity::clear_address() {
  address_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::std::string& SignedIdentity::address() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.crypto.SignedIdentity.address)
  return address_.GetNoArena();
}
inline void SignedIdentity::set_address(const ::std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  address_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:hw.trezor.messages.crypto.SignedIdentity.address)
}
#if LANG_CXX11
inline void SignedIdentity::set_address(::std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  address_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:hw.trezor.messages.crypto.SignedIdentity.address)
}
#endif
inline void SignedIdentity::set_address(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  address_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:hw.trezor.messages.crypto.SignedIdentity.address)
}
inline void SignedIdentity::set_address(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000001u;
  address_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:hw.trezor.messages.crypto.SignedIdentity.address)
}
inline ::std::string* SignedIdentity::mutable_address() {
  _has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_mutable:hw.trezor.messages.crypto.SignedIdentity.address)
  return address_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* SignedIdentity::release_address() {
  // @@protoc_insertion_point(field_release:hw.trezor.messages.crypto.SignedIdentity.address)
  if (!has_address()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return address_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void SignedIdentity::set_allocated_address(::std::string* address) {
  if (address != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  address_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), address);
  // @@protoc_insertion_point(field_set_allocated:hw.trezor.messages.crypto.SignedIdentity.address)
}

// optional bytes public_key = 2;
inline bool SignedIdentity::has_public_key() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SignedIdentity::clear_public_key() {
  public_key_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000002u;
}
inline const ::std::string& SignedIdentity::public_key() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.crypto.SignedIdentity.public_key)
  return public_key_.GetNoArena();
}
inline void SignedIdentity::set_public_key(const ::std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  public_key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:hw.trezor.messages.crypto.SignedIdentity.public_key)
}
#if LANG_CXX11
inline void SignedIdentity::set_public_key(::std::string&& value) {
  _has_bits_[0] |= 0x00000002u;
  public_key_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:hw.trezor.messages.crypto.SignedIdentity.public_key)
}
#endif
inline void SignedIdentity::set_public_key(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000002u;
  public_key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:hw.trezor.messages.crypto.SignedIdentity.public_key)
}
inline void SignedIdentity::set_public_key(const void* value, size_t size) {
  _has_bits_[0] |= 0x00000002u;
  public_key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:hw.trezor.messages.crypto.SignedIdentity.public_key)
}
inline ::std::string* SignedIdentity::mutable_public_key() {
  _has_bits_[0] |= 0x00000002u;
  // @@protoc_insertion_point(field_mutable:hw.trezor.messages.crypto.SignedIdentity.public_key)
  return public_key_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* SignedIdentity::release_public_key() {
  // @@protoc_insertion_point(field_release:hw.trezor.messages.crypto.SignedIdentity.public_key)
  if (!has_public_key()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  return public_key_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void SignedIdentity::set_allocated_public_key(::std::string* public_key) {
  if (public_key != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  public_key_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), public_key);
  // @@protoc_insertion_point(field_set_allocated:hw.trezor.messages.crypto.SignedIdentity.public_key)
}

// optional bytes signature = 3;
inline bool SignedIdentity::has_signature() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void SignedIdentity::clear_signature() {
  signature_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000004u;
}
inline const ::std::string& SignedIdentity::signature() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.crypto.SignedIdentity.signature)
  return signature_.GetNoArena();
}
inline void SignedIdentity::set_signature(const ::std::string& value) {
  _has_bits_[0] |= 0x00000004u;
  signature_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:hw.trezor.messages.crypto.SignedIdentity.signature)
}
#if LANG_CXX11
inline void SignedIdentity::set_signature(::std::string&& value) {
  _has_bits_[0] |= 0x00000004u;
  signature_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:hw.trezor.messages.crypto.SignedIdentity.signature)
}
#endif
inline void SignedIdentity::set_signature(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000004u;
  signature_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:hw.trezor.messages.crypto.SignedIdentity.signature)
}
inline void SignedIdentity::set_signature(const void* value, size_t size) {
  _has_bits_[0] |= 0x00000004u;
  signature_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:hw.trezor.messages.crypto.SignedIdentity.signature)
}
inline ::std::string* SignedIdentity::mutable_signature() {
  _has_bits_[0] |= 0x00000004u;
  // @@protoc_insertion_point(field_mutable:hw.trezor.messages.crypto.SignedIdentity.signature)
  return signature_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* SignedIdentity::release_signature() {
  // @@protoc_insertion_point(field_release:hw.trezor.messages.crypto.SignedIdentity.signature)
  if (!has_signature()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000004u;
  return signature_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void SignedIdentity::set_allocated_signature(::std::string* signature) {
  if (signature != nullptr) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  signature_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), signature);
  // @@protoc_insertion_point(field_set_allocated:hw.trezor.messages.crypto.SignedIdentity.signature)
}

// -------------------------------------------------------------------

// GetECDHSessionKey

// optional .hw.trezor.messages.crypto.IdentityType identity = 1;
inline bool GetECDHSessionKey::has_identity() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void GetECDHSessionKey::clear_identity() {
  if (identity_ != nullptr) identity_->Clear();
  _has_bits_[0] &= ~0x00000004u;
}
inline const ::hw::trezor::messages::crypto::IdentityType& GetECDHSessionKey::identity() const {
  const ::hw::trezor::messages::crypto::IdentityType* p = identity_;
  // @@protoc_insertion_point(field_get:hw.trezor.messages.crypto.GetECDHSessionKey.identity)
  return p != nullptr ? *p : *reinterpret_cast<const ::hw::trezor::messages::crypto::IdentityType*>(
      &::hw::trezor::messages::crypto::_IdentityType_default_instance_);
}
inline ::hw::trezor::messages::crypto::IdentityType* GetECDHSessionKey::release_identity() {
  // @@protoc_insertion_point(field_release:hw.trezor.messages.crypto.GetECDHSessionKey.identity)
  _has_bits_[0] &= ~0x00000004u;
  ::hw::trezor::messages::crypto::IdentityType* temp = identity_;
  identity_ = nullptr;
  return temp;
}
inline ::hw::trezor::messages::crypto::IdentityType* GetECDHSessionKey::mutable_identity() {
  _has_bits_[0] |= 0x00000004u;
  if (identity_ == nullptr) {
    auto* p = CreateMaybeMessage<::hw::trezor::messages::crypto::IdentityType>(GetArenaNoVirtual());
    identity_ = p;
  }
  // @@protoc_insertion_point(field_mutable:hw.trezor.messages.crypto.GetECDHSessionKey.identity)
  return identity_;
}
inline void GetECDHSessionKey::set_allocated_identity(::hw::trezor::messages::crypto::IdentityType* identity) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete identity_;
  }
  if (identity) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      identity = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, identity, submessage_arena);
    }
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  identity_ = identity;
  // @@protoc_insertion_point(field_set_allocated:hw.trezor.messages.crypto.GetECDHSessionKey.identity)
}

// optional bytes peer_public_key = 2;
inline bool GetECDHSessionKey::has_peer_public_key() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GetECDHSessionKey::clear_peer_public_key() {
  peer_public_key_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::std::string& GetECDHSessionKey::peer_public_key() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.crypto.GetECDHSessionKey.peer_public_key)
  return peer_public_key_.GetNoArena();
}
inline void GetECDHSessionKey::set_peer_public_key(const ::std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  peer_public_key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:hw.trezor.messages.crypto.GetECDHSessionKey.peer_public_key)
}
#if LANG_CXX11
inline void GetECDHSessionKey::set_peer_public_key(::std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  peer_public_key_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:hw.trezor.messages.crypto.GetECDHSessionKey.peer_public_key)
}
#endif
inline void GetECDHSessionKey::set_peer_public_key(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  peer_public_key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:hw.trezor.messages.crypto.GetECDHSessionKey.peer_public_key)
}
inline void GetECDHSessionKey::set_peer_public_key(const void* value, size_t size) {
  _has_bits_[0] |= 0x00000001u;
  peer_public_key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:hw.trezor.messages.crypto.GetECDHSessionKey.peer_public_key)
}
inline ::std::string* GetECDHSessionKey::mutable_peer_public_key() {
  _has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_mutable:hw.trezor.messages.crypto.GetECDHSessionKey.peer_public_key)
  return peer_public_key_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* GetECDHSessionKey::release_peer_public_key() {
  // @@protoc_insertion_point(field_release:hw.trezor.messages.crypto.GetECDHSessionKey.peer_public_key)
  if (!has_peer_public_key()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return peer_public_key_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void GetECDHSessionKey::set_allocated_peer_public_key(::std::string* peer_public_key) {
  if (peer_public_key != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  peer_public_key_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), peer_public_key);
  // @@protoc_insertion_point(field_set_allocated:hw.trezor.messages.crypto.GetECDHSessionKey.peer_public_key)
}

// optional string ecdsa_curve_name = 3;
inline bool GetECDHSessionKey::has_ecdsa_curve_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GetECDHSessionKey::clear_ecdsa_curve_name() {
  ecdsa_curve_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000002u;
}
inline const ::std::string& GetECDHSessionKey::ecdsa_curve_name() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.crypto.GetECDHSessionKey.ecdsa_curve_name)
  return ecdsa_curve_name_.GetNoArena();
}
inline void GetECDHSessionKey::set_ecdsa_curve_name(const ::std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  ecdsa_curve_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:hw.trezor.messages.crypto.GetECDHSessionKey.ecdsa_curve_name)
}
#if LANG_CXX11
inline void GetECDHSessionKey::set_ecdsa_curve_name(::std::string&& value) {
  _has_bits_[0] |= 0x00000002u;
  ecdsa_curve_name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:hw.trezor.messages.crypto.GetECDHSessionKey.ecdsa_curve_name)
}
#endif
inline void GetECDHSessionKey::set_ecdsa_curve_name(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000002u;
  ecdsa_curve_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:hw.trezor.messages.crypto.GetECDHSessionKey.ecdsa_curve_name)
}
inline void GetECDHSessionKey::set_ecdsa_curve_name(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000002u;
  ecdsa_curve_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:hw.trezor.messages.crypto.GetECDHSessionKey.ecdsa_curve_name)
}
inline ::std::string* GetECDHSessionKey::mutable_ecdsa_curve_name() {
  _has_bits_[0] |= 0x00000002u;
  // @@protoc_insertion_point(field_mutable:hw.trezor.messages.crypto.GetECDHSessionKey.ecdsa_curve_name)
  return ecdsa_curve_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* GetECDHSessionKey::release_ecdsa_curve_name() {
  // @@protoc_insertion_point(field_release:hw.trezor.messages.crypto.GetECDHSessionKey.ecdsa_curve_name)
  if (!has_ecdsa_curve_name()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  return ecdsa_curve_name_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void GetECDHSessionKey::set_allocated_ecdsa_curve_name(::std::string* ecdsa_curve_name) {
  if (ecdsa_curve_name != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  ecdsa_curve_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ecdsa_curve_name);
  // @@protoc_insertion_point(field_set_allocated:hw.trezor.messages.crypto.GetECDHSessionKey.ecdsa_curve_name)
}

// -------------------------------------------------------------------

// ECDHSessionKey

// optional bytes session_key = 1;
inline bool ECDHSessionKey::has_session_key() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ECDHSessionKey::clear_session_key() {
  session_key_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::std::string& ECDHSessionKey::session_key() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.crypto.ECDHSessionKey.session_key)
  return session_key_.GetNoArena();
}
inline void ECDHSessionKey::set_session_key(const ::std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  session_key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:hw.trezor.messages.crypto.ECDHSessionKey.session_key)
}
#if LANG_CXX11
inline void ECDHSessionKey::set_session_key(::std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  session_key_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:hw.trezor.messages.crypto.ECDHSessionKey.session_key)
}
#endif
inline void ECDHSessionKey::set_session_key(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  session_key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:hw.trezor.messages.crypto.ECDHSessionKey.session_key)
}
inline void ECDHSessionKey::set_session_key(const void* value, size_t size) {
  _has_bits_[0] |= 0x00000001u;
  session_key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:hw.trezor.messages.crypto.ECDHSessionKey.session_key)
}
inline ::std::string* ECDHSessionKey::mutable_session_key() {
  _has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_mutable:hw.trezor.messages.crypto.ECDHSessionKey.session_key)
  return session_key_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ECDHSessionKey::release_session_key() {
  // @@protoc_insertion_point(field_release:hw.trezor.messages.crypto.ECDHSessionKey.session_key)
  if (!has_session_key()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return session_key_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ECDHSessionKey::set_allocated_session_key(::std::string* session_key) {
  if (session_key != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  session_key_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), session_key);
  // @@protoc_insertion_point(field_set_allocated:hw.trezor.messages.crypto.ECDHSessionKey.session_key)
}

// -------------------------------------------------------------------

// CosiCommit

// repeated uint32 address_n = 1;
inline int CosiCommit::address_n_size() const {
  return address_n_.size();
}
inline void CosiCommit::clear_address_n() {
  address_n_.Clear();
}
inline ::google::protobuf::uint32 CosiCommit::address_n(int index) const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.crypto.CosiCommit.address_n)
  return address_n_.Get(index);
}
inline void CosiCommit::set_address_n(int index, ::google::protobuf::uint32 value) {
  address_n_.Set(index, value);
  // @@protoc_insertion_point(field_set:hw.trezor.messages.crypto.CosiCommit.address_n)
}
inline void CosiCommit::add_address_n(::google::protobuf::uint32 value) {
  address_n_.Add(value);
  // @@protoc_insertion_point(field_add:hw.trezor.messages.crypto.CosiCommit.address_n)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
CosiCommit::address_n() const {
  // @@protoc_insertion_point(field_list:hw.trezor.messages.crypto.CosiCommit.address_n)
  return address_n_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
CosiCommit::mutable_address_n() {
  // @@protoc_insertion_point(field_mutable_list:hw.trezor.messages.crypto.CosiCommit.address_n)
  return &address_n_;
}

// optional bytes data = 2;
inline bool CosiCommit::has_data() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CosiCommit::clear_data() {
  data_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::std::string& CosiCommit::data() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.crypto.CosiCommit.data)
  return data_.GetNoArena();
}
inline void CosiCommit::set_data(const ::std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  data_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:hw.trezor.messages.crypto.CosiCommit.data)
}
#if LANG_CXX11
inline void CosiCommit::set_data(::std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  data_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:hw.trezor.messages.crypto.CosiCommit.data)
}
#endif
inline void CosiCommit::set_data(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  data_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:hw.trezor.messages.crypto.CosiCommit.data)
}
inline void CosiCommit::set_data(const void* value, size_t size) {
  _has_bits_[0] |= 0x00000001u;
  data_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:hw.trezor.messages.crypto.CosiCommit.data)
}
inline ::std::string* CosiCommit::mutable_data() {
  _has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_mutable:hw.trezor.messages.crypto.CosiCommit.data)
  return data_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* CosiCommit::release_data() {
  // @@protoc_insertion_point(field_release:hw.trezor.messages.crypto.CosiCommit.data)
  if (!has_data()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return data_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void CosiCommit::set_allocated_data(::std::string* data) {
  if (data != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  data_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), data);
  // @@protoc_insertion_point(field_set_allocated:hw.trezor.messages.crypto.CosiCommit.data)
}

// -------------------------------------------------------------------

// CosiCommitment

// optional bytes commitment = 1;
inline bool CosiCommitment::has_commitment() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CosiCommitment::clear_commitment() {
  commitment_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::std::string& CosiCommitment::commitment() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.crypto.CosiCommitment.commitment)
  return commitment_.GetNoArena();
}
inline void CosiCommitment::set_commitment(const ::std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  commitment_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:hw.trezor.messages.crypto.CosiCommitment.commitment)
}
#if LANG_CXX11
inline void CosiCommitment::set_commitment(::std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  commitment_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:hw.trezor.messages.crypto.CosiCommitment.commitment)
}
#endif
inline void CosiCommitment::set_commitment(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  commitment_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:hw.trezor.messages.crypto.CosiCommitment.commitment)
}
inline void CosiCommitment::set_commitment(const void* value, size_t size) {
  _has_bits_[0] |= 0x00000001u;
  commitment_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:hw.trezor.messages.crypto.CosiCommitment.commitment)
}
inline ::std::string* CosiCommitment::mutable_commitment() {
  _has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_mutable:hw.trezor.messages.crypto.CosiCommitment.commitment)
  return commitment_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* CosiCommitment::release_commitment() {
  // @@protoc_insertion_point(field_release:hw.trezor.messages.crypto.CosiCommitment.commitment)
  if (!has_commitment()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return commitment_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void CosiCommitment::set_allocated_commitment(::std::string* commitment) {
  if (commitment != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  commitment_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), commitment);
  // @@protoc_insertion_point(field_set_allocated:hw.trezor.messages.crypto.CosiCommitment.commitment)
}

// optional bytes pubkey = 2;
inline bool CosiCommitment::has_pubkey() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CosiCommitment::clear_pubkey() {
  pubkey_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000002u;
}
inline const ::std::string& CosiCommitment::pubkey() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.crypto.CosiCommitment.pubkey)
  return pubkey_.GetNoArena();
}
inline void CosiCommitment::set_pubkey(const ::std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  pubkey_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:hw.trezor.messages.crypto.CosiCommitment.pubkey)
}
#if LANG_CXX11
inline void CosiCommitment::set_pubkey(::std::string&& value) {
  _has_bits_[0] |= 0x00000002u;
  pubkey_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:hw.trezor.messages.crypto.CosiCommitment.pubkey)
}
#endif
inline void CosiCommitment::set_pubkey(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000002u;
  pubkey_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:hw.trezor.messages.crypto.CosiCommitment.pubkey)
}
inline void CosiCommitment::set_pubkey(const void* value, size_t size) {
  _has_bits_[0] |= 0x00000002u;
  pubkey_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:hw.trezor.messages.crypto.CosiCommitment.pubkey)
}
inline ::std::string* CosiCommitment::mutable_pubkey() {
  _has_bits_[0] |= 0x00000002u;
  // @@protoc_insertion_point(field_mutable:hw.trezor.messages.crypto.CosiCommitment.pubkey)
  return pubkey_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* CosiCommitment::release_pubkey() {
  // @@protoc_insertion_point(field_release:hw.trezor.messages.crypto.CosiCommitment.pubkey)
  if (!has_pubkey()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  return pubkey_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void CosiCommitment::set_allocated_pubkey(::std::string* pubkey) {
  if (pubkey != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  pubkey_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), pubkey);
  // @@protoc_insertion_point(field_set_allocated:hw.trezor.messages.crypto.CosiCommitment.pubkey)
}

// -------------------------------------------------------------------

// CosiSign

// repeated uint32 address_n = 1;
inline int CosiSign::address_n_size() const {
  return address_n_.size();
}
inline void CosiSign::clear_address_n() {
  address_n_.Clear();
}
inline ::google::protobuf::uint32 CosiSign::address_n(int index) const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.crypto.CosiSign.address_n)
  return address_n_.Get(index);
}
inline void CosiSign::set_address_n(int index, ::google::protobuf::uint32 value) {
  address_n_.Set(index, value);
  // @@protoc_insertion_point(field_set:hw.trezor.messages.crypto.CosiSign.address_n)
}
inline void CosiSign::add_address_n(::google::protobuf::uint32 value) {
  address_n_.Add(value);
  // @@protoc_insertion_point(field_add:hw.trezor.messages.crypto.CosiSign.address_n)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
CosiSign::address_n() const {
  // @@protoc_insertion_point(field_list:hw.trezor.messages.crypto.CosiSign.address_n)
  return address_n_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
CosiSign::mutable_address_n() {
  // @@protoc_insertion_point(field_mutable_list:hw.trezor.messages.crypto.CosiSign.address_n)
  return &address_n_;
}

// optional bytes data = 2;
inline bool CosiSign::has_data() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CosiSign::clear_data() {
  data_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::std::string& CosiSign::data() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.crypto.CosiSign.data)
  return data_.GetNoArena();
}
inline void CosiSign::set_data(const ::std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  data_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:hw.trezor.messages.crypto.CosiSign.data)
}
#if LANG_CXX11
inline void CosiSign::set_data(::std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  data_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:hw.trezor.messages.crypto.CosiSign.data)
}
#endif
inline void CosiSign::set_data(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  data_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:hw.trezor.messages.crypto.CosiSign.data)
}
inline void CosiSign::set_data(const void* value, size_t size) {
  _has_bits_[0] |= 0x00000001u;
  data_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:hw.trezor.messages.crypto.CosiSign.data)
}
inline ::std::string* CosiSign::mutable_data() {
  _has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_mutable:hw.trezor.messages.crypto.CosiSign.data)
  return data_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* CosiSign::release_data() {
  // @@protoc_insertion_point(field_release:hw.trezor.messages.crypto.CosiSign.data)
  if (!has_data()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return data_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void CosiSign::set_allocated_data(::std::string* data) {
  if (data != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  data_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), data);
  // @@protoc_insertion_point(field_set_allocated:hw.trezor.messages.crypto.CosiSign.data)
}

// optional bytes global_commitment = 3;
inline bool CosiSign::has_global_commitment() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CosiSign::clear_global_commitment() {
  global_commitment_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000002u;
}
inline const ::std::string& CosiSign::global_commitment() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.crypto.CosiSign.global_commitment)
  return global_commitment_.GetNoArena();
}
inline void CosiSign::set_global_commitment(const ::std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  global_commitment_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:hw.trezor.messages.crypto.CosiSign.global_commitment)
}
#if LANG_CXX11
inline void CosiSign::set_global_commitment(::std::string&& value) {
  _has_bits_[0] |= 0x00000002u;
  global_commitment_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:hw.trezor.messages.crypto.CosiSign.global_commitment)
}
#endif
inline void CosiSign::set_global_commitment(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000002u;
  global_commitment_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:hw.trezor.messages.crypto.CosiSign.global_commitment)
}
inline void CosiSign::set_global_commitment(const void* value, size_t size) {
  _has_bits_[0] |= 0x00000002u;
  global_commitment_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:hw.trezor.messages.crypto.CosiSign.global_commitment)
}
inline ::std::string* CosiSign::mutable_global_commitment() {
  _has_bits_[0] |= 0x00000002u;
  // @@protoc_insertion_point(field_mutable:hw.trezor.messages.crypto.CosiSign.global_commitment)
  return global_commitment_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* CosiSign::release_global_commitment() {
  // @@protoc_insertion_point(field_release:hw.trezor.messages.crypto.CosiSign.global_commitment)
  if (!has_global_commitment()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  return global_commitment_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void CosiSign::set_allocated_global_commitment(::std::string* global_commitment) {
  if (global_commitment != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  global_commitment_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), global_commitment);
  // @@protoc_insertion_point(field_set_allocated:hw.trezor.messages.crypto.CosiSign.global_commitment)
}

// optional bytes global_pubkey = 4;
inline bool CosiSign::has_global_pubkey() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CosiSign::clear_global_pubkey() {
  global_pubkey_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000004u;
}
inline const ::std::string& CosiSign::global_pubkey() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.crypto.CosiSign.global_pubkey)
  return global_pubkey_.GetNoArena();
}
inline void CosiSign::set_global_pubkey(const ::std::string& value) {
  _has_bits_[0] |= 0x00000004u;
  global_pubkey_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:hw.trezor.messages.crypto.CosiSign.global_pubkey)
}
#if LANG_CXX11
inline void CosiSign::set_global_pubkey(::std::string&& value) {
  _has_bits_[0] |= 0x00000004u;
  global_pubkey_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:hw.trezor.messages.crypto.CosiSign.global_pubkey)
}
#endif
inline void CosiSign::set_global_pubkey(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000004u;
  global_pubkey_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:hw.trezor.messages.crypto.CosiSign.global_pubkey)
}
inline void CosiSign::set_global_pubkey(const void* value, size_t size) {
  _has_bits_[0] |= 0x00000004u;
  global_pubkey_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:hw.trezor.messages.crypto.CosiSign.global_pubkey)
}
inline ::std::string* CosiSign::mutable_global_pubkey() {
  _has_bits_[0] |= 0x00000004u;
  // @@protoc_insertion_point(field_mutable:hw.trezor.messages.crypto.CosiSign.global_pubkey)
  return global_pubkey_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* CosiSign::release_global_pubkey() {
  // @@protoc_insertion_point(field_release:hw.trezor.messages.crypto.CosiSign.global_pubkey)
  if (!has_global_pubkey()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000004u;
  return global_pubkey_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void CosiSign::set_allocated_global_pubkey(::std::string* global_pubkey) {
  if (global_pubkey != nullptr) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  global_pubkey_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), global_pubkey);
  // @@protoc_insertion_point(field_set_allocated:hw.trezor.messages.crypto.CosiSign.global_pubkey)
}

// -------------------------------------------------------------------

// CosiSignature

// optional bytes signature = 1;
inline bool CosiSignature::has_signature() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CosiSignature::clear_signature() {
  signature_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::std::string& CosiSignature::signature() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.crypto.CosiSignature.signature)
  return signature_.GetNoArena();
}
inline void CosiSignature::set_signature(const ::std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  signature_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:hw.trezor.messages.crypto.CosiSignature.signature)
}
#if LANG_CXX11
inline void CosiSignature::set_signature(::std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  signature_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:hw.trezor.messages.crypto.CosiSignature.signature)
}
#endif
inline void CosiSignature::set_signature(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  signature_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:hw.trezor.messages.crypto.CosiSignature.signature)
}
inline void CosiSignature::set_signature(const void* value, size_t size) {
  _has_bits_[0] |= 0x00000001u;
  signature_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:hw.trezor.messages.crypto.CosiSignature.signature)
}
inline ::std::string* CosiSignature::mutable_signature() {
  _has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_mutable:hw.trezor.messages.crypto.CosiSignature.signature)
  return signature_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* CosiSignature::release_signature() {
  // @@protoc_insertion_point(field_release:hw.trezor.messages.crypto.CosiSignature.signature)
  if (!has_signature()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return signature_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void CosiSignature::set_allocated_signature(::std::string* signature) {
  if (signature != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  signature_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), signature);
  // @@protoc_insertion_point(field_set_allocated:hw.trezor.messages.crypto.CosiSignature.signature)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace crypto
}  // namespace messages
}  // namespace trezor
}  // namespace hw

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // PROTOBUF_INCLUDED_messages_2dcrypto_2eproto
