// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: messages-bitcoin.proto

#include "messages-bitcoin.pb.h"

#include <algorithm>

#include <google/protobuf/stubs/common.h>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/wire_format_lite_inl.h>
#include <google/protobuf/descriptor.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/reflection_ops.h>
#include <google/protobuf/wire_format.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>

extern PROTOBUF_INTERNAL_EXPORT_messages_2dbitcoin_2eproto ::google::protobuf::internal::SCCInfo<0> scc_info_TxAck_TransactionType_TxOutputBinType_messages_2dbitcoin_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_messages_2dbitcoin_2eproto ::google::protobuf::internal::SCCInfo<0> scc_info_TxRequest_TxRequestDetailsType_messages_2dbitcoin_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_messages_2dbitcoin_2eproto ::google::protobuf::internal::SCCInfo<0> scc_info_TxRequest_TxRequestSerializedType_messages_2dbitcoin_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_messages_2dbitcoin_2eproto ::google::protobuf::internal::SCCInfo<1> scc_info_MultisigRedeemScriptType_HDNodePathType_messages_2dbitcoin_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_messages_2dbitcoin_2eproto ::google::protobuf::internal::SCCInfo<1> scc_info_MultisigRedeemScriptType_messages_2dbitcoin_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_messages_2dbitcoin_2eproto ::google::protobuf::internal::SCCInfo<1> scc_info_TxAck_TransactionType_TxInputType_messages_2dbitcoin_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_messages_2dbitcoin_2eproto ::google::protobuf::internal::SCCInfo<1> scc_info_TxAck_TransactionType_TxOutputType_messages_2dbitcoin_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_messages_2dbitcoin_2eproto ::google::protobuf::internal::SCCInfo<3> scc_info_TxAck_TransactionType_messages_2dbitcoin_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_messages_2dcommon_2eproto ::google::protobuf::internal::SCCInfo<0> scc_info_HDNodeType_messages_2dcommon_2eproto;
namespace hw {
namespace trezor {
namespace messages {
namespace bitcoin {
class MultisigRedeemScriptType_HDNodePathTypeDefaultTypeInternal {
 public:
  ::google::protobuf::internal::ExplicitlyConstructed<MultisigRedeemScriptType_HDNodePathType> _instance;
} _MultisigRedeemScriptType_HDNodePathType_default_instance_;
class MultisigRedeemScriptTypeDefaultTypeInternal {
 public:
  ::google::protobuf::internal::ExplicitlyConstructed<MultisigRedeemScriptType> _instance;
} _MultisigRedeemScriptType_default_instance_;
class GetPublicKeyDefaultTypeInternal {
 public:
  ::google::protobuf::internal::ExplicitlyConstructed<GetPublicKey> _instance;
} _GetPublicKey_default_instance_;
class PublicKeyDefaultTypeInternal {
 public:
  ::google::protobuf::internal::ExplicitlyConstructed<PublicKey> _instance;
} _PublicKey_default_instance_;
class GetAddressDefaultTypeInternal {
 public:
  ::google::protobuf::internal::ExplicitlyConstructed<GetAddress> _instance;
} _GetAddress_default_instance_;
class AddressDefaultTypeInternal {
 public:
  ::google::protobuf::internal::ExplicitlyConstructed<Address> _instance;
} _Address_default_instance_;
class SignMessageDefaultTypeInternal {
 public:
  ::google::protobuf::internal::ExplicitlyConstructed<SignMessage> _instance;
} _SignMessage_default_instance_;
class MessageSignatureDefaultTypeInternal {
 public:
  ::google::protobuf::internal::ExplicitlyConstructed<MessageSignature> _instance;
} _MessageSignature_default_instance_;
class VerifyMessageDefaultTypeInternal {
 public:
  ::google::protobuf::internal::ExplicitlyConstructed<VerifyMessage> _instance;
} _VerifyMessage_default_instance_;
class SignTxDefaultTypeInternal {
 public:
  ::google::protobuf::internal::ExplicitlyConstructed<SignTx> _instance;
} _SignTx_default_instance_;
class TxRequest_TxRequestDetailsTypeDefaultTypeInternal {
 public:
  ::google::protobuf::internal::ExplicitlyConstructed<TxRequest_TxRequestDetailsType> _instance;
} _TxRequest_TxRequestDetailsType_default_instance_;
class TxRequest_TxRequestSerializedTypeDefaultTypeInternal {
 public:
  ::google::protobuf::internal::ExplicitlyConstructed<TxRequest_TxRequestSerializedType> _instance;
} _TxRequest_TxRequestSerializedType_default_instance_;
class TxRequestDefaultTypeInternal {
 public:
  ::google::protobuf::internal::ExplicitlyConstructed<TxRequest> _instance;
} _TxRequest_default_instance_;
class TxAck_TransactionType_TxInputTypeDefaultTypeInternal {
 public:
  ::google::protobuf::internal::ExplicitlyConstructed<TxAck_TransactionType_TxInputType> _instance;
} _TxAck_TransactionType_TxInputType_default_instance_;
class TxAck_TransactionType_TxOutputBinTypeDefaultTypeInternal {
 public:
  ::google::protobuf::internal::ExplicitlyConstructed<TxAck_TransactionType_TxOutputBinType> _instance;
} _TxAck_TransactionType_TxOutputBinType_default_instance_;
class TxAck_TransactionType_TxOutputTypeDefaultTypeInternal {
 public:
  ::google::protobuf::internal::ExplicitlyConstructed<TxAck_TransactionType_TxOutputType> _instance;
} _TxAck_TransactionType_TxOutputType_default_instance_;
class TxAck_TransactionTypeDefaultTypeInternal {
 public:
  ::google::protobuf::internal::ExplicitlyConstructed<TxAck_TransactionType> _instance;
} _TxAck_TransactionType_default_instance_;
class TxAckDefaultTypeInternal {
 public:
  ::google::protobuf::internal::ExplicitlyConstructed<TxAck> _instance;
} _TxAck_default_instance_;
}  // namespace bitcoin
}  // namespace messages
}  // namespace trezor
}  // namespace hw
static void InitDefaultsMultisigRedeemScriptType_HDNodePathType_messages_2dbitcoin_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::hw::trezor::messages::bitcoin::_MultisigRedeemScriptType_HDNodePathType_default_instance_;
    new (ptr) ::hw::trezor::messages::bitcoin::MultisigRedeemScriptType_HDNodePathType();
    ::google::protobuf::internal::OnShutdownDestroyMessage(ptr);
  }
  ::hw::trezor::messages::bitcoin::MultisigRedeemScriptType_HDNodePathType::InitAsDefaultInstance();
}

::google::protobuf::internal::SCCInfo<1> scc_info_MultisigRedeemScriptType_HDNodePathType_messages_2dbitcoin_2eproto =
    {{ATOMIC_VAR_INIT(::google::protobuf::internal::SCCInfoBase::kUninitialized), 1, InitDefaultsMultisigRedeemScriptType_HDNodePathType_messages_2dbitcoin_2eproto}, {
      &scc_info_HDNodeType_messages_2dcommon_2eproto.base,}};

static void InitDefaultsMultisigRedeemScriptType_messages_2dbitcoin_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::hw::trezor::messages::bitcoin::_MultisigRedeemScriptType_default_instance_;
    new (ptr) ::hw::trezor::messages::bitcoin::MultisigRedeemScriptType();
    ::google::protobuf::internal::OnShutdownDestroyMessage(ptr);
  }
  ::hw::trezor::messages::bitcoin::MultisigRedeemScriptType::InitAsDefaultInstance();
}

::google::protobuf::internal::SCCInfo<1> scc_info_MultisigRedeemScriptType_messages_2dbitcoin_2eproto =
    {{ATOMIC_VAR_INIT(::google::protobuf::internal::SCCInfoBase::kUninitialized), 1, InitDefaultsMultisigRedeemScriptType_messages_2dbitcoin_2eproto}, {
      &scc_info_MultisigRedeemScriptType_HDNodePathType_messages_2dbitcoin_2eproto.base,}};

static void InitDefaultsGetPublicKey_messages_2dbitcoin_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  ::hw::trezor::messages::bitcoin::GetPublicKey::_i_give_permission_to_break_this_code_default_coin_name_.DefaultConstruct();
  *::hw::trezor::messages::bitcoin::GetPublicKey::_i_give_permission_to_break_this_code_default_coin_name_.get_mutable() = ::std::string("Bitcoin", 7);
  ::google::protobuf::internal::OnShutdownDestroyString(
      ::hw::trezor::messages::bitcoin::GetPublicKey::_i_give_permission_to_break_this_code_default_coin_name_.get_mutable());
  {
    void* ptr = &::hw::trezor::messages::bitcoin::_GetPublicKey_default_instance_;
    new (ptr) ::hw::trezor::messages::bitcoin::GetPublicKey();
    ::google::protobuf::internal::OnShutdownDestroyMessage(ptr);
  }
  ::hw::trezor::messages::bitcoin::GetPublicKey::InitAsDefaultInstance();
}

::google::protobuf::internal::SCCInfo<0> scc_info_GetPublicKey_messages_2dbitcoin_2eproto =
    {{ATOMIC_VAR_INIT(::google::protobuf::internal::SCCInfoBase::kUninitialized), 0, InitDefaultsGetPublicKey_messages_2dbitcoin_2eproto}, {}};

static void InitDefaultsPublicKey_messages_2dbitcoin_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::hw::trezor::messages::bitcoin::_PublicKey_default_instance_;
    new (ptr) ::hw::trezor::messages::bitcoin::PublicKey();
    ::google::protobuf::internal::OnShutdownDestroyMessage(ptr);
  }
  ::hw::trezor::messages::bitcoin::PublicKey::InitAsDefaultInstance();
}

::google::protobuf::internal::SCCInfo<1> scc_info_PublicKey_messages_2dbitcoin_2eproto =
    {{ATOMIC_VAR_INIT(::google::protobuf::internal::SCCInfoBase::kUninitialized), 1, InitDefaultsPublicKey_messages_2dbitcoin_2eproto}, {
      &scc_info_HDNodeType_messages_2dcommon_2eproto.base,}};

static void InitDefaultsGetAddress_messages_2dbitcoin_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  ::hw::trezor::messages::bitcoin::GetAddress::_i_give_permission_to_break_this_code_default_coin_name_.DefaultConstruct();
  *::hw::trezor::messages::bitcoin::GetAddress::_i_give_permission_to_break_this_code_default_coin_name_.get_mutable() = ::std::string("Bitcoin", 7);
  ::google::protobuf::internal::OnShutdownDestroyString(
      ::hw::trezor::messages::bitcoin::GetAddress::_i_give_permission_to_break_this_code_default_coin_name_.get_mutable());
  {
    void* ptr = &::hw::trezor::messages::bitcoin::_GetAddress_default_instance_;
    new (ptr) ::hw::trezor::messages::bitcoin::GetAddress();
    ::google::protobuf::internal::OnShutdownDestroyMessage(ptr);
  }
  ::hw::trezor::messages::bitcoin::GetAddress::InitAsDefaultInstance();
}

::google::protobuf::internal::SCCInfo<1> scc_info_GetAddress_messages_2dbitcoin_2eproto =
    {{ATOMIC_VAR_INIT(::google::protobuf::internal::SCCInfoBase::kUninitialized), 1, InitDefaultsGetAddress_messages_2dbitcoin_2eproto}, {
      &scc_info_MultisigRedeemScriptType_messages_2dbitcoin_2eproto.base,}};

static void InitDefaultsAddress_messages_2dbitcoin_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::hw::trezor::messages::bitcoin::_Address_default_instance_;
    new (ptr) ::hw::trezor::messages::bitcoin::Address();
    ::google::protobuf::internal::OnShutdownDestroyMessage(ptr);
  }
  ::hw::trezor::messages::bitcoin::Address::InitAsDefaultInstance();
}

::google::protobuf::internal::SCCInfo<0> scc_info_Address_messages_2dbitcoin_2eproto =
    {{ATOMIC_VAR_INIT(::google::protobuf::internal::SCCInfoBase::kUninitialized), 0, InitDefaultsAddress_messages_2dbitcoin_2eproto}, {}};

static void InitDefaultsSignMessage_messages_2dbitcoin_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  ::hw::trezor::messages::bitcoin::SignMessage::_i_give_permission_to_break_this_code_default_coin_name_.DefaultConstruct();
  *::hw::trezor::messages::bitcoin::SignMessage::_i_give_permission_to_break_this_code_default_coin_name_.get_mutable() = ::std::string("Bitcoin", 7);
  ::google::protobuf::internal::OnShutdownDestroyString(
      ::hw::trezor::messages::bitcoin::SignMessage::_i_give_permission_to_break_this_code_default_coin_name_.get_mutable());
  {
    void* ptr = &::hw::trezor::messages::bitcoin::_SignMessage_default_instance_;
    new (ptr) ::hw::trezor::messages::bitcoin::SignMessage();
    ::google::protobuf::internal::OnShutdownDestroyMessage(ptr);
  }
  ::hw::trezor::messages::bitcoin::SignMessage::InitAsDefaultInstance();
}

::google::protobuf::internal::SCCInfo<0> scc_info_SignMessage_messages_2dbitcoin_2eproto =
    {{ATOMIC_VAR_INIT(::google::protobuf::internal::SCCInfoBase::kUninitialized), 0, InitDefaultsSignMessage_messages_2dbitcoin_2eproto}, {}};

static void InitDefaultsMessageSignature_messages_2dbitcoin_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::hw::trezor::messages::bitcoin::_MessageSignature_default_instance_;
    new (ptr) ::hw::trezor::messages::bitcoin::MessageSignature();
    ::google::protobuf::internal::OnShutdownDestroyMessage(ptr);
  }
  ::hw::trezor::messages::bitcoin::MessageSignature::InitAsDefaultInstance();
}

::google::protobuf::internal::SCCInfo<0> scc_info_MessageSignature_messages_2dbitcoin_2eproto =
    {{ATOMIC_VAR_INIT(::google::protobuf::internal::SCCInfoBase::kUninitialized), 0, InitDefaultsMessageSignature_messages_2dbitcoin_2eproto}, {}};

static void InitDefaultsVerifyMessage_messages_2dbitcoin_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  ::hw::trezor::messages::bitcoin::VerifyMessage::_i_give_permission_to_break_this_code_default_coin_name_.DefaultConstruct();
  *::hw::trezor::messages::bitcoin::VerifyMessage::_i_give_permission_to_break_this_code_default_coin_name_.get_mutable() = ::std::string("Bitcoin", 7);
  ::google::protobuf::internal::OnShutdownDestroyString(
      ::hw::trezor::messages::bitcoin::VerifyMessage::_i_give_permission_to_break_this_code_default_coin_name_.get_mutable());
  {
    void* ptr = &::hw::trezor::messages::bitcoin::_VerifyMessage_default_instance_;
    new (ptr) ::hw::trezor::messages::bitcoin::VerifyMessage();
    ::google::protobuf::internal::OnShutdownDestroyMessage(ptr);
  }
  ::hw::trezor::messages::bitcoin::VerifyMessage::InitAsDefaultInstance();
}

::google::protobuf::internal::SCCInfo<0> scc_info_VerifyMessage_messages_2dbitcoin_2eproto =
    {{ATOMIC_VAR_INIT(::google::protobuf::internal::SCCInfoBase::kUninitialized), 0, InitDefaultsVerifyMessage_messages_2dbitcoin_2eproto}, {}};

static void InitDefaultsSignTx_messages_2dbitcoin_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  ::hw::trezor::messages::bitcoin::SignTx::_i_give_permission_to_break_this_code_default_coin_name_.DefaultConstruct();
  *::hw::trezor::messages::bitcoin::SignTx::_i_give_permission_to_break_this_code_default_coin_name_.get_mutable() = ::std::string("Bitcoin", 7);
  ::google::protobuf::internal::OnShutdownDestroyString(
      ::hw::trezor::messages::bitcoin::SignTx::_i_give_permission_to_break_this_code_default_coin_name_.get_mutable());
  {
    void* ptr = &::hw::trezor::messages::bitcoin::_SignTx_default_instance_;
    new (ptr) ::hw::trezor::messages::bitcoin::SignTx();
    ::google::protobuf::internal::OnShutdownDestroyMessage(ptr);
  }
  ::hw::trezor::messages::bitcoin::SignTx::InitAsDefaultInstance();
}

::google::protobuf::internal::SCCInfo<0> scc_info_SignTx_messages_2dbitcoin_2eproto =
    {{ATOMIC_VAR_INIT(::google::protobuf::internal::SCCInfoBase::kUninitialized), 0, InitDefaultsSignTx_messages_2dbitcoin_2eproto}, {}};

static void InitDefaultsTxRequest_TxRequestDetailsType_messages_2dbitcoin_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::hw::trezor::messages::bitcoin::_TxRequest_TxRequestDetailsType_default_instance_;
    new (ptr) ::hw::trezor::messages::bitcoin::TxRequest_TxRequestDetailsType();
    ::google::protobuf::internal::OnShutdownDestroyMessage(ptr);
  }
  ::hw::trezor::messages::bitcoin::TxRequest_TxRequestDetailsType::InitAsDefaultInstance();
}

::google::protobuf::internal::SCCInfo<0> scc_info_TxRequest_TxRequestDetailsType_messages_2dbitcoin_2eproto =
    {{ATOMIC_VAR_INIT(::google::protobuf::internal::SCCInfoBase::kUninitialized), 0, InitDefaultsTxRequest_TxRequestDetailsType_messages_2dbitcoin_2eproto}, {}};

static void InitDefaultsTxRequest_TxRequestSerializedType_messages_2dbitcoin_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::hw::trezor::messages::bitcoin::_TxRequest_TxRequestSerializedType_default_instance_;
    new (ptr) ::hw::trezor::messages::bitcoin::TxRequest_TxRequestSerializedType();
    ::google::protobuf::internal::OnShutdownDestroyMessage(ptr);
  }
  ::hw::trezor::messages::bitcoin::TxRequest_TxRequestSerializedType::InitAsDefaultInstance();
}

::google::protobuf::internal::SCCInfo<0> scc_info_TxRequest_TxRequestSerializedType_messages_2dbitcoin_2eproto =
    {{ATOMIC_VAR_INIT(::google::protobuf::internal::SCCInfoBase::kUninitialized), 0, InitDefaultsTxRequest_TxRequestSerializedType_messages_2dbitcoin_2eproto}, {}};

static void InitDefaultsTxRequest_messages_2dbitcoin_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::hw::trezor::messages::bitcoin::_TxRequest_default_instance_;
    new (ptr) ::hw::trezor::messages::bitcoin::TxRequest();
    ::google::protobuf::internal::OnShutdownDestroyMessage(ptr);
  }
  ::hw::trezor::messages::bitcoin::TxRequest::InitAsDefaultInstance();
}

::google::protobuf::internal::SCCInfo<2> scc_info_TxRequest_messages_2dbitcoin_2eproto =
    {{ATOMIC_VAR_INIT(::google::protobuf::internal::SCCInfoBase::kUninitialized), 2, InitDefaultsTxRequest_messages_2dbitcoin_2eproto}, {
      &scc_info_TxRequest_TxRequestDetailsType_messages_2dbitcoin_2eproto.base,
      &scc_info_TxRequest_TxRequestSerializedType_messages_2dbitcoin_2eproto.base,}};

static void InitDefaultsTxAck_TransactionType_TxInputType_messages_2dbitcoin_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::hw::trezor::messages::bitcoin::_TxAck_TransactionType_TxInputType_default_instance_;
    new (ptr) ::hw::trezor::messages::bitcoin::TxAck_TransactionType_TxInputType();
    ::google::protobuf::internal::OnShutdownDestroyMessage(ptr);
  }
  ::hw::trezor::messages::bitcoin::TxAck_TransactionType_TxInputType::InitAsDefaultInstance();
}

::google::protobuf::internal::SCCInfo<1> scc_info_TxAck_TransactionType_TxInputType_messages_2dbitcoin_2eproto =
    {{ATOMIC_VAR_INIT(::google::protobuf::internal::SCCInfoBase::kUninitialized), 1, InitDefaultsTxAck_TransactionType_TxInputType_messages_2dbitcoin_2eproto}, {
      &scc_info_MultisigRedeemScriptType_messages_2dbitcoin_2eproto.base,}};

static void InitDefaultsTxAck_TransactionType_TxOutputBinType_messages_2dbitcoin_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::hw::trezor::messages::bitcoin::_TxAck_TransactionType_TxOutputBinType_default_instance_;
    new (ptr) ::hw::trezor::messages::bitcoin::TxAck_TransactionType_TxOutputBinType();
    ::google::protobuf::internal::OnShutdownDestroyMessage(ptr);
  }
  ::hw::trezor::messages::bitcoin::TxAck_TransactionType_TxOutputBinType::InitAsDefaultInstance();
}

::google::protobuf::internal::SCCInfo<0> scc_info_TxAck_TransactionType_TxOutputBinType_messages_2dbitcoin_2eproto =
    {{ATOMIC_VAR_INIT(::google::protobuf::internal::SCCInfoBase::kUninitialized), 0, InitDefaultsTxAck_TransactionType_TxOutputBinType_messages_2dbitcoin_2eproto}, {}};

static void InitDefaultsTxAck_TransactionType_TxOutputType_messages_2dbitcoin_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::hw::trezor::messages::bitcoin::_TxAck_TransactionType_TxOutputType_default_instance_;
    new (ptr) ::hw::trezor::messages::bitcoin::TxAck_TransactionType_TxOutputType();
    ::google::protobuf::internal::OnShutdownDestroyMessage(ptr);
  }
  ::hw::trezor::messages::bitcoin::TxAck_TransactionType_TxOutputType::InitAsDefaultInstance();
}

::google::protobuf::internal::SCCInfo<1> scc_info_TxAck_TransactionType_TxOutputType_messages_2dbitcoin_2eproto =
    {{ATOMIC_VAR_INIT(::google::protobuf::internal::SCCInfoBase::kUninitialized), 1, InitDefaultsTxAck_TransactionType_TxOutputType_messages_2dbitcoin_2eproto}, {
      &scc_info_MultisigRedeemScriptType_messages_2dbitcoin_2eproto.base,}};

static void InitDefaultsTxAck_TransactionType_messages_2dbitcoin_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::hw::trezor::messages::bitcoin::_TxAck_TransactionType_default_instance_;
    new (ptr) ::hw::trezor::messages::bitcoin::TxAck_TransactionType();
    ::google::protobuf::internal::OnShutdownDestroyMessage(ptr);
  }
  ::hw::trezor::messages::bitcoin::TxAck_TransactionType::InitAsDefaultInstance();
}

::google::protobuf::internal::SCCInfo<3> scc_info_TxAck_TransactionType_messages_2dbitcoin_2eproto =
    {{ATOMIC_VAR_INIT(::google::protobuf::internal::SCCInfoBase::kUninitialized), 3, InitDefaultsTxAck_TransactionType_messages_2dbitcoin_2eproto}, {
      &scc_info_TxAck_TransactionType_TxInputType_messages_2dbitcoin_2eproto.base,
      &scc_info_TxAck_TransactionType_TxOutputBinType_messages_2dbitcoin_2eproto.base,
      &scc_info_TxAck_TransactionType_TxOutputType_messages_2dbitcoin_2eproto.base,}};

static void InitDefaultsTxAck_messages_2dbitcoin_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::hw::trezor::messages::bitcoin::_TxAck_default_instance_;
    new (ptr) ::hw::trezor::messages::bitcoin::TxAck();
    ::google::protobuf::internal::OnShutdownDestroyMessage(ptr);
  }
  ::hw::trezor::messages::bitcoin::TxAck::InitAsDefaultInstance();
}

::google::protobuf::internal::SCCInfo<1> scc_info_TxAck_messages_2dbitcoin_2eproto =
    {{ATOMIC_VAR_INIT(::google::protobuf::internal::SCCInfoBase::kUninitialized), 1, InitDefaultsTxAck_messages_2dbitcoin_2eproto}, {
      &scc_info_TxAck_TransactionType_messages_2dbitcoin_2eproto.base,}};

void InitDefaults_messages_2dbitcoin_2eproto() {
  ::google::protobuf::internal::InitSCC(&scc_info_MultisigRedeemScriptType_HDNodePathType_messages_2dbitcoin_2eproto.base);
  ::google::protobuf::internal::InitSCC(&scc_info_MultisigRedeemScriptType_messages_2dbitcoin_2eproto.base);
  ::google::protobuf::internal::InitSCC(&scc_info_GetPublicKey_messages_2dbitcoin_2eproto.base);
  ::google::protobuf::internal::InitSCC(&scc_info_PublicKey_messages_2dbitcoin_2eproto.base);
  ::google::protobuf::internal::InitSCC(&scc_info_GetAddress_messages_2dbitcoin_2eproto.base);
  ::google::protobuf::internal::InitSCC(&scc_info_Address_messages_2dbitcoin_2eproto.base);
  ::google::protobuf::internal::InitSCC(&scc_info_SignMessage_messages_2dbitcoin_2eproto.base);
  ::google::protobuf::internal::InitSCC(&scc_info_MessageSignature_messages_2dbitcoin_2eproto.base);
  ::google::protobuf::internal::InitSCC(&scc_info_VerifyMessage_messages_2dbitcoin_2eproto.base);
  ::google::protobuf::internal::InitSCC(&scc_info_SignTx_messages_2dbitcoin_2eproto.base);
  ::google::protobuf::internal::InitSCC(&scc_info_TxRequest_TxRequestDetailsType_messages_2dbitcoin_2eproto.base);
  ::google::protobuf::internal::InitSCC(&scc_info_TxRequest_TxRequestSerializedType_messages_2dbitcoin_2eproto.base);
  ::google::protobuf::internal::InitSCC(&scc_info_TxRequest_messages_2dbitcoin_2eproto.base);
  ::google::protobuf::internal::InitSCC(&scc_info_TxAck_TransactionType_TxInputType_messages_2dbitcoin_2eproto.base);
  ::google::protobuf::internal::InitSCC(&scc_info_TxAck_TransactionType_TxOutputBinType_messages_2dbitcoin_2eproto.base);
  ::google::protobuf::internal::InitSCC(&scc_info_TxAck_TransactionType_TxOutputType_messages_2dbitcoin_2eproto.base);
  ::google::protobuf::internal::InitSCC(&scc_info_TxAck_TransactionType_messages_2dbitcoin_2eproto.base);
  ::google::protobuf::internal::InitSCC(&scc_info_TxAck_messages_2dbitcoin_2eproto.base);
}

::google::protobuf::Metadata file_level_metadata_messages_2dbitcoin_2eproto[18];
const ::google::protobuf::EnumDescriptor* file_level_enum_descriptors_messages_2dbitcoin_2eproto[3];
constexpr ::google::protobuf::ServiceDescriptor const** file_level_service_descriptors_messages_2dbitcoin_2eproto = nullptr;

const ::google::protobuf::uint32 TableStruct_messages_2dbitcoin_2eproto::offsets[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) = {
  PROTOBUF_FIELD_OFFSET(::hw::trezor::messages::bitcoin::MultisigRedeemScriptType_HDNodePathType, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::hw::trezor::messages::bitcoin::MultisigRedeemScriptType_HDNodePathType, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::hw::trezor::messages::bitcoin::MultisigRedeemScriptType_HDNodePathType, node_),
  PROTOBUF_FIELD_OFFSET(::hw::trezor::messages::bitcoin::MultisigRedeemScriptType_HDNodePathType, address_n_),
  0,
  ~0u,
  PROTOBUF_FIELD_OFFSET(::hw::trezor::messages::bitcoin::MultisigRedeemScriptType, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::hw::trezor::messages::bitcoin::MultisigRedeemScriptType, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::hw::trezor::messages::bitcoin::MultisigRedeemScriptType, pubkeys_),
  PROTOBUF_FIELD_OFFSET(::hw::trezor::messages::bitcoin::MultisigRedeemScriptType, signatures_),
  PROTOBUF_FIELD_OFFSET(::hw::trezor::messages::bitcoin::MultisigRedeemScriptType, m_),
  ~0u,
  ~0u,
  0,
  PROTOBUF_FIELD_OFFSET(::hw::trezor::messages::bitcoin::GetPublicKey, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::hw::trezor::messages::bitcoin::GetPublicKey, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::hw::trezor::messages::bitcoin::GetPublicKey, address_n_),
  PROTOBUF_FIELD_OFFSET(::hw::trezor::messages::bitcoin::GetPublicKey, ecdsa_curve_name_),
  PROTOBUF_FIELD_OFFSET(::hw::trezor::messages::bitcoin::GetPublicKey, show_display_),
  PROTOBUF_FIELD_OFFSET(::hw::trezor::messages::bitcoin::GetPublicKey, coin_name_),
  PROTOBUF_FIELD_OFFSET(::hw::trezor::messages::bitcoin::GetPublicKey, script_type_),
  ~0u,
  0,
  2,
  1,
  3,
  PROTOBUF_FIELD_OFFSET(::hw::trezor::messages::bitcoin::PublicKey, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::hw::trezor::messages::bitcoin::PublicKey, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::hw::trezor::messages::bitcoin::PublicKey, node_),
  PROTOBUF_FIELD_OFFSET(::hw::trezor::messages::bitcoin::PublicKey, xpub_),
  1,
  0,
  PROTOBUF_FIELD_OFFSET(::hw::trezor::messages::bitcoin::GetAddress, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::hw::trezor::messages::bitcoin::GetAddress, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::hw::trezor::messages::bitcoin::GetAddress, address_n_),
  PROTOBUF_FIELD_OFFSET(::hw::trezor::messages::bitcoin::GetAddress, coin_name_),
  PROTOBUF_FIELD_OFFSET(::hw::trezor::messages::bitcoin::GetAddress, show_display_),
  PROTOBUF_FIELD_OFFSET(::hw::trezor::messages::bitcoin::GetAddress, multisig_),
  PROTOBUF_FIELD_OFFSET(::hw::trezor::messages::bitcoin::GetAddress, script_type_),
  ~0u,
  0,
  2,
  1,
  3,
  PROTOBUF_FIELD_OFFSET(::hw::trezor::messages::bitcoin::Address, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::hw::trezor::messages::bitcoin::Address, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::hw::trezor::messages::bitcoin::Address, address_),
  0,
  PROTOBUF_FIELD_OFFSET(::hw::trezor::messages::bitcoin::SignMessage, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::hw::trezor::messages::bitcoin::SignMessage, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::hw::trezor::messages::bitcoin::SignMessage, address_n_),
  PROTOBUF_FIELD_OFFSET(::hw::trezor::messages::bitcoin::SignMessage, message_),
  PROTOBUF_FIELD_OFFSET(::hw::trezor::messages::bitcoin::SignMessage, coin_name_),
  PROTOBUF_FIELD_OFFSET(::hw::trezor::messages::bitcoin::SignMessage, script_type_),
  ~0u,
  0,
  1,
  2,
  PROTOBUF_FIELD_OFFSET(::hw::trezor::messages::bitcoin::MessageSignature, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::hw::trezor::messages::bitcoin::MessageSignature, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::hw::trezor::messages::bitcoin::MessageSignature, address_),
  PROTOBUF_FIELD_OFFSET(::hw::trezor::messages::bitcoin::MessageSignature, signature_),
  0,
  1,
  PROTOBUF_FIELD_OFFSET(::hw::trezor::messages::bitcoin::VerifyMessage, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::hw::trezor::messages::bitcoin::VerifyMessage, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::hw::trezor::messages::bitcoin::VerifyMessage, address_),
  PROTOBUF_FIELD_OFFSET(::hw::trezor::messages::bitcoin::VerifyMessage, signature_),
  PROTOBUF_FIELD_OFFSET(::hw::trezor::messages::bitcoin::VerifyMessage, message_),
  PROTOBUF_FIELD_OFFSET(::hw::trezor::messages::bitcoin::VerifyMessage, coin_name_),
  0,
  1,
  2,
  3,
  PROTOBUF_FIELD_OFFSET(::hw::trezor::messages::bitcoin::SignTx, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::hw::trezor::messages::bitcoin::SignTx, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::hw::trezor::messages::bitcoin::SignTx, outputs_count_),
  PROTOBUF_FIELD_OFFSET(::hw::trezor::messages::bitcoin::SignTx, inputs_count_),
  PROTOBUF_FIELD_OFFSET(::hw::trezor::messages::bitcoin::SignTx, coin_name_),
  PROTOBUF_FIELD_OFFSET(::hw::trezor::messages::bitcoin::SignTx, version_),
  PROTOBUF_FIELD_OFFSET(::hw::trezor::messages::bitcoin::SignTx, lock_time_),
  PROTOBUF_FIELD_OFFSET(::hw::trezor::messages::bitcoin::SignTx, expiry_),
  PROTOBUF_FIELD_OFFSET(::hw::trezor::messages::bitcoin::SignTx, overwintered_),
  PROTOBUF_FIELD_OFFSET(::hw::trezor::messages::bitcoin::SignTx, version_group_id_),
  PROTOBUF_FIELD_OFFSET(::hw::trezor::messages::bitcoin::SignTx, timestamp_),
  1,
  2,
  0,
  8,
  3,
  4,
  5,
  6,
  7,
  PROTOBUF_FIELD_OFFSET(::hw::trezor::messages::bitcoin::TxRequest_TxRequestDetailsType, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::hw::trezor::messages::bitcoin::TxRequest_TxRequestDetailsType, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::hw::trezor::messages::bitcoin::TxRequest_TxRequestDetailsType, request_index_),
  PROTOBUF_FIELD_OFFSET(::hw::trezor::messages::bitcoin::TxRequest_TxRequestDetailsType, tx_hash_),
  PROTOBUF_FIELD_OFFSET(::hw::trezor::messages::bitcoin::TxRequest_TxRequestDetailsType, extra_data_len_),
  PROTOBUF_FIELD_OFFSET(::hw::trezor::messages::bitcoin::TxRequest_TxRequestDetailsType, extra_data_offset_),
  1,
  0,
  2,
  3,
  PROTOBUF_FIELD_OFFSET(::hw::trezor::messages::bitcoin::TxRequest_TxRequestSerializedType, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::hw::trezor::messages::bitcoin::TxRequest_TxRequestSerializedType, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::hw::trezor::messages::bitcoin::TxRequest_TxRequestSerializedType, signature_index_),
  PROTOBUF_FIELD_OFFSET(::hw::trezor::messages::bitcoin::TxRequest_TxRequestSerializedType, signature_),
  PROTOBUF_FIELD_OFFSET(::hw::trezor::messages::bitcoin::TxRequest_TxRequestSerializedType, serialized_tx_),
  2,
  0,
  1,
  PROTOBUF_FIELD_OFFSET(::hw::trezor::messages::bitcoin::TxRequest, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::hw::trezor::messages::bitcoin::TxRequest, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::hw::trezor::messages::bitcoin::TxRequest, request_type_),
  PROTOBUF_FIELD_OFFSET(::hw::trezor::messages::bitcoin::TxRequest, details_),
  PROTOBUF_FIELD_OFFSET(::hw::trezor::messages::bitcoin::TxRequest, serialized_),
  2,
  0,
  1,
  PROTOBUF_FIELD_OFFSET(::hw::trezor::messages::bitcoin::TxAck_TransactionType_TxInputType, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::hw::trezor::messages::bitcoin::TxAck_TransactionType_TxInputType, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::hw::trezor::messages::bitcoin::TxAck_TransactionType_TxInputType, address_n_),
  PROTOBUF_FIELD_OFFSET(::hw::trezor::messages::bitcoin::TxAck_TransactionType_TxInputType, prev_hash_),
  PROTOBUF_FIELD_OFFSET(::hw::trezor::messages::bitcoin::TxAck_TransactionType_TxInputType, prev_index_),
  PROTOBUF_FIELD_OFFSET(::hw::trezor::messages::bitcoin::TxAck_TransactionType_TxInputType, script_sig_),
  PROTOBUF_FIELD_OFFSET(::hw::trezor::messages::bitcoin::TxAck_TransactionType_TxInputType, sequence_),
  PROTOBUF_FIELD_OFFSET(::hw::trezor::messages::bitcoin::TxAck_TransactionType_TxInputType, script_type_),
  PROTOBUF_FIELD_OFFSET(::hw::trezor::messages::bitcoin::TxAck_TransactionType_TxInputType, multisig_),
  PROTOBUF_FIELD_OFFSET(::hw::trezor::messages::bitcoin::TxAck_TransactionType_TxInputType, amount_),
  PROTOBUF_FIELD_OFFSET(::hw::trezor::messages::bitcoin::TxAck_TransactionType_TxInputType, decred_tree_),
  PROTOBUF_FIELD_OFFSET(::hw::trezor::messages::bitcoin::TxAck_TransactionType_TxInputType, decred_script_version_),
  PROTOBUF_FIELD_OFFSET(::hw::trezor::messages::bitcoin::TxAck_TransactionType_TxInputType, prev_block_hash_bip115_),
  PROTOBUF_FIELD_OFFSET(::hw::trezor::messages::bitcoin::TxAck_TransactionType_TxInputType, prev_block_height_bip115_),
  ~0u,
  0,
  4,
  1,
  10,
  5,
  3,
  6,
  7,
  8,
  2,
  9,
  PROTOBUF_FIELD_OFFSET(::hw::trezor::messages::bitcoin::TxAck_TransactionType_TxOutputBinType, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::hw::trezor::messages::bitcoin::TxAck_TransactionType_TxOutputBinType, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::hw::trezor::messages::bitcoin::TxAck_TransactionType_TxOutputBinType, amount_),
  PROTOBUF_FIELD_OFFSET(::hw::trezor::messages::bitcoin::TxAck_TransactionType_TxOutputBinType, script_pubkey_),
  PROTOBUF_FIELD_OFFSET(::hw::trezor::messages::bitcoin::TxAck_TransactionType_TxOutputBinType, decred_script_version_),
  1,
  0,
  2,
  PROTOBUF_FIELD_OFFSET(::hw::trezor::messages::bitcoin::TxAck_TransactionType_TxOutputType, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::hw::trezor::messages::bitcoin::TxAck_TransactionType_TxOutputType, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::hw::trezor::messages::bitcoin::TxAck_TransactionType_TxOutputType, address_),
  PROTOBUF_FIELD_OFFSET(::hw::trezor::messages::bitcoin::TxAck_TransactionType_TxOutputType, address_n_),
  PROTOBUF_FIELD_OFFSET(::hw::trezor::messages::bitcoin::TxAck_TransactionType_TxOutputType, amount_),
  PROTOBUF_FIELD_OFFSET(::hw::trezor::messages::bitcoin::TxAck_TransactionType_TxOutputType, script_type_),
  PROTOBUF_FIELD_OFFSET(::hw::trezor::messages::bitcoin::TxAck_TransactionType_TxOutputType, multisig_),
  PROTOBUF_FIELD_OFFSET(::hw::trezor::messages::bitcoin::TxAck_TransactionType_TxOutputType, op_return_data_),
  PROTOBUF_FIELD_OFFSET(::hw::trezor::messages::bitcoin::TxAck_TransactionType_TxOutputType, decred_script_version_),
  PROTOBUF_FIELD_OFFSET(::hw::trezor::messages::bitcoin::TxAck_TransactionType_TxOutputType, block_hash_bip115_),
  PROTOBUF_FIELD_OFFSET(::hw::trezor::messages::bitcoin::TxAck_TransactionType_TxOutputType, block_height_bip115_),
  0,
  ~0u,
  4,
  5,
  3,
  1,
  6,
  2,
  7,
  PROTOBUF_FIELD_OFFSET(::hw::trezor::messages::bitcoin::TxAck_TransactionType, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::hw::trezor::messages::bitcoin::TxAck_TransactionType, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::hw::trezor::messages::bitcoin::TxAck_TransactionType, version_),
  PROTOBUF_FIELD_OFFSET(::hw::trezor::messages::bitcoin::TxAck_TransactionType, inputs_),
  PROTOBUF_FIELD_OFFSET(::hw::trezor::messages::bitcoin::TxAck_TransactionType, bin_outputs_),
  PROTOBUF_FIELD_OFFSET(::hw::trezor::messages::bitcoin::TxAck_TransactionType, lock_time_),
  PROTOBUF_FIELD_OFFSET(::hw::trezor::messages::bitcoin::TxAck_TransactionType, outputs_),
  PROTOBUF_FIELD_OFFSET(::hw::trezor::messages::bitcoin::TxAck_TransactionType, inputs_cnt_),
  PROTOBUF_FIELD_OFFSET(::hw::trezor::messages::bitcoin::TxAck_TransactionType, outputs_cnt_),
  PROTOBUF_FIELD_OFFSET(::hw::trezor::messages::bitcoin::TxAck_TransactionType, extra_data_),
  PROTOBUF_FIELD_OFFSET(::hw::trezor::messages::bitcoin::TxAck_TransactionType, extra_data_len_),
  PROTOBUF_FIELD_OFFSET(::hw::trezor::messages::bitcoin::TxAck_TransactionType, expiry_),
  PROTOBUF_FIELD_OFFSET(::hw::trezor::messages::bitcoin::TxAck_TransactionType, overwintered_),
  PROTOBUF_FIELD_OFFSET(::hw::trezor::messages::bitcoin::TxAck_TransactionType, version_group_id_),
  PROTOBUF_FIELD_OFFSET(::hw::trezor::messages::bitcoin::TxAck_TransactionType, timestamp_),
  1,
  ~0u,
  ~0u,
  2,
  ~0u,
  3,
  4,
  0,
  5,
  6,
  7,
  8,
  9,
  PROTOBUF_FIELD_OFFSET(::hw::trezor::messages::bitcoin::TxAck, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::hw::trezor::messages::bitcoin::TxAck, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::hw::trezor::messages::bitcoin::TxAck, tx_),
  0,
};
static const ::google::protobuf::internal::MigrationSchema schemas[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) = {
  { 0, 7, sizeof(::hw::trezor::messages::bitcoin::MultisigRedeemScriptType_HDNodePathType)},
  { 9, 17, sizeof(::hw::trezor::messages::bitcoin::MultisigRedeemScriptType)},
  { 20, 30, sizeof(::hw::trezor::messages::bitcoin::GetPublicKey)},
  { 35, 42, sizeof(::hw::trezor::messages::bitcoin::PublicKey)},
  { 44, 54, sizeof(::hw::trezor::messages::bitcoin::GetAddress)},
  { 59, 65, sizeof(::hw::trezor::messages::bitcoin::Address)},
  { 66, 75, sizeof(::hw::trezor::messages::bitcoin::SignMessage)},
  { 79, 86, sizeof(::hw::trezor::messages::bitcoin::MessageSignature)},
  { 88, 97, sizeof(::hw::trezor::messages::bitcoin::VerifyMessage)},
  { 101, 115, sizeof(::hw::trezor::messages::bitcoin::SignTx)},
  { 124, 133, sizeof(::hw::trezor::messages::bitcoin::TxRequest_TxRequestDetailsType)},
  { 137, 145, sizeof(::hw::trezor::messages::bitcoin::TxRequest_TxRequestSerializedType)},
  { 148, 156, sizeof(::hw::trezor::messages::bitcoin::TxRequest)},
  { 159, 176, sizeof(::hw::trezor::messages::bitcoin::TxAck_TransactionType_TxInputType)},
  { 188, 196, sizeof(::hw::trezor::messages::bitcoin::TxAck_TransactionType_TxOutputBinType)},
  { 199, 213, sizeof(::hw::trezor::messages::bitcoin::TxAck_TransactionType_TxOutputType)},
  { 222, 240, sizeof(::hw::trezor::messages::bitcoin::TxAck_TransactionType)},
  { 253, 259, sizeof(::hw::trezor::messages::bitcoin::TxAck)},
};

static ::google::protobuf::Message const * const file_default_instances[] = {
  reinterpret_cast<const ::google::protobuf::Message*>(&::hw::trezor::messages::bitcoin::_MultisigRedeemScriptType_HDNodePathType_default_instance_),
  reinterpret_cast<const ::google::protobuf::Message*>(&::hw::trezor::messages::bitcoin::_MultisigRedeemScriptType_default_instance_),
  reinterpret_cast<const ::google::protobuf::Message*>(&::hw::trezor::messages::bitcoin::_GetPublicKey_default_instance_),
  reinterpret_cast<const ::google::protobuf::Message*>(&::hw::trezor::messages::bitcoin::_PublicKey_default_instance_),
  reinterpret_cast<const ::google::protobuf::Message*>(&::hw::trezor::messages::bitcoin::_GetAddress_default_instance_),
  reinterpret_cast<const ::google::protobuf::Message*>(&::hw::trezor::messages::bitcoin::_Address_default_instance_),
  reinterpret_cast<const ::google::protobuf::Message*>(&::hw::trezor::messages::bitcoin::_SignMessage_default_instance_),
  reinterpret_cast<const ::google::protobuf::Message*>(&::hw::trezor::messages::bitcoin::_MessageSignature_default_instance_),
  reinterpret_cast<const ::google::protobuf::Message*>(&::hw::trezor::messages::bitcoin::_VerifyMessage_default_instance_),
  reinterpret_cast<const ::google::protobuf::Message*>(&::hw::trezor::messages::bitcoin::_SignTx_default_instance_),
  reinterpret_cast<const ::google::protobuf::Message*>(&::hw::trezor::messages::bitcoin::_TxRequest_TxRequestDetailsType_default_instance_),
  reinterpret_cast<const ::google::protobuf::Message*>(&::hw::trezor::messages::bitcoin::_TxRequest_TxRequestSerializedType_default_instance_),
  reinterpret_cast<const ::google::protobuf::Message*>(&::hw::trezor::messages::bitcoin::_TxRequest_default_instance_),
  reinterpret_cast<const ::google::protobuf::Message*>(&::hw::trezor::messages::bitcoin::_TxAck_TransactionType_TxInputType_default_instance_),
  reinterpret_cast<const ::google::protobuf::Message*>(&::hw::trezor::messages::bitcoin::_TxAck_TransactionType_TxOutputBinType_default_instance_),
  reinterpret_cast<const ::google::protobuf::Message*>(&::hw::trezor::messages::bitcoin::_TxAck_TransactionType_TxOutputType_default_instance_),
  reinterpret_cast<const ::google::protobuf::Message*>(&::hw::trezor::messages::bitcoin::_TxAck_TransactionType_default_instance_),
  reinterpret_cast<const ::google::protobuf::Message*>(&::hw::trezor::messages::bitcoin::_TxAck_default_instance_),
};

::google::protobuf::internal::AssignDescriptorsTable assign_descriptors_table_messages_2dbitcoin_2eproto = {
  {}, AddDescriptors_messages_2dbitcoin_2eproto, "messages-bitcoin.proto", schemas,
  file_default_instances, TableStruct_messages_2dbitcoin_2eproto::offsets,
  file_level_metadata_messages_2dbitcoin_2eproto, 18, file_level_enum_descriptors_messages_2dbitcoin_2eproto, file_level_service_descriptors_messages_2dbitcoin_2eproto,
};

const char descriptor_table_protodef_messages_2dbitcoin_2eproto[] =
  "\n\026messages-bitcoin.proto\022\032hw.trezor.mess"
  "ages.bitcoin\032\025messages-common.proto\"\351\001\n\030"
  "MultisigRedeemScriptType\022T\n\007pubkeys\030\001 \003("
  "\0132C.hw.trezor.messages.bitcoin.MultisigR"
  "edeemScriptType.HDNodePathType\022\022\n\nsignat"
  "ures\030\002 \003(\014\022\t\n\001m\030\003 \001(\r\032X\n\016HDNodePathType\022"
  "3\n\004node\030\001 \002(\0132%.hw.trezor.messages.commo"
  "n.HDNodeType\022\021\n\taddress_n\030\002 \003(\r\"\275\001\n\014GetP"
  "ublicKey\022\021\n\taddress_n\030\001 \003(\r\022\030\n\020ecdsa_cur"
  "ve_name\030\002 \001(\t\022\024\n\014show_display\030\003 \001(\010\022\032\n\tc"
  "oin_name\030\004 \001(\t:\007Bitcoin\022N\n\013script_type\030\005"
  " \001(\0162+.hw.trezor.messages.bitcoin.InputS"
  "criptType:\014SPENDADDRESS\"N\n\tPublicKey\0223\n\004"
  "node\030\001 \002(\0132%.hw.trezor.messages.common.H"
  "DNodeType\022\014\n\004xpub\030\002 \001(\t\"\351\001\n\nGetAddress\022\021"
  "\n\taddress_n\030\001 \003(\r\022\032\n\tcoin_name\030\002 \001(\t:\007Bi"
  "tcoin\022\024\n\014show_display\030\003 \001(\010\022F\n\010multisig\030"
  "\004 \001(\01324.hw.trezor.messages.bitcoin.Multi"
  "sigRedeemScriptType\022N\n\013script_type\030\005 \001(\016"
  "2+.hw.trezor.messages.bitcoin.InputScrip"
  "tType:\014SPENDADDRESS\"\032\n\007Address\022\017\n\007addres"
  "s\030\001 \002(\t\"\235\001\n\013SignMessage\022\021\n\taddress_n\030\001 \003"
  "(\r\022\017\n\007message\030\002 \002(\014\022\032\n\tcoin_name\030\003 \001(\t:\007"
  "Bitcoin\022N\n\013script_type\030\004 \001(\0162+.hw.trezor"
  ".messages.bitcoin.InputScriptType:\014SPEND"
  "ADDRESS\"6\n\020MessageSignature\022\017\n\007address\030\001"
  " \001(\t\022\021\n\tsignature\030\002 \001(\014\"`\n\rVerifyMessage"
  "\022\017\n\007address\030\001 \001(\t\022\021\n\tsignature\030\002 \001(\014\022\017\n\007"
  "message\030\003 \001(\014\022\032\n\tcoin_name\030\004 \001(\t:\007Bitcoi"
  "n\"\316\001\n\006SignTx\022\025\n\routputs_count\030\001 \002(\r\022\024\n\014i"
  "nputs_count\030\002 \002(\r\022\032\n\tcoin_name\030\003 \001(\t:\007Bi"
  "tcoin\022\022\n\007version\030\004 \001(\r:\0011\022\024\n\tlock_time\030\005"
  " \001(\r:\0010\022\016\n\006expiry\030\006 \001(\r\022\024\n\014overwintered\030"
  "\007 \001(\010\022\030\n\020version_group_id\030\010 \001(\r\022\021\n\ttimes"
  "tamp\030\t \001(\r\"\234\004\n\tTxRequest\022G\n\014request_type"
  "\030\001 \001(\01621.hw.trezor.messages.bitcoin.TxRe"
  "quest.RequestType\022K\n\007details\030\002 \001(\0132:.hw."
  "trezor.messages.bitcoin.TxRequest.TxRequ"
  "estDetailsType\022Q\n\nserialized\030\003 \001(\0132=.hw."
  "trezor.messages.bitcoin.TxRequest.TxRequ"
  "estSerializedType\032q\n\024TxRequestDetailsTyp"
  "e\022\025\n\rrequest_index\030\001 \001(\r\022\017\n\007tx_hash\030\002 \001("
  "\014\022\026\n\016extra_data_len\030\003 \001(\r\022\031\n\021extra_data_"
  "offset\030\004 \001(\r\032\\\n\027TxRequestSerializedType\022"
  "\027\n\017signature_index\030\001 \001(\r\022\021\n\tsignature\030\002 "
  "\001(\014\022\025\n\rserialized_tx\030\003 \001(\014\"U\n\013RequestTyp"
  "e\022\013\n\007TXINPUT\020\000\022\014\n\010TXOUTPUT\020\001\022\n\n\006TXMETA\020\002"
  "\022\016\n\nTXFINISHED\020\003\022\017\n\013TXEXTRADATA\020\004\"\375\013\n\005Tx"
  "Ack\022=\n\002tx\030\001 \001(\01321.hw.trezor.messages.bit"
  "coin.TxAck.TransactionType\032\264\013\n\017Transacti"
  "onType\022\017\n\007version\030\001 \001(\r\022M\n\006inputs\030\002 \003(\0132"
  "=.hw.trezor.messages.bitcoin.TxAck.Trans"
  "actionType.TxInputType\022V\n\013bin_outputs\030\003 "
  "\003(\0132A.hw.trezor.messages.bitcoin.TxAck.T"
  "ransactionType.TxOutputBinType\022\021\n\tlock_t"
  "ime\030\004 \001(\r\022O\n\007outputs\030\005 \003(\0132>.hw.trezor.m"
  "essages.bitcoin.TxAck.TransactionType.Tx"
  "OutputType\022\022\n\ninputs_cnt\030\006 \001(\r\022\023\n\013output"
  "s_cnt\030\007 \001(\r\022\022\n\nextra_data\030\010 \001(\014\022\026\n\016extra"
  "_data_len\030\t \001(\r\022\016\n\006expiry\030\n \001(\r\022\024\n\014overw"
  "intered\030\013 \001(\010\022\030\n\020version_group_id\030\014 \001(\r\022"
  "\021\n\ttimestamp\030\r \001(\r\032\227\003\n\013TxInputType\022\021\n\tad"
  "dress_n\030\001 \003(\r\022\021\n\tprev_hash\030\002 \002(\014\022\022\n\nprev"
  "_index\030\003 \002(\r\022\022\n\nscript_sig\030\004 \001(\014\022\034\n\010sequ"
  "ence\030\005 \001(\r:\n4294967295\022N\n\013script_type\030\006 "
  "\001(\0162+.hw.trezor.messages.bitcoin.InputSc"
  "riptType:\014SPENDADDRESS\022F\n\010multisig\030\007 \001(\013"
  "24.hw.trezor.messages.bitcoin.MultisigRe"
  "deemScriptType\022\016\n\006amount\030\010 \001(\004\022\023\n\013decred"
  "_tree\030\t \001(\r\022\035\n\025decred_script_version\030\n \001"
  "(\r\022\036\n\026prev_block_hash_bip115\030\013 \001(\014\022 \n\030pr"
  "ev_block_height_bip115\030\014 \001(\r\032W\n\017TxOutput"
  "BinType\022\016\n\006amount\030\001 \002(\004\022\025\n\rscript_pubkey"
  "\030\002 \002(\014\022\035\n\025decred_script_version\030\003 \001(\r\032\351\003"
  "\n\014TxOutputType\022\017\n\007address\030\001 \001(\t\022\021\n\taddre"
  "ss_n\030\002 \003(\r\022\016\n\006amount\030\003 \002(\004\022d\n\013script_typ"
  "e\030\004 \002(\0162O.hw.trezor.messages.bitcoin.TxA"
  "ck.TransactionType.TxOutputType.OutputSc"
  "riptType\022F\n\010multisig\030\005 \001(\01324.hw.trezor.m"
  "essages.bitcoin.MultisigRedeemScriptType"
  "\022\026\n\016op_return_data\030\006 \001(\014\022\035\n\025decred_scrip"
  "t_version\030\007 \001(\r\022\031\n\021block_hash_bip115\030\010 \001"
  "(\014\022\033\n\023block_height_bip115\030\t \001(\r\"\207\001\n\020Outp"
  "utScriptType\022\020\n\014PAYTOADDRESS\020\000\022\023\n\017PAYTOS"
  "CRIPTHASH\020\001\022\021\n\rPAYTOMULTISIG\020\002\022\021\n\rPAYTOO"
  "PRETURN\020\003\022\020\n\014PAYTOWITNESS\020\004\022\024\n\020PAYTOP2SH"
  "WITNESS\020\005*l\n\017InputScriptType\022\020\n\014SPENDADD"
  "RESS\020\000\022\021\n\rSPENDMULTISIG\020\001\022\014\n\010EXTERNAL\020\002\022"
  "\020\n\014SPENDWITNESS\020\003\022\024\n\020SPENDP2SHWITNESS\020\004B"
  ";\n#com.satoshilabs.trezor.lib.protobufB\024"
  "TrezorMessageBitcoin"
  ;
::google::protobuf::internal::DescriptorTable descriptor_table_messages_2dbitcoin_2eproto = {
  false, InitDefaults_messages_2dbitcoin_2eproto, 
  descriptor_table_protodef_messages_2dbitcoin_2eproto,
  "messages-bitcoin.proto", &assign_descriptors_table_messages_2dbitcoin_2eproto, 3620,
};

void AddDescriptors_messages_2dbitcoin_2eproto() {
  static constexpr ::google::protobuf::internal::InitFunc deps[1] =
  {
    ::AddDescriptors_messages_2dcommon_2eproto,
  };
 ::google::protobuf::internal::AddDescriptors(&descriptor_table_messages_2dbitcoin_2eproto, deps, 1);
}

// Force running AddDescriptors() at dynamic initialization time.
static bool dynamic_init_dummy_messages_2dbitcoin_2eproto = []() { AddDescriptors_messages_2dbitcoin_2eproto(); return true; }();
namespace hw {
namespace trezor {
namespace messages {
namespace bitcoin {
const ::google::protobuf::EnumDescriptor* TxRequest_RequestType_descriptor() {
  ::google::protobuf::internal::AssignDescriptors(&assign_descriptors_table_messages_2dbitcoin_2eproto);
  return file_level_enum_descriptors_messages_2dbitcoin_2eproto[0];
}
bool TxRequest_RequestType_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
      return true;
    default:
      return false;
  }
}

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const TxRequest_RequestType TxRequest::TXINPUT;
const TxRequest_RequestType TxRequest::TXOUTPUT;
const TxRequest_RequestType TxRequest::TXMETA;
const TxRequest_RequestType TxRequest::TXFINISHED;
const TxRequest_RequestType TxRequest::TXEXTRADATA;
const TxRequest_RequestType TxRequest::RequestType_MIN;
const TxRequest_RequestType TxRequest::RequestType_MAX;
const int TxRequest::RequestType_ARRAYSIZE;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900
const ::google::protobuf::EnumDescriptor* TxAck_TransactionType_TxOutputType_OutputScriptType_descriptor() {
  ::google::protobuf::internal::AssignDescriptors(&assign_descriptors_table_messages_2dbitcoin_2eproto);
  return file_level_enum_descriptors_messages_2dbitcoin_2eproto[1];
}
bool TxAck_TransactionType_TxOutputType_OutputScriptType_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
      return true;
    default:
      return false;
  }
}

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const TxAck_TransactionType_TxOutputType_OutputScriptType TxAck_TransactionType_TxOutputType::PAYTOADDRESS;
const TxAck_TransactionType_TxOutputType_OutputScriptType TxAck_TransactionType_TxOutputType::PAYTOSCRIPTHASH;
const TxAck_TransactionType_TxOutputType_OutputScriptType TxAck_TransactionType_TxOutputType::PAYTOMULTISIG;
const TxAck_TransactionType_TxOutputType_OutputScriptType TxAck_TransactionType_TxOutputType::PAYTOOPRETURN;
const TxAck_TransactionType_TxOutputType_OutputScriptType TxAck_TransactionType_TxOutputType::PAYTOWITNESS;
const TxAck_TransactionType_TxOutputType_OutputScriptType TxAck_TransactionType_TxOutputType::PAYTOP2SHWITNESS;
const TxAck_TransactionType_TxOutputType_OutputScriptType TxAck_TransactionType_TxOutputType::OutputScriptType_MIN;
const TxAck_TransactionType_TxOutputType_OutputScriptType TxAck_TransactionType_TxOutputType::OutputScriptType_MAX;
const int TxAck_TransactionType_TxOutputType::OutputScriptType_ARRAYSIZE;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900
const ::google::protobuf::EnumDescriptor* InputScriptType_descriptor() {
  ::google::protobuf::internal::AssignDescriptors(&assign_descriptors_table_messages_2dbitcoin_2eproto);
  return file_level_enum_descriptors_messages_2dbitcoin_2eproto[2];
}
bool InputScriptType_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
      return true;
    default:
      return false;
  }
}


// ===================================================================

void MultisigRedeemScriptType_HDNodePathType::InitAsDefaultInstance() {
  ::hw::trezor::messages::bitcoin::_MultisigRedeemScriptType_HDNodePathType_default_instance_._instance.get_mutable()->node_ = const_cast< ::hw::trezor::messages::common::HDNodeType*>(
      ::hw::trezor::messages::common::HDNodeType::internal_default_instance());
}
class MultisigRedeemScriptType_HDNodePathType::HasBitSetters {
 public:
  static const ::hw::trezor::messages::common::HDNodeType& node(const MultisigRedeemScriptType_HDNodePathType* msg);
  static void set_has_node(MultisigRedeemScriptType_HDNodePathType* msg) {
    msg->_has_bits_[0] |= 0x00000001u;
  }
};

const ::hw::trezor::messages::common::HDNodeType&
MultisigRedeemScriptType_HDNodePathType::HasBitSetters::node(const MultisigRedeemScriptType_HDNodePathType* msg) {
  return *msg->node_;
}
void MultisigRedeemScriptType_HDNodePathType::clear_node() {
  if (node_ != nullptr) node_->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int MultisigRedeemScriptType_HDNodePathType::kNodeFieldNumber;
const int MultisigRedeemScriptType_HDNodePathType::kAddressNFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

MultisigRedeemScriptType_HDNodePathType::MultisigRedeemScriptType_HDNodePathType()
  : ::google::protobuf::Message(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:hw.trezor.messages.bitcoin.MultisigRedeemScriptType.HDNodePathType)
}
MultisigRedeemScriptType_HDNodePathType::MultisigRedeemScriptType_HDNodePathType(const MultisigRedeemScriptType_HDNodePathType& from)
  : ::google::protobuf::Message(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_),
      address_n_(from.address_n_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  if (from.has_node()) {
    node_ = new ::hw::trezor::messages::common::HDNodeType(*from.node_);
  } else {
    node_ = nullptr;
  }
  // @@protoc_insertion_point(copy_constructor:hw.trezor.messages.bitcoin.MultisigRedeemScriptType.HDNodePathType)
}

void MultisigRedeemScriptType_HDNodePathType::SharedCtor() {
  ::google::protobuf::internal::InitSCC(
      &scc_info_MultisigRedeemScriptType_HDNodePathType_messages_2dbitcoin_2eproto.base);
  node_ = nullptr;
}

MultisigRedeemScriptType_HDNodePathType::~MultisigRedeemScriptType_HDNodePathType() {
  // @@protoc_insertion_point(destructor:hw.trezor.messages.bitcoin.MultisigRedeemScriptType.HDNodePathType)
  SharedDtor();
}

void MultisigRedeemScriptType_HDNodePathType::SharedDtor() {
  if (this != internal_default_instance()) delete node_;
}

void MultisigRedeemScriptType_HDNodePathType::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const MultisigRedeemScriptType_HDNodePathType& MultisigRedeemScriptType_HDNodePathType::default_instance() {
  ::google::protobuf::internal::InitSCC(&::scc_info_MultisigRedeemScriptType_HDNodePathType_messages_2dbitcoin_2eproto.base);
  return *internal_default_instance();
}


void MultisigRedeemScriptType_HDNodePathType::Clear() {
// @@protoc_insertion_point(message_clear_start:hw.trezor.messages.bitcoin.MultisigRedeemScriptType.HDNodePathType)
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  address_n_.Clear();
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    GOOGLE_DCHECK(node_ != nullptr);
    node_->Clear();
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* MultisigRedeemScriptType_HDNodePathType::_InternalParse(const char* begin, const char* end, void* object,
                  ::google::protobuf::internal::ParseContext* ctx) {
  auto msg = static_cast<MultisigRedeemScriptType_HDNodePathType*>(object);
  ::google::protobuf::int32 size; (void)size;
  int depth; (void)depth;
  ::google::protobuf::uint32 tag;
  ::google::protobuf::internal::ParseFunc parser_till_end; (void)parser_till_end;
  auto ptr = begin;
  while (ptr < end) {
    ptr = ::google::protobuf::io::Parse32(ptr, &tag);
    GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
    switch (tag >> 3) {
      // required .hw.trezor.messages.common.HDNodeType node = 1;
      case 1: {
        if (static_cast<::google::protobuf::uint8>(tag) != 10) goto handle_unusual;
        ptr = ::google::protobuf::io::ReadSize(ptr, &size);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        parser_till_end = ::hw::trezor::messages::common::HDNodeType::_InternalParse;
        object = msg->mutable_node();
        if (size > end - ptr) goto len_delim_till_end;
        ptr += size;
        GOOGLE_PROTOBUF_PARSER_ASSERT(ctx->ParseExactRange(
            {parser_till_end, object}, ptr - size, ptr));
        break;
      }
      // repeated uint32 address_n = 2;
      case 2: {
        if (static_cast<::google::protobuf::uint8>(tag) == 16) {
          do {
            msg->add_address_n(::google::protobuf::internal::ReadVarint(&ptr));
            GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
            if (ptr >= end) break;
          } while ((::google::protobuf::io::UnalignedLoad<::google::protobuf::uint64>(ptr) & 255) == 16 && (ptr += 1));
          break;
        } else if (static_cast<::google::protobuf::uint8>(tag) != 18) goto handle_unusual;
        ptr = ::google::protobuf::io::ReadSize(ptr, &size);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        parser_till_end = ::google::protobuf::internal::PackedUInt32Parser;
        object = msg->mutable_address_n();
        if (size > end - ptr) goto len_delim_till_end;
        auto newend = ptr + size;
        if (size) ptr = parser_till_end(ptr, newend, object, ctx);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr == newend);
        break;
      }
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->EndGroup(tag);
          return ptr;
        }
        auto res = UnknownFieldParse(tag, {_InternalParse, msg},
          ptr, end, msg->_internal_metadata_.mutable_unknown_fields(), ctx);
        ptr = res.first;
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr != nullptr);
        if (res.second) return ptr;
      }
    }  // switch
  }  // while
  return ptr;
len_delim_till_end:
  return ctx->StoreAndTailCall(ptr, end, {_InternalParse, msg},
                               {parser_till_end, object}, size);
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool MultisigRedeemScriptType_HDNodePathType::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:hw.trezor.messages.bitcoin.MultisigRedeemScriptType.HDNodePathType)
  for (;;) {
    ::std::pair<::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required .hw.trezor.messages.common.HDNodeType node = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (10 & 0xFF)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessage(
               input, mutable_node()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // repeated uint32 address_n = 2;
      case 2: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (16 & 0xFF)) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadRepeatedPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 1, 16u, input, this->mutable_address_n())));
        } else if (static_cast< ::google::protobuf::uint8>(tag) == (18 & 0xFF)) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPackedPrimitiveNoInline<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, this->mutable_address_n())));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, _internal_metadata_.mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:hw.trezor.messages.bitcoin.MultisigRedeemScriptType.HDNodePathType)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:hw.trezor.messages.bitcoin.MultisigRedeemScriptType.HDNodePathType)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void MultisigRedeemScriptType_HDNodePathType::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:hw.trezor.messages.bitcoin.MultisigRedeemScriptType.HDNodePathType)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required .hw.trezor.messages.common.HDNodeType node = 1;
  if (cached_has_bits & 0x00000001u) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, HasBitSetters::node(this), output);
  }

  // repeated uint32 address_n = 2;
  for (int i = 0, n = this->address_n_size(); i < n; i++) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(
      2, this->address_n(i), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        _internal_metadata_.unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:hw.trezor.messages.bitcoin.MultisigRedeemScriptType.HDNodePathType)
}

::google::protobuf::uint8* MultisigRedeemScriptType_HDNodePathType::InternalSerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:hw.trezor.messages.bitcoin.MultisigRedeemScriptType.HDNodePathType)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required .hw.trezor.messages.common.HDNodeType node = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageToArray(
        1, HasBitSetters::node(this), target);
  }

  // repeated uint32 address_n = 2;
  target = ::google::protobuf::internal::WireFormatLite::
    WriteUInt32ToArray(2, this->address_n_, target);

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:hw.trezor.messages.bitcoin.MultisigRedeemScriptType.HDNodePathType)
  return target;
}

size_t MultisigRedeemScriptType_HDNodePathType::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:hw.trezor.messages.bitcoin.MultisigRedeemScriptType.HDNodePathType)
  size_t total_size = 0;

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        _internal_metadata_.unknown_fields());
  }
  // required .hw.trezor.messages.common.HDNodeType node = 1;
  if (has_node()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::MessageSize(
        *node_);
  }
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated uint32 address_n = 2;
  {
    size_t data_size = ::google::protobuf::internal::WireFormatLite::
      UInt32Size(this->address_n_);
    total_size += 1 *
                  ::google::protobuf::internal::FromIntSize(this->address_n_size());
    total_size += data_size;
  }

  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void MultisigRedeemScriptType_HDNodePathType::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:hw.trezor.messages.bitcoin.MultisigRedeemScriptType.HDNodePathType)
  GOOGLE_DCHECK_NE(&from, this);
  const MultisigRedeemScriptType_HDNodePathType* source =
      ::google::protobuf::DynamicCastToGenerated<MultisigRedeemScriptType_HDNodePathType>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:hw.trezor.messages.bitcoin.MultisigRedeemScriptType.HDNodePathType)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:hw.trezor.messages.bitcoin.MultisigRedeemScriptType.HDNodePathType)
    MergeFrom(*source);
  }
}

void MultisigRedeemScriptType_HDNodePathType::MergeFrom(const MultisigRedeemScriptType_HDNodePathType& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:hw.trezor.messages.bitcoin.MultisigRedeemScriptType.HDNodePathType)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  address_n_.MergeFrom(from.address_n_);
  if (from.has_node()) {
    mutable_node()->::hw::trezor::messages::common::HDNodeType::MergeFrom(from.node());
  }
}

void MultisigRedeemScriptType_HDNodePathType::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:hw.trezor.messages.bitcoin.MultisigRedeemScriptType.HDNodePathType)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void MultisigRedeemScriptType_HDNodePathType::CopyFrom(const MultisigRedeemScriptType_HDNodePathType& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:hw.trezor.messages.bitcoin.MultisigRedeemScriptType.HDNodePathType)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool MultisigRedeemScriptType_HDNodePathType::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;
  if (has_node()) {
    if (!this->node_->IsInitialized()) return false;
  }
  return true;
}

void MultisigRedeemScriptType_HDNodePathType::Swap(MultisigRedeemScriptType_HDNodePathType* other) {
  if (other == this) return;
  InternalSwap(other);
}
void MultisigRedeemScriptType_HDNodePathType::InternalSwap(MultisigRedeemScriptType_HDNodePathType* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  address_n_.InternalSwap(&other->address_n_);
  swap(node_, other->node_);
}

::google::protobuf::Metadata MultisigRedeemScriptType_HDNodePathType::GetMetadata() const {
  ::google::protobuf::internal::AssignDescriptors(&::assign_descriptors_table_messages_2dbitcoin_2eproto);
  return ::file_level_metadata_messages_2dbitcoin_2eproto[kIndexInFileMessages];
}


// ===================================================================

void MultisigRedeemScriptType::InitAsDefaultInstance() {
}
class MultisigRedeemScriptType::HasBitSetters {
 public:
  static void set_has_m(MultisigRedeemScriptType* msg) {
    msg->_has_bits_[0] |= 0x00000001u;
  }
};

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int MultisigRedeemScriptType::kPubkeysFieldNumber;
const int MultisigRedeemScriptType::kSignaturesFieldNumber;
const int MultisigRedeemScriptType::kMFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

MultisigRedeemScriptType::MultisigRedeemScriptType()
  : ::google::protobuf::Message(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:hw.trezor.messages.bitcoin.MultisigRedeemScriptType)
}
MultisigRedeemScriptType::MultisigRedeemScriptType(const MultisigRedeemScriptType& from)
  : ::google::protobuf::Message(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_),
      pubkeys_(from.pubkeys_),
      signatures_(from.signatures_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  m_ = from.m_;
  // @@protoc_insertion_point(copy_constructor:hw.trezor.messages.bitcoin.MultisigRedeemScriptType)
}

void MultisigRedeemScriptType::SharedCtor() {
  ::google::protobuf::internal::InitSCC(
      &scc_info_MultisigRedeemScriptType_messages_2dbitcoin_2eproto.base);
  m_ = 0u;
}

MultisigRedeemScriptType::~MultisigRedeemScriptType() {
  // @@protoc_insertion_point(destructor:hw.trezor.messages.bitcoin.MultisigRedeemScriptType)
  SharedDtor();
}

void MultisigRedeemScriptType::SharedDtor() {
}

void MultisigRedeemScriptType::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const MultisigRedeemScriptType& MultisigRedeemScriptType::default_instance() {
  ::google::protobuf::internal::InitSCC(&::scc_info_MultisigRedeemScriptType_messages_2dbitcoin_2eproto.base);
  return *internal_default_instance();
}


void MultisigRedeemScriptType::Clear() {
// @@protoc_insertion_point(message_clear_start:hw.trezor.messages.bitcoin.MultisigRedeemScriptType)
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  pubkeys_.Clear();
  signatures_.Clear();
  m_ = 0u;
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* MultisigRedeemScriptType::_InternalParse(const char* begin, const char* end, void* object,
                  ::google::protobuf::internal::ParseContext* ctx) {
  auto msg = static_cast<MultisigRedeemScriptType*>(object);
  ::google::protobuf::int32 size; (void)size;
  int depth; (void)depth;
  ::google::protobuf::uint32 tag;
  ::google::protobuf::internal::ParseFunc parser_till_end; (void)parser_till_end;
  auto ptr = begin;
  while (ptr < end) {
    ptr = ::google::protobuf::io::Parse32(ptr, &tag);
    GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
    switch (tag >> 3) {
      // repeated .hw.trezor.messages.bitcoin.MultisigRedeemScriptType.HDNodePathType pubkeys = 1;
      case 1: {
        if (static_cast<::google::protobuf::uint8>(tag) != 10) goto handle_unusual;
        do {
          ptr = ::google::protobuf::io::ReadSize(ptr, &size);
          GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
          parser_till_end = ::hw::trezor::messages::bitcoin::MultisigRedeemScriptType_HDNodePathType::_InternalParse;
          object = msg->add_pubkeys();
          if (size > end - ptr) goto len_delim_till_end;
          ptr += size;
          GOOGLE_PROTOBUF_PARSER_ASSERT(ctx->ParseExactRange(
              {parser_till_end, object}, ptr - size, ptr));
          if (ptr >= end) break;
        } while ((::google::protobuf::io::UnalignedLoad<::google::protobuf::uint64>(ptr) & 255) == 10 && (ptr += 1));
        break;
      }
      // repeated bytes signatures = 2;
      case 2: {
        if (static_cast<::google::protobuf::uint8>(tag) != 18) goto handle_unusual;
        do {
          ptr = ::google::protobuf::io::ReadSize(ptr, &size);
          GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
          object = msg->add_signatures();
          if (size > end - ptr + ::google::protobuf::internal::ParseContext::kSlopBytes) {
            parser_till_end = ::google::protobuf::internal::GreedyStringParser;
            goto string_till_end;
          }
          GOOGLE_PROTOBUF_PARSER_ASSERT(::google::protobuf::internal::StringCheck(ptr, size, ctx));
          ::google::protobuf::internal::InlineGreedyStringParser(object, ptr, size, ctx);
          ptr += size;
          if (ptr >= end) break;
        } while ((::google::protobuf::io::UnalignedLoad<::google::protobuf::uint64>(ptr) & 255) == 18 && (ptr += 1));
        break;
      }
      // optional uint32 m = 3;
      case 3: {
        if (static_cast<::google::protobuf::uint8>(tag) != 24) goto handle_unusual;
        msg->set_m(::google::protobuf::internal::ReadVarint(&ptr));
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        break;
      }
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->EndGroup(tag);
          return ptr;
        }
        auto res = UnknownFieldParse(tag, {_InternalParse, msg},
          ptr, end, msg->_internal_metadata_.mutable_unknown_fields(), ctx);
        ptr = res.first;
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr != nullptr);
        if (res.second) return ptr;
      }
    }  // switch
  }  // while
  return ptr;
string_till_end:
  static_cast<::std::string*>(object)->clear();
  static_cast<::std::string*>(object)->reserve(size);
  goto len_delim_till_end;
len_delim_till_end:
  return ctx->StoreAndTailCall(ptr, end, {_InternalParse, msg},
                               {parser_till_end, object}, size);
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool MultisigRedeemScriptType::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:hw.trezor.messages.bitcoin.MultisigRedeemScriptType)
  for (;;) {
    ::std::pair<::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated .hw.trezor.messages.bitcoin.MultisigRedeemScriptType.HDNodePathType pubkeys = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (10 & 0xFF)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessage(
                input, add_pubkeys()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // repeated bytes signatures = 2;
      case 2: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (18 & 0xFF)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->add_signatures()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional uint32 m = 3;
      case 3: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (24 & 0xFF)) {
          HasBitSetters::set_has_m(this);
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &m_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, _internal_metadata_.mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:hw.trezor.messages.bitcoin.MultisigRedeemScriptType)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:hw.trezor.messages.bitcoin.MultisigRedeemScriptType)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void MultisigRedeemScriptType::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:hw.trezor.messages.bitcoin.MultisigRedeemScriptType)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .hw.trezor.messages.bitcoin.MultisigRedeemScriptType.HDNodePathType pubkeys = 1;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->pubkeys_size()); i < n; i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1,
      this->pubkeys(static_cast<int>(i)),
      output);
  }

  // repeated bytes signatures = 2;
  for (int i = 0, n = this->signatures_size(); i < n; i++) {
    ::google::protobuf::internal::WireFormatLite::WriteBytes(
      2, this->signatures(i), output);
  }

  cached_has_bits = _has_bits_[0];
  // optional uint32 m = 3;
  if (cached_has_bits & 0x00000001u) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(3, this->m(), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        _internal_metadata_.unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:hw.trezor.messages.bitcoin.MultisigRedeemScriptType)
}

::google::protobuf::uint8* MultisigRedeemScriptType::InternalSerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:hw.trezor.messages.bitcoin.MultisigRedeemScriptType)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .hw.trezor.messages.bitcoin.MultisigRedeemScriptType.HDNodePathType pubkeys = 1;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->pubkeys_size()); i < n; i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageToArray(
        1, this->pubkeys(static_cast<int>(i)), target);
  }

  // repeated bytes signatures = 2;
  for (int i = 0, n = this->signatures_size(); i < n; i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteBytesToArray(2, this->signatures(i), target);
  }

  cached_has_bits = _has_bits_[0];
  // optional uint32 m = 3;
  if (cached_has_bits & 0x00000001u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(3, this->m(), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:hw.trezor.messages.bitcoin.MultisigRedeemScriptType)
  return target;
}

size_t MultisigRedeemScriptType::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:hw.trezor.messages.bitcoin.MultisigRedeemScriptType)
  size_t total_size = 0;

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        _internal_metadata_.unknown_fields());
  }
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .hw.trezor.messages.bitcoin.MultisigRedeemScriptType.HDNodePathType pubkeys = 1;
  {
    unsigned int count = static_cast<unsigned int>(this->pubkeys_size());
    total_size += 1UL * count;
    for (unsigned int i = 0; i < count; i++) {
      total_size +=
        ::google::protobuf::internal::WireFormatLite::MessageSize(
          this->pubkeys(static_cast<int>(i)));
    }
  }

  // repeated bytes signatures = 2;
  total_size += 1 *
      ::google::protobuf::internal::FromIntSize(this->signatures_size());
  for (int i = 0, n = this->signatures_size(); i < n; i++) {
    total_size += ::google::protobuf::internal::WireFormatLite::BytesSize(
      this->signatures(i));
  }

  // optional uint32 m = 3;
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::UInt32Size(
        this->m());
  }

  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void MultisigRedeemScriptType::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:hw.trezor.messages.bitcoin.MultisigRedeemScriptType)
  GOOGLE_DCHECK_NE(&from, this);
  const MultisigRedeemScriptType* source =
      ::google::protobuf::DynamicCastToGenerated<MultisigRedeemScriptType>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:hw.trezor.messages.bitcoin.MultisigRedeemScriptType)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:hw.trezor.messages.bitcoin.MultisigRedeemScriptType)
    MergeFrom(*source);
  }
}

void MultisigRedeemScriptType::MergeFrom(const MultisigRedeemScriptType& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:hw.trezor.messages.bitcoin.MultisigRedeemScriptType)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  pubkeys_.MergeFrom(from.pubkeys_);
  signatures_.MergeFrom(from.signatures_);
  if (from.has_m()) {
    set_m(from.m());
  }
}

void MultisigRedeemScriptType::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:hw.trezor.messages.bitcoin.MultisigRedeemScriptType)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void MultisigRedeemScriptType::CopyFrom(const MultisigRedeemScriptType& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:hw.trezor.messages.bitcoin.MultisigRedeemScriptType)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool MultisigRedeemScriptType::IsInitialized() const {
  if (!::google::protobuf::internal::AllAreInitialized(this->pubkeys())) return false;
  return true;
}

void MultisigRedeemScriptType::Swap(MultisigRedeemScriptType* other) {
  if (other == this) return;
  InternalSwap(other);
}
void MultisigRedeemScriptType::InternalSwap(MultisigRedeemScriptType* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  CastToBase(&pubkeys_)->InternalSwap(CastToBase(&other->pubkeys_));
  signatures_.InternalSwap(CastToBase(&other->signatures_));
  swap(m_, other->m_);
}

::google::protobuf::Metadata MultisigRedeemScriptType::GetMetadata() const {
  ::google::protobuf::internal::AssignDescriptors(&::assign_descriptors_table_messages_2dbitcoin_2eproto);
  return ::file_level_metadata_messages_2dbitcoin_2eproto[kIndexInFileMessages];
}


// ===================================================================

void GetPublicKey::InitAsDefaultInstance() {
}
class GetPublicKey::HasBitSetters {
 public:
  static void set_has_ecdsa_curve_name(GetPublicKey* msg) {
    msg->_has_bits_[0] |= 0x00000001u;
  }
  static void set_has_show_display(GetPublicKey* msg) {
    msg->_has_bits_[0] |= 0x00000004u;
  }
  static void set_has_coin_name(GetPublicKey* msg) {
    msg->_has_bits_[0] |= 0x00000002u;
  }
  static void set_has_script_type(GetPublicKey* msg) {
    msg->_has_bits_[0] |= 0x00000008u;
  }
};

::google::protobuf::internal::ExplicitlyConstructed<::std::string> GetPublicKey::_i_give_permission_to_break_this_code_default_coin_name_;
#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int GetPublicKey::kAddressNFieldNumber;
const int GetPublicKey::kEcdsaCurveNameFieldNumber;
const int GetPublicKey::kShowDisplayFieldNumber;
const int GetPublicKey::kCoinNameFieldNumber;
const int GetPublicKey::kScriptTypeFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

GetPublicKey::GetPublicKey()
  : ::google::protobuf::Message(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:hw.trezor.messages.bitcoin.GetPublicKey)
}
GetPublicKey::GetPublicKey(const GetPublicKey& from)
  : ::google::protobuf::Message(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_),
      address_n_(from.address_n_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ecdsa_curve_name_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (from.has_ecdsa_curve_name()) {
    ecdsa_curve_name_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.ecdsa_curve_name_);
  }
  coin_name_.UnsafeSetDefault(&::hw::trezor::messages::bitcoin::GetPublicKey::_i_give_permission_to_break_this_code_default_coin_name_.get());
  if (from.has_coin_name()) {
    coin_name_.AssignWithDefault(&::hw::trezor::messages::bitcoin::GetPublicKey::_i_give_permission_to_break_this_code_default_coin_name_.get(), from.coin_name_);
  }
  ::memcpy(&show_display_, &from.show_display_,
    static_cast<size_t>(reinterpret_cast<char*>(&script_type_) -
    reinterpret_cast<char*>(&show_display_)) + sizeof(script_type_));
  // @@protoc_insertion_point(copy_constructor:hw.trezor.messages.bitcoin.GetPublicKey)
}

void GetPublicKey::SharedCtor() {
  ::google::protobuf::internal::InitSCC(
      &scc_info_GetPublicKey_messages_2dbitcoin_2eproto.base);
  ecdsa_curve_name_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  coin_name_.UnsafeSetDefault(&::hw::trezor::messages::bitcoin::GetPublicKey::_i_give_permission_to_break_this_code_default_coin_name_.get());
  ::memset(&show_display_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&script_type_) -
      reinterpret_cast<char*>(&show_display_)) + sizeof(script_type_));
}

GetPublicKey::~GetPublicKey() {
  // @@protoc_insertion_point(destructor:hw.trezor.messages.bitcoin.GetPublicKey)
  SharedDtor();
}

void GetPublicKey::SharedDtor() {
  ecdsa_curve_name_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  coin_name_.DestroyNoArena(&::hw::trezor::messages::bitcoin::GetPublicKey::_i_give_permission_to_break_this_code_default_coin_name_.get());
}

void GetPublicKey::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const GetPublicKey& GetPublicKey::default_instance() {
  ::google::protobuf::internal::InitSCC(&::scc_info_GetPublicKey_messages_2dbitcoin_2eproto.base);
  return *internal_default_instance();
}


void GetPublicKey::Clear() {
// @@protoc_insertion_point(message_clear_start:hw.trezor.messages.bitcoin.GetPublicKey)
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  address_n_.Clear();
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      ecdsa_curve_name_.ClearNonDefaultToEmptyNoArena();
    }
    if (cached_has_bits & 0x00000002u) {
      coin_name_.UnsafeMutablePointer()->assign(*&::hw::trezor::messages::bitcoin::GetPublicKey::_i_give_permission_to_break_this_code_default_coin_name_.get());
    }
  }
  if (cached_has_bits & 0x0000000cu) {
    ::memset(&show_display_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&script_type_) -
        reinterpret_cast<char*>(&show_display_)) + sizeof(script_type_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* GetPublicKey::_InternalParse(const char* begin, const char* end, void* object,
                  ::google::protobuf::internal::ParseContext* ctx) {
  auto msg = static_cast<GetPublicKey*>(object);
  ::google::protobuf::int32 size; (void)size;
  int depth; (void)depth;
  ::google::protobuf::uint32 tag;
  ::google::protobuf::internal::ParseFunc parser_till_end; (void)parser_till_end;
  auto ptr = begin;
  while (ptr < end) {
    ptr = ::google::protobuf::io::Parse32(ptr, &tag);
    GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
    switch (tag >> 3) {
      // repeated uint32 address_n = 1;
      case 1: {
        if (static_cast<::google::protobuf::uint8>(tag) == 8) {
          do {
            msg->add_address_n(::google::protobuf::internal::ReadVarint(&ptr));
            GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
            if (ptr >= end) break;
          } while ((::google::protobuf::io::UnalignedLoad<::google::protobuf::uint64>(ptr) & 255) == 8 && (ptr += 1));
          break;
        } else if (static_cast<::google::protobuf::uint8>(tag) != 10) goto handle_unusual;
        ptr = ::google::protobuf::io::ReadSize(ptr, &size);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        parser_till_end = ::google::protobuf::internal::PackedUInt32Parser;
        object = msg->mutable_address_n();
        if (size > end - ptr) goto len_delim_till_end;
        auto newend = ptr + size;
        if (size) ptr = parser_till_end(ptr, newend, object, ctx);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr == newend);
        break;
      }
      // optional string ecdsa_curve_name = 2;
      case 2: {
        if (static_cast<::google::protobuf::uint8>(tag) != 18) goto handle_unusual;
        ptr = ::google::protobuf::io::ReadSize(ptr, &size);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        ctx->extra_parse_data().SetFieldName("hw.trezor.messages.bitcoin.GetPublicKey.ecdsa_curve_name");
        object = msg->mutable_ecdsa_curve_name();
        if (size > end - ptr + ::google::protobuf::internal::ParseContext::kSlopBytes) {
          parser_till_end = ::google::protobuf::internal::GreedyStringParserUTF8Verify;
          goto string_till_end;
        }
        GOOGLE_PROTOBUF_PARSER_ASSERT(::google::protobuf::internal::StringCheckUTF8Verify(ptr, size, ctx));
        ::google::protobuf::internal::InlineGreedyStringParser(object, ptr, size, ctx);
        ptr += size;
        break;
      }
      // optional bool show_display = 3;
      case 3: {
        if (static_cast<::google::protobuf::uint8>(tag) != 24) goto handle_unusual;
        msg->set_show_display(::google::protobuf::internal::ReadVarint(&ptr));
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        break;
      }
      // optional string coin_name = 4 [default = "Bitcoin"];
      case 4: {
        if (static_cast<::google::protobuf::uint8>(tag) != 34) goto handle_unusual;
        ptr = ::google::protobuf::io::ReadSize(ptr, &size);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        ctx->extra_parse_data().SetFieldName("hw.trezor.messages.bitcoin.GetPublicKey.coin_name");
        object = msg->mutable_coin_name();
        if (size > end - ptr + ::google::protobuf::internal::ParseContext::kSlopBytes) {
          parser_till_end = ::google::protobuf::internal::GreedyStringParserUTF8Verify;
          goto string_till_end;
        }
        GOOGLE_PROTOBUF_PARSER_ASSERT(::google::protobuf::internal::StringCheckUTF8Verify(ptr, size, ctx));
        ::google::protobuf::internal::InlineGreedyStringParser(object, ptr, size, ctx);
        ptr += size;
        break;
      }
      // optional .hw.trezor.messages.bitcoin.InputScriptType script_type = 5 [default = SPENDADDRESS];
      case 5: {
        if (static_cast<::google::protobuf::uint8>(tag) != 40) goto handle_unusual;
        ::google::protobuf::uint64 val = ::google::protobuf::internal::ReadVarint(&ptr);
        if (!::hw::trezor::messages::bitcoin::InputScriptType_IsValid(val)) {
          ::google::protobuf::internal::WriteVarint(5, val, msg->mutable_unknown_fields());
          break;
        }
        msg->set_script_type(static_cast<::hw::trezor::messages::bitcoin::InputScriptType>(val));
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        break;
      }
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->EndGroup(tag);
          return ptr;
        }
        auto res = UnknownFieldParse(tag, {_InternalParse, msg},
          ptr, end, msg->_internal_metadata_.mutable_unknown_fields(), ctx);
        ptr = res.first;
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr != nullptr);
        if (res.second) return ptr;
      }
    }  // switch
  }  // while
  return ptr;
string_till_end:
  static_cast<::std::string*>(object)->clear();
  static_cast<::std::string*>(object)->reserve(size);
  goto len_delim_till_end;
len_delim_till_end:
  return ctx->StoreAndTailCall(ptr, end, {_InternalParse, msg},
                               {parser_till_end, object}, size);
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool GetPublicKey::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:hw.trezor.messages.bitcoin.GetPublicKey)
  for (;;) {
    ::std::pair<::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated uint32 address_n = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (8 & 0xFF)) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadRepeatedPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 1, 8u, input, this->mutable_address_n())));
        } else if (static_cast< ::google::protobuf::uint8>(tag) == (10 & 0xFF)) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPackedPrimitiveNoInline<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, this->mutable_address_n())));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional string ecdsa_curve_name = 2;
      case 2: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (18 & 0xFF)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_ecdsa_curve_name()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->ecdsa_curve_name().data(), static_cast<int>(this->ecdsa_curve_name().length()),
            ::google::protobuf::internal::WireFormat::PARSE,
            "hw.trezor.messages.bitcoin.GetPublicKey.ecdsa_curve_name");
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional bool show_display = 3;
      case 3: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (24 & 0xFF)) {
          HasBitSetters::set_has_show_display(this);
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &show_display_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional string coin_name = 4 [default = "Bitcoin"];
      case 4: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (34 & 0xFF)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_coin_name()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->coin_name().data(), static_cast<int>(this->coin_name().length()),
            ::google::protobuf::internal::WireFormat::PARSE,
            "hw.trezor.messages.bitcoin.GetPublicKey.coin_name");
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional .hw.trezor.messages.bitcoin.InputScriptType script_type = 5 [default = SPENDADDRESS];
      case 5: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (40 & 0xFF)) {
          int value = 0;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::hw::trezor::messages::bitcoin::InputScriptType_IsValid(value)) {
            set_script_type(static_cast< ::hw::trezor::messages::bitcoin::InputScriptType >(value));
          } else {
            mutable_unknown_fields()->AddVarint(
                5, static_cast<::google::protobuf::uint64>(value));
          }
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, _internal_metadata_.mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:hw.trezor.messages.bitcoin.GetPublicKey)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:hw.trezor.messages.bitcoin.GetPublicKey)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void GetPublicKey::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:hw.trezor.messages.bitcoin.GetPublicKey)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated uint32 address_n = 1;
  for (int i = 0, n = this->address_n_size(); i < n; i++) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(
      1, this->address_n(i), output);
  }

  cached_has_bits = _has_bits_[0];
  // optional string ecdsa_curve_name = 2;
  if (cached_has_bits & 0x00000001u) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->ecdsa_curve_name().data(), static_cast<int>(this->ecdsa_curve_name().length()),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "hw.trezor.messages.bitcoin.GetPublicKey.ecdsa_curve_name");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      2, this->ecdsa_curve_name(), output);
  }

  // optional bool show_display = 3;
  if (cached_has_bits & 0x00000004u) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(3, this->show_display(), output);
  }

  // optional string coin_name = 4 [default = "Bitcoin"];
  if (cached_has_bits & 0x00000002u) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->coin_name().data(), static_cast<int>(this->coin_name().length()),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "hw.trezor.messages.bitcoin.GetPublicKey.coin_name");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      4, this->coin_name(), output);
  }

  // optional .hw.trezor.messages.bitcoin.InputScriptType script_type = 5 [default = SPENDADDRESS];
  if (cached_has_bits & 0x00000008u) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      5, this->script_type(), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        _internal_metadata_.unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:hw.trezor.messages.bitcoin.GetPublicKey)
}

::google::protobuf::uint8* GetPublicKey::InternalSerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:hw.trezor.messages.bitcoin.GetPublicKey)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated uint32 address_n = 1;
  target = ::google::protobuf::internal::WireFormatLite::
    WriteUInt32ToArray(1, this->address_n_, target);

  cached_has_bits = _has_bits_[0];
  // optional string ecdsa_curve_name = 2;
  if (cached_has_bits & 0x00000001u) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->ecdsa_curve_name().data(), static_cast<int>(this->ecdsa_curve_name().length()),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "hw.trezor.messages.bitcoin.GetPublicKey.ecdsa_curve_name");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        2, this->ecdsa_curve_name(), target);
  }

  // optional bool show_display = 3;
  if (cached_has_bits & 0x00000004u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteBoolToArray(3, this->show_display(), target);
  }

  // optional string coin_name = 4 [default = "Bitcoin"];
  if (cached_has_bits & 0x00000002u) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->coin_name().data(), static_cast<int>(this->coin_name().length()),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "hw.trezor.messages.bitcoin.GetPublicKey.coin_name");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        4, this->coin_name(), target);
  }

  // optional .hw.trezor.messages.bitcoin.InputScriptType script_type = 5 [default = SPENDADDRESS];
  if (cached_has_bits & 0x00000008u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      5, this->script_type(), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:hw.trezor.messages.bitcoin.GetPublicKey)
  return target;
}

size_t GetPublicKey::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:hw.trezor.messages.bitcoin.GetPublicKey)
  size_t total_size = 0;

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        _internal_metadata_.unknown_fields());
  }
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated uint32 address_n = 1;
  {
    size_t data_size = ::google::protobuf::internal::WireFormatLite::
      UInt32Size(this->address_n_);
    total_size += 1 *
                  ::google::protobuf::internal::FromIntSize(this->address_n_size());
    total_size += data_size;
  }

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    // optional string ecdsa_curve_name = 2;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->ecdsa_curve_name());
    }

    // optional string coin_name = 4 [default = "Bitcoin"];
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->coin_name());
    }

    // optional bool show_display = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 + 1;
    }

    // optional .hw.trezor.messages.bitcoin.InputScriptType script_type = 5 [default = SPENDADDRESS];
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->script_type());
    }

  }
  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void GetPublicKey::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:hw.trezor.messages.bitcoin.GetPublicKey)
  GOOGLE_DCHECK_NE(&from, this);
  const GetPublicKey* source =
      ::google::protobuf::DynamicCastToGenerated<GetPublicKey>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:hw.trezor.messages.bitcoin.GetPublicKey)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:hw.trezor.messages.bitcoin.GetPublicKey)
    MergeFrom(*source);
  }
}

void GetPublicKey::MergeFrom(const GetPublicKey& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:hw.trezor.messages.bitcoin.GetPublicKey)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  address_n_.MergeFrom(from.address_n_);
  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      _has_bits_[0] |= 0x00000001u;
      ecdsa_curve_name_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.ecdsa_curve_name_);
    }
    if (cached_has_bits & 0x00000002u) {
      _has_bits_[0] |= 0x00000002u;
      coin_name_.AssignWithDefault(&::hw::trezor::messages::bitcoin::GetPublicKey::_i_give_permission_to_break_this_code_default_coin_name_.get(), from.coin_name_);
    }
    if (cached_has_bits & 0x00000004u) {
      show_display_ = from.show_display_;
    }
    if (cached_has_bits & 0x00000008u) {
      script_type_ = from.script_type_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void GetPublicKey::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:hw.trezor.messages.bitcoin.GetPublicKey)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void GetPublicKey::CopyFrom(const GetPublicKey& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:hw.trezor.messages.bitcoin.GetPublicKey)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool GetPublicKey::IsInitialized() const {
  return true;
}

void GetPublicKey::Swap(GetPublicKey* other) {
  if (other == this) return;
  InternalSwap(other);
}
void GetPublicKey::InternalSwap(GetPublicKey* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  address_n_.InternalSwap(&other->address_n_);
  ecdsa_curve_name_.Swap(&other->ecdsa_curve_name_, &::google::protobuf::internal::GetEmptyStringAlreadyInited(),
    GetArenaNoVirtual());
  coin_name_.Swap(&other->coin_name_, &::hw::trezor::messages::bitcoin::GetPublicKey::_i_give_permission_to_break_this_code_default_coin_name_.get(),
    GetArenaNoVirtual());
  swap(show_display_, other->show_display_);
  swap(script_type_, other->script_type_);
}

::google::protobuf::Metadata GetPublicKey::GetMetadata() const {
  ::google::protobuf::internal::AssignDescriptors(&::assign_descriptors_table_messages_2dbitcoin_2eproto);
  return ::file_level_metadata_messages_2dbitcoin_2eproto[kIndexInFileMessages];
}


// ===================================================================

void PublicKey::InitAsDefaultInstance() {
  ::hw::trezor::messages::bitcoin::_PublicKey_default_instance_._instance.get_mutable()->node_ = const_cast< ::hw::trezor::messages::common::HDNodeType*>(
      ::hw::trezor::messages::common::HDNodeType::internal_default_instance());
}
class PublicKey::HasBitSetters {
 public:
  static const ::hw::trezor::messages::common::HDNodeType& node(const PublicKey* msg);
  static void set_has_node(PublicKey* msg) {
    msg->_has_bits_[0] |= 0x00000002u;
  }
  static void set_has_xpub(PublicKey* msg) {
    msg->_has_bits_[0] |= 0x00000001u;
  }
};

const ::hw::trezor::messages::common::HDNodeType&
PublicKey::HasBitSetters::node(const PublicKey* msg) {
  return *msg->node_;
}
void PublicKey::clear_node() {
  if (node_ != nullptr) node_->Clear();
  _has_bits_[0] &= ~0x00000002u;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int PublicKey::kNodeFieldNumber;
const int PublicKey::kXpubFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

PublicKey::PublicKey()
  : ::google::protobuf::Message(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:hw.trezor.messages.bitcoin.PublicKey)
}
PublicKey::PublicKey(const PublicKey& from)
  : ::google::protobuf::Message(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  xpub_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (from.has_xpub()) {
    xpub_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.xpub_);
  }
  if (from.has_node()) {
    node_ = new ::hw::trezor::messages::common::HDNodeType(*from.node_);
  } else {
    node_ = nullptr;
  }
  // @@protoc_insertion_point(copy_constructor:hw.trezor.messages.bitcoin.PublicKey)
}

void PublicKey::SharedCtor() {
  ::google::protobuf::internal::InitSCC(
      &scc_info_PublicKey_messages_2dbitcoin_2eproto.base);
  xpub_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  node_ = nullptr;
}

PublicKey::~PublicKey() {
  // @@protoc_insertion_point(destructor:hw.trezor.messages.bitcoin.PublicKey)
  SharedDtor();
}

void PublicKey::SharedDtor() {
  xpub_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (this != internal_default_instance()) delete node_;
}

void PublicKey::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const PublicKey& PublicKey::default_instance() {
  ::google::protobuf::internal::InitSCC(&::scc_info_PublicKey_messages_2dbitcoin_2eproto.base);
  return *internal_default_instance();
}


void PublicKey::Clear() {
// @@protoc_insertion_point(message_clear_start:hw.trezor.messages.bitcoin.PublicKey)
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      xpub_.ClearNonDefaultToEmptyNoArena();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(node_ != nullptr);
      node_->Clear();
    }
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* PublicKey::_InternalParse(const char* begin, const char* end, void* object,
                  ::google::protobuf::internal::ParseContext* ctx) {
  auto msg = static_cast<PublicKey*>(object);
  ::google::protobuf::int32 size; (void)size;
  int depth; (void)depth;
  ::google::protobuf::uint32 tag;
  ::google::protobuf::internal::ParseFunc parser_till_end; (void)parser_till_end;
  auto ptr = begin;
  while (ptr < end) {
    ptr = ::google::protobuf::io::Parse32(ptr, &tag);
    GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
    switch (tag >> 3) {
      // required .hw.trezor.messages.common.HDNodeType node = 1;
      case 1: {
        if (static_cast<::google::protobuf::uint8>(tag) != 10) goto handle_unusual;
        ptr = ::google::protobuf::io::ReadSize(ptr, &size);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        parser_till_end = ::hw::trezor::messages::common::HDNodeType::_InternalParse;
        object = msg->mutable_node();
        if (size > end - ptr) goto len_delim_till_end;
        ptr += size;
        GOOGLE_PROTOBUF_PARSER_ASSERT(ctx->ParseExactRange(
            {parser_till_end, object}, ptr - size, ptr));
        break;
      }
      // optional string xpub = 2;
      case 2: {
        if (static_cast<::google::protobuf::uint8>(tag) != 18) goto handle_unusual;
        ptr = ::google::protobuf::io::ReadSize(ptr, &size);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        ctx->extra_parse_data().SetFieldName("hw.trezor.messages.bitcoin.PublicKey.xpub");
        object = msg->mutable_xpub();
        if (size > end - ptr + ::google::protobuf::internal::ParseContext::kSlopBytes) {
          parser_till_end = ::google::protobuf::internal::GreedyStringParserUTF8Verify;
          goto string_till_end;
        }
        GOOGLE_PROTOBUF_PARSER_ASSERT(::google::protobuf::internal::StringCheckUTF8Verify(ptr, size, ctx));
        ::google::protobuf::internal::InlineGreedyStringParser(object, ptr, size, ctx);
        ptr += size;
        break;
      }
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->EndGroup(tag);
          return ptr;
        }
        auto res = UnknownFieldParse(tag, {_InternalParse, msg},
          ptr, end, msg->_internal_metadata_.mutable_unknown_fields(), ctx);
        ptr = res.first;
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr != nullptr);
        if (res.second) return ptr;
      }
    }  // switch
  }  // while
  return ptr;
string_till_end:
  static_cast<::std::string*>(object)->clear();
  static_cast<::std::string*>(object)->reserve(size);
  goto len_delim_till_end;
len_delim_till_end:
  return ctx->StoreAndTailCall(ptr, end, {_InternalParse, msg},
                               {parser_till_end, object}, size);
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool PublicKey::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:hw.trezor.messages.bitcoin.PublicKey)
  for (;;) {
    ::std::pair<::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required .hw.trezor.messages.common.HDNodeType node = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (10 & 0xFF)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessage(
               input, mutable_node()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional string xpub = 2;
      case 2: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (18 & 0xFF)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_xpub()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->xpub().data(), static_cast<int>(this->xpub().length()),
            ::google::protobuf::internal::WireFormat::PARSE,
            "hw.trezor.messages.bitcoin.PublicKey.xpub");
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, _internal_metadata_.mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:hw.trezor.messages.bitcoin.PublicKey)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:hw.trezor.messages.bitcoin.PublicKey)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void PublicKey::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:hw.trezor.messages.bitcoin.PublicKey)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required .hw.trezor.messages.common.HDNodeType node = 1;
  if (cached_has_bits & 0x00000002u) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, HasBitSetters::node(this), output);
  }

  // optional string xpub = 2;
  if (cached_has_bits & 0x00000001u) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->xpub().data(), static_cast<int>(this->xpub().length()),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "hw.trezor.messages.bitcoin.PublicKey.xpub");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      2, this->xpub(), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        _internal_metadata_.unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:hw.trezor.messages.bitcoin.PublicKey)
}

::google::protobuf::uint8* PublicKey::InternalSerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:hw.trezor.messages.bitcoin.PublicKey)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required .hw.trezor.messages.common.HDNodeType node = 1;
  if (cached_has_bits & 0x00000002u) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageToArray(
        1, HasBitSetters::node(this), target);
  }

  // optional string xpub = 2;
  if (cached_has_bits & 0x00000001u) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->xpub().data(), static_cast<int>(this->xpub().length()),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "hw.trezor.messages.bitcoin.PublicKey.xpub");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        2, this->xpub(), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:hw.trezor.messages.bitcoin.PublicKey)
  return target;
}

size_t PublicKey::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:hw.trezor.messages.bitcoin.PublicKey)
  size_t total_size = 0;

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        _internal_metadata_.unknown_fields());
  }
  // required .hw.trezor.messages.common.HDNodeType node = 1;
  if (has_node()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::MessageSize(
        *node_);
  }
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional string xpub = 2;
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::StringSize(
        this->xpub());
  }

  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void PublicKey::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:hw.trezor.messages.bitcoin.PublicKey)
  GOOGLE_DCHECK_NE(&from, this);
  const PublicKey* source =
      ::google::protobuf::DynamicCastToGenerated<PublicKey>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:hw.trezor.messages.bitcoin.PublicKey)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:hw.trezor.messages.bitcoin.PublicKey)
    MergeFrom(*source);
  }
}

void PublicKey::MergeFrom(const PublicKey& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:hw.trezor.messages.bitcoin.PublicKey)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _has_bits_[0] |= 0x00000001u;
      xpub_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.xpub_);
    }
    if (cached_has_bits & 0x00000002u) {
      mutable_node()->::hw::trezor::messages::common::HDNodeType::MergeFrom(from.node());
    }
  }
}

void PublicKey::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:hw.trezor.messages.bitcoin.PublicKey)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void PublicKey::CopyFrom(const PublicKey& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:hw.trezor.messages.bitcoin.PublicKey)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool PublicKey::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000002) != 0x00000002) return false;
  if (has_node()) {
    if (!this->node_->IsInitialized()) return false;
  }
  return true;
}

void PublicKey::Swap(PublicKey* other) {
  if (other == this) return;
  InternalSwap(other);
}
void PublicKey::InternalSwap(PublicKey* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  xpub_.Swap(&other->xpub_, &::google::protobuf::internal::GetEmptyStringAlreadyInited(),
    GetArenaNoVirtual());
  swap(node_, other->node_);
}

::google::protobuf::Metadata PublicKey::GetMetadata() const {
  ::google::protobuf::internal::AssignDescriptors(&::assign_descriptors_table_messages_2dbitcoin_2eproto);
  return ::file_level_metadata_messages_2dbitcoin_2eproto[kIndexInFileMessages];
}


// ===================================================================

void GetAddress::InitAsDefaultInstance() {
  ::hw::trezor::messages::bitcoin::_GetAddress_default_instance_._instance.get_mutable()->multisig_ = const_cast< ::hw::trezor::messages::bitcoin::MultisigRedeemScriptType*>(
      ::hw::trezor::messages::bitcoin::MultisigRedeemScriptType::internal_default_instance());
}
class GetAddress::HasBitSetters {
 public:
  static void set_has_coin_name(GetAddress* msg) {
    msg->_has_bits_[0] |= 0x00000001u;
  }
  static void set_has_show_display(GetAddress* msg) {
    msg->_has_bits_[0] |= 0x00000004u;
  }
  static const ::hw::trezor::messages::bitcoin::MultisigRedeemScriptType& multisig(const GetAddress* msg);
  static void set_has_multisig(GetAddress* msg) {
    msg->_has_bits_[0] |= 0x00000002u;
  }
  static void set_has_script_type(GetAddress* msg) {
    msg->_has_bits_[0] |= 0x00000008u;
  }
};

const ::hw::trezor::messages::bitcoin::MultisigRedeemScriptType&
GetAddress::HasBitSetters::multisig(const GetAddress* msg) {
  return *msg->multisig_;
}
::google::protobuf::internal::ExplicitlyConstructed<::std::string> GetAddress::_i_give_permission_to_break_this_code_default_coin_name_;
#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int GetAddress::kAddressNFieldNumber;
const int GetAddress::kCoinNameFieldNumber;
const int GetAddress::kShowDisplayFieldNumber;
const int GetAddress::kMultisigFieldNumber;
const int GetAddress::kScriptTypeFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

GetAddress::GetAddress()
  : ::google::protobuf::Message(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:hw.trezor.messages.bitcoin.GetAddress)
}
GetAddress::GetAddress(const GetAddress& from)
  : ::google::protobuf::Message(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_),
      address_n_(from.address_n_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  coin_name_.UnsafeSetDefault(&::hw::trezor::messages::bitcoin::GetAddress::_i_give_permission_to_break_this_code_default_coin_name_.get());
  if (from.has_coin_name()) {
    coin_name_.AssignWithDefault(&::hw::trezor::messages::bitcoin::GetAddress::_i_give_permission_to_break_this_code_default_coin_name_.get(), from.coin_name_);
  }
  if (from.has_multisig()) {
    multisig_ = new ::hw::trezor::messages::bitcoin::MultisigRedeemScriptType(*from.multisig_);
  } else {
    multisig_ = nullptr;
  }
  ::memcpy(&show_display_, &from.show_display_,
    static_cast<size_t>(reinterpret_cast<char*>(&script_type_) -
    reinterpret_cast<char*>(&show_display_)) + sizeof(script_type_));
  // @@protoc_insertion_point(copy_constructor:hw.trezor.messages.bitcoin.GetAddress)
}

void GetAddress::SharedCtor() {
  ::google::protobuf::internal::InitSCC(
      &scc_info_GetAddress_messages_2dbitcoin_2eproto.base);
  coin_name_.UnsafeSetDefault(&::hw::trezor::messages::bitcoin::GetAddress::_i_give_permission_to_break_this_code_default_coin_name_.get());
  ::memset(&multisig_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&script_type_) -
      reinterpret_cast<char*>(&multisig_)) + sizeof(script_type_));
}

GetAddress::~GetAddress() {
  // @@protoc_insertion_point(destructor:hw.trezor.messages.bitcoin.GetAddress)
  SharedDtor();
}

void GetAddress::SharedDtor() {
  coin_name_.DestroyNoArena(&::hw::trezor::messages::bitcoin::GetAddress::_i_give_permission_to_break_this_code_default_coin_name_.get());
  if (this != internal_default_instance()) delete multisig_;
}

void GetAddress::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const GetAddress& GetAddress::default_instance() {
  ::google::protobuf::internal::InitSCC(&::scc_info_GetAddress_messages_2dbitcoin_2eproto.base);
  return *internal_default_instance();
}


void GetAddress::Clear() {
// @@protoc_insertion_point(message_clear_start:hw.trezor.messages.bitcoin.GetAddress)
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  address_n_.Clear();
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      coin_name_.UnsafeMutablePointer()->assign(*&::hw::trezor::messages::bitcoin::GetAddress::_i_give_permission_to_break_this_code_default_coin_name_.get());
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(multisig_ != nullptr);
      multisig_->Clear();
    }
  }
  if (cached_has_bits & 0x0000000cu) {
    ::memset(&show_display_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&script_type_) -
        reinterpret_cast<char*>(&show_display_)) + sizeof(script_type_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* GetAddress::_InternalParse(const char* begin, const char* end, void* object,
                  ::google::protobuf::internal::ParseContext* ctx) {
  auto msg = static_cast<GetAddress*>(object);
  ::google::protobuf::int32 size; (void)size;
  int depth; (void)depth;
  ::google::protobuf::uint32 tag;
  ::google::protobuf::internal::ParseFunc parser_till_end; (void)parser_till_end;
  auto ptr = begin;
  while (ptr < end) {
    ptr = ::google::protobuf::io::Parse32(ptr, &tag);
    GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
    switch (tag >> 3) {
      // repeated uint32 address_n = 1;
      case 1: {
        if (static_cast<::google::protobuf::uint8>(tag) == 8) {
          do {
            msg->add_address_n(::google::protobuf::internal::ReadVarint(&ptr));
            GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
            if (ptr >= end) break;
          } while ((::google::protobuf::io::UnalignedLoad<::google::protobuf::uint64>(ptr) & 255) == 8 && (ptr += 1));
          break;
        } else if (static_cast<::google::protobuf::uint8>(tag) != 10) goto handle_unusual;
        ptr = ::google::protobuf::io::ReadSize(ptr, &size);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        parser_till_end = ::google::protobuf::internal::PackedUInt32Parser;
        object = msg->mutable_address_n();
        if (size > end - ptr) goto len_delim_till_end;
        auto newend = ptr + size;
        if (size) ptr = parser_till_end(ptr, newend, object, ctx);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr == newend);
        break;
      }
      // optional string coin_name = 2 [default = "Bitcoin"];
      case 2: {
        if (static_cast<::google::protobuf::uint8>(tag) != 18) goto handle_unusual;
        ptr = ::google::protobuf::io::ReadSize(ptr, &size);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        ctx->extra_parse_data().SetFieldName("hw.trezor.messages.bitcoin.GetAddress.coin_name");
        object = msg->mutable_coin_name();
        if (size > end - ptr + ::google::protobuf::internal::ParseContext::kSlopBytes) {
          parser_till_end = ::google::protobuf::internal::GreedyStringParserUTF8Verify;
          goto string_till_end;
        }
        GOOGLE_PROTOBUF_PARSER_ASSERT(::google::protobuf::internal::StringCheckUTF8Verify(ptr, size, ctx));
        ::google::protobuf::internal::InlineGreedyStringParser(object, ptr, size, ctx);
        ptr += size;
        break;
      }
      // optional bool show_display = 3;
      case 3: {
        if (static_cast<::google::protobuf::uint8>(tag) != 24) goto handle_unusual;
        msg->set_show_display(::google::protobuf::internal::ReadVarint(&ptr));
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        break;
      }
      // optional .hw.trezor.messages.bitcoin.MultisigRedeemScriptType multisig = 4;
      case 4: {
        if (static_cast<::google::protobuf::uint8>(tag) != 34) goto handle_unusual;
        ptr = ::google::protobuf::io::ReadSize(ptr, &size);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        parser_till_end = ::hw::trezor::messages::bitcoin::MultisigRedeemScriptType::_InternalParse;
        object = msg->mutable_multisig();
        if (size > end - ptr) goto len_delim_till_end;
        ptr += size;
        GOOGLE_PROTOBUF_PARSER_ASSERT(ctx->ParseExactRange(
            {parser_till_end, object}, ptr - size, ptr));
        break;
      }
      // optional .hw.trezor.messages.bitcoin.InputScriptType script_type = 5 [default = SPENDADDRESS];
      case 5: {
        if (static_cast<::google::protobuf::uint8>(tag) != 40) goto handle_unusual;
        ::google::protobuf::uint64 val = ::google::protobuf::internal::ReadVarint(&ptr);
        if (!::hw::trezor::messages::bitcoin::InputScriptType_IsValid(val)) {
          ::google::protobuf::internal::WriteVarint(5, val, msg->mutable_unknown_fields());
          break;
        }
        msg->set_script_type(static_cast<::hw::trezor::messages::bitcoin::InputScriptType>(val));
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        break;
      }
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->EndGroup(tag);
          return ptr;
        }
        auto res = UnknownFieldParse(tag, {_InternalParse, msg},
          ptr, end, msg->_internal_metadata_.mutable_unknown_fields(), ctx);
        ptr = res.first;
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr != nullptr);
        if (res.second) return ptr;
      }
    }  // switch
  }  // while
  return ptr;
string_till_end:
  static_cast<::std::string*>(object)->clear();
  static_cast<::std::string*>(object)->reserve(size);
  goto len_delim_till_end;
len_delim_till_end:
  return ctx->StoreAndTailCall(ptr, end, {_InternalParse, msg},
                               {parser_till_end, object}, size);
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool GetAddress::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:hw.trezor.messages.bitcoin.GetAddress)
  for (;;) {
    ::std::pair<::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated uint32 address_n = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (8 & 0xFF)) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadRepeatedPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 1, 8u, input, this->mutable_address_n())));
        } else if (static_cast< ::google::protobuf::uint8>(tag) == (10 & 0xFF)) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPackedPrimitiveNoInline<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, this->mutable_address_n())));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional string coin_name = 2 [default = "Bitcoin"];
      case 2: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (18 & 0xFF)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_coin_name()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->coin_name().data(), static_cast<int>(this->coin_name().length()),
            ::google::protobuf::internal::WireFormat::PARSE,
            "hw.trezor.messages.bitcoin.GetAddress.coin_name");
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional bool show_display = 3;
      case 3: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (24 & 0xFF)) {
          HasBitSetters::set_has_show_display(this);
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &show_display_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional .hw.trezor.messages.bitcoin.MultisigRedeemScriptType multisig = 4;
      case 4: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (34 & 0xFF)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessage(
               input, mutable_multisig()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional .hw.trezor.messages.bitcoin.InputScriptType script_type = 5 [default = SPENDADDRESS];
      case 5: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (40 & 0xFF)) {
          int value = 0;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::hw::trezor::messages::bitcoin::InputScriptType_IsValid(value)) {
            set_script_type(static_cast< ::hw::trezor::messages::bitcoin::InputScriptType >(value));
          } else {
            mutable_unknown_fields()->AddVarint(
                5, static_cast<::google::protobuf::uint64>(value));
          }
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, _internal_metadata_.mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:hw.trezor.messages.bitcoin.GetAddress)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:hw.trezor.messages.bitcoin.GetAddress)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void GetAddress::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:hw.trezor.messages.bitcoin.GetAddress)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated uint32 address_n = 1;
  for (int i = 0, n = this->address_n_size(); i < n; i++) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(
      1, this->address_n(i), output);
  }

  cached_has_bits = _has_bits_[0];
  // optional string coin_name = 2 [default = "Bitcoin"];
  if (cached_has_bits & 0x00000001u) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->coin_name().data(), static_cast<int>(this->coin_name().length()),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "hw.trezor.messages.bitcoin.GetAddress.coin_name");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      2, this->coin_name(), output);
  }

  // optional bool show_display = 3;
  if (cached_has_bits & 0x00000004u) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(3, this->show_display(), output);
  }

  // optional .hw.trezor.messages.bitcoin.MultisigRedeemScriptType multisig = 4;
  if (cached_has_bits & 0x00000002u) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      4, HasBitSetters::multisig(this), output);
  }

  // optional .hw.trezor.messages.bitcoin.InputScriptType script_type = 5 [default = SPENDADDRESS];
  if (cached_has_bits & 0x00000008u) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      5, this->script_type(), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        _internal_metadata_.unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:hw.trezor.messages.bitcoin.GetAddress)
}

::google::protobuf::uint8* GetAddress::InternalSerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:hw.trezor.messages.bitcoin.GetAddress)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated uint32 address_n = 1;
  target = ::google::protobuf::internal::WireFormatLite::
    WriteUInt32ToArray(1, this->address_n_, target);

  cached_has_bits = _has_bits_[0];
  // optional string coin_name = 2 [default = "Bitcoin"];
  if (cached_has_bits & 0x00000001u) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->coin_name().data(), static_cast<int>(this->coin_name().length()),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "hw.trezor.messages.bitcoin.GetAddress.coin_name");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        2, this->coin_name(), target);
  }

  // optional bool show_display = 3;
  if (cached_has_bits & 0x00000004u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteBoolToArray(3, this->show_display(), target);
  }

  // optional .hw.trezor.messages.bitcoin.MultisigRedeemScriptType multisig = 4;
  if (cached_has_bits & 0x00000002u) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageToArray(
        4, HasBitSetters::multisig(this), target);
  }

  // optional .hw.trezor.messages.bitcoin.InputScriptType script_type = 5 [default = SPENDADDRESS];
  if (cached_has_bits & 0x00000008u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      5, this->script_type(), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:hw.trezor.messages.bitcoin.GetAddress)
  return target;
}

size_t GetAddress::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:hw.trezor.messages.bitcoin.GetAddress)
  size_t total_size = 0;

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        _internal_metadata_.unknown_fields());
  }
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated uint32 address_n = 1;
  {
    size_t data_size = ::google::protobuf::internal::WireFormatLite::
      UInt32Size(this->address_n_);
    total_size += 1 *
                  ::google::protobuf::internal::FromIntSize(this->address_n_size());
    total_size += data_size;
  }

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    // optional string coin_name = 2 [default = "Bitcoin"];
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->coin_name());
    }

    // optional .hw.trezor.messages.bitcoin.MultisigRedeemScriptType multisig = 4;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSize(
          *multisig_);
    }

    // optional bool show_display = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 + 1;
    }

    // optional .hw.trezor.messages.bitcoin.InputScriptType script_type = 5 [default = SPENDADDRESS];
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->script_type());
    }

  }
  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void GetAddress::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:hw.trezor.messages.bitcoin.GetAddress)
  GOOGLE_DCHECK_NE(&from, this);
  const GetAddress* source =
      ::google::protobuf::DynamicCastToGenerated<GetAddress>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:hw.trezor.messages.bitcoin.GetAddress)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:hw.trezor.messages.bitcoin.GetAddress)
    MergeFrom(*source);
  }
}

void GetAddress::MergeFrom(const GetAddress& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:hw.trezor.messages.bitcoin.GetAddress)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  address_n_.MergeFrom(from.address_n_);
  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      _has_bits_[0] |= 0x00000001u;
      coin_name_.AssignWithDefault(&::hw::trezor::messages::bitcoin::GetAddress::_i_give_permission_to_break_this_code_default_coin_name_.get(), from.coin_name_);
    }
    if (cached_has_bits & 0x00000002u) {
      mutable_multisig()->::hw::trezor::messages::bitcoin::MultisigRedeemScriptType::MergeFrom(from.multisig());
    }
    if (cached_has_bits & 0x00000004u) {
      show_display_ = from.show_display_;
    }
    if (cached_has_bits & 0x00000008u) {
      script_type_ = from.script_type_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void GetAddress::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:hw.trezor.messages.bitcoin.GetAddress)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void GetAddress::CopyFrom(const GetAddress& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:hw.trezor.messages.bitcoin.GetAddress)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool GetAddress::IsInitialized() const {
  if (has_multisig()) {
    if (!this->multisig_->IsInitialized()) return false;
  }
  return true;
}

void GetAddress::Swap(GetAddress* other) {
  if (other == this) return;
  InternalSwap(other);
}
void GetAddress::InternalSwap(GetAddress* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  address_n_.InternalSwap(&other->address_n_);
  coin_name_.Swap(&other->coin_name_, &::hw::trezor::messages::bitcoin::GetAddress::_i_give_permission_to_break_this_code_default_coin_name_.get(),
    GetArenaNoVirtual());
  swap(multisig_, other->multisig_);
  swap(show_display_, other->show_display_);
  swap(script_type_, other->script_type_);
}

::google::protobuf::Metadata GetAddress::GetMetadata() const {
  ::google::protobuf::internal::AssignDescriptors(&::assign_descriptors_table_messages_2dbitcoin_2eproto);
  return ::file_level_metadata_messages_2dbitcoin_2eproto[kIndexInFileMessages];
}


// ===================================================================

void Address::InitAsDefaultInstance() {
}
class Address::HasBitSetters {
 public:
  static void set_has_address(Address* msg) {
    msg->_has_bits_[0] |= 0x00000001u;
  }
};

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int Address::kAddressFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

Address::Address()
  : ::google::protobuf::Message(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:hw.trezor.messages.bitcoin.Address)
}
Address::Address(const Address& from)
  : ::google::protobuf::Message(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  address_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (from.has_address()) {
    address_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.address_);
  }
  // @@protoc_insertion_point(copy_constructor:hw.trezor.messages.bitcoin.Address)
}

void Address::SharedCtor() {
  ::google::protobuf::internal::InitSCC(
      &scc_info_Address_messages_2dbitcoin_2eproto.base);
  address_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}

Address::~Address() {
  // @@protoc_insertion_point(destructor:hw.trezor.messages.bitcoin.Address)
  SharedDtor();
}

void Address::SharedDtor() {
  address_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}

void Address::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const Address& Address::default_instance() {
  ::google::protobuf::internal::InitSCC(&::scc_info_Address_messages_2dbitcoin_2eproto.base);
  return *internal_default_instance();
}


void Address::Clear() {
// @@protoc_insertion_point(message_clear_start:hw.trezor.messages.bitcoin.Address)
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    address_.ClearNonDefaultToEmptyNoArena();
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* Address::_InternalParse(const char* begin, const char* end, void* object,
                  ::google::protobuf::internal::ParseContext* ctx) {
  auto msg = static_cast<Address*>(object);
  ::google::protobuf::int32 size; (void)size;
  int depth; (void)depth;
  ::google::protobuf::uint32 tag;
  ::google::protobuf::internal::ParseFunc parser_till_end; (void)parser_till_end;
  auto ptr = begin;
  while (ptr < end) {
    ptr = ::google::protobuf::io::Parse32(ptr, &tag);
    GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
    switch (tag >> 3) {
      // required string address = 1;
      case 1: {
        if (static_cast<::google::protobuf::uint8>(tag) != 10) goto handle_unusual;
        ptr = ::google::protobuf::io::ReadSize(ptr, &size);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        ctx->extra_parse_data().SetFieldName("hw.trezor.messages.bitcoin.Address.address");
        object = msg->mutable_address();
        if (size > end - ptr + ::google::protobuf::internal::ParseContext::kSlopBytes) {
          parser_till_end = ::google::protobuf::internal::GreedyStringParserUTF8Verify;
          goto string_till_end;
        }
        GOOGLE_PROTOBUF_PARSER_ASSERT(::google::protobuf::internal::StringCheckUTF8Verify(ptr, size, ctx));
        ::google::protobuf::internal::InlineGreedyStringParser(object, ptr, size, ctx);
        ptr += size;
        break;
      }
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->EndGroup(tag);
          return ptr;
        }
        auto res = UnknownFieldParse(tag, {_InternalParse, msg},
          ptr, end, msg->_internal_metadata_.mutable_unknown_fields(), ctx);
        ptr = res.first;
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr != nullptr);
        if (res.second) return ptr;
      }
    }  // switch
  }  // while
  return ptr;
string_till_end:
  static_cast<::std::string*>(object)->clear();
  static_cast<::std::string*>(object)->reserve(size);
  goto len_delim_till_end;
len_delim_till_end:
  return ctx->StoreAndTailCall(ptr, end, {_InternalParse, msg},
                               {parser_till_end, object}, size);
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool Address::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:hw.trezor.messages.bitcoin.Address)
  for (;;) {
    ::std::pair<::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required string address = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (10 & 0xFF)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_address()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->address().data(), static_cast<int>(this->address().length()),
            ::google::protobuf::internal::WireFormat::PARSE,
            "hw.trezor.messages.bitcoin.Address.address");
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, _internal_metadata_.mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:hw.trezor.messages.bitcoin.Address)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:hw.trezor.messages.bitcoin.Address)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void Address::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:hw.trezor.messages.bitcoin.Address)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required string address = 1;
  if (cached_has_bits & 0x00000001u) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->address().data(), static_cast<int>(this->address().length()),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "hw.trezor.messages.bitcoin.Address.address");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      1, this->address(), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        _internal_metadata_.unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:hw.trezor.messages.bitcoin.Address)
}

::google::protobuf::uint8* Address::InternalSerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:hw.trezor.messages.bitcoin.Address)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required string address = 1;
  if (cached_has_bits & 0x00000001u) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->address().data(), static_cast<int>(this->address().length()),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "hw.trezor.messages.bitcoin.Address.address");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        1, this->address(), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:hw.trezor.messages.bitcoin.Address)
  return target;
}

size_t Address::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:hw.trezor.messages.bitcoin.Address)
  size_t total_size = 0;

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        _internal_metadata_.unknown_fields());
  }
  // required string address = 1;
  if (has_address()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::StringSize(
        this->address());
  }
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void Address::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:hw.trezor.messages.bitcoin.Address)
  GOOGLE_DCHECK_NE(&from, this);
  const Address* source =
      ::google::protobuf::DynamicCastToGenerated<Address>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:hw.trezor.messages.bitcoin.Address)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:hw.trezor.messages.bitcoin.Address)
    MergeFrom(*source);
  }
}

void Address::MergeFrom(const Address& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:hw.trezor.messages.bitcoin.Address)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  if (from.has_address()) {
    _has_bits_[0] |= 0x00000001u;
    address_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.address_);
  }
}

void Address::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:hw.trezor.messages.bitcoin.Address)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Address::CopyFrom(const Address& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:hw.trezor.messages.bitcoin.Address)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Address::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;
  return true;
}

void Address::Swap(Address* other) {
  if (other == this) return;
  InternalSwap(other);
}
void Address::InternalSwap(Address* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  address_.Swap(&other->address_, &::google::protobuf::internal::GetEmptyStringAlreadyInited(),
    GetArenaNoVirtual());
}

::google::protobuf::Metadata Address::GetMetadata() const {
  ::google::protobuf::internal::AssignDescriptors(&::assign_descriptors_table_messages_2dbitcoin_2eproto);
  return ::file_level_metadata_messages_2dbitcoin_2eproto[kIndexInFileMessages];
}


// ===================================================================

void SignMessage::InitAsDefaultInstance() {
}
class SignMessage::HasBitSetters {
 public:
  static void set_has_message(SignMessage* msg) {
    msg->_has_bits_[0] |= 0x00000001u;
  }
  static void set_has_coin_name(SignMessage* msg) {
    msg->_has_bits_[0] |= 0x00000002u;
  }
  static void set_has_script_type(SignMessage* msg) {
    msg->_has_bits_[0] |= 0x00000004u;
  }
};

::google::protobuf::internal::ExplicitlyConstructed<::std::string> SignMessage::_i_give_permission_to_break_this_code_default_coin_name_;
#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int SignMessage::kAddressNFieldNumber;
const int SignMessage::kMessageFieldNumber;
const int SignMessage::kCoinNameFieldNumber;
const int SignMessage::kScriptTypeFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

SignMessage::SignMessage()
  : ::google::protobuf::Message(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:hw.trezor.messages.bitcoin.SignMessage)
}
SignMessage::SignMessage(const SignMessage& from)
  : ::google::protobuf::Message(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_),
      address_n_(from.address_n_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  message_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (from.has_message()) {
    message_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.message_);
  }
  coin_name_.UnsafeSetDefault(&::hw::trezor::messages::bitcoin::SignMessage::_i_give_permission_to_break_this_code_default_coin_name_.get());
  if (from.has_coin_name()) {
    coin_name_.AssignWithDefault(&::hw::trezor::messages::bitcoin::SignMessage::_i_give_permission_to_break_this_code_default_coin_name_.get(), from.coin_name_);
  }
  script_type_ = from.script_type_;
  // @@protoc_insertion_point(copy_constructor:hw.trezor.messages.bitcoin.SignMessage)
}

void SignMessage::SharedCtor() {
  ::google::protobuf::internal::InitSCC(
      &scc_info_SignMessage_messages_2dbitcoin_2eproto.base);
  message_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  coin_name_.UnsafeSetDefault(&::hw::trezor::messages::bitcoin::SignMessage::_i_give_permission_to_break_this_code_default_coin_name_.get());
  script_type_ = 0;
}

SignMessage::~SignMessage() {
  // @@protoc_insertion_point(destructor:hw.trezor.messages.bitcoin.SignMessage)
  SharedDtor();
}

void SignMessage::SharedDtor() {
  message_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  coin_name_.DestroyNoArena(&::hw::trezor::messages::bitcoin::SignMessage::_i_give_permission_to_break_this_code_default_coin_name_.get());
}

void SignMessage::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const SignMessage& SignMessage::default_instance() {
  ::google::protobuf::internal::InitSCC(&::scc_info_SignMessage_messages_2dbitcoin_2eproto.base);
  return *internal_default_instance();
}


void SignMessage::Clear() {
// @@protoc_insertion_point(message_clear_start:hw.trezor.messages.bitcoin.SignMessage)
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  address_n_.Clear();
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      message_.ClearNonDefaultToEmptyNoArena();
    }
    if (cached_has_bits & 0x00000002u) {
      coin_name_.UnsafeMutablePointer()->assign(*&::hw::trezor::messages::bitcoin::SignMessage::_i_give_permission_to_break_this_code_default_coin_name_.get());
    }
  }
  script_type_ = 0;
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* SignMessage::_InternalParse(const char* begin, const char* end, void* object,
                  ::google::protobuf::internal::ParseContext* ctx) {
  auto msg = static_cast<SignMessage*>(object);
  ::google::protobuf::int32 size; (void)size;
  int depth; (void)depth;
  ::google::protobuf::uint32 tag;
  ::google::protobuf::internal::ParseFunc parser_till_end; (void)parser_till_end;
  auto ptr = begin;
  while (ptr < end) {
    ptr = ::google::protobuf::io::Parse32(ptr, &tag);
    GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
    switch (tag >> 3) {
      // repeated uint32 address_n = 1;
      case 1: {
        if (static_cast<::google::protobuf::uint8>(tag) == 8) {
          do {
            msg->add_address_n(::google::protobuf::internal::ReadVarint(&ptr));
            GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
            if (ptr >= end) break;
          } while ((::google::protobuf::io::UnalignedLoad<::google::protobuf::uint64>(ptr) & 255) == 8 && (ptr += 1));
          break;
        } else if (static_cast<::google::protobuf::uint8>(tag) != 10) goto handle_unusual;
        ptr = ::google::protobuf::io::ReadSize(ptr, &size);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        parser_till_end = ::google::protobuf::internal::PackedUInt32Parser;
        object = msg->mutable_address_n();
        if (size > end - ptr) goto len_delim_till_end;
        auto newend = ptr + size;
        if (size) ptr = parser_till_end(ptr, newend, object, ctx);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr == newend);
        break;
      }
      // required bytes message = 2;
      case 2: {
        if (static_cast<::google::protobuf::uint8>(tag) != 18) goto handle_unusual;
        ptr = ::google::protobuf::io::ReadSize(ptr, &size);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        object = msg->mutable_message();
        if (size > end - ptr + ::google::protobuf::internal::ParseContext::kSlopBytes) {
          parser_till_end = ::google::protobuf::internal::GreedyStringParser;
          goto string_till_end;
        }
        GOOGLE_PROTOBUF_PARSER_ASSERT(::google::protobuf::internal::StringCheck(ptr, size, ctx));
        ::google::protobuf::internal::InlineGreedyStringParser(object, ptr, size, ctx);
        ptr += size;
        break;
      }
      // optional string coin_name = 3 [default = "Bitcoin"];
      case 3: {
        if (static_cast<::google::protobuf::uint8>(tag) != 26) goto handle_unusual;
        ptr = ::google::protobuf::io::ReadSize(ptr, &size);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        ctx->extra_parse_data().SetFieldName("hw.trezor.messages.bitcoin.SignMessage.coin_name");
        object = msg->mutable_coin_name();
        if (size > end - ptr + ::google::protobuf::internal::ParseContext::kSlopBytes) {
          parser_till_end = ::google::protobuf::internal::GreedyStringParserUTF8Verify;
          goto string_till_end;
        }
        GOOGLE_PROTOBUF_PARSER_ASSERT(::google::protobuf::internal::StringCheckUTF8Verify(ptr, size, ctx));
        ::google::protobuf::internal::InlineGreedyStringParser(object, ptr, size, ctx);
        ptr += size;
        break;
      }
      // optional .hw.trezor.messages.bitcoin.InputScriptType script_type = 4 [default = SPENDADDRESS];
      case 4: {
        if (static_cast<::google::protobuf::uint8>(tag) != 32) goto handle_unusual;
        ::google::protobuf::uint64 val = ::google::protobuf::internal::ReadVarint(&ptr);
        if (!::hw::trezor::messages::bitcoin::InputScriptType_IsValid(val)) {
          ::google::protobuf::internal::WriteVarint(4, val, msg->mutable_unknown_fields());
          break;
        }
        msg->set_script_type(static_cast<::hw::trezor::messages::bitcoin::InputScriptType>(val));
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        break;
      }
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->EndGroup(tag);
          return ptr;
        }
        auto res = UnknownFieldParse(tag, {_InternalParse, msg},
          ptr, end, msg->_internal_metadata_.mutable_unknown_fields(), ctx);
        ptr = res.first;
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr != nullptr);
        if (res.second) return ptr;
      }
    }  // switch
  }  // while
  return ptr;
string_till_end:
  static_cast<::std::string*>(object)->clear();
  static_cast<::std::string*>(object)->reserve(size);
  goto len_delim_till_end;
len_delim_till_end:
  return ctx->StoreAndTailCall(ptr, end, {_InternalParse, msg},
                               {parser_till_end, object}, size);
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool SignMessage::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:hw.trezor.messages.bitcoin.SignMessage)
  for (;;) {
    ::std::pair<::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated uint32 address_n = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (8 & 0xFF)) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadRepeatedPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 1, 8u, input, this->mutable_address_n())));
        } else if (static_cast< ::google::protobuf::uint8>(tag) == (10 & 0xFF)) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPackedPrimitiveNoInline<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, this->mutable_address_n())));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // required bytes message = 2;
      case 2: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (18 & 0xFF)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_message()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional string coin_name = 3 [default = "Bitcoin"];
      case 3: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (26 & 0xFF)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_coin_name()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->coin_name().data(), static_cast<int>(this->coin_name().length()),
            ::google::protobuf::internal::WireFormat::PARSE,
            "hw.trezor.messages.bitcoin.SignMessage.coin_name");
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional .hw.trezor.messages.bitcoin.InputScriptType script_type = 4 [default = SPENDADDRESS];
      case 4: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (32 & 0xFF)) {
          int value = 0;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::hw::trezor::messages::bitcoin::InputScriptType_IsValid(value)) {
            set_script_type(static_cast< ::hw::trezor::messages::bitcoin::InputScriptType >(value));
          } else {
            mutable_unknown_fields()->AddVarint(
                4, static_cast<::google::protobuf::uint64>(value));
          }
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, _internal_metadata_.mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:hw.trezor.messages.bitcoin.SignMessage)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:hw.trezor.messages.bitcoin.SignMessage)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void SignMessage::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:hw.trezor.messages.bitcoin.SignMessage)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated uint32 address_n = 1;
  for (int i = 0, n = this->address_n_size(); i < n; i++) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(
      1, this->address_n(i), output);
  }

  cached_has_bits = _has_bits_[0];
  // required bytes message = 2;
  if (cached_has_bits & 0x00000001u) {
    ::google::protobuf::internal::WireFormatLite::WriteBytesMaybeAliased(
      2, this->message(), output);
  }

  // optional string coin_name = 3 [default = "Bitcoin"];
  if (cached_has_bits & 0x00000002u) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->coin_name().data(), static_cast<int>(this->coin_name().length()),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "hw.trezor.messages.bitcoin.SignMessage.coin_name");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      3, this->coin_name(), output);
  }

  // optional .hw.trezor.messages.bitcoin.InputScriptType script_type = 4 [default = SPENDADDRESS];
  if (cached_has_bits & 0x00000004u) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      4, this->script_type(), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        _internal_metadata_.unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:hw.trezor.messages.bitcoin.SignMessage)
}

::google::protobuf::uint8* SignMessage::InternalSerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:hw.trezor.messages.bitcoin.SignMessage)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated uint32 address_n = 1;
  target = ::google::protobuf::internal::WireFormatLite::
    WriteUInt32ToArray(1, this->address_n_, target);

  cached_has_bits = _has_bits_[0];
  // required bytes message = 2;
  if (cached_has_bits & 0x00000001u) {
    target =
      ::google::protobuf::internal::WireFormatLite::WriteBytesToArray(
        2, this->message(), target);
  }

  // optional string coin_name = 3 [default = "Bitcoin"];
  if (cached_has_bits & 0x00000002u) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->coin_name().data(), static_cast<int>(this->coin_name().length()),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "hw.trezor.messages.bitcoin.SignMessage.coin_name");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        3, this->coin_name(), target);
  }

  // optional .hw.trezor.messages.bitcoin.InputScriptType script_type = 4 [default = SPENDADDRESS];
  if (cached_has_bits & 0x00000004u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      4, this->script_type(), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:hw.trezor.messages.bitcoin.SignMessage)
  return target;
}

size_t SignMessage::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:hw.trezor.messages.bitcoin.SignMessage)
  size_t total_size = 0;

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        _internal_metadata_.unknown_fields());
  }
  // required bytes message = 2;
  if (has_message()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::BytesSize(
        this->message());
  }
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated uint32 address_n = 1;
  {
    size_t data_size = ::google::protobuf::internal::WireFormatLite::
      UInt32Size(this->address_n_);
    total_size += 1 *
                  ::google::protobuf::internal::FromIntSize(this->address_n_size());
    total_size += data_size;
  }

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000006u) {
    // optional string coin_name = 3 [default = "Bitcoin"];
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->coin_name());
    }

    // optional .hw.trezor.messages.bitcoin.InputScriptType script_type = 4 [default = SPENDADDRESS];
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->script_type());
    }

  }
  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void SignMessage::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:hw.trezor.messages.bitcoin.SignMessage)
  GOOGLE_DCHECK_NE(&from, this);
  const SignMessage* source =
      ::google::protobuf::DynamicCastToGenerated<SignMessage>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:hw.trezor.messages.bitcoin.SignMessage)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:hw.trezor.messages.bitcoin.SignMessage)
    MergeFrom(*source);
  }
}

void SignMessage::MergeFrom(const SignMessage& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:hw.trezor.messages.bitcoin.SignMessage)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  address_n_.MergeFrom(from.address_n_);
  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _has_bits_[0] |= 0x00000001u;
      message_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.message_);
    }
    if (cached_has_bits & 0x00000002u) {
      _has_bits_[0] |= 0x00000002u;
      coin_name_.AssignWithDefault(&::hw::trezor::messages::bitcoin::SignMessage::_i_give_permission_to_break_this_code_default_coin_name_.get(), from.coin_name_);
    }
    if (cached_has_bits & 0x00000004u) {
      script_type_ = from.script_type_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void SignMessage::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:hw.trezor.messages.bitcoin.SignMessage)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void SignMessage::CopyFrom(const SignMessage& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:hw.trezor.messages.bitcoin.SignMessage)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SignMessage::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;
  return true;
}

void SignMessage::Swap(SignMessage* other) {
  if (other == this) return;
  InternalSwap(other);
}
void SignMessage::InternalSwap(SignMessage* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  address_n_.InternalSwap(&other->address_n_);
  message_.Swap(&other->message_, &::google::protobuf::internal::GetEmptyStringAlreadyInited(),
    GetArenaNoVirtual());
  coin_name_.Swap(&other->coin_name_, &::hw::trezor::messages::bitcoin::SignMessage::_i_give_permission_to_break_this_code_default_coin_name_.get(),
    GetArenaNoVirtual());
  swap(script_type_, other->script_type_);
}

::google::protobuf::Metadata SignMessage::GetMetadata() const {
  ::google::protobuf::internal::AssignDescriptors(&::assign_descriptors_table_messages_2dbitcoin_2eproto);
  return ::file_level_metadata_messages_2dbitcoin_2eproto[kIndexInFileMessages];
}


// ===================================================================

void MessageSignature::InitAsDefaultInstance() {
}
class MessageSignature::HasBitSetters {
 public:
  static void set_has_address(MessageSignature* msg) {
    msg->_has_bits_[0] |= 0x00000001u;
  }
  static void set_has_signature(MessageSignature* msg) {
    msg->_has_bits_[0] |= 0x00000002u;
  }
};

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int MessageSignature::kAddressFieldNumber;
const int MessageSignature::kSignatureFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

MessageSignature::MessageSignature()
  : ::google::protobuf::Message(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:hw.trezor.messages.bitcoin.MessageSignature)
}
MessageSignature::MessageSignature(const MessageSignature& from)
  : ::google::protobuf::Message(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  address_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (from.has_address()) {
    address_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.address_);
  }
  signature_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (from.has_signature()) {
    signature_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.signature_);
  }
  // @@protoc_insertion_point(copy_constructor:hw.trezor.messages.bitcoin.MessageSignature)
}

void MessageSignature::SharedCtor() {
  ::google::protobuf::internal::InitSCC(
      &scc_info_MessageSignature_messages_2dbitcoin_2eproto.base);
  address_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  signature_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}

MessageSignature::~MessageSignature() {
  // @@protoc_insertion_point(destructor:hw.trezor.messages.bitcoin.MessageSignature)
  SharedDtor();
}

void MessageSignature::SharedDtor() {
  address_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  signature_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}

void MessageSignature::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const MessageSignature& MessageSignature::default_instance() {
  ::google::protobuf::internal::InitSCC(&::scc_info_MessageSignature_messages_2dbitcoin_2eproto.base);
  return *internal_default_instance();
}


void MessageSignature::Clear() {
// @@protoc_insertion_point(message_clear_start:hw.trezor.messages.bitcoin.MessageSignature)
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      address_.ClearNonDefaultToEmptyNoArena();
    }
    if (cached_has_bits & 0x00000002u) {
      signature_.ClearNonDefaultToEmptyNoArena();
    }
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* MessageSignature::_InternalParse(const char* begin, const char* end, void* object,
                  ::google::protobuf::internal::ParseContext* ctx) {
  auto msg = static_cast<MessageSignature*>(object);
  ::google::protobuf::int32 size; (void)size;
  int depth; (void)depth;
  ::google::protobuf::uint32 tag;
  ::google::protobuf::internal::ParseFunc parser_till_end; (void)parser_till_end;
  auto ptr = begin;
  while (ptr < end) {
    ptr = ::google::protobuf::io::Parse32(ptr, &tag);
    GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
    switch (tag >> 3) {
      // optional string address = 1;
      case 1: {
        if (static_cast<::google::protobuf::uint8>(tag) != 10) goto handle_unusual;
        ptr = ::google::protobuf::io::ReadSize(ptr, &size);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        ctx->extra_parse_data().SetFieldName("hw.trezor.messages.bitcoin.MessageSignature.address");
        object = msg->mutable_address();
        if (size > end - ptr + ::google::protobuf::internal::ParseContext::kSlopBytes) {
          parser_till_end = ::google::protobuf::internal::GreedyStringParserUTF8Verify;
          goto string_till_end;
        }
        GOOGLE_PROTOBUF_PARSER_ASSERT(::google::protobuf::internal::StringCheckUTF8Verify(ptr, size, ctx));
        ::google::protobuf::internal::InlineGreedyStringParser(object, ptr, size, ctx);
        ptr += size;
        break;
      }
      // optional bytes signature = 2;
      case 2: {
        if (static_cast<::google::protobuf::uint8>(tag) != 18) goto handle_unusual;
        ptr = ::google::protobuf::io::ReadSize(ptr, &size);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        object = msg->mutable_signature();
        if (size > end - ptr + ::google::protobuf::internal::ParseContext::kSlopBytes) {
          parser_till_end = ::google::protobuf::internal::GreedyStringParser;
          goto string_till_end;
        }
        GOOGLE_PROTOBUF_PARSER_ASSERT(::google::protobuf::internal::StringCheck(ptr, size, ctx));
        ::google::protobuf::internal::InlineGreedyStringParser(object, ptr, size, ctx);
        ptr += size;
        break;
      }
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->EndGroup(tag);
          return ptr;
        }
        auto res = UnknownFieldParse(tag, {_InternalParse, msg},
          ptr, end, msg->_internal_metadata_.mutable_unknown_fields(), ctx);
        ptr = res.first;
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr != nullptr);
        if (res.second) return ptr;
      }
    }  // switch
  }  // while
  return ptr;
string_till_end:
  static_cast<::std::string*>(object)->clear();
  static_cast<::std::string*>(object)->reserve(size);
  goto len_delim_till_end;
len_delim_till_end:
  return ctx->StoreAndTailCall(ptr, end, {_InternalParse, msg},
                               {parser_till_end, object}, size);
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool MessageSignature::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:hw.trezor.messages.bitcoin.MessageSignature)
  for (;;) {
    ::std::pair<::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional string address = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (10 & 0xFF)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_address()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->address().data(), static_cast<int>(this->address().length()),
            ::google::protobuf::internal::WireFormat::PARSE,
            "hw.trezor.messages.bitcoin.MessageSignature.address");
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional bytes signature = 2;
      case 2: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (18 & 0xFF)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_signature()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, _internal_metadata_.mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:hw.trezor.messages.bitcoin.MessageSignature)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:hw.trezor.messages.bitcoin.MessageSignature)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void MessageSignature::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:hw.trezor.messages.bitcoin.MessageSignature)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional string address = 1;
  if (cached_has_bits & 0x00000001u) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->address().data(), static_cast<int>(this->address().length()),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "hw.trezor.messages.bitcoin.MessageSignature.address");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      1, this->address(), output);
  }

  // optional bytes signature = 2;
  if (cached_has_bits & 0x00000002u) {
    ::google::protobuf::internal::WireFormatLite::WriteBytesMaybeAliased(
      2, this->signature(), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        _internal_metadata_.unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:hw.trezor.messages.bitcoin.MessageSignature)
}

::google::protobuf::uint8* MessageSignature::InternalSerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:hw.trezor.messages.bitcoin.MessageSignature)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional string address = 1;
  if (cached_has_bits & 0x00000001u) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->address().data(), static_cast<int>(this->address().length()),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "hw.trezor.messages.bitcoin.MessageSignature.address");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        1, this->address(), target);
  }

  // optional bytes signature = 2;
  if (cached_has_bits & 0x00000002u) {
    target =
      ::google::protobuf::internal::WireFormatLite::WriteBytesToArray(
        2, this->signature(), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:hw.trezor.messages.bitcoin.MessageSignature)
  return target;
}

size_t MessageSignature::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:hw.trezor.messages.bitcoin.MessageSignature)
  size_t total_size = 0;

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        _internal_metadata_.unknown_fields());
  }
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional string address = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->address());
    }

    // optional bytes signature = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->signature());
    }

  }
  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void MessageSignature::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:hw.trezor.messages.bitcoin.MessageSignature)
  GOOGLE_DCHECK_NE(&from, this);
  const MessageSignature* source =
      ::google::protobuf::DynamicCastToGenerated<MessageSignature>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:hw.trezor.messages.bitcoin.MessageSignature)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:hw.trezor.messages.bitcoin.MessageSignature)
    MergeFrom(*source);
  }
}

void MessageSignature::MergeFrom(const MessageSignature& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:hw.trezor.messages.bitcoin.MessageSignature)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _has_bits_[0] |= 0x00000001u;
      address_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.address_);
    }
    if (cached_has_bits & 0x00000002u) {
      _has_bits_[0] |= 0x00000002u;
      signature_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.signature_);
    }
  }
}

void MessageSignature::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:hw.trezor.messages.bitcoin.MessageSignature)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void MessageSignature::CopyFrom(const MessageSignature& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:hw.trezor.messages.bitcoin.MessageSignature)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool MessageSignature::IsInitialized() const {
  return true;
}

void MessageSignature::Swap(MessageSignature* other) {
  if (other == this) return;
  InternalSwap(other);
}
void MessageSignature::InternalSwap(MessageSignature* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  address_.Swap(&other->address_, &::google::protobuf::internal::GetEmptyStringAlreadyInited(),
    GetArenaNoVirtual());
  signature_.Swap(&other->signature_, &::google::protobuf::internal::GetEmptyStringAlreadyInited(),
    GetArenaNoVirtual());
}

::google::protobuf::Metadata MessageSignature::GetMetadata() const {
  ::google::protobuf::internal::AssignDescriptors(&::assign_descriptors_table_messages_2dbitcoin_2eproto);
  return ::file_level_metadata_messages_2dbitcoin_2eproto[kIndexInFileMessages];
}


// ===================================================================

void VerifyMessage::InitAsDefaultInstance() {
}
class VerifyMessage::HasBitSetters {
 public:
  static void set_has_address(VerifyMessage* msg) {
    msg->_has_bits_[0] |= 0x00000001u;
  }
  static void set_has_signature(VerifyMessage* msg) {
    msg->_has_bits_[0] |= 0x00000002u;
  }
  static void set_has_message(VerifyMessage* msg) {
    msg->_has_bits_[0] |= 0x00000004u;
  }
  static void set_has_coin_name(VerifyMessage* msg) {
    msg->_has_bits_[0] |= 0x00000008u;
  }
};

::google::protobuf::internal::ExplicitlyConstructed<::std::string> VerifyMessage::_i_give_permission_to_break_this_code_default_coin_name_;
#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int VerifyMessage::kAddressFieldNumber;
const int VerifyMessage::kSignatureFieldNumber;
const int VerifyMessage::kMessageFieldNumber;
const int VerifyMessage::kCoinNameFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

VerifyMessage::VerifyMessage()
  : ::google::protobuf::Message(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:hw.trezor.messages.bitcoin.VerifyMessage)
}
VerifyMessage::VerifyMessage(const VerifyMessage& from)
  : ::google::protobuf::Message(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  address_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (from.has_address()) {
    address_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.address_);
  }
  signature_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (from.has_signature()) {
    signature_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.signature_);
  }
  message_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (from.has_message()) {
    message_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.message_);
  }
  coin_name_.UnsafeSetDefault(&::hw::trezor::messages::bitcoin::VerifyMessage::_i_give_permission_to_break_this_code_default_coin_name_.get());
  if (from.has_coin_name()) {
    coin_name_.AssignWithDefault(&::hw::trezor::messages::bitcoin::VerifyMessage::_i_give_permission_to_break_this_code_default_coin_name_.get(), from.coin_name_);
  }
  // @@protoc_insertion_point(copy_constructor:hw.trezor.messages.bitcoin.VerifyMessage)
}

void VerifyMessage::SharedCtor() {
  ::google::protobuf::internal::InitSCC(
      &scc_info_VerifyMessage_messages_2dbitcoin_2eproto.base);
  address_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  signature_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  message_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  coin_name_.UnsafeSetDefault(&::hw::trezor::messages::bitcoin::VerifyMessage::_i_give_permission_to_break_this_code_default_coin_name_.get());
}

VerifyMessage::~VerifyMessage() {
  // @@protoc_insertion_point(destructor:hw.trezor.messages.bitcoin.VerifyMessage)
  SharedDtor();
}

void VerifyMessage::SharedDtor() {
  address_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  signature_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  message_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  coin_name_.DestroyNoArena(&::hw::trezor::messages::bitcoin::VerifyMessage::_i_give_permission_to_break_this_code_default_coin_name_.get());
}

void VerifyMessage::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const VerifyMessage& VerifyMessage::default_instance() {
  ::google::protobuf::internal::InitSCC(&::scc_info_VerifyMessage_messages_2dbitcoin_2eproto.base);
  return *internal_default_instance();
}


void VerifyMessage::Clear() {
// @@protoc_insertion_point(message_clear_start:hw.trezor.messages.bitcoin.VerifyMessage)
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      address_.ClearNonDefaultToEmptyNoArena();
    }
    if (cached_has_bits & 0x00000002u) {
      signature_.ClearNonDefaultToEmptyNoArena();
    }
    if (cached_has_bits & 0x00000004u) {
      message_.ClearNonDefaultToEmptyNoArena();
    }
    if (cached_has_bits & 0x00000008u) {
      coin_name_.UnsafeMutablePointer()->assign(*&::hw::trezor::messages::bitcoin::VerifyMessage::_i_give_permission_to_break_this_code_default_coin_name_.get());
    }
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* VerifyMessage::_InternalParse(const char* begin, const char* end, void* object,
                  ::google::protobuf::internal::ParseContext* ctx) {
  auto msg = static_cast<VerifyMessage*>(object);
  ::google::protobuf::int32 size; (void)size;
  int depth; (void)depth;
  ::google::protobuf::uint32 tag;
  ::google::protobuf::internal::ParseFunc parser_till_end; (void)parser_till_end;
  auto ptr = begin;
  while (ptr < end) {
    ptr = ::google::protobuf::io::Parse32(ptr, &tag);
    GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
    switch (tag >> 3) {
      // optional string address = 1;
      case 1: {
        if (static_cast<::google::protobuf::uint8>(tag) != 10) goto handle_unusual;
        ptr = ::google::protobuf::io::ReadSize(ptr, &size);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        ctx->extra_parse_data().SetFieldName("hw.trezor.messages.bitcoin.VerifyMessage.address");
        object = msg->mutable_address();
        if (size > end - ptr + ::google::protobuf::internal::ParseContext::kSlopBytes) {
          parser_till_end = ::google::protobuf::internal::GreedyStringParserUTF8Verify;
          goto string_till_end;
        }
        GOOGLE_PROTOBUF_PARSER_ASSERT(::google::protobuf::internal::StringCheckUTF8Verify(ptr, size, ctx));
        ::google::protobuf::internal::InlineGreedyStringParser(object, ptr, size, ctx);
        ptr += size;
        break;
      }
      // optional bytes signature = 2;
      case 2: {
        if (static_cast<::google::protobuf::uint8>(tag) != 18) goto handle_unusual;
        ptr = ::google::protobuf::io::ReadSize(ptr, &size);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        object = msg->mutable_signature();
        if (size > end - ptr + ::google::protobuf::internal::ParseContext::kSlopBytes) {
          parser_till_end = ::google::protobuf::internal::GreedyStringParser;
          goto string_till_end;
        }
        GOOGLE_PROTOBUF_PARSER_ASSERT(::google::protobuf::internal::StringCheck(ptr, size, ctx));
        ::google::protobuf::internal::InlineGreedyStringParser(object, ptr, size, ctx);
        ptr += size;
        break;
      }
      // optional bytes message = 3;
      case 3: {
        if (static_cast<::google::protobuf::uint8>(tag) != 26) goto handle_unusual;
        ptr = ::google::protobuf::io::ReadSize(ptr, &size);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        object = msg->mutable_message();
        if (size > end - ptr + ::google::protobuf::internal::ParseContext::kSlopBytes) {
          parser_till_end = ::google::protobuf::internal::GreedyStringParser;
          goto string_till_end;
        }
        GOOGLE_PROTOBUF_PARSER_ASSERT(::google::protobuf::internal::StringCheck(ptr, size, ctx));
        ::google::protobuf::internal::InlineGreedyStringParser(object, ptr, size, ctx);
        ptr += size;
        break;
      }
      // optional string coin_name = 4 [default = "Bitcoin"];
      case 4: {
        if (static_cast<::google::protobuf::uint8>(tag) != 34) goto handle_unusual;
        ptr = ::google::protobuf::io::ReadSize(ptr, &size);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        ctx->extra_parse_data().SetFieldName("hw.trezor.messages.bitcoin.VerifyMessage.coin_name");
        object = msg->mutable_coin_name();
        if (size > end - ptr + ::google::protobuf::internal::ParseContext::kSlopBytes) {
          parser_till_end = ::google::protobuf::internal::GreedyStringParserUTF8Verify;
          goto string_till_end;
        }
        GOOGLE_PROTOBUF_PARSER_ASSERT(::google::protobuf::internal::StringCheckUTF8Verify(ptr, size, ctx));
        ::google::protobuf::internal::InlineGreedyStringParser(object, ptr, size, ctx);
        ptr += size;
        break;
      }
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->EndGroup(tag);
          return ptr;
        }
        auto res = UnknownFieldParse(tag, {_InternalParse, msg},
          ptr, end, msg->_internal_metadata_.mutable_unknown_fields(), ctx);
        ptr = res.first;
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr != nullptr);
        if (res.second) return ptr;
      }
    }  // switch
  }  // while
  return ptr;
string_till_end:
  static_cast<::std::string*>(object)->clear();
  static_cast<::std::string*>(object)->reserve(size);
  goto len_delim_till_end;
len_delim_till_end:
  return ctx->StoreAndTailCall(ptr, end, {_InternalParse, msg},
                               {parser_till_end, object}, size);
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool VerifyMessage::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:hw.trezor.messages.bitcoin.VerifyMessage)
  for (;;) {
    ::std::pair<::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional string address = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (10 & 0xFF)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_address()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->address().data(), static_cast<int>(this->address().length()),
            ::google::protobuf::internal::WireFormat::PARSE,
            "hw.trezor.messages.bitcoin.VerifyMessage.address");
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional bytes signature = 2;
      case 2: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (18 & 0xFF)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_signature()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional bytes message = 3;
      case 3: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (26 & 0xFF)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_message()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional string coin_name = 4 [default = "Bitcoin"];
      case 4: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (34 & 0xFF)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_coin_name()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->coin_name().data(), static_cast<int>(this->coin_name().length()),
            ::google::protobuf::internal::WireFormat::PARSE,
            "hw.trezor.messages.bitcoin.VerifyMessage.coin_name");
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, _internal_metadata_.mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:hw.trezor.messages.bitcoin.VerifyMessage)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:hw.trezor.messages.bitcoin.VerifyMessage)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void VerifyMessage::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:hw.trezor.messages.bitcoin.VerifyMessage)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional string address = 1;
  if (cached_has_bits & 0x00000001u) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->address().data(), static_cast<int>(this->address().length()),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "hw.trezor.messages.bitcoin.VerifyMessage.address");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      1, this->address(), output);
  }

  // optional bytes signature = 2;
  if (cached_has_bits & 0x00000002u) {
    ::google::protobuf::internal::WireFormatLite::WriteBytesMaybeAliased(
      2, this->signature(), output);
  }

  // optional bytes message = 3;
  if (cached_has_bits & 0x00000004u) {
    ::google::protobuf::internal::WireFormatLite::WriteBytesMaybeAliased(
      3, this->message(), output);
  }

  // optional string coin_name = 4 [default = "Bitcoin"];
  if (cached_has_bits & 0x00000008u) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->coin_name().data(), static_cast<int>(this->coin_name().length()),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "hw.trezor.messages.bitcoin.VerifyMessage.coin_name");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      4, this->coin_name(), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        _internal_metadata_.unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:hw.trezor.messages.bitcoin.VerifyMessage)
}

::google::protobuf::uint8* VerifyMessage::InternalSerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:hw.trezor.messages.bitcoin.VerifyMessage)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional string address = 1;
  if (cached_has_bits & 0x00000001u) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->address().data(), static_cast<int>(this->address().length()),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "hw.trezor.messages.bitcoin.VerifyMessage.address");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        1, this->address(), target);
  }

  // optional bytes signature = 2;
  if (cached_has_bits & 0x00000002u) {
    target =
      ::google::protobuf::internal::WireFormatLite::WriteBytesToArray(
        2, this->signature(), target);
  }

  // optional bytes message = 3;
  if (cached_has_bits & 0x00000004u) {
    target =
      ::google::protobuf::internal::WireFormatLite::WriteBytesToArray(
        3, this->message(), target);
  }

  // optional string coin_name = 4 [default = "Bitcoin"];
  if (cached_has_bits & 0x00000008u) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->coin_name().data(), static_cast<int>(this->coin_name().length()),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "hw.trezor.messages.bitcoin.VerifyMessage.coin_name");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        4, this->coin_name(), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:hw.trezor.messages.bitcoin.VerifyMessage)
  return target;
}

size_t VerifyMessage::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:hw.trezor.messages.bitcoin.VerifyMessage)
  size_t total_size = 0;

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        _internal_metadata_.unknown_fields());
  }
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    // optional string address = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->address());
    }

    // optional bytes signature = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->signature());
    }

    // optional bytes message = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->message());
    }

    // optional string coin_name = 4 [default = "Bitcoin"];
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->coin_name());
    }

  }
  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void VerifyMessage::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:hw.trezor.messages.bitcoin.VerifyMessage)
  GOOGLE_DCHECK_NE(&from, this);
  const VerifyMessage* source =
      ::google::protobuf::DynamicCastToGenerated<VerifyMessage>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:hw.trezor.messages.bitcoin.VerifyMessage)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:hw.trezor.messages.bitcoin.VerifyMessage)
    MergeFrom(*source);
  }
}

void VerifyMessage::MergeFrom(const VerifyMessage& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:hw.trezor.messages.bitcoin.VerifyMessage)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      _has_bits_[0] |= 0x00000001u;
      address_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.address_);
    }
    if (cached_has_bits & 0x00000002u) {
      _has_bits_[0] |= 0x00000002u;
      signature_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.signature_);
    }
    if (cached_has_bits & 0x00000004u) {
      _has_bits_[0] |= 0x00000004u;
      message_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.message_);
    }
    if (cached_has_bits & 0x00000008u) {
      _has_bits_[0] |= 0x00000008u;
      coin_name_.AssignWithDefault(&::hw::trezor::messages::bitcoin::VerifyMessage::_i_give_permission_to_break_this_code_default_coin_name_.get(), from.coin_name_);
    }
  }
}

void VerifyMessage::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:hw.trezor.messages.bitcoin.VerifyMessage)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void VerifyMessage::CopyFrom(const VerifyMessage& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:hw.trezor.messages.bitcoin.VerifyMessage)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool VerifyMessage::IsInitialized() const {
  return true;
}

void VerifyMessage::Swap(VerifyMessage* other) {
  if (other == this) return;
  InternalSwap(other);
}
void VerifyMessage::InternalSwap(VerifyMessage* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  address_.Swap(&other->address_, &::google::protobuf::internal::GetEmptyStringAlreadyInited(),
    GetArenaNoVirtual());
  signature_.Swap(&other->signature_, &::google::protobuf::internal::GetEmptyStringAlreadyInited(),
    GetArenaNoVirtual());
  message_.Swap(&other->message_, &::google::protobuf::internal::GetEmptyStringAlreadyInited(),
    GetArenaNoVirtual());
  coin_name_.Swap(&other->coin_name_, &::hw::trezor::messages::bitcoin::VerifyMessage::_i_give_permission_to_break_this_code_default_coin_name_.get(),
    GetArenaNoVirtual());
}

::google::protobuf::Metadata VerifyMessage::GetMetadata() const {
  ::google::protobuf::internal::AssignDescriptors(&::assign_descriptors_table_messages_2dbitcoin_2eproto);
  return ::file_level_metadata_messages_2dbitcoin_2eproto[kIndexInFileMessages];
}


// ===================================================================

void SignTx::InitAsDefaultInstance() {
}
class SignTx::HasBitSetters {
 public:
  static void set_has_outputs_count(SignTx* msg) {
    msg->_has_bits_[0] |= 0x00000002u;
  }
  static void set_has_inputs_count(SignTx* msg) {
    msg->_has_bits_[0] |= 0x00000004u;
  }
  static void set_has_coin_name(SignTx* msg) {
    msg->_has_bits_[0] |= 0x00000001u;
  }
  static void set_has_version(SignTx* msg) {
    msg->_has_bits_[0] |= 0x00000100u;
  }
  static void set_has_lock_time(SignTx* msg) {
    msg->_has_bits_[0] |= 0x00000008u;
  }
  static void set_has_expiry(SignTx* msg) {
    msg->_has_bits_[0] |= 0x00000010u;
  }
  static void set_has_overwintered(SignTx* msg) {
    msg->_has_bits_[0] |= 0x00000020u;
  }
  static void set_has_version_group_id(SignTx* msg) {
    msg->_has_bits_[0] |= 0x00000040u;
  }
  static void set_has_timestamp(SignTx* msg) {
    msg->_has_bits_[0] |= 0x00000080u;
  }
};

::google::protobuf::internal::ExplicitlyConstructed<::std::string> SignTx::_i_give_permission_to_break_this_code_default_coin_name_;
#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int SignTx::kOutputsCountFieldNumber;
const int SignTx::kInputsCountFieldNumber;
const int SignTx::kCoinNameFieldNumber;
const int SignTx::kVersionFieldNumber;
const int SignTx::kLockTimeFieldNumber;
const int SignTx::kExpiryFieldNumber;
const int SignTx::kOverwinteredFieldNumber;
const int SignTx::kVersionGroupIdFieldNumber;
const int SignTx::kTimestampFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

SignTx::SignTx()
  : ::google::protobuf::Message(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:hw.trezor.messages.bitcoin.SignTx)
}
SignTx::SignTx(const SignTx& from)
  : ::google::protobuf::Message(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  coin_name_.UnsafeSetDefault(&::hw::trezor::messages::bitcoin::SignTx::_i_give_permission_to_break_this_code_default_coin_name_.get());
  if (from.has_coin_name()) {
    coin_name_.AssignWithDefault(&::hw::trezor::messages::bitcoin::SignTx::_i_give_permission_to_break_this_code_default_coin_name_.get(), from.coin_name_);
  }
  ::memcpy(&outputs_count_, &from.outputs_count_,
    static_cast<size_t>(reinterpret_cast<char*>(&version_) -
    reinterpret_cast<char*>(&outputs_count_)) + sizeof(version_));
  // @@protoc_insertion_point(copy_constructor:hw.trezor.messages.bitcoin.SignTx)
}

void SignTx::SharedCtor() {
  ::google::protobuf::internal::InitSCC(
      &scc_info_SignTx_messages_2dbitcoin_2eproto.base);
  coin_name_.UnsafeSetDefault(&::hw::trezor::messages::bitcoin::SignTx::_i_give_permission_to_break_this_code_default_coin_name_.get());
  ::memset(&outputs_count_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&timestamp_) -
      reinterpret_cast<char*>(&outputs_count_)) + sizeof(timestamp_));
  version_ = 1u;
}

SignTx::~SignTx() {
  // @@protoc_insertion_point(destructor:hw.trezor.messages.bitcoin.SignTx)
  SharedDtor();
}

void SignTx::SharedDtor() {
  coin_name_.DestroyNoArena(&::hw::trezor::messages::bitcoin::SignTx::_i_give_permission_to_break_this_code_default_coin_name_.get());
}

void SignTx::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const SignTx& SignTx::default_instance() {
  ::google::protobuf::internal::InitSCC(&::scc_info_SignTx_messages_2dbitcoin_2eproto.base);
  return *internal_default_instance();
}


void SignTx::Clear() {
// @@protoc_insertion_point(message_clear_start:hw.trezor.messages.bitcoin.SignTx)
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    coin_name_.UnsafeMutablePointer()->assign(*&::hw::trezor::messages::bitcoin::SignTx::_i_give_permission_to_break_this_code_default_coin_name_.get());
  }
  if (cached_has_bits & 0x000000feu) {
    ::memset(&outputs_count_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&timestamp_) -
        reinterpret_cast<char*>(&outputs_count_)) + sizeof(timestamp_));
  }
  version_ = 1u;
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* SignTx::_InternalParse(const char* begin, const char* end, void* object,
                  ::google::protobuf::internal::ParseContext* ctx) {
  auto msg = static_cast<SignTx*>(object);
  ::google::protobuf::int32 size; (void)size;
  int depth; (void)depth;
  ::google::protobuf::uint32 tag;
  ::google::protobuf::internal::ParseFunc parser_till_end; (void)parser_till_end;
  auto ptr = begin;
  while (ptr < end) {
    ptr = ::google::protobuf::io::Parse32(ptr, &tag);
    GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
    switch (tag >> 3) {
      // required uint32 outputs_count = 1;
      case 1: {
        if (static_cast<::google::protobuf::uint8>(tag) != 8) goto handle_unusual;
        msg->set_outputs_count(::google::protobuf::internal::ReadVarint(&ptr));
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        break;
      }
      // required uint32 inputs_count = 2;
      case 2: {
        if (static_cast<::google::protobuf::uint8>(tag) != 16) goto handle_unusual;
        msg->set_inputs_count(::google::protobuf::internal::ReadVarint(&ptr));
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        break;
      }
      // optional string coin_name = 3 [default = "Bitcoin"];
      case 3: {
        if (static_cast<::google::protobuf::uint8>(tag) != 26) goto handle_unusual;
        ptr = ::google::protobuf::io::ReadSize(ptr, &size);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        ctx->extra_parse_data().SetFieldName("hw.trezor.messages.bitcoin.SignTx.coin_name");
        object = msg->mutable_coin_name();
        if (size > end - ptr + ::google::protobuf::internal::ParseContext::kSlopBytes) {
          parser_till_end = ::google::protobuf::internal::GreedyStringParserUTF8Verify;
          goto string_till_end;
        }
        GOOGLE_PROTOBUF_PARSER_ASSERT(::google::protobuf::internal::StringCheckUTF8Verify(ptr, size, ctx));
        ::google::protobuf::internal::InlineGreedyStringParser(object, ptr, size, ctx);
        ptr += size;
        break;
      }
      // optional uint32 version = 4 [default = 1];
      case 4: {
        if (static_cast<::google::protobuf::uint8>(tag) != 32) goto handle_unusual;
        msg->set_version(::google::protobuf::internal::ReadVarint(&ptr));
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        break;
      }
      // optional uint32 lock_time = 5 [default = 0];
      case 5: {
        if (static_cast<::google::protobuf::uint8>(tag) != 40) goto handle_unusual;
        msg->set_lock_time(::google::protobuf::internal::ReadVarint(&ptr));
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        break;
      }
      // optional uint32 expiry = 6;
      case 6: {
        if (static_cast<::google::protobuf::uint8>(tag) != 48) goto handle_unusual;
        msg->set_expiry(::google::protobuf::internal::ReadVarint(&ptr));
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        break;
      }
      // optional bool overwintered = 7;
      case 7: {
        if (static_cast<::google::protobuf::uint8>(tag) != 56) goto handle_unusual;
        msg->set_overwintered(::google::protobuf::internal::ReadVarint(&ptr));
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        break;
      }
      // optional uint32 version_group_id = 8;
      case 8: {
        if (static_cast<::google::protobuf::uint8>(tag) != 64) goto handle_unusual;
        msg->set_version_group_id(::google::protobuf::internal::ReadVarint(&ptr));
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        break;
      }
      // optional uint32 timestamp = 9;
      case 9: {
        if (static_cast<::google::protobuf::uint8>(tag) != 72) goto handle_unusual;
        msg->set_timestamp(::google::protobuf::internal::ReadVarint(&ptr));
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        break;
      }
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->EndGroup(tag);
          return ptr;
        }
        auto res = UnknownFieldParse(tag, {_InternalParse, msg},
          ptr, end, msg->_internal_metadata_.mutable_unknown_fields(), ctx);
        ptr = res.first;
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr != nullptr);
        if (res.second) return ptr;
      }
    }  // switch
  }  // while
  return ptr;
string_till_end:
  static_cast<::std::string*>(object)->clear();
  static_cast<::std::string*>(object)->reserve(size);
  goto len_delim_till_end;
len_delim_till_end:
  return ctx->StoreAndTailCall(ptr, end, {_InternalParse, msg},
                               {parser_till_end, object}, size);
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool SignTx::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:hw.trezor.messages.bitcoin.SignTx)
  for (;;) {
    ::std::pair<::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 outputs_count = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (8 & 0xFF)) {
          HasBitSetters::set_has_outputs_count(this);
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &outputs_count_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // required uint32 inputs_count = 2;
      case 2: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (16 & 0xFF)) {
          HasBitSetters::set_has_inputs_count(this);
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &inputs_count_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional string coin_name = 3 [default = "Bitcoin"];
      case 3: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (26 & 0xFF)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_coin_name()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->coin_name().data(), static_cast<int>(this->coin_name().length()),
            ::google::protobuf::internal::WireFormat::PARSE,
            "hw.trezor.messages.bitcoin.SignTx.coin_name");
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional uint32 version = 4 [default = 1];
      case 4: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (32 & 0xFF)) {
          HasBitSetters::set_has_version(this);
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &version_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional uint32 lock_time = 5 [default = 0];
      case 5: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (40 & 0xFF)) {
          HasBitSetters::set_has_lock_time(this);
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &lock_time_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional uint32 expiry = 6;
      case 6: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (48 & 0xFF)) {
          HasBitSetters::set_has_expiry(this);
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &expiry_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional bool overwintered = 7;
      case 7: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (56 & 0xFF)) {
          HasBitSetters::set_has_overwintered(this);
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &overwintered_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional uint32 version_group_id = 8;
      case 8: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (64 & 0xFF)) {
          HasBitSetters::set_has_version_group_id(this);
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &version_group_id_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional uint32 timestamp = 9;
      case 9: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (72 & 0xFF)) {
          HasBitSetters::set_has_timestamp(this);
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &timestamp_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, _internal_metadata_.mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:hw.trezor.messages.bitcoin.SignTx)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:hw.trezor.messages.bitcoin.SignTx)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void SignTx::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:hw.trezor.messages.bitcoin.SignTx)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required uint32 outputs_count = 1;
  if (cached_has_bits & 0x00000002u) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->outputs_count(), output);
  }

  // required uint32 inputs_count = 2;
  if (cached_has_bits & 0x00000004u) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->inputs_count(), output);
  }

  // optional string coin_name = 3 [default = "Bitcoin"];
  if (cached_has_bits & 0x00000001u) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->coin_name().data(), static_cast<int>(this->coin_name().length()),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "hw.trezor.messages.bitcoin.SignTx.coin_name");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      3, this->coin_name(), output);
  }

  // optional uint32 version = 4 [default = 1];
  if (cached_has_bits & 0x00000100u) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(4, this->version(), output);
  }

  // optional uint32 lock_time = 5 [default = 0];
  if (cached_has_bits & 0x00000008u) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(5, this->lock_time(), output);
  }

  // optional uint32 expiry = 6;
  if (cached_has_bits & 0x00000010u) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(6, this->expiry(), output);
  }

  // optional bool overwintered = 7;
  if (cached_has_bits & 0x00000020u) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(7, this->overwintered(), output);
  }

  // optional uint32 version_group_id = 8;
  if (cached_has_bits & 0x00000040u) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(8, this->version_group_id(), output);
  }

  // optional uint32 timestamp = 9;
  if (cached_has_bits & 0x00000080u) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(9, this->timestamp(), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        _internal_metadata_.unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:hw.trezor.messages.bitcoin.SignTx)
}

::google::protobuf::uint8* SignTx::InternalSerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:hw.trezor.messages.bitcoin.SignTx)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required uint32 outputs_count = 1;
  if (cached_has_bits & 0x00000002u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(1, this->outputs_count(), target);
  }

  // required uint32 inputs_count = 2;
  if (cached_has_bits & 0x00000004u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(2, this->inputs_count(), target);
  }

  // optional string coin_name = 3 [default = "Bitcoin"];
  if (cached_has_bits & 0x00000001u) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->coin_name().data(), static_cast<int>(this->coin_name().length()),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "hw.trezor.messages.bitcoin.SignTx.coin_name");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        3, this->coin_name(), target);
  }

  // optional uint32 version = 4 [default = 1];
  if (cached_has_bits & 0x00000100u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(4, this->version(), target);
  }

  // optional uint32 lock_time = 5 [default = 0];
  if (cached_has_bits & 0x00000008u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(5, this->lock_time(), target);
  }

  // optional uint32 expiry = 6;
  if (cached_has_bits & 0x00000010u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(6, this->expiry(), target);
  }

  // optional bool overwintered = 7;
  if (cached_has_bits & 0x00000020u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteBoolToArray(7, this->overwintered(), target);
  }

  // optional uint32 version_group_id = 8;
  if (cached_has_bits & 0x00000040u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(8, this->version_group_id(), target);
  }

  // optional uint32 timestamp = 9;
  if (cached_has_bits & 0x00000080u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(9, this->timestamp(), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:hw.trezor.messages.bitcoin.SignTx)
  return target;
}

size_t SignTx::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:hw.trezor.messages.bitcoin.SignTx)
  size_t total_size = 0;

  if (has_outputs_count()) {
    // required uint32 outputs_count = 1;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::UInt32Size(
        this->outputs_count());
  }

  if (has_inputs_count()) {
    // required uint32 inputs_count = 2;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::UInt32Size(
        this->inputs_count());
  }

  return total_size;
}
size_t SignTx::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:hw.trezor.messages.bitcoin.SignTx)
  size_t total_size = 0;

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        _internal_metadata_.unknown_fields());
  }
  if (((_has_bits_[0] & 0x00000006) ^ 0x00000006) == 0) {  // All required fields are present.
    // required uint32 outputs_count = 1;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::UInt32Size(
        this->outputs_count());

    // required uint32 inputs_count = 2;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::UInt32Size(
        this->inputs_count());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional string coin_name = 3 [default = "Bitcoin"];
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::StringSize(
        this->coin_name());
  }

  if (cached_has_bits & 0x000000f8u) {
    // optional uint32 lock_time = 5 [default = 0];
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->lock_time());
    }

    // optional uint32 expiry = 6;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->expiry());
    }

    // optional bool overwintered = 7;
    if (cached_has_bits & 0x00000020u) {
      total_size += 1 + 1;
    }

    // optional uint32 version_group_id = 8;
    if (cached_has_bits & 0x00000040u) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->version_group_id());
    }

    // optional uint32 timestamp = 9;
    if (cached_has_bits & 0x00000080u) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->timestamp());
    }

  }
  // optional uint32 version = 4 [default = 1];
  if (cached_has_bits & 0x00000100u) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::UInt32Size(
        this->version());
  }

  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void SignTx::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:hw.trezor.messages.bitcoin.SignTx)
  GOOGLE_DCHECK_NE(&from, this);
  const SignTx* source =
      ::google::protobuf::DynamicCastToGenerated<SignTx>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:hw.trezor.messages.bitcoin.SignTx)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:hw.trezor.messages.bitcoin.SignTx)
    MergeFrom(*source);
  }
}

void SignTx::MergeFrom(const SignTx& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:hw.trezor.messages.bitcoin.SignTx)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      _has_bits_[0] |= 0x00000001u;
      coin_name_.AssignWithDefault(&::hw::trezor::messages::bitcoin::SignTx::_i_give_permission_to_break_this_code_default_coin_name_.get(), from.coin_name_);
    }
    if (cached_has_bits & 0x00000002u) {
      outputs_count_ = from.outputs_count_;
    }
    if (cached_has_bits & 0x00000004u) {
      inputs_count_ = from.inputs_count_;
    }
    if (cached_has_bits & 0x00000008u) {
      lock_time_ = from.lock_time_;
    }
    if (cached_has_bits & 0x00000010u) {
      expiry_ = from.expiry_;
    }
    if (cached_has_bits & 0x00000020u) {
      overwintered_ = from.overwintered_;
    }
    if (cached_has_bits & 0x00000040u) {
      version_group_id_ = from.version_group_id_;
    }
    if (cached_has_bits & 0x00000080u) {
      timestamp_ = from.timestamp_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  if (cached_has_bits & 0x00000100u) {
    set_version(from.version());
  }
}

void SignTx::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:hw.trezor.messages.bitcoin.SignTx)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void SignTx::CopyFrom(const SignTx& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:hw.trezor.messages.bitcoin.SignTx)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SignTx::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000006) != 0x00000006) return false;
  return true;
}

void SignTx::Swap(SignTx* other) {
  if (other == this) return;
  InternalSwap(other);
}
void SignTx::InternalSwap(SignTx* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  coin_name_.Swap(&other->coin_name_, &::hw::trezor::messages::bitcoin::SignTx::_i_give_permission_to_break_this_code_default_coin_name_.get(),
    GetArenaNoVirtual());
  swap(outputs_count_, other->outputs_count_);
  swap(inputs_count_, other->inputs_count_);
  swap(lock_time_, other->lock_time_);
  swap(expiry_, other->expiry_);
  swap(overwintered_, other->overwintered_);
  swap(version_group_id_, other->version_group_id_);
  swap(timestamp_, other->timestamp_);
  swap(version_, other->version_);
}

::google::protobuf::Metadata SignTx::GetMetadata() const {
  ::google::protobuf::internal::AssignDescriptors(&::assign_descriptors_table_messages_2dbitcoin_2eproto);
  return ::file_level_metadata_messages_2dbitcoin_2eproto[kIndexInFileMessages];
}


// ===================================================================

void TxRequest_TxRequestDetailsType::InitAsDefaultInstance() {
}
class TxRequest_TxRequestDetailsType::HasBitSetters {
 public:
  static void set_has_request_index(TxRequest_TxRequestDetailsType* msg) {
    msg->_has_bits_[0] |= 0x00000002u;
  }
  static void set_has_tx_hash(TxRequest_TxRequestDetailsType* msg) {
    msg->_has_bits_[0] |= 0x00000001u;
  }
  static void set_has_extra_data_len(TxRequest_TxRequestDetailsType* msg) {
    msg->_has_bits_[0] |= 0x00000004u;
  }
  static void set_has_extra_data_offset(TxRequest_TxRequestDetailsType* msg) {
    msg->_has_bits_[0] |= 0x00000008u;
  }
};

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int TxRequest_TxRequestDetailsType::kRequestIndexFieldNumber;
const int TxRequest_TxRequestDetailsType::kTxHashFieldNumber;
const int TxRequest_TxRequestDetailsType::kExtraDataLenFieldNumber;
const int TxRequest_TxRequestDetailsType::kExtraDataOffsetFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

TxRequest_TxRequestDetailsType::TxRequest_TxRequestDetailsType()
  : ::google::protobuf::Message(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:hw.trezor.messages.bitcoin.TxRequest.TxRequestDetailsType)
}
TxRequest_TxRequestDetailsType::TxRequest_TxRequestDetailsType(const TxRequest_TxRequestDetailsType& from)
  : ::google::protobuf::Message(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  tx_hash_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (from.has_tx_hash()) {
    tx_hash_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.tx_hash_);
  }
  ::memcpy(&request_index_, &from.request_index_,
    static_cast<size_t>(reinterpret_cast<char*>(&extra_data_offset_) -
    reinterpret_cast<char*>(&request_index_)) + sizeof(extra_data_offset_));
  // @@protoc_insertion_point(copy_constructor:hw.trezor.messages.bitcoin.TxRequest.TxRequestDetailsType)
}

void TxRequest_TxRequestDetailsType::SharedCtor() {
  ::google::protobuf::internal::InitSCC(
      &scc_info_TxRequest_TxRequestDetailsType_messages_2dbitcoin_2eproto.base);
  tx_hash_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  ::memset(&request_index_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&extra_data_offset_) -
      reinterpret_cast<char*>(&request_index_)) + sizeof(extra_data_offset_));
}

TxRequest_TxRequestDetailsType::~TxRequest_TxRequestDetailsType() {
  // @@protoc_insertion_point(destructor:hw.trezor.messages.bitcoin.TxRequest.TxRequestDetailsType)
  SharedDtor();
}

void TxRequest_TxRequestDetailsType::SharedDtor() {
  tx_hash_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}

void TxRequest_TxRequestDetailsType::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const TxRequest_TxRequestDetailsType& TxRequest_TxRequestDetailsType::default_instance() {
  ::google::protobuf::internal::InitSCC(&::scc_info_TxRequest_TxRequestDetailsType_messages_2dbitcoin_2eproto.base);
  return *internal_default_instance();
}


void TxRequest_TxRequestDetailsType::Clear() {
// @@protoc_insertion_point(message_clear_start:hw.trezor.messages.bitcoin.TxRequest.TxRequestDetailsType)
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    tx_hash_.ClearNonDefaultToEmptyNoArena();
  }
  if (cached_has_bits & 0x0000000eu) {
    ::memset(&request_index_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&extra_data_offset_) -
        reinterpret_cast<char*>(&request_index_)) + sizeof(extra_data_offset_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* TxRequest_TxRequestDetailsType::_InternalParse(const char* begin, const char* end, void* object,
                  ::google::protobuf::internal::ParseContext* ctx) {
  auto msg = static_cast<TxRequest_TxRequestDetailsType*>(object);
  ::google::protobuf::int32 size; (void)size;
  int depth; (void)depth;
  ::google::protobuf::uint32 tag;
  ::google::protobuf::internal::ParseFunc parser_till_end; (void)parser_till_end;
  auto ptr = begin;
  while (ptr < end) {
    ptr = ::google::protobuf::io::Parse32(ptr, &tag);
    GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
    switch (tag >> 3) {
      // optional uint32 request_index = 1;
      case 1: {
        if (static_cast<::google::protobuf::uint8>(tag) != 8) goto handle_unusual;
        msg->set_request_index(::google::protobuf::internal::ReadVarint(&ptr));
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        break;
      }
      // optional bytes tx_hash = 2;
      case 2: {
        if (static_cast<::google::protobuf::uint8>(tag) != 18) goto handle_unusual;
        ptr = ::google::protobuf::io::ReadSize(ptr, &size);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        object = msg->mutable_tx_hash();
        if (size > end - ptr + ::google::protobuf::internal::ParseContext::kSlopBytes) {
          parser_till_end = ::google::protobuf::internal::GreedyStringParser;
          goto string_till_end;
        }
        GOOGLE_PROTOBUF_PARSER_ASSERT(::google::protobuf::internal::StringCheck(ptr, size, ctx));
        ::google::protobuf::internal::InlineGreedyStringParser(object, ptr, size, ctx);
        ptr += size;
        break;
      }
      // optional uint32 extra_data_len = 3;
      case 3: {
        if (static_cast<::google::protobuf::uint8>(tag) != 24) goto handle_unusual;
        msg->set_extra_data_len(::google::protobuf::internal::ReadVarint(&ptr));
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        break;
      }
      // optional uint32 extra_data_offset = 4;
      case 4: {
        if (static_cast<::google::protobuf::uint8>(tag) != 32) goto handle_unusual;
        msg->set_extra_data_offset(::google::protobuf::internal::ReadVarint(&ptr));
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        break;
      }
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->EndGroup(tag);
          return ptr;
        }
        auto res = UnknownFieldParse(tag, {_InternalParse, msg},
          ptr, end, msg->_internal_metadata_.mutable_unknown_fields(), ctx);
        ptr = res.first;
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr != nullptr);
        if (res.second) return ptr;
      }
    }  // switch
  }  // while
  return ptr;
string_till_end:
  static_cast<::std::string*>(object)->clear();
  static_cast<::std::string*>(object)->reserve(size);
  goto len_delim_till_end;
len_delim_till_end:
  return ctx->StoreAndTailCall(ptr, end, {_InternalParse, msg},
                               {parser_till_end, object}, size);
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool TxRequest_TxRequestDetailsType::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:hw.trezor.messages.bitcoin.TxRequest.TxRequestDetailsType)
  for (;;) {
    ::std::pair<::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional uint32 request_index = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (8 & 0xFF)) {
          HasBitSetters::set_has_request_index(this);
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &request_index_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional bytes tx_hash = 2;
      case 2: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (18 & 0xFF)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_tx_hash()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional uint32 extra_data_len = 3;
      case 3: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (24 & 0xFF)) {
          HasBitSetters::set_has_extra_data_len(this);
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &extra_data_len_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional uint32 extra_data_offset = 4;
      case 4: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (32 & 0xFF)) {
          HasBitSetters::set_has_extra_data_offset(this);
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &extra_data_offset_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, _internal_metadata_.mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:hw.trezor.messages.bitcoin.TxRequest.TxRequestDetailsType)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:hw.trezor.messages.bitcoin.TxRequest.TxRequestDetailsType)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void TxRequest_TxRequestDetailsType::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:hw.trezor.messages.bitcoin.TxRequest.TxRequestDetailsType)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional uint32 request_index = 1;
  if (cached_has_bits & 0x00000002u) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->request_index(), output);
  }

  // optional bytes tx_hash = 2;
  if (cached_has_bits & 0x00000001u) {
    ::google::protobuf::internal::WireFormatLite::WriteBytesMaybeAliased(
      2, this->tx_hash(), output);
  }

  // optional uint32 extra_data_len = 3;
  if (cached_has_bits & 0x00000004u) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(3, this->extra_data_len(), output);
  }

  // optional uint32 extra_data_offset = 4;
  if (cached_has_bits & 0x00000008u) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(4, this->extra_data_offset(), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        _internal_metadata_.unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:hw.trezor.messages.bitcoin.TxRequest.TxRequestDetailsType)
}

::google::protobuf::uint8* TxRequest_TxRequestDetailsType::InternalSerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:hw.trezor.messages.bitcoin.TxRequest.TxRequestDetailsType)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional uint32 request_index = 1;
  if (cached_has_bits & 0x00000002u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(1, this->request_index(), target);
  }

  // optional bytes tx_hash = 2;
  if (cached_has_bits & 0x00000001u) {
    target =
      ::google::protobuf::internal::WireFormatLite::WriteBytesToArray(
        2, this->tx_hash(), target);
  }

  // optional uint32 extra_data_len = 3;
  if (cached_has_bits & 0x00000004u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(3, this->extra_data_len(), target);
  }

  // optional uint32 extra_data_offset = 4;
  if (cached_has_bits & 0x00000008u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(4, this->extra_data_offset(), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:hw.trezor.messages.bitcoin.TxRequest.TxRequestDetailsType)
  return target;
}

size_t TxRequest_TxRequestDetailsType::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:hw.trezor.messages.bitcoin.TxRequest.TxRequestDetailsType)
  size_t total_size = 0;

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        _internal_metadata_.unknown_fields());
  }
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    // optional bytes tx_hash = 2;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->tx_hash());
    }

    // optional uint32 request_index = 1;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->request_index());
    }

    // optional uint32 extra_data_len = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->extra_data_len());
    }

    // optional uint32 extra_data_offset = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->extra_data_offset());
    }

  }
  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void TxRequest_TxRequestDetailsType::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:hw.trezor.messages.bitcoin.TxRequest.TxRequestDetailsType)
  GOOGLE_DCHECK_NE(&from, this);
  const TxRequest_TxRequestDetailsType* source =
      ::google::protobuf::DynamicCastToGenerated<TxRequest_TxRequestDetailsType>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:hw.trezor.messages.bitcoin.TxRequest.TxRequestDetailsType)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:hw.trezor.messages.bitcoin.TxRequest.TxRequestDetailsType)
    MergeFrom(*source);
  }
}

void TxRequest_TxRequestDetailsType::MergeFrom(const TxRequest_TxRequestDetailsType& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:hw.trezor.messages.bitcoin.TxRequest.TxRequestDetailsType)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      _has_bits_[0] |= 0x00000001u;
      tx_hash_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.tx_hash_);
    }
    if (cached_has_bits & 0x00000002u) {
      request_index_ = from.request_index_;
    }
    if (cached_has_bits & 0x00000004u) {
      extra_data_len_ = from.extra_data_len_;
    }
    if (cached_has_bits & 0x00000008u) {
      extra_data_offset_ = from.extra_data_offset_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void TxRequest_TxRequestDetailsType::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:hw.trezor.messages.bitcoin.TxRequest.TxRequestDetailsType)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void TxRequest_TxRequestDetailsType::CopyFrom(const TxRequest_TxRequestDetailsType& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:hw.trezor.messages.bitcoin.TxRequest.TxRequestDetailsType)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TxRequest_TxRequestDetailsType::IsInitialized() const {
  return true;
}

void TxRequest_TxRequestDetailsType::Swap(TxRequest_TxRequestDetailsType* other) {
  if (other == this) return;
  InternalSwap(other);
}
void TxRequest_TxRequestDetailsType::InternalSwap(TxRequest_TxRequestDetailsType* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  tx_hash_.Swap(&other->tx_hash_, &::google::protobuf::internal::GetEmptyStringAlreadyInited(),
    GetArenaNoVirtual());
  swap(request_index_, other->request_index_);
  swap(extra_data_len_, other->extra_data_len_);
  swap(extra_data_offset_, other->extra_data_offset_);
}

::google::protobuf::Metadata TxRequest_TxRequestDetailsType::GetMetadata() const {
  ::google::protobuf::internal::AssignDescriptors(&::assign_descriptors_table_messages_2dbitcoin_2eproto);
  return ::file_level_metadata_messages_2dbitcoin_2eproto[kIndexInFileMessages];
}


// ===================================================================

void TxRequest_TxRequestSerializedType::InitAsDefaultInstance() {
}
class TxRequest_TxRequestSerializedType::HasBitSetters {
 public:
  static void set_has_signature_index(TxRequest_TxRequestSerializedType* msg) {
    msg->_has_bits_[0] |= 0x00000004u;
  }
  static void set_has_signature(TxRequest_TxRequestSerializedType* msg) {
    msg->_has_bits_[0] |= 0x00000001u;
  }
  static void set_has_serialized_tx(TxRequest_TxRequestSerializedType* msg) {
    msg->_has_bits_[0] |= 0x00000002u;
  }
};

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int TxRequest_TxRequestSerializedType::kSignatureIndexFieldNumber;
const int TxRequest_TxRequestSerializedType::kSignatureFieldNumber;
const int TxRequest_TxRequestSerializedType::kSerializedTxFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

TxRequest_TxRequestSerializedType::TxRequest_TxRequestSerializedType()
  : ::google::protobuf::Message(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:hw.trezor.messages.bitcoin.TxRequest.TxRequestSerializedType)
}
TxRequest_TxRequestSerializedType::TxRequest_TxRequestSerializedType(const TxRequest_TxRequestSerializedType& from)
  : ::google::protobuf::Message(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  signature_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (from.has_signature()) {
    signature_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.signature_);
  }
  serialized_tx_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (from.has_serialized_tx()) {
    serialized_tx_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.serialized_tx_);
  }
  signature_index_ = from.signature_index_;
  // @@protoc_insertion_point(copy_constructor:hw.trezor.messages.bitcoin.TxRequest.TxRequestSerializedType)
}

void TxRequest_TxRequestSerializedType::SharedCtor() {
  ::google::protobuf::internal::InitSCC(
      &scc_info_TxRequest_TxRequestSerializedType_messages_2dbitcoin_2eproto.base);
  signature_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  serialized_tx_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  signature_index_ = 0u;
}

TxRequest_TxRequestSerializedType::~TxRequest_TxRequestSerializedType() {
  // @@protoc_insertion_point(destructor:hw.trezor.messages.bitcoin.TxRequest.TxRequestSerializedType)
  SharedDtor();
}

void TxRequest_TxRequestSerializedType::SharedDtor() {
  signature_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  serialized_tx_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}

void TxRequest_TxRequestSerializedType::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const TxRequest_TxRequestSerializedType& TxRequest_TxRequestSerializedType::default_instance() {
  ::google::protobuf::internal::InitSCC(&::scc_info_TxRequest_TxRequestSerializedType_messages_2dbitcoin_2eproto.base);
  return *internal_default_instance();
}


void TxRequest_TxRequestSerializedType::Clear() {
// @@protoc_insertion_point(message_clear_start:hw.trezor.messages.bitcoin.TxRequest.TxRequestSerializedType)
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      signature_.ClearNonDefaultToEmptyNoArena();
    }
    if (cached_has_bits & 0x00000002u) {
      serialized_tx_.ClearNonDefaultToEmptyNoArena();
    }
  }
  signature_index_ = 0u;
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* TxRequest_TxRequestSerializedType::_InternalParse(const char* begin, const char* end, void* object,
                  ::google::protobuf::internal::ParseContext* ctx) {
  auto msg = static_cast<TxRequest_TxRequestSerializedType*>(object);
  ::google::protobuf::int32 size; (void)size;
  int depth; (void)depth;
  ::google::protobuf::uint32 tag;
  ::google::protobuf::internal::ParseFunc parser_till_end; (void)parser_till_end;
  auto ptr = begin;
  while (ptr < end) {
    ptr = ::google::protobuf::io::Parse32(ptr, &tag);
    GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
    switch (tag >> 3) {
      // optional uint32 signature_index = 1;
      case 1: {
        if (static_cast<::google::protobuf::uint8>(tag) != 8) goto handle_unusual;
        msg->set_signature_index(::google::protobuf::internal::ReadVarint(&ptr));
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        break;
      }
      // optional bytes signature = 2;
      case 2: {
        if (static_cast<::google::protobuf::uint8>(tag) != 18) goto handle_unusual;
        ptr = ::google::protobuf::io::ReadSize(ptr, &size);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        object = msg->mutable_signature();
        if (size > end - ptr + ::google::protobuf::internal::ParseContext::kSlopBytes) {
          parser_till_end = ::google::protobuf::internal::GreedyStringParser;
          goto string_till_end;
        }
        GOOGLE_PROTOBUF_PARSER_ASSERT(::google::protobuf::internal::StringCheck(ptr, size, ctx));
        ::google::protobuf::internal::InlineGreedyStringParser(object, ptr, size, ctx);
        ptr += size;
        break;
      }
      // optional bytes serialized_tx = 3;
      case 3: {
        if (static_cast<::google::protobuf::uint8>(tag) != 26) goto handle_unusual;
        ptr = ::google::protobuf::io::ReadSize(ptr, &size);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        object = msg->mutable_serialized_tx();
        if (size > end - ptr + ::google::protobuf::internal::ParseContext::kSlopBytes) {
          parser_till_end = ::google::protobuf::internal::GreedyStringParser;
          goto string_till_end;
        }
        GOOGLE_PROTOBUF_PARSER_ASSERT(::google::protobuf::internal::StringCheck(ptr, size, ctx));
        ::google::protobuf::internal::InlineGreedyStringParser(object, ptr, size, ctx);
        ptr += size;
        break;
      }
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->EndGroup(tag);
          return ptr;
        }
        auto res = UnknownFieldParse(tag, {_InternalParse, msg},
          ptr, end, msg->_internal_metadata_.mutable_unknown_fields(), ctx);
        ptr = res.first;
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr != nullptr);
        if (res.second) return ptr;
      }
    }  // switch
  }  // while
  return ptr;
string_till_end:
  static_cast<::std::string*>(object)->clear();
  static_cast<::std::string*>(object)->reserve(size);
  goto len_delim_till_end;
len_delim_till_end:
  return ctx->StoreAndTailCall(ptr, end, {_InternalParse, msg},
                               {parser_till_end, object}, size);
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool TxRequest_TxRequestSerializedType::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:hw.trezor.messages.bitcoin.TxRequest.TxRequestSerializedType)
  for (;;) {
    ::std::pair<::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional uint32 signature_index = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (8 & 0xFF)) {
          HasBitSetters::set_has_signature_index(this);
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &signature_index_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional bytes signature = 2;
      case 2: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (18 & 0xFF)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_signature()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional bytes serialized_tx = 3;
      case 3: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (26 & 0xFF)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_serialized_tx()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, _internal_metadata_.mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:hw.trezor.messages.bitcoin.TxRequest.TxRequestSerializedType)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:hw.trezor.messages.bitcoin.TxRequest.TxRequestSerializedType)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void TxRequest_TxRequestSerializedType::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:hw.trezor.messages.bitcoin.TxRequest.TxRequestSerializedType)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional uint32 signature_index = 1;
  if (cached_has_bits & 0x00000004u) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->signature_index(), output);
  }

  // optional bytes signature = 2;
  if (cached_has_bits & 0x00000001u) {
    ::google::protobuf::internal::WireFormatLite::WriteBytesMaybeAliased(
      2, this->signature(), output);
  }

  // optional bytes serialized_tx = 3;
  if (cached_has_bits & 0x00000002u) {
    ::google::protobuf::internal::WireFormatLite::WriteBytesMaybeAliased(
      3, this->serialized_tx(), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        _internal_metadata_.unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:hw.trezor.messages.bitcoin.TxRequest.TxRequestSerializedType)
}

::google::protobuf::uint8* TxRequest_TxRequestSerializedType::InternalSerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:hw.trezor.messages.bitcoin.TxRequest.TxRequestSerializedType)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional uint32 signature_index = 1;
  if (cached_has_bits & 0x00000004u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(1, this->signature_index(), target);
  }

  // optional bytes signature = 2;
  if (cached_has_bits & 0x00000001u) {
    target =
      ::google::protobuf::internal::WireFormatLite::WriteBytesToArray(
        2, this->signature(), target);
  }

  // optional bytes serialized_tx = 3;
  if (cached_has_bits & 0x00000002u) {
    target =
      ::google::protobuf::internal::WireFormatLite::WriteBytesToArray(
        3, this->serialized_tx(), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:hw.trezor.messages.bitcoin.TxRequest.TxRequestSerializedType)
  return target;
}

size_t TxRequest_TxRequestSerializedType::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:hw.trezor.messages.bitcoin.TxRequest.TxRequestSerializedType)
  size_t total_size = 0;

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        _internal_metadata_.unknown_fields());
  }
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional bytes signature = 2;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->signature());
    }

    // optional bytes serialized_tx = 3;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->serialized_tx());
    }

    // optional uint32 signature_index = 1;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->signature_index());
    }

  }
  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void TxRequest_TxRequestSerializedType::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:hw.trezor.messages.bitcoin.TxRequest.TxRequestSerializedType)
  GOOGLE_DCHECK_NE(&from, this);
  const TxRequest_TxRequestSerializedType* source =
      ::google::protobuf::DynamicCastToGenerated<TxRequest_TxRequestSerializedType>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:hw.trezor.messages.bitcoin.TxRequest.TxRequestSerializedType)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:hw.trezor.messages.bitcoin.TxRequest.TxRequestSerializedType)
    MergeFrom(*source);
  }
}

void TxRequest_TxRequestSerializedType::MergeFrom(const TxRequest_TxRequestSerializedType& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:hw.trezor.messages.bitcoin.TxRequest.TxRequestSerializedType)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _has_bits_[0] |= 0x00000001u;
      signature_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.signature_);
    }
    if (cached_has_bits & 0x00000002u) {
      _has_bits_[0] |= 0x00000002u;
      serialized_tx_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.serialized_tx_);
    }
    if (cached_has_bits & 0x00000004u) {
      signature_index_ = from.signature_index_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void TxRequest_TxRequestSerializedType::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:hw.trezor.messages.bitcoin.TxRequest.TxRequestSerializedType)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void TxRequest_TxRequestSerializedType::CopyFrom(const TxRequest_TxRequestSerializedType& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:hw.trezor.messages.bitcoin.TxRequest.TxRequestSerializedType)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TxRequest_TxRequestSerializedType::IsInitialized() const {
  return true;
}

void TxRequest_TxRequestSerializedType::Swap(TxRequest_TxRequestSerializedType* other) {
  if (other == this) return;
  InternalSwap(other);
}
void TxRequest_TxRequestSerializedType::InternalSwap(TxRequest_TxRequestSerializedType* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  signature_.Swap(&other->signature_, &::google::protobuf::internal::GetEmptyStringAlreadyInited(),
    GetArenaNoVirtual());
  serialized_tx_.Swap(&other->serialized_tx_, &::google::protobuf::internal::GetEmptyStringAlreadyInited(),
    GetArenaNoVirtual());
  swap(signature_index_, other->signature_index_);
}

::google::protobuf::Metadata TxRequest_TxRequestSerializedType::GetMetadata() const {
  ::google::protobuf::internal::AssignDescriptors(&::assign_descriptors_table_messages_2dbitcoin_2eproto);
  return ::file_level_metadata_messages_2dbitcoin_2eproto[kIndexInFileMessages];
}


// ===================================================================

void TxRequest::InitAsDefaultInstance() {
  ::hw::trezor::messages::bitcoin::_TxRequest_default_instance_._instance.get_mutable()->details_ = const_cast< ::hw::trezor::messages::bitcoin::TxRequest_TxRequestDetailsType*>(
      ::hw::trezor::messages::bitcoin::TxRequest_TxRequestDetailsType::internal_default_instance());
  ::hw::trezor::messages::bitcoin::_TxRequest_default_instance_._instance.get_mutable()->serialized_ = const_cast< ::hw::trezor::messages::bitcoin::TxRequest_TxRequestSerializedType*>(
      ::hw::trezor::messages::bitcoin::TxRequest_TxRequestSerializedType::internal_default_instance());
}
class TxRequest::HasBitSetters {
 public:
  static void set_has_request_type(TxRequest* msg) {
    msg->_has_bits_[0] |= 0x00000004u;
  }
  static const ::hw::trezor::messages::bitcoin::TxRequest_TxRequestDetailsType& details(const TxRequest* msg);
  static void set_has_details(TxRequest* msg) {
    msg->_has_bits_[0] |= 0x00000001u;
  }
  static const ::hw::trezor::messages::bitcoin::TxRequest_TxRequestSerializedType& serialized(const TxRequest* msg);
  static void set_has_serialized(TxRequest* msg) {
    msg->_has_bits_[0] |= 0x00000002u;
  }
};

const ::hw::trezor::messages::bitcoin::TxRequest_TxRequestDetailsType&
TxRequest::HasBitSetters::details(const TxRequest* msg) {
  return *msg->details_;
}
const ::hw::trezor::messages::bitcoin::TxRequest_TxRequestSerializedType&
TxRequest::HasBitSetters::serialized(const TxRequest* msg) {
  return *msg->serialized_;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int TxRequest::kRequestTypeFieldNumber;
const int TxRequest::kDetailsFieldNumber;
const int TxRequest::kSerializedFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

TxRequest::TxRequest()
  : ::google::protobuf::Message(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:hw.trezor.messages.bitcoin.TxRequest)
}
TxRequest::TxRequest(const TxRequest& from)
  : ::google::protobuf::Message(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  if (from.has_details()) {
    details_ = new ::hw::trezor::messages::bitcoin::TxRequest_TxRequestDetailsType(*from.details_);
  } else {
    details_ = nullptr;
  }
  if (from.has_serialized()) {
    serialized_ = new ::hw::trezor::messages::bitcoin::TxRequest_TxRequestSerializedType(*from.serialized_);
  } else {
    serialized_ = nullptr;
  }
  request_type_ = from.request_type_;
  // @@protoc_insertion_point(copy_constructor:hw.trezor.messages.bitcoin.TxRequest)
}

void TxRequest::SharedCtor() {
  ::google::protobuf::internal::InitSCC(
      &scc_info_TxRequest_messages_2dbitcoin_2eproto.base);
  ::memset(&details_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&request_type_) -
      reinterpret_cast<char*>(&details_)) + sizeof(request_type_));
}

TxRequest::~TxRequest() {
  // @@protoc_insertion_point(destructor:hw.trezor.messages.bitcoin.TxRequest)
  SharedDtor();
}

void TxRequest::SharedDtor() {
  if (this != internal_default_instance()) delete details_;
  if (this != internal_default_instance()) delete serialized_;
}

void TxRequest::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const TxRequest& TxRequest::default_instance() {
  ::google::protobuf::internal::InitSCC(&::scc_info_TxRequest_messages_2dbitcoin_2eproto.base);
  return *internal_default_instance();
}


void TxRequest::Clear() {
// @@protoc_insertion_point(message_clear_start:hw.trezor.messages.bitcoin.TxRequest)
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(details_ != nullptr);
      details_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(serialized_ != nullptr);
      serialized_->Clear();
    }
  }
  request_type_ = 0;
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* TxRequest::_InternalParse(const char* begin, const char* end, void* object,
                  ::google::protobuf::internal::ParseContext* ctx) {
  auto msg = static_cast<TxRequest*>(object);
  ::google::protobuf::int32 size; (void)size;
  int depth; (void)depth;
  ::google::protobuf::uint32 tag;
  ::google::protobuf::internal::ParseFunc parser_till_end; (void)parser_till_end;
  auto ptr = begin;
  while (ptr < end) {
    ptr = ::google::protobuf::io::Parse32(ptr, &tag);
    GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
    switch (tag >> 3) {
      // optional .hw.trezor.messages.bitcoin.TxRequest.RequestType request_type = 1;
      case 1: {
        if (static_cast<::google::protobuf::uint8>(tag) != 8) goto handle_unusual;
        ::google::protobuf::uint64 val = ::google::protobuf::internal::ReadVarint(&ptr);
        if (!::hw::trezor::messages::bitcoin::TxRequest_RequestType_IsValid(val)) {
          ::google::protobuf::internal::WriteVarint(1, val, msg->mutable_unknown_fields());
          break;
        }
        msg->set_request_type(static_cast<::hw::trezor::messages::bitcoin::TxRequest_RequestType>(val));
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        break;
      }
      // optional .hw.trezor.messages.bitcoin.TxRequest.TxRequestDetailsType details = 2;
      case 2: {
        if (static_cast<::google::protobuf::uint8>(tag) != 18) goto handle_unusual;
        ptr = ::google::protobuf::io::ReadSize(ptr, &size);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        parser_till_end = ::hw::trezor::messages::bitcoin::TxRequest_TxRequestDetailsType::_InternalParse;
        object = msg->mutable_details();
        if (size > end - ptr) goto len_delim_till_end;
        ptr += size;
        GOOGLE_PROTOBUF_PARSER_ASSERT(ctx->ParseExactRange(
            {parser_till_end, object}, ptr - size, ptr));
        break;
      }
      // optional .hw.trezor.messages.bitcoin.TxRequest.TxRequestSerializedType serialized = 3;
      case 3: {
        if (static_cast<::google::protobuf::uint8>(tag) != 26) goto handle_unusual;
        ptr = ::google::protobuf::io::ReadSize(ptr, &size);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        parser_till_end = ::hw::trezor::messages::bitcoin::TxRequest_TxRequestSerializedType::_InternalParse;
        object = msg->mutable_serialized();
        if (size > end - ptr) goto len_delim_till_end;
        ptr += size;
        GOOGLE_PROTOBUF_PARSER_ASSERT(ctx->ParseExactRange(
            {parser_till_end, object}, ptr - size, ptr));
        break;
      }
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->EndGroup(tag);
          return ptr;
        }
        auto res = UnknownFieldParse(tag, {_InternalParse, msg},
          ptr, end, msg->_internal_metadata_.mutable_unknown_fields(), ctx);
        ptr = res.first;
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr != nullptr);
        if (res.second) return ptr;
      }
    }  // switch
  }  // while
  return ptr;
len_delim_till_end:
  return ctx->StoreAndTailCall(ptr, end, {_InternalParse, msg},
                               {parser_till_end, object}, size);
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool TxRequest::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:hw.trezor.messages.bitcoin.TxRequest)
  for (;;) {
    ::std::pair<::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .hw.trezor.messages.bitcoin.TxRequest.RequestType request_type = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (8 & 0xFF)) {
          int value = 0;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::hw::trezor::messages::bitcoin::TxRequest_RequestType_IsValid(value)) {
            set_request_type(static_cast< ::hw::trezor::messages::bitcoin::TxRequest_RequestType >(value));
          } else {
            mutable_unknown_fields()->AddVarint(
                1, static_cast<::google::protobuf::uint64>(value));
          }
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional .hw.trezor.messages.bitcoin.TxRequest.TxRequestDetailsType details = 2;
      case 2: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (18 & 0xFF)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessage(
               input, mutable_details()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional .hw.trezor.messages.bitcoin.TxRequest.TxRequestSerializedType serialized = 3;
      case 3: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (26 & 0xFF)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessage(
               input, mutable_serialized()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, _internal_metadata_.mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:hw.trezor.messages.bitcoin.TxRequest)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:hw.trezor.messages.bitcoin.TxRequest)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void TxRequest::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:hw.trezor.messages.bitcoin.TxRequest)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional .hw.trezor.messages.bitcoin.TxRequest.RequestType request_type = 1;
  if (cached_has_bits & 0x00000004u) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      1, this->request_type(), output);
  }

  // optional .hw.trezor.messages.bitcoin.TxRequest.TxRequestDetailsType details = 2;
  if (cached_has_bits & 0x00000001u) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, HasBitSetters::details(this), output);
  }

  // optional .hw.trezor.messages.bitcoin.TxRequest.TxRequestSerializedType serialized = 3;
  if (cached_has_bits & 0x00000002u) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      3, HasBitSetters::serialized(this), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        _internal_metadata_.unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:hw.trezor.messages.bitcoin.TxRequest)
}

::google::protobuf::uint8* TxRequest::InternalSerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:hw.trezor.messages.bitcoin.TxRequest)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional .hw.trezor.messages.bitcoin.TxRequest.RequestType request_type = 1;
  if (cached_has_bits & 0x00000004u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      1, this->request_type(), target);
  }

  // optional .hw.trezor.messages.bitcoin.TxRequest.TxRequestDetailsType details = 2;
  if (cached_has_bits & 0x00000001u) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageToArray(
        2, HasBitSetters::details(this), target);
  }

  // optional .hw.trezor.messages.bitcoin.TxRequest.TxRequestSerializedType serialized = 3;
  if (cached_has_bits & 0x00000002u) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageToArray(
        3, HasBitSetters::serialized(this), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:hw.trezor.messages.bitcoin.TxRequest)
  return target;
}

size_t TxRequest::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:hw.trezor.messages.bitcoin.TxRequest)
  size_t total_size = 0;

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        _internal_metadata_.unknown_fields());
  }
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional .hw.trezor.messages.bitcoin.TxRequest.TxRequestDetailsType details = 2;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSize(
          *details_);
    }

    // optional .hw.trezor.messages.bitcoin.TxRequest.TxRequestSerializedType serialized = 3;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSize(
          *serialized_);
    }

    // optional .hw.trezor.messages.bitcoin.TxRequest.RequestType request_type = 1;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->request_type());
    }

  }
  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void TxRequest::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:hw.trezor.messages.bitcoin.TxRequest)
  GOOGLE_DCHECK_NE(&from, this);
  const TxRequest* source =
      ::google::protobuf::DynamicCastToGenerated<TxRequest>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:hw.trezor.messages.bitcoin.TxRequest)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:hw.trezor.messages.bitcoin.TxRequest)
    MergeFrom(*source);
  }
}

void TxRequest::MergeFrom(const TxRequest& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:hw.trezor.messages.bitcoin.TxRequest)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      mutable_details()->::hw::trezor::messages::bitcoin::TxRequest_TxRequestDetailsType::MergeFrom(from.details());
    }
    if (cached_has_bits & 0x00000002u) {
      mutable_serialized()->::hw::trezor::messages::bitcoin::TxRequest_TxRequestSerializedType::MergeFrom(from.serialized());
    }
    if (cached_has_bits & 0x00000004u) {
      request_type_ = from.request_type_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void TxRequest::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:hw.trezor.messages.bitcoin.TxRequest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void TxRequest::CopyFrom(const TxRequest& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:hw.trezor.messages.bitcoin.TxRequest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TxRequest::IsInitialized() const {
  return true;
}

void TxRequest::Swap(TxRequest* other) {
  if (other == this) return;
  InternalSwap(other);
}
void TxRequest::InternalSwap(TxRequest* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  swap(details_, other->details_);
  swap(serialized_, other->serialized_);
  swap(request_type_, other->request_type_);
}

::google::protobuf::Metadata TxRequest::GetMetadata() const {
  ::google::protobuf::internal::AssignDescriptors(&::assign_descriptors_table_messages_2dbitcoin_2eproto);
  return ::file_level_metadata_messages_2dbitcoin_2eproto[kIndexInFileMessages];
}


// ===================================================================

void TxAck_TransactionType_TxInputType::InitAsDefaultInstance() {
  ::hw::trezor::messages::bitcoin::_TxAck_TransactionType_TxInputType_default_instance_._instance.get_mutable()->multisig_ = const_cast< ::hw::trezor::messages::bitcoin::MultisigRedeemScriptType*>(
      ::hw::trezor::messages::bitcoin::MultisigRedeemScriptType::internal_default_instance());
}
class TxAck_TransactionType_TxInputType::HasBitSetters {
 public:
  static void set_has_prev_hash(TxAck_TransactionType_TxInputType* msg) {
    msg->_has_bits_[0] |= 0x00000001u;
  }
  static void set_has_prev_index(TxAck_TransactionType_TxInputType* msg) {
    msg->_has_bits_[0] |= 0x00000010u;
  }
  static void set_has_script_sig(TxAck_TransactionType_TxInputType* msg) {
    msg->_has_bits_[0] |= 0x00000002u;
  }
  static void set_has_sequence(TxAck_TransactionType_TxInputType* msg) {
    msg->_has_bits_[0] |= 0x00000400u;
  }
  static void set_has_script_type(TxAck_TransactionType_TxInputType* msg) {
    msg->_has_bits_[0] |= 0x00000020u;
  }
  static const ::hw::trezor::messages::bitcoin::MultisigRedeemScriptType& multisig(const TxAck_TransactionType_TxInputType* msg);
  static void set_has_multisig(TxAck_TransactionType_TxInputType* msg) {
    msg->_has_bits_[0] |= 0x00000008u;
  }
  static void set_has_amount(TxAck_TransactionType_TxInputType* msg) {
    msg->_has_bits_[0] |= 0x00000040u;
  }
  static void set_has_decred_tree(TxAck_TransactionType_TxInputType* msg) {
    msg->_has_bits_[0] |= 0x00000080u;
  }
  static void set_has_decred_script_version(TxAck_TransactionType_TxInputType* msg) {
    msg->_has_bits_[0] |= 0x00000100u;
  }
  static void set_has_prev_block_hash_bip115(TxAck_TransactionType_TxInputType* msg) {
    msg->_has_bits_[0] |= 0x00000004u;
  }
  static void set_has_prev_block_height_bip115(TxAck_TransactionType_TxInputType* msg) {
    msg->_has_bits_[0] |= 0x00000200u;
  }
};

const ::hw::trezor::messages::bitcoin::MultisigRedeemScriptType&
TxAck_TransactionType_TxInputType::HasBitSetters::multisig(const TxAck_TransactionType_TxInputType* msg) {
  return *msg->multisig_;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int TxAck_TransactionType_TxInputType::kAddressNFieldNumber;
const int TxAck_TransactionType_TxInputType::kPrevHashFieldNumber;
const int TxAck_TransactionType_TxInputType::kPrevIndexFieldNumber;
const int TxAck_TransactionType_TxInputType::kScriptSigFieldNumber;
const int TxAck_TransactionType_TxInputType::kSequenceFieldNumber;
const int TxAck_TransactionType_TxInputType::kScriptTypeFieldNumber;
const int TxAck_TransactionType_TxInputType::kMultisigFieldNumber;
const int TxAck_TransactionType_TxInputType::kAmountFieldNumber;
const int TxAck_TransactionType_TxInputType::kDecredTreeFieldNumber;
const int TxAck_TransactionType_TxInputType::kDecredScriptVersionFieldNumber;
const int TxAck_TransactionType_TxInputType::kPrevBlockHashBip115FieldNumber;
const int TxAck_TransactionType_TxInputType::kPrevBlockHeightBip115FieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

TxAck_TransactionType_TxInputType::TxAck_TransactionType_TxInputType()
  : ::google::protobuf::Message(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:hw.trezor.messages.bitcoin.TxAck.TransactionType.TxInputType)
}
TxAck_TransactionType_TxInputType::TxAck_TransactionType_TxInputType(const TxAck_TransactionType_TxInputType& from)
  : ::google::protobuf::Message(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_),
      address_n_(from.address_n_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  prev_hash_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (from.has_prev_hash()) {
    prev_hash_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.prev_hash_);
  }
  script_sig_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (from.has_script_sig()) {
    script_sig_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.script_sig_);
  }
  prev_block_hash_bip115_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (from.has_prev_block_hash_bip115()) {
    prev_block_hash_bip115_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.prev_block_hash_bip115_);
  }
  if (from.has_multisig()) {
    multisig_ = new ::hw::trezor::messages::bitcoin::MultisigRedeemScriptType(*from.multisig_);
  } else {
    multisig_ = nullptr;
  }
  ::memcpy(&prev_index_, &from.prev_index_,
    static_cast<size_t>(reinterpret_cast<char*>(&sequence_) -
    reinterpret_cast<char*>(&prev_index_)) + sizeof(sequence_));
  // @@protoc_insertion_point(copy_constructor:hw.trezor.messages.bitcoin.TxAck.TransactionType.TxInputType)
}

void TxAck_TransactionType_TxInputType::SharedCtor() {
  ::google::protobuf::internal::InitSCC(
      &scc_info_TxAck_TransactionType_TxInputType_messages_2dbitcoin_2eproto.base);
  prev_hash_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  script_sig_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  prev_block_hash_bip115_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  ::memset(&multisig_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&prev_block_height_bip115_) -
      reinterpret_cast<char*>(&multisig_)) + sizeof(prev_block_height_bip115_));
  sequence_ = 4294967295u;
}

TxAck_TransactionType_TxInputType::~TxAck_TransactionType_TxInputType() {
  // @@protoc_insertion_point(destructor:hw.trezor.messages.bitcoin.TxAck.TransactionType.TxInputType)
  SharedDtor();
}

void TxAck_TransactionType_TxInputType::SharedDtor() {
  prev_hash_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  script_sig_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  prev_block_hash_bip115_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (this != internal_default_instance()) delete multisig_;
}

void TxAck_TransactionType_TxInputType::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const TxAck_TransactionType_TxInputType& TxAck_TransactionType_TxInputType::default_instance() {
  ::google::protobuf::internal::InitSCC(&::scc_info_TxAck_TransactionType_TxInputType_messages_2dbitcoin_2eproto.base);
  return *internal_default_instance();
}


void TxAck_TransactionType_TxInputType::Clear() {
// @@protoc_insertion_point(message_clear_start:hw.trezor.messages.bitcoin.TxAck.TransactionType.TxInputType)
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  address_n_.Clear();
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      prev_hash_.ClearNonDefaultToEmptyNoArena();
    }
    if (cached_has_bits & 0x00000002u) {
      script_sig_.ClearNonDefaultToEmptyNoArena();
    }
    if (cached_has_bits & 0x00000004u) {
      prev_block_hash_bip115_.ClearNonDefaultToEmptyNoArena();
    }
    if (cached_has_bits & 0x00000008u) {
      GOOGLE_DCHECK(multisig_ != nullptr);
      multisig_->Clear();
    }
  }
  if (cached_has_bits & 0x000000f0u) {
    ::memset(&prev_index_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&decred_tree_) -
        reinterpret_cast<char*>(&prev_index_)) + sizeof(decred_tree_));
  }
  if (cached_has_bits & 0x00000700u) {
    ::memset(&decred_script_version_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&prev_block_height_bip115_) -
        reinterpret_cast<char*>(&decred_script_version_)) + sizeof(prev_block_height_bip115_));
    sequence_ = 4294967295u;
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* TxAck_TransactionType_TxInputType::_InternalParse(const char* begin, const char* end, void* object,
                  ::google::protobuf::internal::ParseContext* ctx) {
  auto msg = static_cast<TxAck_TransactionType_TxInputType*>(object);
  ::google::protobuf::int32 size; (void)size;
  int depth; (void)depth;
  ::google::protobuf::uint32 tag;
  ::google::protobuf::internal::ParseFunc parser_till_end; (void)parser_till_end;
  auto ptr = begin;
  while (ptr < end) {
    ptr = ::google::protobuf::io::Parse32(ptr, &tag);
    GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
    switch (tag >> 3) {
      // repeated uint32 address_n = 1;
      case 1: {
        if (static_cast<::google::protobuf::uint8>(tag) == 8) {
          do {
            msg->add_address_n(::google::protobuf::internal::ReadVarint(&ptr));
            GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
            if (ptr >= end) break;
          } while ((::google::protobuf::io::UnalignedLoad<::google::protobuf::uint64>(ptr) & 255) == 8 && (ptr += 1));
          break;
        } else if (static_cast<::google::protobuf::uint8>(tag) != 10) goto handle_unusual;
        ptr = ::google::protobuf::io::ReadSize(ptr, &size);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        parser_till_end = ::google::protobuf::internal::PackedUInt32Parser;
        object = msg->mutable_address_n();
        if (size > end - ptr) goto len_delim_till_end;
        auto newend = ptr + size;
        if (size) ptr = parser_till_end(ptr, newend, object, ctx);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr == newend);
        break;
      }
      // required bytes prev_hash = 2;
      case 2: {
        if (static_cast<::google::protobuf::uint8>(tag) != 18) goto handle_unusual;
        ptr = ::google::protobuf::io::ReadSize(ptr, &size);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        object = msg->mutable_prev_hash();
        if (size > end - ptr + ::google::protobuf::internal::ParseContext::kSlopBytes) {
          parser_till_end = ::google::protobuf::internal::GreedyStringParser;
          goto string_till_end;
        }
        GOOGLE_PROTOBUF_PARSER_ASSERT(::google::protobuf::internal::StringCheck(ptr, size, ctx));
        ::google::protobuf::internal::InlineGreedyStringParser(object, ptr, size, ctx);
        ptr += size;
        break;
      }
      // required uint32 prev_index = 3;
      case 3: {
        if (static_cast<::google::protobuf::uint8>(tag) != 24) goto handle_unusual;
        msg->set_prev_index(::google::protobuf::internal::ReadVarint(&ptr));
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        break;
      }
      // optional bytes script_sig = 4;
      case 4: {
        if (static_cast<::google::protobuf::uint8>(tag) != 34) goto handle_unusual;
        ptr = ::google::protobuf::io::ReadSize(ptr, &size);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        object = msg->mutable_script_sig();
        if (size > end - ptr + ::google::protobuf::internal::ParseContext::kSlopBytes) {
          parser_till_end = ::google::protobuf::internal::GreedyStringParser;
          goto string_till_end;
        }
        GOOGLE_PROTOBUF_PARSER_ASSERT(::google::protobuf::internal::StringCheck(ptr, size, ctx));
        ::google::protobuf::internal::InlineGreedyStringParser(object, ptr, size, ctx);
        ptr += size;
        break;
      }
      // optional uint32 sequence = 5 [default = 4294967295];
      case 5: {
        if (static_cast<::google::protobuf::uint8>(tag) != 40) goto handle_unusual;
        msg->set_sequence(::google::protobuf::internal::ReadVarint(&ptr));
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        break;
      }
      // optional .hw.trezor.messages.bitcoin.InputScriptType script_type = 6 [default = SPENDADDRESS];
      case 6: {
        if (static_cast<::google::protobuf::uint8>(tag) != 48) goto handle_unusual;
        ::google::protobuf::uint64 val = ::google::protobuf::internal::ReadVarint(&ptr);
        if (!::hw::trezor::messages::bitcoin::InputScriptType_IsValid(val)) {
          ::google::protobuf::internal::WriteVarint(6, val, msg->mutable_unknown_fields());
          break;
        }
        msg->set_script_type(static_cast<::hw::trezor::messages::bitcoin::InputScriptType>(val));
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        break;
      }
      // optional .hw.trezor.messages.bitcoin.MultisigRedeemScriptType multisig = 7;
      case 7: {
        if (static_cast<::google::protobuf::uint8>(tag) != 58) goto handle_unusual;
        ptr = ::google::protobuf::io::ReadSize(ptr, &size);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        parser_till_end = ::hw::trezor::messages::bitcoin::MultisigRedeemScriptType::_InternalParse;
        object = msg->mutable_multisig();
        if (size > end - ptr) goto len_delim_till_end;
        ptr += size;
        GOOGLE_PROTOBUF_PARSER_ASSERT(ctx->ParseExactRange(
            {parser_till_end, object}, ptr - size, ptr));
        break;
      }
      // optional uint64 amount = 8;
      case 8: {
        if (static_cast<::google::protobuf::uint8>(tag) != 64) goto handle_unusual;
        msg->set_amount(::google::protobuf::internal::ReadVarint(&ptr));
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        break;
      }
      // optional uint32 decred_tree = 9;
      case 9: {
        if (static_cast<::google::protobuf::uint8>(tag) != 72) goto handle_unusual;
        msg->set_decred_tree(::google::protobuf::internal::ReadVarint(&ptr));
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        break;
      }
      // optional uint32 decred_script_version = 10;
      case 10: {
        if (static_cast<::google::protobuf::uint8>(tag) != 80) goto handle_unusual;
        msg->set_decred_script_version(::google::protobuf::internal::ReadVarint(&ptr));
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        break;
      }
      // optional bytes prev_block_hash_bip115 = 11;
      case 11: {
        if (static_cast<::google::protobuf::uint8>(tag) != 90) goto handle_unusual;
        ptr = ::google::protobuf::io::ReadSize(ptr, &size);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        object = msg->mutable_prev_block_hash_bip115();
        if (size > end - ptr + ::google::protobuf::internal::ParseContext::kSlopBytes) {
          parser_till_end = ::google::protobuf::internal::GreedyStringParser;
          goto string_till_end;
        }
        GOOGLE_PROTOBUF_PARSER_ASSERT(::google::protobuf::internal::StringCheck(ptr, size, ctx));
        ::google::protobuf::internal::InlineGreedyStringParser(object, ptr, size, ctx);
        ptr += size;
        break;
      }
      // optional uint32 prev_block_height_bip115 = 12;
      case 12: {
        if (static_cast<::google::protobuf::uint8>(tag) != 96) goto handle_unusual;
        msg->set_prev_block_height_bip115(::google::protobuf::internal::ReadVarint(&ptr));
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        break;
      }
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->EndGroup(tag);
          return ptr;
        }
        auto res = UnknownFieldParse(tag, {_InternalParse, msg},
          ptr, end, msg->_internal_metadata_.mutable_unknown_fields(), ctx);
        ptr = res.first;
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr != nullptr);
        if (res.second) return ptr;
      }
    }  // switch
  }  // while
  return ptr;
string_till_end:
  static_cast<::std::string*>(object)->clear();
  static_cast<::std::string*>(object)->reserve(size);
  goto len_delim_till_end;
len_delim_till_end:
  return ctx->StoreAndTailCall(ptr, end, {_InternalParse, msg},
                               {parser_till_end, object}, size);
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool TxAck_TransactionType_TxInputType::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:hw.trezor.messages.bitcoin.TxAck.TransactionType.TxInputType)
  for (;;) {
    ::std::pair<::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated uint32 address_n = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (8 & 0xFF)) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadRepeatedPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 1, 8u, input, this->mutable_address_n())));
        } else if (static_cast< ::google::protobuf::uint8>(tag) == (10 & 0xFF)) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPackedPrimitiveNoInline<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, this->mutable_address_n())));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // required bytes prev_hash = 2;
      case 2: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (18 & 0xFF)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_prev_hash()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // required uint32 prev_index = 3;
      case 3: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (24 & 0xFF)) {
          HasBitSetters::set_has_prev_index(this);
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &prev_index_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional bytes script_sig = 4;
      case 4: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (34 & 0xFF)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_script_sig()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional uint32 sequence = 5 [default = 4294967295];
      case 5: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (40 & 0xFF)) {
          HasBitSetters::set_has_sequence(this);
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &sequence_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional .hw.trezor.messages.bitcoin.InputScriptType script_type = 6 [default = SPENDADDRESS];
      case 6: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (48 & 0xFF)) {
          int value = 0;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::hw::trezor::messages::bitcoin::InputScriptType_IsValid(value)) {
            set_script_type(static_cast< ::hw::trezor::messages::bitcoin::InputScriptType >(value));
          } else {
            mutable_unknown_fields()->AddVarint(
                6, static_cast<::google::protobuf::uint64>(value));
          }
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional .hw.trezor.messages.bitcoin.MultisigRedeemScriptType multisig = 7;
      case 7: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (58 & 0xFF)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessage(
               input, mutable_multisig()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional uint64 amount = 8;
      case 8: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (64 & 0xFF)) {
          HasBitSetters::set_has_amount(this);
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &amount_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional uint32 decred_tree = 9;
      case 9: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (72 & 0xFF)) {
          HasBitSetters::set_has_decred_tree(this);
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &decred_tree_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional uint32 decred_script_version = 10;
      case 10: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (80 & 0xFF)) {
          HasBitSetters::set_has_decred_script_version(this);
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &decred_script_version_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional bytes prev_block_hash_bip115 = 11;
      case 11: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (90 & 0xFF)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_prev_block_hash_bip115()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional uint32 prev_block_height_bip115 = 12;
      case 12: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (96 & 0xFF)) {
          HasBitSetters::set_has_prev_block_height_bip115(this);
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &prev_block_height_bip115_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, _internal_metadata_.mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:hw.trezor.messages.bitcoin.TxAck.TransactionType.TxInputType)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:hw.trezor.messages.bitcoin.TxAck.TransactionType.TxInputType)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void TxAck_TransactionType_TxInputType::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:hw.trezor.messages.bitcoin.TxAck.TransactionType.TxInputType)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated uint32 address_n = 1;
  for (int i = 0, n = this->address_n_size(); i < n; i++) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(
      1, this->address_n(i), output);
  }

  cached_has_bits = _has_bits_[0];
  // required bytes prev_hash = 2;
  if (cached_has_bits & 0x00000001u) {
    ::google::protobuf::internal::WireFormatLite::WriteBytesMaybeAliased(
      2, this->prev_hash(), output);
  }

  // required uint32 prev_index = 3;
  if (cached_has_bits & 0x00000010u) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(3, this->prev_index(), output);
  }

  // optional bytes script_sig = 4;
  if (cached_has_bits & 0x00000002u) {
    ::google::protobuf::internal::WireFormatLite::WriteBytesMaybeAliased(
      4, this->script_sig(), output);
  }

  // optional uint32 sequence = 5 [default = 4294967295];
  if (cached_has_bits & 0x00000400u) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(5, this->sequence(), output);
  }

  // optional .hw.trezor.messages.bitcoin.InputScriptType script_type = 6 [default = SPENDADDRESS];
  if (cached_has_bits & 0x00000020u) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      6, this->script_type(), output);
  }

  // optional .hw.trezor.messages.bitcoin.MultisigRedeemScriptType multisig = 7;
  if (cached_has_bits & 0x00000008u) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      7, HasBitSetters::multisig(this), output);
  }

  // optional uint64 amount = 8;
  if (cached_has_bits & 0x00000040u) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(8, this->amount(), output);
  }

  // optional uint32 decred_tree = 9;
  if (cached_has_bits & 0x00000080u) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(9, this->decred_tree(), output);
  }

  // optional uint32 decred_script_version = 10;
  if (cached_has_bits & 0x00000100u) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(10, this->decred_script_version(), output);
  }

  // optional bytes prev_block_hash_bip115 = 11;
  if (cached_has_bits & 0x00000004u) {
    ::google::protobuf::internal::WireFormatLite::WriteBytesMaybeAliased(
      11, this->prev_block_hash_bip115(), output);
  }

  // optional uint32 prev_block_height_bip115 = 12;
  if (cached_has_bits & 0x00000200u) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(12, this->prev_block_height_bip115(), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        _internal_metadata_.unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:hw.trezor.messages.bitcoin.TxAck.TransactionType.TxInputType)
}

::google::protobuf::uint8* TxAck_TransactionType_TxInputType::InternalSerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:hw.trezor.messages.bitcoin.TxAck.TransactionType.TxInputType)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated uint32 address_n = 1;
  target = ::google::protobuf::internal::WireFormatLite::
    WriteUInt32ToArray(1, this->address_n_, target);

  cached_has_bits = _has_bits_[0];
  // required bytes prev_hash = 2;
  if (cached_has_bits & 0x00000001u) {
    target =
      ::google::protobuf::internal::WireFormatLite::WriteBytesToArray(
        2, this->prev_hash(), target);
  }

  // required uint32 prev_index = 3;
  if (cached_has_bits & 0x00000010u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(3, this->prev_index(), target);
  }

  // optional bytes script_sig = 4;
  if (cached_has_bits & 0x00000002u) {
    target =
      ::google::protobuf::internal::WireFormatLite::WriteBytesToArray(
        4, this->script_sig(), target);
  }

  // optional uint32 sequence = 5 [default = 4294967295];
  if (cached_has_bits & 0x00000400u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(5, this->sequence(), target);
  }

  // optional .hw.trezor.messages.bitcoin.InputScriptType script_type = 6 [default = SPENDADDRESS];
  if (cached_has_bits & 0x00000020u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      6, this->script_type(), target);
  }

  // optional .hw.trezor.messages.bitcoin.MultisigRedeemScriptType multisig = 7;
  if (cached_has_bits & 0x00000008u) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageToArray(
        7, HasBitSetters::multisig(this), target);
  }

  // optional uint64 amount = 8;
  if (cached_has_bits & 0x00000040u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt64ToArray(8, this->amount(), target);
  }

  // optional uint32 decred_tree = 9;
  if (cached_has_bits & 0x00000080u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(9, this->decred_tree(), target);
  }

  // optional uint32 decred_script_version = 10;
  if (cached_has_bits & 0x00000100u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(10, this->decred_script_version(), target);
  }

  // optional bytes prev_block_hash_bip115 = 11;
  if (cached_has_bits & 0x00000004u) {
    target =
      ::google::protobuf::internal::WireFormatLite::WriteBytesToArray(
        11, this->prev_block_hash_bip115(), target);
  }

  // optional uint32 prev_block_height_bip115 = 12;
  if (cached_has_bits & 0x00000200u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(12, this->prev_block_height_bip115(), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:hw.trezor.messages.bitcoin.TxAck.TransactionType.TxInputType)
  return target;
}

size_t TxAck_TransactionType_TxInputType::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:hw.trezor.messages.bitcoin.TxAck.TransactionType.TxInputType)
  size_t total_size = 0;

  if (has_prev_hash()) {
    // required bytes prev_hash = 2;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::BytesSize(
        this->prev_hash());
  }

  if (has_prev_index()) {
    // required uint32 prev_index = 3;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::UInt32Size(
        this->prev_index());
  }

  return total_size;
}
size_t TxAck_TransactionType_TxInputType::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:hw.trezor.messages.bitcoin.TxAck.TransactionType.TxInputType)
  size_t total_size = 0;

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        _internal_metadata_.unknown_fields());
  }
  if (((_has_bits_[0] & 0x00000011) ^ 0x00000011) == 0) {  // All required fields are present.
    // required bytes prev_hash = 2;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::BytesSize(
        this->prev_hash());

    // required uint32 prev_index = 3;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::UInt32Size(
        this->prev_index());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated uint32 address_n = 1;
  {
    size_t data_size = ::google::protobuf::internal::WireFormatLite::
      UInt32Size(this->address_n_);
    total_size += 1 *
                  ::google::protobuf::internal::FromIntSize(this->address_n_size());
    total_size += data_size;
  }

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000000eu) {
    // optional bytes script_sig = 4;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->script_sig());
    }

    // optional bytes prev_block_hash_bip115 = 11;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->prev_block_hash_bip115());
    }

    // optional .hw.trezor.messages.bitcoin.MultisigRedeemScriptType multisig = 7;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSize(
          *multisig_);
    }

  }
  if (cached_has_bits & 0x000000e0u) {
    // optional .hw.trezor.messages.bitcoin.InputScriptType script_type = 6 [default = SPENDADDRESS];
    if (cached_has_bits & 0x00000020u) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->script_type());
    }

    // optional uint64 amount = 8;
    if (cached_has_bits & 0x00000040u) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->amount());
    }

    // optional uint32 decred_tree = 9;
    if (cached_has_bits & 0x00000080u) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->decred_tree());
    }

  }
  if (cached_has_bits & 0x00000700u) {
    // optional uint32 decred_script_version = 10;
    if (cached_has_bits & 0x00000100u) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->decred_script_version());
    }

    // optional uint32 prev_block_height_bip115 = 12;
    if (cached_has_bits & 0x00000200u) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->prev_block_height_bip115());
    }

    // optional uint32 sequence = 5 [default = 4294967295];
    if (cached_has_bits & 0x00000400u) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->sequence());
    }

  }
  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void TxAck_TransactionType_TxInputType::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:hw.trezor.messages.bitcoin.TxAck.TransactionType.TxInputType)
  GOOGLE_DCHECK_NE(&from, this);
  const TxAck_TransactionType_TxInputType* source =
      ::google::protobuf::DynamicCastToGenerated<TxAck_TransactionType_TxInputType>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:hw.trezor.messages.bitcoin.TxAck.TransactionType.TxInputType)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:hw.trezor.messages.bitcoin.TxAck.TransactionType.TxInputType)
    MergeFrom(*source);
  }
}

void TxAck_TransactionType_TxInputType::MergeFrom(const TxAck_TransactionType_TxInputType& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:hw.trezor.messages.bitcoin.TxAck.TransactionType.TxInputType)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  address_n_.MergeFrom(from.address_n_);
  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      _has_bits_[0] |= 0x00000001u;
      prev_hash_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.prev_hash_);
    }
    if (cached_has_bits & 0x00000002u) {
      _has_bits_[0] |= 0x00000002u;
      script_sig_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.script_sig_);
    }
    if (cached_has_bits & 0x00000004u) {
      _has_bits_[0] |= 0x00000004u;
      prev_block_hash_bip115_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.prev_block_hash_bip115_);
    }
    if (cached_has_bits & 0x00000008u) {
      mutable_multisig()->::hw::trezor::messages::bitcoin::MultisigRedeemScriptType::MergeFrom(from.multisig());
    }
    if (cached_has_bits & 0x00000010u) {
      prev_index_ = from.prev_index_;
    }
    if (cached_has_bits & 0x00000020u) {
      script_type_ = from.script_type_;
    }
    if (cached_has_bits & 0x00000040u) {
      amount_ = from.amount_;
    }
    if (cached_has_bits & 0x00000080u) {
      decred_tree_ = from.decred_tree_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  if (cached_has_bits & 0x00000700u) {
    if (cached_has_bits & 0x00000100u) {
      decred_script_version_ = from.decred_script_version_;
    }
    if (cached_has_bits & 0x00000200u) {
      prev_block_height_bip115_ = from.prev_block_height_bip115_;
    }
    if (cached_has_bits & 0x00000400u) {
      sequence_ = from.sequence_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void TxAck_TransactionType_TxInputType::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:hw.trezor.messages.bitcoin.TxAck.TransactionType.TxInputType)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void TxAck_TransactionType_TxInputType::CopyFrom(const TxAck_TransactionType_TxInputType& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:hw.trezor.messages.bitcoin.TxAck.TransactionType.TxInputType)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TxAck_TransactionType_TxInputType::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000011) != 0x00000011) return false;
  if (has_multisig()) {
    if (!this->multisig_->IsInitialized()) return false;
  }
  return true;
}

void TxAck_TransactionType_TxInputType::Swap(TxAck_TransactionType_TxInputType* other) {
  if (other == this) return;
  InternalSwap(other);
}
void TxAck_TransactionType_TxInputType::InternalSwap(TxAck_TransactionType_TxInputType* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  address_n_.InternalSwap(&other->address_n_);
  prev_hash_.Swap(&other->prev_hash_, &::google::protobuf::internal::GetEmptyStringAlreadyInited(),
    GetArenaNoVirtual());
  script_sig_.Swap(&other->script_sig_, &::google::protobuf::internal::GetEmptyStringAlreadyInited(),
    GetArenaNoVirtual());
  prev_block_hash_bip115_.Swap(&other->prev_block_hash_bip115_, &::google::protobuf::internal::GetEmptyStringAlreadyInited(),
    GetArenaNoVirtual());
  swap(multisig_, other->multisig_);
  swap(prev_index_, other->prev_index_);
  swap(script_type_, other->script_type_);
  swap(amount_, other->amount_);
  swap(decred_tree_, other->decred_tree_);
  swap(decred_script_version_, other->decred_script_version_);
  swap(prev_block_height_bip115_, other->prev_block_height_bip115_);
  swap(sequence_, other->sequence_);
}

::google::protobuf::Metadata TxAck_TransactionType_TxInputType::GetMetadata() const {
  ::google::protobuf::internal::AssignDescriptors(&::assign_descriptors_table_messages_2dbitcoin_2eproto);
  return ::file_level_metadata_messages_2dbitcoin_2eproto[kIndexInFileMessages];
}


// ===================================================================

void TxAck_TransactionType_TxOutputBinType::InitAsDefaultInstance() {
}
class TxAck_TransactionType_TxOutputBinType::HasBitSetters {
 public:
  static void set_has_amount(TxAck_TransactionType_TxOutputBinType* msg) {
    msg->_has_bits_[0] |= 0x00000002u;
  }
  static void set_has_script_pubkey(TxAck_TransactionType_TxOutputBinType* msg) {
    msg->_has_bits_[0] |= 0x00000001u;
  }
  static void set_has_decred_script_version(TxAck_TransactionType_TxOutputBinType* msg) {
    msg->_has_bits_[0] |= 0x00000004u;
  }
};

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int TxAck_TransactionType_TxOutputBinType::kAmountFieldNumber;
const int TxAck_TransactionType_TxOutputBinType::kScriptPubkeyFieldNumber;
const int TxAck_TransactionType_TxOutputBinType::kDecredScriptVersionFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

TxAck_TransactionType_TxOutputBinType::TxAck_TransactionType_TxOutputBinType()
  : ::google::protobuf::Message(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:hw.trezor.messages.bitcoin.TxAck.TransactionType.TxOutputBinType)
}
TxAck_TransactionType_TxOutputBinType::TxAck_TransactionType_TxOutputBinType(const TxAck_TransactionType_TxOutputBinType& from)
  : ::google::protobuf::Message(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  script_pubkey_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (from.has_script_pubkey()) {
    script_pubkey_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.script_pubkey_);
  }
  ::memcpy(&amount_, &from.amount_,
    static_cast<size_t>(reinterpret_cast<char*>(&decred_script_version_) -
    reinterpret_cast<char*>(&amount_)) + sizeof(decred_script_version_));
  // @@protoc_insertion_point(copy_constructor:hw.trezor.messages.bitcoin.TxAck.TransactionType.TxOutputBinType)
}

void TxAck_TransactionType_TxOutputBinType::SharedCtor() {
  ::google::protobuf::internal::InitSCC(
      &scc_info_TxAck_TransactionType_TxOutputBinType_messages_2dbitcoin_2eproto.base);
  script_pubkey_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  ::memset(&amount_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&decred_script_version_) -
      reinterpret_cast<char*>(&amount_)) + sizeof(decred_script_version_));
}

TxAck_TransactionType_TxOutputBinType::~TxAck_TransactionType_TxOutputBinType() {
  // @@protoc_insertion_point(destructor:hw.trezor.messages.bitcoin.TxAck.TransactionType.TxOutputBinType)
  SharedDtor();
}

void TxAck_TransactionType_TxOutputBinType::SharedDtor() {
  script_pubkey_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}

void TxAck_TransactionType_TxOutputBinType::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const TxAck_TransactionType_TxOutputBinType& TxAck_TransactionType_TxOutputBinType::default_instance() {
  ::google::protobuf::internal::InitSCC(&::scc_info_TxAck_TransactionType_TxOutputBinType_messages_2dbitcoin_2eproto.base);
  return *internal_default_instance();
}


void TxAck_TransactionType_TxOutputBinType::Clear() {
// @@protoc_insertion_point(message_clear_start:hw.trezor.messages.bitcoin.TxAck.TransactionType.TxOutputBinType)
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    script_pubkey_.ClearNonDefaultToEmptyNoArena();
  }
  if (cached_has_bits & 0x00000006u) {
    ::memset(&amount_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&decred_script_version_) -
        reinterpret_cast<char*>(&amount_)) + sizeof(decred_script_version_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* TxAck_TransactionType_TxOutputBinType::_InternalParse(const char* begin, const char* end, void* object,
                  ::google::protobuf::internal::ParseContext* ctx) {
  auto msg = static_cast<TxAck_TransactionType_TxOutputBinType*>(object);
  ::google::protobuf::int32 size; (void)size;
  int depth; (void)depth;
  ::google::protobuf::uint32 tag;
  ::google::protobuf::internal::ParseFunc parser_till_end; (void)parser_till_end;
  auto ptr = begin;
  while (ptr < end) {
    ptr = ::google::protobuf::io::Parse32(ptr, &tag);
    GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
    switch (tag >> 3) {
      // required uint64 amount = 1;
      case 1: {
        if (static_cast<::google::protobuf::uint8>(tag) != 8) goto handle_unusual;
        msg->set_amount(::google::protobuf::internal::ReadVarint(&ptr));
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        break;
      }
      // required bytes script_pubkey = 2;
      case 2: {
        if (static_cast<::google::protobuf::uint8>(tag) != 18) goto handle_unusual;
        ptr = ::google::protobuf::io::ReadSize(ptr, &size);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        object = msg->mutable_script_pubkey();
        if (size > end - ptr + ::google::protobuf::internal::ParseContext::kSlopBytes) {
          parser_till_end = ::google::protobuf::internal::GreedyStringParser;
          goto string_till_end;
        }
        GOOGLE_PROTOBUF_PARSER_ASSERT(::google::protobuf::internal::StringCheck(ptr, size, ctx));
        ::google::protobuf::internal::InlineGreedyStringParser(object, ptr, size, ctx);
        ptr += size;
        break;
      }
      // optional uint32 decred_script_version = 3;
      case 3: {
        if (static_cast<::google::protobuf::uint8>(tag) != 24) goto handle_unusual;
        msg->set_decred_script_version(::google::protobuf::internal::ReadVarint(&ptr));
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        break;
      }
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->EndGroup(tag);
          return ptr;
        }
        auto res = UnknownFieldParse(tag, {_InternalParse, msg},
          ptr, end, msg->_internal_metadata_.mutable_unknown_fields(), ctx);
        ptr = res.first;
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr != nullptr);
        if (res.second) return ptr;
      }
    }  // switch
  }  // while
  return ptr;
string_till_end:
  static_cast<::std::string*>(object)->clear();
  static_cast<::std::string*>(object)->reserve(size);
  goto len_delim_till_end;
len_delim_till_end:
  return ctx->StoreAndTailCall(ptr, end, {_InternalParse, msg},
                               {parser_till_end, object}, size);
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool TxAck_TransactionType_TxOutputBinType::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:hw.trezor.messages.bitcoin.TxAck.TransactionType.TxOutputBinType)
  for (;;) {
    ::std::pair<::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint64 amount = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (8 & 0xFF)) {
          HasBitSetters::set_has_amount(this);
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &amount_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // required bytes script_pubkey = 2;
      case 2: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (18 & 0xFF)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_script_pubkey()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional uint32 decred_script_version = 3;
      case 3: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (24 & 0xFF)) {
          HasBitSetters::set_has_decred_script_version(this);
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &decred_script_version_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, _internal_metadata_.mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:hw.trezor.messages.bitcoin.TxAck.TransactionType.TxOutputBinType)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:hw.trezor.messages.bitcoin.TxAck.TransactionType.TxOutputBinType)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void TxAck_TransactionType_TxOutputBinType::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:hw.trezor.messages.bitcoin.TxAck.TransactionType.TxOutputBinType)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required uint64 amount = 1;
  if (cached_has_bits & 0x00000002u) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(1, this->amount(), output);
  }

  // required bytes script_pubkey = 2;
  if (cached_has_bits & 0x00000001u) {
    ::google::protobuf::internal::WireFormatLite::WriteBytesMaybeAliased(
      2, this->script_pubkey(), output);
  }

  // optional uint32 decred_script_version = 3;
  if (cached_has_bits & 0x00000004u) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(3, this->decred_script_version(), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        _internal_metadata_.unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:hw.trezor.messages.bitcoin.TxAck.TransactionType.TxOutputBinType)
}

::google::protobuf::uint8* TxAck_TransactionType_TxOutputBinType::InternalSerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:hw.trezor.messages.bitcoin.TxAck.TransactionType.TxOutputBinType)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required uint64 amount = 1;
  if (cached_has_bits & 0x00000002u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt64ToArray(1, this->amount(), target);
  }

  // required bytes script_pubkey = 2;
  if (cached_has_bits & 0x00000001u) {
    target =
      ::google::protobuf::internal::WireFormatLite::WriteBytesToArray(
        2, this->script_pubkey(), target);
  }

  // optional uint32 decred_script_version = 3;
  if (cached_has_bits & 0x00000004u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(3, this->decred_script_version(), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:hw.trezor.messages.bitcoin.TxAck.TransactionType.TxOutputBinType)
  return target;
}

size_t TxAck_TransactionType_TxOutputBinType::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:hw.trezor.messages.bitcoin.TxAck.TransactionType.TxOutputBinType)
  size_t total_size = 0;

  if (has_script_pubkey()) {
    // required bytes script_pubkey = 2;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::BytesSize(
        this->script_pubkey());
  }

  if (has_amount()) {
    // required uint64 amount = 1;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::UInt64Size(
        this->amount());
  }

  return total_size;
}
size_t TxAck_TransactionType_TxOutputBinType::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:hw.trezor.messages.bitcoin.TxAck.TransactionType.TxOutputBinType)
  size_t total_size = 0;

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        _internal_metadata_.unknown_fields());
  }
  if (((_has_bits_[0] & 0x00000003) ^ 0x00000003) == 0) {  // All required fields are present.
    // required bytes script_pubkey = 2;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::BytesSize(
        this->script_pubkey());

    // required uint64 amount = 1;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::UInt64Size(
        this->amount());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional uint32 decred_script_version = 3;
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000004u) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::UInt32Size(
        this->decred_script_version());
  }

  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void TxAck_TransactionType_TxOutputBinType::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:hw.trezor.messages.bitcoin.TxAck.TransactionType.TxOutputBinType)
  GOOGLE_DCHECK_NE(&from, this);
  const TxAck_TransactionType_TxOutputBinType* source =
      ::google::protobuf::DynamicCastToGenerated<TxAck_TransactionType_TxOutputBinType>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:hw.trezor.messages.bitcoin.TxAck.TransactionType.TxOutputBinType)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:hw.trezor.messages.bitcoin.TxAck.TransactionType.TxOutputBinType)
    MergeFrom(*source);
  }
}

void TxAck_TransactionType_TxOutputBinType::MergeFrom(const TxAck_TransactionType_TxOutputBinType& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:hw.trezor.messages.bitcoin.TxAck.TransactionType.TxOutputBinType)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _has_bits_[0] |= 0x00000001u;
      script_pubkey_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.script_pubkey_);
    }
    if (cached_has_bits & 0x00000002u) {
      amount_ = from.amount_;
    }
    if (cached_has_bits & 0x00000004u) {
      decred_script_version_ = from.decred_script_version_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void TxAck_TransactionType_TxOutputBinType::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:hw.trezor.messages.bitcoin.TxAck.TransactionType.TxOutputBinType)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void TxAck_TransactionType_TxOutputBinType::CopyFrom(const TxAck_TransactionType_TxOutputBinType& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:hw.trezor.messages.bitcoin.TxAck.TransactionType.TxOutputBinType)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TxAck_TransactionType_TxOutputBinType::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000003) != 0x00000003) return false;
  return true;
}

void TxAck_TransactionType_TxOutputBinType::Swap(TxAck_TransactionType_TxOutputBinType* other) {
  if (other == this) return;
  InternalSwap(other);
}
void TxAck_TransactionType_TxOutputBinType::InternalSwap(TxAck_TransactionType_TxOutputBinType* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  script_pubkey_.Swap(&other->script_pubkey_, &::google::protobuf::internal::GetEmptyStringAlreadyInited(),
    GetArenaNoVirtual());
  swap(amount_, other->amount_);
  swap(decred_script_version_, other->decred_script_version_);
}

::google::protobuf::Metadata TxAck_TransactionType_TxOutputBinType::GetMetadata() const {
  ::google::protobuf::internal::AssignDescriptors(&::assign_descriptors_table_messages_2dbitcoin_2eproto);
  return ::file_level_metadata_messages_2dbitcoin_2eproto[kIndexInFileMessages];
}


// ===================================================================

void TxAck_TransactionType_TxOutputType::InitAsDefaultInstance() {
  ::hw::trezor::messages::bitcoin::_TxAck_TransactionType_TxOutputType_default_instance_._instance.get_mutable()->multisig_ = const_cast< ::hw::trezor::messages::bitcoin::MultisigRedeemScriptType*>(
      ::hw::trezor::messages::bitcoin::MultisigRedeemScriptType::internal_default_instance());
}
class TxAck_TransactionType_TxOutputType::HasBitSetters {
 public:
  static void set_has_address(TxAck_TransactionType_TxOutputType* msg) {
    msg->_has_bits_[0] |= 0x00000001u;
  }
  static void set_has_amount(TxAck_TransactionType_TxOutputType* msg) {
    msg->_has_bits_[0] |= 0x00000010u;
  }
  static void set_has_script_type(TxAck_TransactionType_TxOutputType* msg) {
    msg->_has_bits_[0] |= 0x00000020u;
  }
  static const ::hw::trezor::messages::bitcoin::MultisigRedeemScriptType& multisig(const TxAck_TransactionType_TxOutputType* msg);
  static void set_has_multisig(TxAck_TransactionType_TxOutputType* msg) {
    msg->_has_bits_[0] |= 0x00000008u;
  }
  static void set_has_op_return_data(TxAck_TransactionType_TxOutputType* msg) {
    msg->_has_bits_[0] |= 0x00000002u;
  }
  static void set_has_decred_script_version(TxAck_TransactionType_TxOutputType* msg) {
    msg->_has_bits_[0] |= 0x00000040u;
  }
  static void set_has_block_hash_bip115(TxAck_TransactionType_TxOutputType* msg) {
    msg->_has_bits_[0] |= 0x00000004u;
  }
  static void set_has_block_height_bip115(TxAck_TransactionType_TxOutputType* msg) {
    msg->_has_bits_[0] |= 0x00000080u;
  }
};

const ::hw::trezor::messages::bitcoin::MultisigRedeemScriptType&
TxAck_TransactionType_TxOutputType::HasBitSetters::multisig(const TxAck_TransactionType_TxOutputType* msg) {
  return *msg->multisig_;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int TxAck_TransactionType_TxOutputType::kAddressFieldNumber;
const int TxAck_TransactionType_TxOutputType::kAddressNFieldNumber;
const int TxAck_TransactionType_TxOutputType::kAmountFieldNumber;
const int TxAck_TransactionType_TxOutputType::kScriptTypeFieldNumber;
const int TxAck_TransactionType_TxOutputType::kMultisigFieldNumber;
const int TxAck_TransactionType_TxOutputType::kOpReturnDataFieldNumber;
const int TxAck_TransactionType_TxOutputType::kDecredScriptVersionFieldNumber;
const int TxAck_TransactionType_TxOutputType::kBlockHashBip115FieldNumber;
const int TxAck_TransactionType_TxOutputType::kBlockHeightBip115FieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

TxAck_TransactionType_TxOutputType::TxAck_TransactionType_TxOutputType()
  : ::google::protobuf::Message(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:hw.trezor.messages.bitcoin.TxAck.TransactionType.TxOutputType)
}
TxAck_TransactionType_TxOutputType::TxAck_TransactionType_TxOutputType(const TxAck_TransactionType_TxOutputType& from)
  : ::google::protobuf::Message(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_),
      address_n_(from.address_n_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  address_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (from.has_address()) {
    address_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.address_);
  }
  op_return_data_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (from.has_op_return_data()) {
    op_return_data_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.op_return_data_);
  }
  block_hash_bip115_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (from.has_block_hash_bip115()) {
    block_hash_bip115_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.block_hash_bip115_);
  }
  if (from.has_multisig()) {
    multisig_ = new ::hw::trezor::messages::bitcoin::MultisigRedeemScriptType(*from.multisig_);
  } else {
    multisig_ = nullptr;
  }
  ::memcpy(&amount_, &from.amount_,
    static_cast<size_t>(reinterpret_cast<char*>(&block_height_bip115_) -
    reinterpret_cast<char*>(&amount_)) + sizeof(block_height_bip115_));
  // @@protoc_insertion_point(copy_constructor:hw.trezor.messages.bitcoin.TxAck.TransactionType.TxOutputType)
}

void TxAck_TransactionType_TxOutputType::SharedCtor() {
  ::google::protobuf::internal::InitSCC(
      &scc_info_TxAck_TransactionType_TxOutputType_messages_2dbitcoin_2eproto.base);
  address_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  op_return_data_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  block_hash_bip115_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  ::memset(&multisig_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&block_height_bip115_) -
      reinterpret_cast<char*>(&multisig_)) + sizeof(block_height_bip115_));
}

TxAck_TransactionType_TxOutputType::~TxAck_TransactionType_TxOutputType() {
  // @@protoc_insertion_point(destructor:hw.trezor.messages.bitcoin.TxAck.TransactionType.TxOutputType)
  SharedDtor();
}

void TxAck_TransactionType_TxOutputType::SharedDtor() {
  address_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  op_return_data_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  block_hash_bip115_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (this != internal_default_instance()) delete multisig_;
}

void TxAck_TransactionType_TxOutputType::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const TxAck_TransactionType_TxOutputType& TxAck_TransactionType_TxOutputType::default_instance() {
  ::google::protobuf::internal::InitSCC(&::scc_info_TxAck_TransactionType_TxOutputType_messages_2dbitcoin_2eproto.base);
  return *internal_default_instance();
}


void TxAck_TransactionType_TxOutputType::Clear() {
// @@protoc_insertion_point(message_clear_start:hw.trezor.messages.bitcoin.TxAck.TransactionType.TxOutputType)
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  address_n_.Clear();
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      address_.ClearNonDefaultToEmptyNoArena();
    }
    if (cached_has_bits & 0x00000002u) {
      op_return_data_.ClearNonDefaultToEmptyNoArena();
    }
    if (cached_has_bits & 0x00000004u) {
      block_hash_bip115_.ClearNonDefaultToEmptyNoArena();
    }
    if (cached_has_bits & 0x00000008u) {
      GOOGLE_DCHECK(multisig_ != nullptr);
      multisig_->Clear();
    }
  }
  if (cached_has_bits & 0x000000f0u) {
    ::memset(&amount_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&block_height_bip115_) -
        reinterpret_cast<char*>(&amount_)) + sizeof(block_height_bip115_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* TxAck_TransactionType_TxOutputType::_InternalParse(const char* begin, const char* end, void* object,
                  ::google::protobuf::internal::ParseContext* ctx) {
  auto msg = static_cast<TxAck_TransactionType_TxOutputType*>(object);
  ::google::protobuf::int32 size; (void)size;
  int depth; (void)depth;
  ::google::protobuf::uint32 tag;
  ::google::protobuf::internal::ParseFunc parser_till_end; (void)parser_till_end;
  auto ptr = begin;
  while (ptr < end) {
    ptr = ::google::protobuf::io::Parse32(ptr, &tag);
    GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
    switch (tag >> 3) {
      // optional string address = 1;
      case 1: {
        if (static_cast<::google::protobuf::uint8>(tag) != 10) goto handle_unusual;
        ptr = ::google::protobuf::io::ReadSize(ptr, &size);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        ctx->extra_parse_data().SetFieldName("hw.trezor.messages.bitcoin.TxAck.TransactionType.TxOutputType.address");
        object = msg->mutable_address();
        if (size > end - ptr + ::google::protobuf::internal::ParseContext::kSlopBytes) {
          parser_till_end = ::google::protobuf::internal::GreedyStringParserUTF8Verify;
          goto string_till_end;
        }
        GOOGLE_PROTOBUF_PARSER_ASSERT(::google::protobuf::internal::StringCheckUTF8Verify(ptr, size, ctx));
        ::google::protobuf::internal::InlineGreedyStringParser(object, ptr, size, ctx);
        ptr += size;
        break;
      }
      // repeated uint32 address_n = 2;
      case 2: {
        if (static_cast<::google::protobuf::uint8>(tag) == 16) {
          do {
            msg->add_address_n(::google::protobuf::internal::ReadVarint(&ptr));
            GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
            if (ptr >= end) break;
          } while ((::google::protobuf::io::UnalignedLoad<::google::protobuf::uint64>(ptr) & 255) == 16 && (ptr += 1));
          break;
        } else if (static_cast<::google::protobuf::uint8>(tag) != 18) goto handle_unusual;
        ptr = ::google::protobuf::io::ReadSize(ptr, &size);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        parser_till_end = ::google::protobuf::internal::PackedUInt32Parser;
        object = msg->mutable_address_n();
        if (size > end - ptr) goto len_delim_till_end;
        auto newend = ptr + size;
        if (size) ptr = parser_till_end(ptr, newend, object, ctx);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr == newend);
        break;
      }
      // required uint64 amount = 3;
      case 3: {
        if (static_cast<::google::protobuf::uint8>(tag) != 24) goto handle_unusual;
        msg->set_amount(::google::protobuf::internal::ReadVarint(&ptr));
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        break;
      }
      // required .hw.trezor.messages.bitcoin.TxAck.TransactionType.TxOutputType.OutputScriptType script_type = 4;
      case 4: {
        if (static_cast<::google::protobuf::uint8>(tag) != 32) goto handle_unusual;
        ::google::protobuf::uint64 val = ::google::protobuf::internal::ReadVarint(&ptr);
        if (!::hw::trezor::messages::bitcoin::TxAck_TransactionType_TxOutputType_OutputScriptType_IsValid(val)) {
          ::google::protobuf::internal::WriteVarint(4, val, msg->mutable_unknown_fields());
          break;
        }
        msg->set_script_type(static_cast<::hw::trezor::messages::bitcoin::TxAck_TransactionType_TxOutputType_OutputScriptType>(val));
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        break;
      }
      // optional .hw.trezor.messages.bitcoin.MultisigRedeemScriptType multisig = 5;
      case 5: {
        if (static_cast<::google::protobuf::uint8>(tag) != 42) goto handle_unusual;
        ptr = ::google::protobuf::io::ReadSize(ptr, &size);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        parser_till_end = ::hw::trezor::messages::bitcoin::MultisigRedeemScriptType::_InternalParse;
        object = msg->mutable_multisig();
        if (size > end - ptr) goto len_delim_till_end;
        ptr += size;
        GOOGLE_PROTOBUF_PARSER_ASSERT(ctx->ParseExactRange(
            {parser_till_end, object}, ptr - size, ptr));
        break;
      }
      // optional bytes op_return_data = 6;
      case 6: {
        if (static_cast<::google::protobuf::uint8>(tag) != 50) goto handle_unusual;
        ptr = ::google::protobuf::io::ReadSize(ptr, &size);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        object = msg->mutable_op_return_data();
        if (size > end - ptr + ::google::protobuf::internal::ParseContext::kSlopBytes) {
          parser_till_end = ::google::protobuf::internal::GreedyStringParser;
          goto string_till_end;
        }
        GOOGLE_PROTOBUF_PARSER_ASSERT(::google::protobuf::internal::StringCheck(ptr, size, ctx));
        ::google::protobuf::internal::InlineGreedyStringParser(object, ptr, size, ctx);
        ptr += size;
        break;
      }
      // optional uint32 decred_script_version = 7;
      case 7: {
        if (static_cast<::google::protobuf::uint8>(tag) != 56) goto handle_unusual;
        msg->set_decred_script_version(::google::protobuf::internal::ReadVarint(&ptr));
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        break;
      }
      // optional bytes block_hash_bip115 = 8;
      case 8: {
        if (static_cast<::google::protobuf::uint8>(tag) != 66) goto handle_unusual;
        ptr = ::google::protobuf::io::ReadSize(ptr, &size);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        object = msg->mutable_block_hash_bip115();
        if (size > end - ptr + ::google::protobuf::internal::ParseContext::kSlopBytes) {
          parser_till_end = ::google::protobuf::internal::GreedyStringParser;
          goto string_till_end;
        }
        GOOGLE_PROTOBUF_PARSER_ASSERT(::google::protobuf::internal::StringCheck(ptr, size, ctx));
        ::google::protobuf::internal::InlineGreedyStringParser(object, ptr, size, ctx);
        ptr += size;
        break;
      }
      // optional uint32 block_height_bip115 = 9;
      case 9: {
        if (static_cast<::google::protobuf::uint8>(tag) != 72) goto handle_unusual;
        msg->set_block_height_bip115(::google::protobuf::internal::ReadVarint(&ptr));
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        break;
      }
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->EndGroup(tag);
          return ptr;
        }
        auto res = UnknownFieldParse(tag, {_InternalParse, msg},
          ptr, end, msg->_internal_metadata_.mutable_unknown_fields(), ctx);
        ptr = res.first;
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr != nullptr);
        if (res.second) return ptr;
      }
    }  // switch
  }  // while
  return ptr;
string_till_end:
  static_cast<::std::string*>(object)->clear();
  static_cast<::std::string*>(object)->reserve(size);
  goto len_delim_till_end;
len_delim_till_end:
  return ctx->StoreAndTailCall(ptr, end, {_InternalParse, msg},
                               {parser_till_end, object}, size);
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool TxAck_TransactionType_TxOutputType::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:hw.trezor.messages.bitcoin.TxAck.TransactionType.TxOutputType)
  for (;;) {
    ::std::pair<::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional string address = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (10 & 0xFF)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_address()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->address().data(), static_cast<int>(this->address().length()),
            ::google::protobuf::internal::WireFormat::PARSE,
            "hw.trezor.messages.bitcoin.TxAck.TransactionType.TxOutputType.address");
        } else {
          goto handle_unusual;
        }
        break;
      }

      // repeated uint32 address_n = 2;
      case 2: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (16 & 0xFF)) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadRepeatedPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 1, 16u, input, this->mutable_address_n())));
        } else if (static_cast< ::google::protobuf::uint8>(tag) == (18 & 0xFF)) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPackedPrimitiveNoInline<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, this->mutable_address_n())));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // required uint64 amount = 3;
      case 3: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (24 & 0xFF)) {
          HasBitSetters::set_has_amount(this);
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &amount_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // required .hw.trezor.messages.bitcoin.TxAck.TransactionType.TxOutputType.OutputScriptType script_type = 4;
      case 4: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (32 & 0xFF)) {
          int value = 0;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::hw::trezor::messages::bitcoin::TxAck_TransactionType_TxOutputType_OutputScriptType_IsValid(value)) {
            set_script_type(static_cast< ::hw::trezor::messages::bitcoin::TxAck_TransactionType_TxOutputType_OutputScriptType >(value));
          } else {
            mutable_unknown_fields()->AddVarint(
                4, static_cast<::google::protobuf::uint64>(value));
          }
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional .hw.trezor.messages.bitcoin.MultisigRedeemScriptType multisig = 5;
      case 5: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (42 & 0xFF)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessage(
               input, mutable_multisig()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional bytes op_return_data = 6;
      case 6: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (50 & 0xFF)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_op_return_data()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional uint32 decred_script_version = 7;
      case 7: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (56 & 0xFF)) {
          HasBitSetters::set_has_decred_script_version(this);
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &decred_script_version_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional bytes block_hash_bip115 = 8;
      case 8: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (66 & 0xFF)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_block_hash_bip115()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional uint32 block_height_bip115 = 9;
      case 9: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (72 & 0xFF)) {
          HasBitSetters::set_has_block_height_bip115(this);
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &block_height_bip115_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, _internal_metadata_.mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:hw.trezor.messages.bitcoin.TxAck.TransactionType.TxOutputType)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:hw.trezor.messages.bitcoin.TxAck.TransactionType.TxOutputType)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void TxAck_TransactionType_TxOutputType::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:hw.trezor.messages.bitcoin.TxAck.TransactionType.TxOutputType)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional string address = 1;
  if (cached_has_bits & 0x00000001u) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->address().data(), static_cast<int>(this->address().length()),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "hw.trezor.messages.bitcoin.TxAck.TransactionType.TxOutputType.address");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      1, this->address(), output);
  }

  // repeated uint32 address_n = 2;
  for (int i = 0, n = this->address_n_size(); i < n; i++) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(
      2, this->address_n(i), output);
  }

  // required uint64 amount = 3;
  if (cached_has_bits & 0x00000010u) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(3, this->amount(), output);
  }

  // required .hw.trezor.messages.bitcoin.TxAck.TransactionType.TxOutputType.OutputScriptType script_type = 4;
  if (cached_has_bits & 0x00000020u) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      4, this->script_type(), output);
  }

  // optional .hw.trezor.messages.bitcoin.MultisigRedeemScriptType multisig = 5;
  if (cached_has_bits & 0x00000008u) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      5, HasBitSetters::multisig(this), output);
  }

  // optional bytes op_return_data = 6;
  if (cached_has_bits & 0x00000002u) {
    ::google::protobuf::internal::WireFormatLite::WriteBytesMaybeAliased(
      6, this->op_return_data(), output);
  }

  // optional uint32 decred_script_version = 7;
  if (cached_has_bits & 0x00000040u) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(7, this->decred_script_version(), output);
  }

  // optional bytes block_hash_bip115 = 8;
  if (cached_has_bits & 0x00000004u) {
    ::google::protobuf::internal::WireFormatLite::WriteBytesMaybeAliased(
      8, this->block_hash_bip115(), output);
  }

  // optional uint32 block_height_bip115 = 9;
  if (cached_has_bits & 0x00000080u) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(9, this->block_height_bip115(), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        _internal_metadata_.unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:hw.trezor.messages.bitcoin.TxAck.TransactionType.TxOutputType)
}

::google::protobuf::uint8* TxAck_TransactionType_TxOutputType::InternalSerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:hw.trezor.messages.bitcoin.TxAck.TransactionType.TxOutputType)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional string address = 1;
  if (cached_has_bits & 0x00000001u) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->address().data(), static_cast<int>(this->address().length()),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "hw.trezor.messages.bitcoin.TxAck.TransactionType.TxOutputType.address");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        1, this->address(), target);
  }

  // repeated uint32 address_n = 2;
  target = ::google::protobuf::internal::WireFormatLite::
    WriteUInt32ToArray(2, this->address_n_, target);

  // required uint64 amount = 3;
  if (cached_has_bits & 0x00000010u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt64ToArray(3, this->amount(), target);
  }

  // required .hw.trezor.messages.bitcoin.TxAck.TransactionType.TxOutputType.OutputScriptType script_type = 4;
  if (cached_has_bits & 0x00000020u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      4, this->script_type(), target);
  }

  // optional .hw.trezor.messages.bitcoin.MultisigRedeemScriptType multisig = 5;
  if (cached_has_bits & 0x00000008u) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageToArray(
        5, HasBitSetters::multisig(this), target);
  }

  // optional bytes op_return_data = 6;
  if (cached_has_bits & 0x00000002u) {
    target =
      ::google::protobuf::internal::WireFormatLite::WriteBytesToArray(
        6, this->op_return_data(), target);
  }

  // optional uint32 decred_script_version = 7;
  if (cached_has_bits & 0x00000040u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(7, this->decred_script_version(), target);
  }

  // optional bytes block_hash_bip115 = 8;
  if (cached_has_bits & 0x00000004u) {
    target =
      ::google::protobuf::internal::WireFormatLite::WriteBytesToArray(
        8, this->block_hash_bip115(), target);
  }

  // optional uint32 block_height_bip115 = 9;
  if (cached_has_bits & 0x00000080u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(9, this->block_height_bip115(), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:hw.trezor.messages.bitcoin.TxAck.TransactionType.TxOutputType)
  return target;
}

size_t TxAck_TransactionType_TxOutputType::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:hw.trezor.messages.bitcoin.TxAck.TransactionType.TxOutputType)
  size_t total_size = 0;

  if (has_amount()) {
    // required uint64 amount = 3;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::UInt64Size(
        this->amount());
  }

  if (has_script_type()) {
    // required .hw.trezor.messages.bitcoin.TxAck.TransactionType.TxOutputType.OutputScriptType script_type = 4;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::EnumSize(this->script_type());
  }

  return total_size;
}
size_t TxAck_TransactionType_TxOutputType::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:hw.trezor.messages.bitcoin.TxAck.TransactionType.TxOutputType)
  size_t total_size = 0;

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        _internal_metadata_.unknown_fields());
  }
  if (((_has_bits_[0] & 0x00000030) ^ 0x00000030) == 0) {  // All required fields are present.
    // required uint64 amount = 3;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::UInt64Size(
        this->amount());

    // required .hw.trezor.messages.bitcoin.TxAck.TransactionType.TxOutputType.OutputScriptType script_type = 4;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::EnumSize(this->script_type());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated uint32 address_n = 2;
  {
    size_t data_size = ::google::protobuf::internal::WireFormatLite::
      UInt32Size(this->address_n_);
    total_size += 1 *
                  ::google::protobuf::internal::FromIntSize(this->address_n_size());
    total_size += data_size;
  }

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    // optional string address = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->address());
    }

    // optional bytes op_return_data = 6;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->op_return_data());
    }

    // optional bytes block_hash_bip115 = 8;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->block_hash_bip115());
    }

    // optional .hw.trezor.messages.bitcoin.MultisigRedeemScriptType multisig = 5;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSize(
          *multisig_);
    }

  }
  if (cached_has_bits & 0x000000c0u) {
    // optional uint32 decred_script_version = 7;
    if (cached_has_bits & 0x00000040u) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->decred_script_version());
    }

    // optional uint32 block_height_bip115 = 9;
    if (cached_has_bits & 0x00000080u) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->block_height_bip115());
    }

  }
  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void TxAck_TransactionType_TxOutputType::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:hw.trezor.messages.bitcoin.TxAck.TransactionType.TxOutputType)
  GOOGLE_DCHECK_NE(&from, this);
  const TxAck_TransactionType_TxOutputType* source =
      ::google::protobuf::DynamicCastToGenerated<TxAck_TransactionType_TxOutputType>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:hw.trezor.messages.bitcoin.TxAck.TransactionType.TxOutputType)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:hw.trezor.messages.bitcoin.TxAck.TransactionType.TxOutputType)
    MergeFrom(*source);
  }
}

void TxAck_TransactionType_TxOutputType::MergeFrom(const TxAck_TransactionType_TxOutputType& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:hw.trezor.messages.bitcoin.TxAck.TransactionType.TxOutputType)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  address_n_.MergeFrom(from.address_n_);
  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      _has_bits_[0] |= 0x00000001u;
      address_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.address_);
    }
    if (cached_has_bits & 0x00000002u) {
      _has_bits_[0] |= 0x00000002u;
      op_return_data_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.op_return_data_);
    }
    if (cached_has_bits & 0x00000004u) {
      _has_bits_[0] |= 0x00000004u;
      block_hash_bip115_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.block_hash_bip115_);
    }
    if (cached_has_bits & 0x00000008u) {
      mutable_multisig()->::hw::trezor::messages::bitcoin::MultisigRedeemScriptType::MergeFrom(from.multisig());
    }
    if (cached_has_bits & 0x00000010u) {
      amount_ = from.amount_;
    }
    if (cached_has_bits & 0x00000020u) {
      script_type_ = from.script_type_;
    }
    if (cached_has_bits & 0x00000040u) {
      decred_script_version_ = from.decred_script_version_;
    }
    if (cached_has_bits & 0x00000080u) {
      block_height_bip115_ = from.block_height_bip115_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void TxAck_TransactionType_TxOutputType::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:hw.trezor.messages.bitcoin.TxAck.TransactionType.TxOutputType)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void TxAck_TransactionType_TxOutputType::CopyFrom(const TxAck_TransactionType_TxOutputType& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:hw.trezor.messages.bitcoin.TxAck.TransactionType.TxOutputType)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TxAck_TransactionType_TxOutputType::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000030) != 0x00000030) return false;
  if (has_multisig()) {
    if (!this->multisig_->IsInitialized()) return false;
  }
  return true;
}

void TxAck_TransactionType_TxOutputType::Swap(TxAck_TransactionType_TxOutputType* other) {
  if (other == this) return;
  InternalSwap(other);
}
void TxAck_TransactionType_TxOutputType::InternalSwap(TxAck_TransactionType_TxOutputType* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  address_n_.InternalSwap(&other->address_n_);
  address_.Swap(&other->address_, &::google::protobuf::internal::GetEmptyStringAlreadyInited(),
    GetArenaNoVirtual());
  op_return_data_.Swap(&other->op_return_data_, &::google::protobuf::internal::GetEmptyStringAlreadyInited(),
    GetArenaNoVirtual());
  block_hash_bip115_.Swap(&other->block_hash_bip115_, &::google::protobuf::internal::GetEmptyStringAlreadyInited(),
    GetArenaNoVirtual());
  swap(multisig_, other->multisig_);
  swap(amount_, other->amount_);
  swap(script_type_, other->script_type_);
  swap(decred_script_version_, other->decred_script_version_);
  swap(block_height_bip115_, other->block_height_bip115_);
}

::google::protobuf::Metadata TxAck_TransactionType_TxOutputType::GetMetadata() const {
  ::google::protobuf::internal::AssignDescriptors(&::assign_descriptors_table_messages_2dbitcoin_2eproto);
  return ::file_level_metadata_messages_2dbitcoin_2eproto[kIndexInFileMessages];
}


// ===================================================================

void TxAck_TransactionType::InitAsDefaultInstance() {
}
class TxAck_TransactionType::HasBitSetters {
 public:
  static void set_has_version(TxAck_TransactionType* msg) {
    msg->_has_bits_[0] |= 0x00000002u;
  }
  static void set_has_lock_time(TxAck_TransactionType* msg) {
    msg->_has_bits_[0] |= 0x00000004u;
  }
  static void set_has_inputs_cnt(TxAck_TransactionType* msg) {
    msg->_has_bits_[0] |= 0x00000008u;
  }
  static void set_has_outputs_cnt(TxAck_TransactionType* msg) {
    msg->_has_bits_[0] |= 0x00000010u;
  }
  static void set_has_extra_data(TxAck_TransactionType* msg) {
    msg->_has_bits_[0] |= 0x00000001u;
  }
  static void set_has_extra_data_len(TxAck_TransactionType* msg) {
    msg->_has_bits_[0] |= 0x00000020u;
  }
  static void set_has_expiry(TxAck_TransactionType* msg) {
    msg->_has_bits_[0] |= 0x00000040u;
  }
  static void set_has_overwintered(TxAck_TransactionType* msg) {
    msg->_has_bits_[0] |= 0x00000080u;
  }
  static void set_has_version_group_id(TxAck_TransactionType* msg) {
    msg->_has_bits_[0] |= 0x00000100u;
  }
  static void set_has_timestamp(TxAck_TransactionType* msg) {
    msg->_has_bits_[0] |= 0x00000200u;
  }
};

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int TxAck_TransactionType::kVersionFieldNumber;
const int TxAck_TransactionType::kInputsFieldNumber;
const int TxAck_TransactionType::kBinOutputsFieldNumber;
const int TxAck_TransactionType::kLockTimeFieldNumber;
const int TxAck_TransactionType::kOutputsFieldNumber;
const int TxAck_TransactionType::kInputsCntFieldNumber;
const int TxAck_TransactionType::kOutputsCntFieldNumber;
const int TxAck_TransactionType::kExtraDataFieldNumber;
const int TxAck_TransactionType::kExtraDataLenFieldNumber;
const int TxAck_TransactionType::kExpiryFieldNumber;
const int TxAck_TransactionType::kOverwinteredFieldNumber;
const int TxAck_TransactionType::kVersionGroupIdFieldNumber;
const int TxAck_TransactionType::kTimestampFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

TxAck_TransactionType::TxAck_TransactionType()
  : ::google::protobuf::Message(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:hw.trezor.messages.bitcoin.TxAck.TransactionType)
}
TxAck_TransactionType::TxAck_TransactionType(const TxAck_TransactionType& from)
  : ::google::protobuf::Message(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_),
      inputs_(from.inputs_),
      bin_outputs_(from.bin_outputs_),
      outputs_(from.outputs_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  extra_data_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (from.has_extra_data()) {
    extra_data_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.extra_data_);
  }
  ::memcpy(&version_, &from.version_,
    static_cast<size_t>(reinterpret_cast<char*>(&timestamp_) -
    reinterpret_cast<char*>(&version_)) + sizeof(timestamp_));
  // @@protoc_insertion_point(copy_constructor:hw.trezor.messages.bitcoin.TxAck.TransactionType)
}

void TxAck_TransactionType::SharedCtor() {
  ::google::protobuf::internal::InitSCC(
      &scc_info_TxAck_TransactionType_messages_2dbitcoin_2eproto.base);
  extra_data_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  ::memset(&version_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&timestamp_) -
      reinterpret_cast<char*>(&version_)) + sizeof(timestamp_));
}

TxAck_TransactionType::~TxAck_TransactionType() {
  // @@protoc_insertion_point(destructor:hw.trezor.messages.bitcoin.TxAck.TransactionType)
  SharedDtor();
}

void TxAck_TransactionType::SharedDtor() {
  extra_data_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}

void TxAck_TransactionType::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const TxAck_TransactionType& TxAck_TransactionType::default_instance() {
  ::google::protobuf::internal::InitSCC(&::scc_info_TxAck_TransactionType_messages_2dbitcoin_2eproto.base);
  return *internal_default_instance();
}


void TxAck_TransactionType::Clear() {
// @@protoc_insertion_point(message_clear_start:hw.trezor.messages.bitcoin.TxAck.TransactionType)
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  inputs_.Clear();
  bin_outputs_.Clear();
  outputs_.Clear();
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    extra_data_.ClearNonDefaultToEmptyNoArena();
  }
  if (cached_has_bits & 0x000000feu) {
    ::memset(&version_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&overwintered_) -
        reinterpret_cast<char*>(&version_)) + sizeof(overwintered_));
  }
  if (cached_has_bits & 0x00000300u) {
    ::memset(&version_group_id_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&timestamp_) -
        reinterpret_cast<char*>(&version_group_id_)) + sizeof(timestamp_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* TxAck_TransactionType::_InternalParse(const char* begin, const char* end, void* object,
                  ::google::protobuf::internal::ParseContext* ctx) {
  auto msg = static_cast<TxAck_TransactionType*>(object);
  ::google::protobuf::int32 size; (void)size;
  int depth; (void)depth;
  ::google::protobuf::uint32 tag;
  ::google::protobuf::internal::ParseFunc parser_till_end; (void)parser_till_end;
  auto ptr = begin;
  while (ptr < end) {
    ptr = ::google::protobuf::io::Parse32(ptr, &tag);
    GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
    switch (tag >> 3) {
      // optional uint32 version = 1;
      case 1: {
        if (static_cast<::google::protobuf::uint8>(tag) != 8) goto handle_unusual;
        msg->set_version(::google::protobuf::internal::ReadVarint(&ptr));
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        break;
      }
      // repeated .hw.trezor.messages.bitcoin.TxAck.TransactionType.TxInputType inputs = 2;
      case 2: {
        if (static_cast<::google::protobuf::uint8>(tag) != 18) goto handle_unusual;
        do {
          ptr = ::google::protobuf::io::ReadSize(ptr, &size);
          GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
          parser_till_end = ::hw::trezor::messages::bitcoin::TxAck_TransactionType_TxInputType::_InternalParse;
          object = msg->add_inputs();
          if (size > end - ptr) goto len_delim_till_end;
          ptr += size;
          GOOGLE_PROTOBUF_PARSER_ASSERT(ctx->ParseExactRange(
              {parser_till_end, object}, ptr - size, ptr));
          if (ptr >= end) break;
        } while ((::google::protobuf::io::UnalignedLoad<::google::protobuf::uint64>(ptr) & 255) == 18 && (ptr += 1));
        break;
      }
      // repeated .hw.trezor.messages.bitcoin.TxAck.TransactionType.TxOutputBinType bin_outputs = 3;
      case 3: {
        if (static_cast<::google::protobuf::uint8>(tag) != 26) goto handle_unusual;
        do {
          ptr = ::google::protobuf::io::ReadSize(ptr, &size);
          GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
          parser_till_end = ::hw::trezor::messages::bitcoin::TxAck_TransactionType_TxOutputBinType::_InternalParse;
          object = msg->add_bin_outputs();
          if (size > end - ptr) goto len_delim_till_end;
          ptr += size;
          GOOGLE_PROTOBUF_PARSER_ASSERT(ctx->ParseExactRange(
              {parser_till_end, object}, ptr - size, ptr));
          if (ptr >= end) break;
        } while ((::google::protobuf::io::UnalignedLoad<::google::protobuf::uint64>(ptr) & 255) == 26 && (ptr += 1));
        break;
      }
      // optional uint32 lock_time = 4;
      case 4: {
        if (static_cast<::google::protobuf::uint8>(tag) != 32) goto handle_unusual;
        msg->set_lock_time(::google::protobuf::internal::ReadVarint(&ptr));
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        break;
      }
      // repeated .hw.trezor.messages.bitcoin.TxAck.TransactionType.TxOutputType outputs = 5;
      case 5: {
        if (static_cast<::google::protobuf::uint8>(tag) != 42) goto handle_unusual;
        do {
          ptr = ::google::protobuf::io::ReadSize(ptr, &size);
          GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
          parser_till_end = ::hw::trezor::messages::bitcoin::TxAck_TransactionType_TxOutputType::_InternalParse;
          object = msg->add_outputs();
          if (size > end - ptr) goto len_delim_till_end;
          ptr += size;
          GOOGLE_PROTOBUF_PARSER_ASSERT(ctx->ParseExactRange(
              {parser_till_end, object}, ptr - size, ptr));
          if (ptr >= end) break;
        } while ((::google::protobuf::io::UnalignedLoad<::google::protobuf::uint64>(ptr) & 255) == 42 && (ptr += 1));
        break;
      }
      // optional uint32 inputs_cnt = 6;
      case 6: {
        if (static_cast<::google::protobuf::uint8>(tag) != 48) goto handle_unusual;
        msg->set_inputs_cnt(::google::protobuf::internal::ReadVarint(&ptr));
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        break;
      }
      // optional uint32 outputs_cnt = 7;
      case 7: {
        if (static_cast<::google::protobuf::uint8>(tag) != 56) goto handle_unusual;
        msg->set_outputs_cnt(::google::protobuf::internal::ReadVarint(&ptr));
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        break;
      }
      // optional bytes extra_data = 8;
      case 8: {
        if (static_cast<::google::protobuf::uint8>(tag) != 66) goto handle_unusual;
        ptr = ::google::protobuf::io::ReadSize(ptr, &size);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        object = msg->mutable_extra_data();
        if (size > end - ptr + ::google::protobuf::internal::ParseContext::kSlopBytes) {
          parser_till_end = ::google::protobuf::internal::GreedyStringParser;
          goto string_till_end;
        }
        GOOGLE_PROTOBUF_PARSER_ASSERT(::google::protobuf::internal::StringCheck(ptr, size, ctx));
        ::google::protobuf::internal::InlineGreedyStringParser(object, ptr, size, ctx);
        ptr += size;
        break;
      }
      // optional uint32 extra_data_len = 9;
      case 9: {
        if (static_cast<::google::protobuf::uint8>(tag) != 72) goto handle_unusual;
        msg->set_extra_data_len(::google::protobuf::internal::ReadVarint(&ptr));
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        break;
      }
      // optional uint32 expiry = 10;
      case 10: {
        if (static_cast<::google::protobuf::uint8>(tag) != 80) goto handle_unusual;
        msg->set_expiry(::google::protobuf::internal::ReadVarint(&ptr));
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        break;
      }
      // optional bool overwintered = 11;
      case 11: {
        if (static_cast<::google::protobuf::uint8>(tag) != 88) goto handle_unusual;
        msg->set_overwintered(::google::protobuf::internal::ReadVarint(&ptr));
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        break;
      }
      // optional uint32 version_group_id = 12;
      case 12: {
        if (static_cast<::google::protobuf::uint8>(tag) != 96) goto handle_unusual;
        msg->set_version_group_id(::google::protobuf::internal::ReadVarint(&ptr));
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        break;
      }
      // optional uint32 timestamp = 13;
      case 13: {
        if (static_cast<::google::protobuf::uint8>(tag) != 104) goto handle_unusual;
        msg->set_timestamp(::google::protobuf::internal::ReadVarint(&ptr));
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        break;
      }
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->EndGroup(tag);
          return ptr;
        }
        auto res = UnknownFieldParse(tag, {_InternalParse, msg},
          ptr, end, msg->_internal_metadata_.mutable_unknown_fields(), ctx);
        ptr = res.first;
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr != nullptr);
        if (res.second) return ptr;
      }
    }  // switch
  }  // while
  return ptr;
string_till_end:
  static_cast<::std::string*>(object)->clear();
  static_cast<::std::string*>(object)->reserve(size);
  goto len_delim_till_end;
len_delim_till_end:
  return ctx->StoreAndTailCall(ptr, end, {_InternalParse, msg},
                               {parser_till_end, object}, size);
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool TxAck_TransactionType::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:hw.trezor.messages.bitcoin.TxAck.TransactionType)
  for (;;) {
    ::std::pair<::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional uint32 version = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (8 & 0xFF)) {
          HasBitSetters::set_has_version(this);
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &version_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // repeated .hw.trezor.messages.bitcoin.TxAck.TransactionType.TxInputType inputs = 2;
      case 2: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (18 & 0xFF)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessage(
                input, add_inputs()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // repeated .hw.trezor.messages.bitcoin.TxAck.TransactionType.TxOutputBinType bin_outputs = 3;
      case 3: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (26 & 0xFF)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessage(
                input, add_bin_outputs()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional uint32 lock_time = 4;
      case 4: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (32 & 0xFF)) {
          HasBitSetters::set_has_lock_time(this);
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &lock_time_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // repeated .hw.trezor.messages.bitcoin.TxAck.TransactionType.TxOutputType outputs = 5;
      case 5: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (42 & 0xFF)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessage(
                input, add_outputs()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional uint32 inputs_cnt = 6;
      case 6: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (48 & 0xFF)) {
          HasBitSetters::set_has_inputs_cnt(this);
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &inputs_cnt_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional uint32 outputs_cnt = 7;
      case 7: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (56 & 0xFF)) {
          HasBitSetters::set_has_outputs_cnt(this);
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &outputs_cnt_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional bytes extra_data = 8;
      case 8: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (66 & 0xFF)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_extra_data()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional uint32 extra_data_len = 9;
      case 9: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (72 & 0xFF)) {
          HasBitSetters::set_has_extra_data_len(this);
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &extra_data_len_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional uint32 expiry = 10;
      case 10: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (80 & 0xFF)) {
          HasBitSetters::set_has_expiry(this);
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &expiry_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional bool overwintered = 11;
      case 11: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (88 & 0xFF)) {
          HasBitSetters::set_has_overwintered(this);
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &overwintered_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional uint32 version_group_id = 12;
      case 12: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (96 & 0xFF)) {
          HasBitSetters::set_has_version_group_id(this);
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &version_group_id_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional uint32 timestamp = 13;
      case 13: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (104 & 0xFF)) {
          HasBitSetters::set_has_timestamp(this);
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &timestamp_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, _internal_metadata_.mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:hw.trezor.messages.bitcoin.TxAck.TransactionType)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:hw.trezor.messages.bitcoin.TxAck.TransactionType)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void TxAck_TransactionType::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:hw.trezor.messages.bitcoin.TxAck.TransactionType)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional uint32 version = 1;
  if (cached_has_bits & 0x00000002u) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->version(), output);
  }

  // repeated .hw.trezor.messages.bitcoin.TxAck.TransactionType.TxInputType inputs = 2;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->inputs_size()); i < n; i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2,
      this->inputs(static_cast<int>(i)),
      output);
  }

  // repeated .hw.trezor.messages.bitcoin.TxAck.TransactionType.TxOutputBinType bin_outputs = 3;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->bin_outputs_size()); i < n; i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      3,
      this->bin_outputs(static_cast<int>(i)),
      output);
  }

  // optional uint32 lock_time = 4;
  if (cached_has_bits & 0x00000004u) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(4, this->lock_time(), output);
  }

  // repeated .hw.trezor.messages.bitcoin.TxAck.TransactionType.TxOutputType outputs = 5;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->outputs_size()); i < n; i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      5,
      this->outputs(static_cast<int>(i)),
      output);
  }

  // optional uint32 inputs_cnt = 6;
  if (cached_has_bits & 0x00000008u) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(6, this->inputs_cnt(), output);
  }

  // optional uint32 outputs_cnt = 7;
  if (cached_has_bits & 0x00000010u) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(7, this->outputs_cnt(), output);
  }

  // optional bytes extra_data = 8;
  if (cached_has_bits & 0x00000001u) {
    ::google::protobuf::internal::WireFormatLite::WriteBytesMaybeAliased(
      8, this->extra_data(), output);
  }

  // optional uint32 extra_data_len = 9;
  if (cached_has_bits & 0x00000020u) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(9, this->extra_data_len(), output);
  }

  // optional uint32 expiry = 10;
  if (cached_has_bits & 0x00000040u) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(10, this->expiry(), output);
  }

  // optional bool overwintered = 11;
  if (cached_has_bits & 0x00000080u) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(11, this->overwintered(), output);
  }

  // optional uint32 version_group_id = 12;
  if (cached_has_bits & 0x00000100u) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(12, this->version_group_id(), output);
  }

  // optional uint32 timestamp = 13;
  if (cached_has_bits & 0x00000200u) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(13, this->timestamp(), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        _internal_metadata_.unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:hw.trezor.messages.bitcoin.TxAck.TransactionType)
}

::google::protobuf::uint8* TxAck_TransactionType::InternalSerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:hw.trezor.messages.bitcoin.TxAck.TransactionType)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional uint32 version = 1;
  if (cached_has_bits & 0x00000002u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(1, this->version(), target);
  }

  // repeated .hw.trezor.messages.bitcoin.TxAck.TransactionType.TxInputType inputs = 2;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->inputs_size()); i < n; i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageToArray(
        2, this->inputs(static_cast<int>(i)), target);
  }

  // repeated .hw.trezor.messages.bitcoin.TxAck.TransactionType.TxOutputBinType bin_outputs = 3;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->bin_outputs_size()); i < n; i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageToArray(
        3, this->bin_outputs(static_cast<int>(i)), target);
  }

  // optional uint32 lock_time = 4;
  if (cached_has_bits & 0x00000004u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(4, this->lock_time(), target);
  }

  // repeated .hw.trezor.messages.bitcoin.TxAck.TransactionType.TxOutputType outputs = 5;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->outputs_size()); i < n; i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageToArray(
        5, this->outputs(static_cast<int>(i)), target);
  }

  // optional uint32 inputs_cnt = 6;
  if (cached_has_bits & 0x00000008u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(6, this->inputs_cnt(), target);
  }

  // optional uint32 outputs_cnt = 7;
  if (cached_has_bits & 0x00000010u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(7, this->outputs_cnt(), target);
  }

  // optional bytes extra_data = 8;
  if (cached_has_bits & 0x00000001u) {
    target =
      ::google::protobuf::internal::WireFormatLite::WriteBytesToArray(
        8, this->extra_data(), target);
  }

  // optional uint32 extra_data_len = 9;
  if (cached_has_bits & 0x00000020u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(9, this->extra_data_len(), target);
  }

  // optional uint32 expiry = 10;
  if (cached_has_bits & 0x00000040u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(10, this->expiry(), target);
  }

  // optional bool overwintered = 11;
  if (cached_has_bits & 0x00000080u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteBoolToArray(11, this->overwintered(), target);
  }

  // optional uint32 version_group_id = 12;
  if (cached_has_bits & 0x00000100u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(12, this->version_group_id(), target);
  }

  // optional uint32 timestamp = 13;
  if (cached_has_bits & 0x00000200u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(13, this->timestamp(), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:hw.trezor.messages.bitcoin.TxAck.TransactionType)
  return target;
}

size_t TxAck_TransactionType::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:hw.trezor.messages.bitcoin.TxAck.TransactionType)
  size_t total_size = 0;

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        _internal_metadata_.unknown_fields());
  }
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .hw.trezor.messages.bitcoin.TxAck.TransactionType.TxInputType inputs = 2;
  {
    unsigned int count = static_cast<unsigned int>(this->inputs_size());
    total_size += 1UL * count;
    for (unsigned int i = 0; i < count; i++) {
      total_size +=
        ::google::protobuf::internal::WireFormatLite::MessageSize(
          this->inputs(static_cast<int>(i)));
    }
  }

  // repeated .hw.trezor.messages.bitcoin.TxAck.TransactionType.TxOutputBinType bin_outputs = 3;
  {
    unsigned int count = static_cast<unsigned int>(this->bin_outputs_size());
    total_size += 1UL * count;
    for (unsigned int i = 0; i < count; i++) {
      total_size +=
        ::google::protobuf::internal::WireFormatLite::MessageSize(
          this->bin_outputs(static_cast<int>(i)));
    }
  }

  // repeated .hw.trezor.messages.bitcoin.TxAck.TransactionType.TxOutputType outputs = 5;
  {
    unsigned int count = static_cast<unsigned int>(this->outputs_size());
    total_size += 1UL * count;
    for (unsigned int i = 0; i < count; i++) {
      total_size +=
        ::google::protobuf::internal::WireFormatLite::MessageSize(
          this->outputs(static_cast<int>(i)));
    }
  }

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    // optional bytes extra_data = 8;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->extra_data());
    }

    // optional uint32 version = 1;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->version());
    }

    // optional uint32 lock_time = 4;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->lock_time());
    }

    // optional uint32 inputs_cnt = 6;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->inputs_cnt());
    }

    // optional uint32 outputs_cnt = 7;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->outputs_cnt());
    }

    // optional uint32 extra_data_len = 9;
    if (cached_has_bits & 0x00000020u) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->extra_data_len());
    }

    // optional uint32 expiry = 10;
    if (cached_has_bits & 0x00000040u) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->expiry());
    }

    // optional bool overwintered = 11;
    if (cached_has_bits & 0x00000080u) {
      total_size += 1 + 1;
    }

  }
  if (cached_has_bits & 0x00000300u) {
    // optional uint32 version_group_id = 12;
    if (cached_has_bits & 0x00000100u) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->version_group_id());
    }

    // optional uint32 timestamp = 13;
    if (cached_has_bits & 0x00000200u) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->timestamp());
    }

  }
  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void TxAck_TransactionType::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:hw.trezor.messages.bitcoin.TxAck.TransactionType)
  GOOGLE_DCHECK_NE(&from, this);
  const TxAck_TransactionType* source =
      ::google::protobuf::DynamicCastToGenerated<TxAck_TransactionType>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:hw.trezor.messages.bitcoin.TxAck.TransactionType)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:hw.trezor.messages.bitcoin.TxAck.TransactionType)
    MergeFrom(*source);
  }
}

void TxAck_TransactionType::MergeFrom(const TxAck_TransactionType& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:hw.trezor.messages.bitcoin.TxAck.TransactionType)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  inputs_.MergeFrom(from.inputs_);
  bin_outputs_.MergeFrom(from.bin_outputs_);
  outputs_.MergeFrom(from.outputs_);
  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      _has_bits_[0] |= 0x00000001u;
      extra_data_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.extra_data_);
    }
    if (cached_has_bits & 0x00000002u) {
      version_ = from.version_;
    }
    if (cached_has_bits & 0x00000004u) {
      lock_time_ = from.lock_time_;
    }
    if (cached_has_bits & 0x00000008u) {
      inputs_cnt_ = from.inputs_cnt_;
    }
    if (cached_has_bits & 0x00000010u) {
      outputs_cnt_ = from.outputs_cnt_;
    }
    if (cached_has_bits & 0x00000020u) {
      extra_data_len_ = from.extra_data_len_;
    }
    if (cached_has_bits & 0x00000040u) {
      expiry_ = from.expiry_;
    }
    if (cached_has_bits & 0x00000080u) {
      overwintered_ = from.overwintered_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  if (cached_has_bits & 0x00000300u) {
    if (cached_has_bits & 0x00000100u) {
      version_group_id_ = from.version_group_id_;
    }
    if (cached_has_bits & 0x00000200u) {
      timestamp_ = from.timestamp_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void TxAck_TransactionType::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:hw.trezor.messages.bitcoin.TxAck.TransactionType)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void TxAck_TransactionType::CopyFrom(const TxAck_TransactionType& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:hw.trezor.messages.bitcoin.TxAck.TransactionType)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TxAck_TransactionType::IsInitialized() const {
  if (!::google::protobuf::internal::AllAreInitialized(this->inputs())) return false;
  if (!::google::protobuf::internal::AllAreInitialized(this->bin_outputs())) return false;
  if (!::google::protobuf::internal::AllAreInitialized(this->outputs())) return false;
  return true;
}

void TxAck_TransactionType::Swap(TxAck_TransactionType* other) {
  if (other == this) return;
  InternalSwap(other);
}
void TxAck_TransactionType::InternalSwap(TxAck_TransactionType* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  CastToBase(&inputs_)->InternalSwap(CastToBase(&other->inputs_));
  CastToBase(&bin_outputs_)->InternalSwap(CastToBase(&other->bin_outputs_));
  CastToBase(&outputs_)->InternalSwap(CastToBase(&other->outputs_));
  extra_data_.Swap(&other->extra_data_, &::google::protobuf::internal::GetEmptyStringAlreadyInited(),
    GetArenaNoVirtual());
  swap(version_, other->version_);
  swap(lock_time_, other->lock_time_);
  swap(inputs_cnt_, other->inputs_cnt_);
  swap(outputs_cnt_, other->outputs_cnt_);
  swap(extra_data_len_, other->extra_data_len_);
  swap(expiry_, other->expiry_);
  swap(overwintered_, other->overwintered_);
  swap(version_group_id_, other->version_group_id_);
  swap(timestamp_, other->timestamp_);
}

::google::protobuf::Metadata TxAck_TransactionType::GetMetadata() const {
  ::google::protobuf::internal::AssignDescriptors(&::assign_descriptors_table_messages_2dbitcoin_2eproto);
  return ::file_level_metadata_messages_2dbitcoin_2eproto[kIndexInFileMessages];
}


// ===================================================================

void TxAck::InitAsDefaultInstance() {
  ::hw::trezor::messages::bitcoin::_TxAck_default_instance_._instance.get_mutable()->tx_ = const_cast< ::hw::trezor::messages::bitcoin::TxAck_TransactionType*>(
      ::hw::trezor::messages::bitcoin::TxAck_TransactionType::internal_default_instance());
}
class TxAck::HasBitSetters {
 public:
  static const ::hw::trezor::messages::bitcoin::TxAck_TransactionType& tx(const TxAck* msg);
  static void set_has_tx(TxAck* msg) {
    msg->_has_bits_[0] |= 0x00000001u;
  }
};

const ::hw::trezor::messages::bitcoin::TxAck_TransactionType&
TxAck::HasBitSetters::tx(const TxAck* msg) {
  return *msg->tx_;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int TxAck::kTxFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

TxAck::TxAck()
  : ::google::protobuf::Message(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:hw.trezor.messages.bitcoin.TxAck)
}
TxAck::TxAck(const TxAck& from)
  : ::google::protobuf::Message(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  if (from.has_tx()) {
    tx_ = new ::hw::trezor::messages::bitcoin::TxAck_TransactionType(*from.tx_);
  } else {
    tx_ = nullptr;
  }
  // @@protoc_insertion_point(copy_constructor:hw.trezor.messages.bitcoin.TxAck)
}

void TxAck::SharedCtor() {
  ::google::protobuf::internal::InitSCC(
      &scc_info_TxAck_messages_2dbitcoin_2eproto.base);
  tx_ = nullptr;
}

TxAck::~TxAck() {
  // @@protoc_insertion_point(destructor:hw.trezor.messages.bitcoin.TxAck)
  SharedDtor();
}

void TxAck::SharedDtor() {
  if (this != internal_default_instance()) delete tx_;
}

void TxAck::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const TxAck& TxAck::default_instance() {
  ::google::protobuf::internal::InitSCC(&::scc_info_TxAck_messages_2dbitcoin_2eproto.base);
  return *internal_default_instance();
}


void TxAck::Clear() {
// @@protoc_insertion_point(message_clear_start:hw.trezor.messages.bitcoin.TxAck)
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    GOOGLE_DCHECK(tx_ != nullptr);
    tx_->Clear();
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* TxAck::_InternalParse(const char* begin, const char* end, void* object,
                  ::google::protobuf::internal::ParseContext* ctx) {
  auto msg = static_cast<TxAck*>(object);
  ::google::protobuf::int32 size; (void)size;
  int depth; (void)depth;
  ::google::protobuf::uint32 tag;
  ::google::protobuf::internal::ParseFunc parser_till_end; (void)parser_till_end;
  auto ptr = begin;
  while (ptr < end) {
    ptr = ::google::protobuf::io::Parse32(ptr, &tag);
    GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
    switch (tag >> 3) {
      // optional .hw.trezor.messages.bitcoin.TxAck.TransactionType tx = 1;
      case 1: {
        if (static_cast<::google::protobuf::uint8>(tag) != 10) goto handle_unusual;
        ptr = ::google::protobuf::io::ReadSize(ptr, &size);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        parser_till_end = ::hw::trezor::messages::bitcoin::TxAck_TransactionType::_InternalParse;
        object = msg->mutable_tx();
        if (size > end - ptr) goto len_delim_till_end;
        ptr += size;
        GOOGLE_PROTOBUF_PARSER_ASSERT(ctx->ParseExactRange(
            {parser_till_end, object}, ptr - size, ptr));
        break;
      }
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->EndGroup(tag);
          return ptr;
        }
        auto res = UnknownFieldParse(tag, {_InternalParse, msg},
          ptr, end, msg->_internal_metadata_.mutable_unknown_fields(), ctx);
        ptr = res.first;
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr != nullptr);
        if (res.second) return ptr;
      }
    }  // switch
  }  // while
  return ptr;
len_delim_till_end:
  return ctx->StoreAndTailCall(ptr, end, {_InternalParse, msg},
                               {parser_till_end, object}, size);
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool TxAck::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:hw.trezor.messages.bitcoin.TxAck)
  for (;;) {
    ::std::pair<::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .hw.trezor.messages.bitcoin.TxAck.TransactionType tx = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (10 & 0xFF)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessage(
               input, mutable_tx()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, _internal_metadata_.mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:hw.trezor.messages.bitcoin.TxAck)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:hw.trezor.messages.bitcoin.TxAck)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void TxAck::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:hw.trezor.messages.bitcoin.TxAck)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional .hw.trezor.messages.bitcoin.TxAck.TransactionType tx = 1;
  if (cached_has_bits & 0x00000001u) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, HasBitSetters::tx(this), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        _internal_metadata_.unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:hw.trezor.messages.bitcoin.TxAck)
}

::google::protobuf::uint8* TxAck::InternalSerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:hw.trezor.messages.bitcoin.TxAck)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional .hw.trezor.messages.bitcoin.TxAck.TransactionType tx = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageToArray(
        1, HasBitSetters::tx(this), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:hw.trezor.messages.bitcoin.TxAck)
  return target;
}

size_t TxAck::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:hw.trezor.messages.bitcoin.TxAck)
  size_t total_size = 0;

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        _internal_metadata_.unknown_fields());
  }
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional .hw.trezor.messages.bitcoin.TxAck.TransactionType tx = 1;
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::MessageSize(
        *tx_);
  }

  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void TxAck::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:hw.trezor.messages.bitcoin.TxAck)
  GOOGLE_DCHECK_NE(&from, this);
  const TxAck* source =
      ::google::protobuf::DynamicCastToGenerated<TxAck>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:hw.trezor.messages.bitcoin.TxAck)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:hw.trezor.messages.bitcoin.TxAck)
    MergeFrom(*source);
  }
}

void TxAck::MergeFrom(const TxAck& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:hw.trezor.messages.bitcoin.TxAck)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  if (from.has_tx()) {
    mutable_tx()->::hw::trezor::messages::bitcoin::TxAck_TransactionType::MergeFrom(from.tx());
  }
}

void TxAck::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:hw.trezor.messages.bitcoin.TxAck)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void TxAck::CopyFrom(const TxAck& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:hw.trezor.messages.bitcoin.TxAck)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TxAck::IsInitialized() const {
  if (has_tx()) {
    if (!this->tx_->IsInitialized()) return false;
  }
  return true;
}

void TxAck::Swap(TxAck* other) {
  if (other == this) return;
  InternalSwap(other);
}
void TxAck::InternalSwap(TxAck* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  swap(tx_, other->tx_);
}

::google::protobuf::Metadata TxAck::GetMetadata() const {
  ::google::protobuf::internal::AssignDescriptors(&::assign_descriptors_table_messages_2dbitcoin_2eproto);
  return ::file_level_metadata_messages_2dbitcoin_2eproto[kIndexInFileMessages];
}


// @@protoc_insertion_point(namespace_scope)
}  // namespace bitcoin
}  // namespace messages
}  // namespace trezor
}  // namespace hw
namespace google {
namespace protobuf {
template<> PROTOBUF_NOINLINE ::hw::trezor::messages::bitcoin::MultisigRedeemScriptType_HDNodePathType* Arena::CreateMaybeMessage< ::hw::trezor::messages::bitcoin::MultisigRedeemScriptType_HDNodePathType >(Arena* arena) {
  return Arena::CreateInternal< ::hw::trezor::messages::bitcoin::MultisigRedeemScriptType_HDNodePathType >(arena);
}
template<> PROTOBUF_NOINLINE ::hw::trezor::messages::bitcoin::MultisigRedeemScriptType* Arena::CreateMaybeMessage< ::hw::trezor::messages::bitcoin::MultisigRedeemScriptType >(Arena* arena) {
  return Arena::CreateInternal< ::hw::trezor::messages::bitcoin::MultisigRedeemScriptType >(arena);
}
template<> PROTOBUF_NOINLINE ::hw::trezor::messages::bitcoin::GetPublicKey* Arena::CreateMaybeMessage< ::hw::trezor::messages::bitcoin::GetPublicKey >(Arena* arena) {
  return Arena::CreateInternal< ::hw::trezor::messages::bitcoin::GetPublicKey >(arena);
}
template<> PROTOBUF_NOINLINE ::hw::trezor::messages::bitcoin::PublicKey* Arena::CreateMaybeMessage< ::hw::trezor::messages::bitcoin::PublicKey >(Arena* arena) {
  return Arena::CreateInternal< ::hw::trezor::messages::bitcoin::PublicKey >(arena);
}
template<> PROTOBUF_NOINLINE ::hw::trezor::messages::bitcoin::GetAddress* Arena::CreateMaybeMessage< ::hw::trezor::messages::bitcoin::GetAddress >(Arena* arena) {
  return Arena::CreateInternal< ::hw::trezor::messages::bitcoin::GetAddress >(arena);
}
template<> PROTOBUF_NOINLINE ::hw::trezor::messages::bitcoin::Address* Arena::CreateMaybeMessage< ::hw::trezor::messages::bitcoin::Address >(Arena* arena) {
  return Arena::CreateInternal< ::hw::trezor::messages::bitcoin::Address >(arena);
}
template<> PROTOBUF_NOINLINE ::hw::trezor::messages::bitcoin::SignMessage* Arena::CreateMaybeMessage< ::hw::trezor::messages::bitcoin::SignMessage >(Arena* arena) {
  return Arena::CreateInternal< ::hw::trezor::messages::bitcoin::SignMessage >(arena);
}
template<> PROTOBUF_NOINLINE ::hw::trezor::messages::bitcoin::MessageSignature* Arena::CreateMaybeMessage< ::hw::trezor::messages::bitcoin::MessageSignature >(Arena* arena) {
  return Arena::CreateInternal< ::hw::trezor::messages::bitcoin::MessageSignature >(arena);
}
template<> PROTOBUF_NOINLINE ::hw::trezor::messages::bitcoin::VerifyMessage* Arena::CreateMaybeMessage< ::hw::trezor::messages::bitcoin::VerifyMessage >(Arena* arena) {
  return Arena::CreateInternal< ::hw::trezor::messages::bitcoin::VerifyMessage >(arena);
}
template<> PROTOBUF_NOINLINE ::hw::trezor::messages::bitcoin::SignTx* Arena::CreateMaybeMessage< ::hw::trezor::messages::bitcoin::SignTx >(Arena* arena) {
  return Arena::CreateInternal< ::hw::trezor::messages::bitcoin::SignTx >(arena);
}
template<> PROTOBUF_NOINLINE ::hw::trezor::messages::bitcoin::TxRequest_TxRequestDetailsType* Arena::CreateMaybeMessage< ::hw::trezor::messages::bitcoin::TxRequest_TxRequestDetailsType >(Arena* arena) {
  return Arena::CreateInternal< ::hw::trezor::messages::bitcoin::TxRequest_TxRequestDetailsType >(arena);
}
template<> PROTOBUF_NOINLINE ::hw::trezor::messages::bitcoin::TxRequest_TxRequestSerializedType* Arena::CreateMaybeMessage< ::hw::trezor::messages::bitcoin::TxRequest_TxRequestSerializedType >(Arena* arena) {
  return Arena::CreateInternal< ::hw::trezor::messages::bitcoin::TxRequest_TxRequestSerializedType >(arena);
}
template<> PROTOBUF_NOINLINE ::hw::trezor::messages::bitcoin::TxRequest* Arena::CreateMaybeMessage< ::hw::trezor::messages::bitcoin::TxRequest >(Arena* arena) {
  return Arena::CreateInternal< ::hw::trezor::messages::bitcoin::TxRequest >(arena);
}
template<> PROTOBUF_NOINLINE ::hw::trezor::messages::bitcoin::TxAck_TransactionType_TxInputType* Arena::CreateMaybeMessage< ::hw::trezor::messages::bitcoin::TxAck_TransactionType_TxInputType >(Arena* arena) {
  return Arena::CreateInternal< ::hw::trezor::messages::bitcoin::TxAck_TransactionType_TxInputType >(arena);
}
template<> PROTOBUF_NOINLINE ::hw::trezor::messages::bitcoin::TxAck_TransactionType_TxOutputBinType* Arena::CreateMaybeMessage< ::hw::trezor::messages::bitcoin::TxAck_TransactionType_TxOutputBinType >(Arena* arena) {
  return Arena::CreateInternal< ::hw::trezor::messages::bitcoin::TxAck_TransactionType_TxOutputBinType >(arena);
}
template<> PROTOBUF_NOINLINE ::hw::trezor::messages::bitcoin::TxAck_TransactionType_TxOutputType* Arena::CreateMaybeMessage< ::hw::trezor::messages::bitcoin::TxAck_TransactionType_TxOutputType >(Arena* arena) {
  return Arena::CreateInternal< ::hw::trezor::messages::bitcoin::TxAck_TransactionType_TxOutputType >(arena);
}
template<> PROTOBUF_NOINLINE ::hw::trezor::messages::bitcoin::TxAck_TransactionType* Arena::CreateMaybeMessage< ::hw::trezor::messages::bitcoin::TxAck_TransactionType >(Arena* arena) {
  return Arena::CreateInternal< ::hw::trezor::messages::bitcoin::TxAck_TransactionType >(arena);
}
template<> PROTOBUF_NOINLINE ::hw::trezor::messages::bitcoin::TxAck* Arena::CreateMaybeMessage< ::hw::trezor::messages::bitcoin::TxAck >(Arena* arena) {
  return Arena::CreateInternal< ::hw::trezor::messages::bitcoin::TxAck >(arena);
}
}  // namespace protobuf
}  // namespace google

// @@protoc_insertion_point(global_scope)
#include <google/protobuf/port_undef.inc>
