// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: messages-ethereum.proto

#include "messages-ethereum.pb.h"

#include <algorithm>

#include <google/protobuf/stubs/common.h>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/wire_format_lite_inl.h>
#include <google/protobuf/descriptor.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/reflection_ops.h>
#include <google/protobuf/wire_format.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>

extern PROTOBUF_INTERNAL_EXPORT_messages_2dcommon_2eproto ::google::protobuf::internal::SCCInfo<0> scc_info_HDNodeType_messages_2dcommon_2eproto;
namespace hw {
namespace trezor {
namespace messages {
namespace ethereum {
class EthereumGetPublicKeyDefaultTypeInternal {
 public:
  ::google::protobuf::internal::ExplicitlyConstructed<EthereumGetPublicKey> _instance;
} _EthereumGetPublicKey_default_instance_;
class EthereumPublicKeyDefaultTypeInternal {
 public:
  ::google::protobuf::internal::ExplicitlyConstructed<EthereumPublicKey> _instance;
} _EthereumPublicKey_default_instance_;
class EthereumGetAddressDefaultTypeInternal {
 public:
  ::google::protobuf::internal::ExplicitlyConstructed<EthereumGetAddress> _instance;
} _EthereumGetAddress_default_instance_;
class EthereumAddressDefaultTypeInternal {
 public:
  ::google::protobuf::internal::ExplicitlyConstructed<EthereumAddress> _instance;
} _EthereumAddress_default_instance_;
class EthereumSignTxDefaultTypeInternal {
 public:
  ::google::protobuf::internal::ExplicitlyConstructed<EthereumSignTx> _instance;
} _EthereumSignTx_default_instance_;
class EthereumTxRequestDefaultTypeInternal {
 public:
  ::google::protobuf::internal::ExplicitlyConstructed<EthereumTxRequest> _instance;
} _EthereumTxRequest_default_instance_;
class EthereumTxAckDefaultTypeInternal {
 public:
  ::google::protobuf::internal::ExplicitlyConstructed<EthereumTxAck> _instance;
} _EthereumTxAck_default_instance_;
class EthereumSignMessageDefaultTypeInternal {
 public:
  ::google::protobuf::internal::ExplicitlyConstructed<EthereumSignMessage> _instance;
} _EthereumSignMessage_default_instance_;
class EthereumMessageSignatureDefaultTypeInternal {
 public:
  ::google::protobuf::internal::ExplicitlyConstructed<EthereumMessageSignature> _instance;
} _EthereumMessageSignature_default_instance_;
class EthereumVerifyMessageDefaultTypeInternal {
 public:
  ::google::protobuf::internal::ExplicitlyConstructed<EthereumVerifyMessage> _instance;
} _EthereumVerifyMessage_default_instance_;
}  // namespace ethereum
}  // namespace messages
}  // namespace trezor
}  // namespace hw
static void InitDefaultsEthereumGetPublicKey_messages_2dethereum_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::hw::trezor::messages::ethereum::_EthereumGetPublicKey_default_instance_;
    new (ptr) ::hw::trezor::messages::ethereum::EthereumGetPublicKey();
    ::google::protobuf::internal::OnShutdownDestroyMessage(ptr);
  }
  ::hw::trezor::messages::ethereum::EthereumGetPublicKey::InitAsDefaultInstance();
}

::google::protobuf::internal::SCCInfo<0> scc_info_EthereumGetPublicKey_messages_2dethereum_2eproto =
    {{ATOMIC_VAR_INIT(::google::protobuf::internal::SCCInfoBase::kUninitialized), 0, InitDefaultsEthereumGetPublicKey_messages_2dethereum_2eproto}, {}};

static void InitDefaultsEthereumPublicKey_messages_2dethereum_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::hw::trezor::messages::ethereum::_EthereumPublicKey_default_instance_;
    new (ptr) ::hw::trezor::messages::ethereum::EthereumPublicKey();
    ::google::protobuf::internal::OnShutdownDestroyMessage(ptr);
  }
  ::hw::trezor::messages::ethereum::EthereumPublicKey::InitAsDefaultInstance();
}

::google::protobuf::internal::SCCInfo<1> scc_info_EthereumPublicKey_messages_2dethereum_2eproto =
    {{ATOMIC_VAR_INIT(::google::protobuf::internal::SCCInfoBase::kUninitialized), 1, InitDefaultsEthereumPublicKey_messages_2dethereum_2eproto}, {
      &scc_info_HDNodeType_messages_2dcommon_2eproto.base,}};

static void InitDefaultsEthereumGetAddress_messages_2dethereum_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::hw::trezor::messages::ethereum::_EthereumGetAddress_default_instance_;
    new (ptr) ::hw::trezor::messages::ethereum::EthereumGetAddress();
    ::google::protobuf::internal::OnShutdownDestroyMessage(ptr);
  }
  ::hw::trezor::messages::ethereum::EthereumGetAddress::InitAsDefaultInstance();
}

::google::protobuf::internal::SCCInfo<0> scc_info_EthereumGetAddress_messages_2dethereum_2eproto =
    {{ATOMIC_VAR_INIT(::google::protobuf::internal::SCCInfoBase::kUninitialized), 0, InitDefaultsEthereumGetAddress_messages_2dethereum_2eproto}, {}};

static void InitDefaultsEthereumAddress_messages_2dethereum_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::hw::trezor::messages::ethereum::_EthereumAddress_default_instance_;
    new (ptr) ::hw::trezor::messages::ethereum::EthereumAddress();
    ::google::protobuf::internal::OnShutdownDestroyMessage(ptr);
  }
  ::hw::trezor::messages::ethereum::EthereumAddress::InitAsDefaultInstance();
}

::google::protobuf::internal::SCCInfo<0> scc_info_EthereumAddress_messages_2dethereum_2eproto =
    {{ATOMIC_VAR_INIT(::google::protobuf::internal::SCCInfoBase::kUninitialized), 0, InitDefaultsEthereumAddress_messages_2dethereum_2eproto}, {}};

static void InitDefaultsEthereumSignTx_messages_2dethereum_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::hw::trezor::messages::ethereum::_EthereumSignTx_default_instance_;
    new (ptr) ::hw::trezor::messages::ethereum::EthereumSignTx();
    ::google::protobuf::internal::OnShutdownDestroyMessage(ptr);
  }
  ::hw::trezor::messages::ethereum::EthereumSignTx::InitAsDefaultInstance();
}

::google::protobuf::internal::SCCInfo<0> scc_info_EthereumSignTx_messages_2dethereum_2eproto =
    {{ATOMIC_VAR_INIT(::google::protobuf::internal::SCCInfoBase::kUninitialized), 0, InitDefaultsEthereumSignTx_messages_2dethereum_2eproto}, {}};

static void InitDefaultsEthereumTxRequest_messages_2dethereum_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::hw::trezor::messages::ethereum::_EthereumTxRequest_default_instance_;
    new (ptr) ::hw::trezor::messages::ethereum::EthereumTxRequest();
    ::google::protobuf::internal::OnShutdownDestroyMessage(ptr);
  }
  ::hw::trezor::messages::ethereum::EthereumTxRequest::InitAsDefaultInstance();
}

::google::protobuf::internal::SCCInfo<0> scc_info_EthereumTxRequest_messages_2dethereum_2eproto =
    {{ATOMIC_VAR_INIT(::google::protobuf::internal::SCCInfoBase::kUninitialized), 0, InitDefaultsEthereumTxRequest_messages_2dethereum_2eproto}, {}};

static void InitDefaultsEthereumTxAck_messages_2dethereum_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::hw::trezor::messages::ethereum::_EthereumTxAck_default_instance_;
    new (ptr) ::hw::trezor::messages::ethereum::EthereumTxAck();
    ::google::protobuf::internal::OnShutdownDestroyMessage(ptr);
  }
  ::hw::trezor::messages::ethereum::EthereumTxAck::InitAsDefaultInstance();
}

::google::protobuf::internal::SCCInfo<0> scc_info_EthereumTxAck_messages_2dethereum_2eproto =
    {{ATOMIC_VAR_INIT(::google::protobuf::internal::SCCInfoBase::kUninitialized), 0, InitDefaultsEthereumTxAck_messages_2dethereum_2eproto}, {}};

static void InitDefaultsEthereumSignMessage_messages_2dethereum_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::hw::trezor::messages::ethereum::_EthereumSignMessage_default_instance_;
    new (ptr) ::hw::trezor::messages::ethereum::EthereumSignMessage();
    ::google::protobuf::internal::OnShutdownDestroyMessage(ptr);
  }
  ::hw::trezor::messages::ethereum::EthereumSignMessage::InitAsDefaultInstance();
}

::google::protobuf::internal::SCCInfo<0> scc_info_EthereumSignMessage_messages_2dethereum_2eproto =
    {{ATOMIC_VAR_INIT(::google::protobuf::internal::SCCInfoBase::kUninitialized), 0, InitDefaultsEthereumSignMessage_messages_2dethereum_2eproto}, {}};

static void InitDefaultsEthereumMessageSignature_messages_2dethereum_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::hw::trezor::messages::ethereum::_EthereumMessageSignature_default_instance_;
    new (ptr) ::hw::trezor::messages::ethereum::EthereumMessageSignature();
    ::google::protobuf::internal::OnShutdownDestroyMessage(ptr);
  }
  ::hw::trezor::messages::ethereum::EthereumMessageSignature::InitAsDefaultInstance();
}

::google::protobuf::internal::SCCInfo<0> scc_info_EthereumMessageSignature_messages_2dethereum_2eproto =
    {{ATOMIC_VAR_INIT(::google::protobuf::internal::SCCInfoBase::kUninitialized), 0, InitDefaultsEthereumMessageSignature_messages_2dethereum_2eproto}, {}};

static void InitDefaultsEthereumVerifyMessage_messages_2dethereum_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::hw::trezor::messages::ethereum::_EthereumVerifyMessage_default_instance_;
    new (ptr) ::hw::trezor::messages::ethereum::EthereumVerifyMessage();
    ::google::protobuf::internal::OnShutdownDestroyMessage(ptr);
  }
  ::hw::trezor::messages::ethereum::EthereumVerifyMessage::InitAsDefaultInstance();
}

::google::protobuf::internal::SCCInfo<0> scc_info_EthereumVerifyMessage_messages_2dethereum_2eproto =
    {{ATOMIC_VAR_INIT(::google::protobuf::internal::SCCInfoBase::kUninitialized), 0, InitDefaultsEthereumVerifyMessage_messages_2dethereum_2eproto}, {}};

void InitDefaults_messages_2dethereum_2eproto() {
  ::google::protobuf::internal::InitSCC(&scc_info_EthereumGetPublicKey_messages_2dethereum_2eproto.base);
  ::google::protobuf::internal::InitSCC(&scc_info_EthereumPublicKey_messages_2dethereum_2eproto.base);
  ::google::protobuf::internal::InitSCC(&scc_info_EthereumGetAddress_messages_2dethereum_2eproto.base);
  ::google::protobuf::internal::InitSCC(&scc_info_EthereumAddress_messages_2dethereum_2eproto.base);
  ::google::protobuf::internal::InitSCC(&scc_info_EthereumSignTx_messages_2dethereum_2eproto.base);
  ::google::protobuf::internal::InitSCC(&scc_info_EthereumTxRequest_messages_2dethereum_2eproto.base);
  ::google::protobuf::internal::InitSCC(&scc_info_EthereumTxAck_messages_2dethereum_2eproto.base);
  ::google::protobuf::internal::InitSCC(&scc_info_EthereumSignMessage_messages_2dethereum_2eproto.base);
  ::google::protobuf::internal::InitSCC(&scc_info_EthereumMessageSignature_messages_2dethereum_2eproto.base);
  ::google::protobuf::internal::InitSCC(&scc_info_EthereumVerifyMessage_messages_2dethereum_2eproto.base);
}

::google::protobuf::Metadata file_level_metadata_messages_2dethereum_2eproto[10];
constexpr ::google::protobuf::EnumDescriptor const** file_level_enum_descriptors_messages_2dethereum_2eproto = nullptr;
constexpr ::google::protobuf::ServiceDescriptor const** file_level_service_descriptors_messages_2dethereum_2eproto = nullptr;

const ::google::protobuf::uint32 TableStruct_messages_2dethereum_2eproto::offsets[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) = {
  PROTOBUF_FIELD_OFFSET(::hw::trezor::messages::ethereum::EthereumGetPublicKey, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::hw::trezor::messages::ethereum::EthereumGetPublicKey, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::hw::trezor::messages::ethereum::EthereumGetPublicKey, address_n_),
  PROTOBUF_FIELD_OFFSET(::hw::trezor::messages::ethereum::EthereumGetPublicKey, show_display_),
  ~0u,
  0,
  PROTOBUF_FIELD_OFFSET(::hw::trezor::messages::ethereum::EthereumPublicKey, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::hw::trezor::messages::ethereum::EthereumPublicKey, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::hw::trezor::messages::ethereum::EthereumPublicKey, node_),
  PROTOBUF_FIELD_OFFSET(::hw::trezor::messages::ethereum::EthereumPublicKey, xpub_),
  1,
  0,
  PROTOBUF_FIELD_OFFSET(::hw::trezor::messages::ethereum::EthereumGetAddress, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::hw::trezor::messages::ethereum::EthereumGetAddress, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::hw::trezor::messages::ethereum::EthereumGetAddress, address_n_),
  PROTOBUF_FIELD_OFFSET(::hw::trezor::messages::ethereum::EthereumGetAddress, show_display_),
  ~0u,
  0,
  PROTOBUF_FIELD_OFFSET(::hw::trezor::messages::ethereum::EthereumAddress, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::hw::trezor::messages::ethereum::EthereumAddress, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::hw::trezor::messages::ethereum::EthereumAddress, address_),
  0,
  PROTOBUF_FIELD_OFFSET(::hw::trezor::messages::ethereum::EthereumSignTx, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::hw::trezor::messages::ethereum::EthereumSignTx, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::hw::trezor::messages::ethereum::EthereumSignTx, address_n_),
  PROTOBUF_FIELD_OFFSET(::hw::trezor::messages::ethereum::EthereumSignTx, nonce_),
  PROTOBUF_FIELD_OFFSET(::hw::trezor::messages::ethereum::EthereumSignTx, gas_price_),
  PROTOBUF_FIELD_OFFSET(::hw::trezor::messages::ethereum::EthereumSignTx, gas_limit_),
  PROTOBUF_FIELD_OFFSET(::hw::trezor::messages::ethereum::EthereumSignTx, to_),
  PROTOBUF_FIELD_OFFSET(::hw::trezor::messages::ethereum::EthereumSignTx, value_),
  PROTOBUF_FIELD_OFFSET(::hw::trezor::messages::ethereum::EthereumSignTx, data_initial_chunk_),
  PROTOBUF_FIELD_OFFSET(::hw::trezor::messages::ethereum::EthereumSignTx, data_length_),
  PROTOBUF_FIELD_OFFSET(::hw::trezor::messages::ethereum::EthereumSignTx, chain_id_),
  PROTOBUF_FIELD_OFFSET(::hw::trezor::messages::ethereum::EthereumSignTx, tx_type_),
  ~0u,
  0,
  1,
  2,
  5,
  3,
  4,
  6,
  7,
  8,
  PROTOBUF_FIELD_OFFSET(::hw::trezor::messages::ethereum::EthereumTxRequest, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::hw::trezor::messages::ethereum::EthereumTxRequest, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::hw::trezor::messages::ethereum::EthereumTxRequest, data_length_),
  PROTOBUF_FIELD_OFFSET(::hw::trezor::messages::ethereum::EthereumTxRequest, signature_v_),
  PROTOBUF_FIELD_OFFSET(::hw::trezor::messages::ethereum::EthereumTxRequest, signature_r_),
  PROTOBUF_FIELD_OFFSET(::hw::trezor::messages::ethereum::EthereumTxRequest, signature_s_),
  2,
  3,
  0,
  1,
  PROTOBUF_FIELD_OFFSET(::hw::trezor::messages::ethereum::EthereumTxAck, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::hw::trezor::messages::ethereum::EthereumTxAck, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::hw::trezor::messages::ethereum::EthereumTxAck, data_chunk_),
  0,
  PROTOBUF_FIELD_OFFSET(::hw::trezor::messages::ethereum::EthereumSignMessage, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::hw::trezor::messages::ethereum::EthereumSignMessage, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::hw::trezor::messages::ethereum::EthereumSignMessage, address_n_),
  PROTOBUF_FIELD_OFFSET(::hw::trezor::messages::ethereum::EthereumSignMessage, message_),
  ~0u,
  0,
  PROTOBUF_FIELD_OFFSET(::hw::trezor::messages::ethereum::EthereumMessageSignature, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::hw::trezor::messages::ethereum::EthereumMessageSignature, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::hw::trezor::messages::ethereum::EthereumMessageSignature, signature_),
  PROTOBUF_FIELD_OFFSET(::hw::trezor::messages::ethereum::EthereumMessageSignature, address_),
  0,
  1,
  PROTOBUF_FIELD_OFFSET(::hw::trezor::messages::ethereum::EthereumVerifyMessage, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::hw::trezor::messages::ethereum::EthereumVerifyMessage, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::hw::trezor::messages::ethereum::EthereumVerifyMessage, signature_),
  PROTOBUF_FIELD_OFFSET(::hw::trezor::messages::ethereum::EthereumVerifyMessage, message_),
  PROTOBUF_FIELD_OFFSET(::hw::trezor::messages::ethereum::EthereumVerifyMessage, address_),
  0,
  1,
  2,
};
static const ::google::protobuf::internal::MigrationSchema schemas[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) = {
  { 0, 7, sizeof(::hw::trezor::messages::ethereum::EthereumGetPublicKey)},
  { 9, 16, sizeof(::hw::trezor::messages::ethereum::EthereumPublicKey)},
  { 18, 25, sizeof(::hw::trezor::messages::ethereum::EthereumGetAddress)},
  { 27, 33, sizeof(::hw::trezor::messages::ethereum::EthereumAddress)},
  { 34, 49, sizeof(::hw::trezor::messages::ethereum::EthereumSignTx)},
  { 59, 68, sizeof(::hw::trezor::messages::ethereum::EthereumTxRequest)},
  { 72, 78, sizeof(::hw::trezor::messages::ethereum::EthereumTxAck)},
  { 79, 86, sizeof(::hw::trezor::messages::ethereum::EthereumSignMessage)},
  { 88, 95, sizeof(::hw::trezor::messages::ethereum::EthereumMessageSignature)},
  { 97, 105, sizeof(::hw::trezor::messages::ethereum::EthereumVerifyMessage)},
};

static ::google::protobuf::Message const * const file_default_instances[] = {
  reinterpret_cast<const ::google::protobuf::Message*>(&::hw::trezor::messages::ethereum::_EthereumGetPublicKey_default_instance_),
  reinterpret_cast<const ::google::protobuf::Message*>(&::hw::trezor::messages::ethereum::_EthereumPublicKey_default_instance_),
  reinterpret_cast<const ::google::protobuf::Message*>(&::hw::trezor::messages::ethereum::_EthereumGetAddress_default_instance_),
  reinterpret_cast<const ::google::protobuf::Message*>(&::hw::trezor::messages::ethereum::_EthereumAddress_default_instance_),
  reinterpret_cast<const ::google::protobuf::Message*>(&::hw::trezor::messages::ethereum::_EthereumSignTx_default_instance_),
  reinterpret_cast<const ::google::protobuf::Message*>(&::hw::trezor::messages::ethereum::_EthereumTxRequest_default_instance_),
  reinterpret_cast<const ::google::protobuf::Message*>(&::hw::trezor::messages::ethereum::_EthereumTxAck_default_instance_),
  reinterpret_cast<const ::google::protobuf::Message*>(&::hw::trezor::messages::ethereum::_EthereumSignMessage_default_instance_),
  reinterpret_cast<const ::google::protobuf::Message*>(&::hw::trezor::messages::ethereum::_EthereumMessageSignature_default_instance_),
  reinterpret_cast<const ::google::protobuf::Message*>(&::hw::trezor::messages::ethereum::_EthereumVerifyMessage_default_instance_),
};

::google::protobuf::internal::AssignDescriptorsTable assign_descriptors_table_messages_2dethereum_2eproto = {
  {}, AddDescriptors_messages_2dethereum_2eproto, "messages-ethereum.proto", schemas,
  file_default_instances, TableStruct_messages_2dethereum_2eproto::offsets,
  file_level_metadata_messages_2dethereum_2eproto, 10, file_level_enum_descriptors_messages_2dethereum_2eproto, file_level_service_descriptors_messages_2dethereum_2eproto,
};

const char descriptor_table_protodef_messages_2dethereum_2eproto[] =
  "\n\027messages-ethereum.proto\022\033hw.trezor.mes"
  "sages.ethereum\032\025messages-common.proto\"\?\n"
  "\024EthereumGetPublicKey\022\021\n\taddress_n\030\001 \003(\r"
  "\022\024\n\014show_display\030\002 \001(\010\"V\n\021EthereumPublic"
  "Key\0223\n\004node\030\001 \001(\0132%.hw.trezor.messages.c"
  "ommon.HDNodeType\022\014\n\004xpub\030\002 \001(\t\"=\n\022Ethere"
  "umGetAddress\022\021\n\taddress_n\030\001 \003(\r\022\024\n\014show_"
  "display\030\002 \001(\010\"\"\n\017EthereumAddress\022\017\n\007addr"
  "ess\030\002 \001(\t\"\307\001\n\016EthereumSignTx\022\021\n\taddress_"
  "n\030\001 \003(\r\022\r\n\005nonce\030\002 \001(\014\022\021\n\tgas_price\030\003 \001("
  "\014\022\021\n\tgas_limit\030\004 \001(\014\022\n\n\002to\030\013 \001(\t\022\r\n\005valu"
  "e\030\006 \001(\014\022\032\n\022data_initial_chunk\030\007 \001(\014\022\023\n\013d"
  "ata_length\030\010 \001(\r\022\020\n\010chain_id\030\t \001(\r\022\017\n\007tx"
  "_type\030\n \001(\r\"g\n\021EthereumTxRequest\022\023\n\013data"
  "_length\030\001 \001(\r\022\023\n\013signature_v\030\002 \001(\r\022\023\n\013si"
  "gnature_r\030\003 \001(\014\022\023\n\013signature_s\030\004 \001(\014\"#\n\r"
  "EthereumTxAck\022\022\n\ndata_chunk\030\001 \001(\014\"9\n\023Eth"
  "ereumSignMessage\022\021\n\taddress_n\030\001 \003(\r\022\017\n\007m"
  "essage\030\002 \001(\014\">\n\030EthereumMessageSignature"
  "\022\021\n\tsignature\030\002 \001(\014\022\017\n\007address\030\003 \001(\t\"L\n\025"
  "EthereumVerifyMessage\022\021\n\tsignature\030\002 \001(\014"
  "\022\017\n\007message\030\003 \001(\014\022\017\n\007address\030\004 \001(\tB<\n#co"
  "m.satoshilabs.trezor.lib.protobufB\025Trezo"
  "rMessageEthereum"
  ;
::google::protobuf::internal::DescriptorTable descriptor_table_messages_2dethereum_2eproto = {
  false, InitDefaults_messages_2dethereum_2eproto, 
  descriptor_table_protodef_messages_2dethereum_2eproto,
  "messages-ethereum.proto", &assign_descriptors_table_messages_2dethereum_2eproto, 936,
};

void AddDescriptors_messages_2dethereum_2eproto() {
  static constexpr ::google::protobuf::internal::InitFunc deps[1] =
  {
    ::AddDescriptors_messages_2dcommon_2eproto,
  };
 ::google::protobuf::internal::AddDescriptors(&descriptor_table_messages_2dethereum_2eproto, deps, 1);
}

// Force running AddDescriptors() at dynamic initialization time.
static bool dynamic_init_dummy_messages_2dethereum_2eproto = []() { AddDescriptors_messages_2dethereum_2eproto(); return true; }();
namespace hw {
namespace trezor {
namespace messages {
namespace ethereum {

// ===================================================================

void EthereumGetPublicKey::InitAsDefaultInstance() {
}
class EthereumGetPublicKey::HasBitSetters {
 public:
  static void set_has_show_display(EthereumGetPublicKey* msg) {
    msg->_has_bits_[0] |= 0x00000001u;
  }
};

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int EthereumGetPublicKey::kAddressNFieldNumber;
const int EthereumGetPublicKey::kShowDisplayFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

EthereumGetPublicKey::EthereumGetPublicKey()
  : ::google::protobuf::Message(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:hw.trezor.messages.ethereum.EthereumGetPublicKey)
}
EthereumGetPublicKey::EthereumGetPublicKey(const EthereumGetPublicKey& from)
  : ::google::protobuf::Message(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_),
      address_n_(from.address_n_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  show_display_ = from.show_display_;
  // @@protoc_insertion_point(copy_constructor:hw.trezor.messages.ethereum.EthereumGetPublicKey)
}

void EthereumGetPublicKey::SharedCtor() {
  show_display_ = false;
}

EthereumGetPublicKey::~EthereumGetPublicKey() {
  // @@protoc_insertion_point(destructor:hw.trezor.messages.ethereum.EthereumGetPublicKey)
  SharedDtor();
}

void EthereumGetPublicKey::SharedDtor() {
}

void EthereumGetPublicKey::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const EthereumGetPublicKey& EthereumGetPublicKey::default_instance() {
  ::google::protobuf::internal::InitSCC(&::scc_info_EthereumGetPublicKey_messages_2dethereum_2eproto.base);
  return *internal_default_instance();
}


void EthereumGetPublicKey::Clear() {
// @@protoc_insertion_point(message_clear_start:hw.trezor.messages.ethereum.EthereumGetPublicKey)
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  address_n_.Clear();
  show_display_ = false;
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* EthereumGetPublicKey::_InternalParse(const char* begin, const char* end, void* object,
                  ::google::protobuf::internal::ParseContext* ctx) {
  auto msg = static_cast<EthereumGetPublicKey*>(object);
  ::google::protobuf::int32 size; (void)size;
  int depth; (void)depth;
  ::google::protobuf::uint32 tag;
  ::google::protobuf::internal::ParseFunc parser_till_end; (void)parser_till_end;
  auto ptr = begin;
  while (ptr < end) {
    ptr = ::google::protobuf::io::Parse32(ptr, &tag);
    GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
    switch (tag >> 3) {
      // repeated uint32 address_n = 1;
      case 1: {
        if (static_cast<::google::protobuf::uint8>(tag) == 8) {
          do {
            msg->add_address_n(::google::protobuf::internal::ReadVarint(&ptr));
            GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
            if (ptr >= end) break;
          } while ((::google::protobuf::io::UnalignedLoad<::google::protobuf::uint64>(ptr) & 255) == 8 && (ptr += 1));
          break;
        } else if (static_cast<::google::protobuf::uint8>(tag) != 10) goto handle_unusual;
        ptr = ::google::protobuf::io::ReadSize(ptr, &size);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        parser_till_end = ::google::protobuf::internal::PackedUInt32Parser;
        object = msg->mutable_address_n();
        if (size > end - ptr) goto len_delim_till_end;
        auto newend = ptr + size;
        if (size) ptr = parser_till_end(ptr, newend, object, ctx);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr == newend);
        break;
      }
      // optional bool show_display = 2;
      case 2: {
        if (static_cast<::google::protobuf::uint8>(tag) != 16) goto handle_unusual;
        msg->set_show_display(::google::protobuf::internal::ReadVarint(&ptr));
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        break;
      }
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->EndGroup(tag);
          return ptr;
        }
        auto res = UnknownFieldParse(tag, {_InternalParse, msg},
          ptr, end, msg->_internal_metadata_.mutable_unknown_fields(), ctx);
        ptr = res.first;
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr != nullptr);
        if (res.second) return ptr;
      }
    }  // switch
  }  // while
  return ptr;
len_delim_till_end:
  return ctx->StoreAndTailCall(ptr, end, {_InternalParse, msg},
                               {parser_till_end, object}, size);
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool EthereumGetPublicKey::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:hw.trezor.messages.ethereum.EthereumGetPublicKey)
  for (;;) {
    ::std::pair<::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated uint32 address_n = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (8 & 0xFF)) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadRepeatedPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 1, 8u, input, this->mutable_address_n())));
        } else if (static_cast< ::google::protobuf::uint8>(tag) == (10 & 0xFF)) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPackedPrimitiveNoInline<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, this->mutable_address_n())));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional bool show_display = 2;
      case 2: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (16 & 0xFF)) {
          HasBitSetters::set_has_show_display(this);
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &show_display_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, _internal_metadata_.mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:hw.trezor.messages.ethereum.EthereumGetPublicKey)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:hw.trezor.messages.ethereum.EthereumGetPublicKey)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void EthereumGetPublicKey::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:hw.trezor.messages.ethereum.EthereumGetPublicKey)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated uint32 address_n = 1;
  for (int i = 0, n = this->address_n_size(); i < n; i++) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(
      1, this->address_n(i), output);
  }

  cached_has_bits = _has_bits_[0];
  // optional bool show_display = 2;
  if (cached_has_bits & 0x00000001u) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(2, this->show_display(), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        _internal_metadata_.unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:hw.trezor.messages.ethereum.EthereumGetPublicKey)
}

::google::protobuf::uint8* EthereumGetPublicKey::InternalSerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:hw.trezor.messages.ethereum.EthereumGetPublicKey)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated uint32 address_n = 1;
  target = ::google::protobuf::internal::WireFormatLite::
    WriteUInt32ToArray(1, this->address_n_, target);

  cached_has_bits = _has_bits_[0];
  // optional bool show_display = 2;
  if (cached_has_bits & 0x00000001u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteBoolToArray(2, this->show_display(), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:hw.trezor.messages.ethereum.EthereumGetPublicKey)
  return target;
}

size_t EthereumGetPublicKey::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:hw.trezor.messages.ethereum.EthereumGetPublicKey)
  size_t total_size = 0;

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        _internal_metadata_.unknown_fields());
  }
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated uint32 address_n = 1;
  {
    size_t data_size = ::google::protobuf::internal::WireFormatLite::
      UInt32Size(this->address_n_);
    total_size += 1 *
                  ::google::protobuf::internal::FromIntSize(this->address_n_size());
    total_size += data_size;
  }

  // optional bool show_display = 2;
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 + 1;
  }

  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void EthereumGetPublicKey::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:hw.trezor.messages.ethereum.EthereumGetPublicKey)
  GOOGLE_DCHECK_NE(&from, this);
  const EthereumGetPublicKey* source =
      ::google::protobuf::DynamicCastToGenerated<EthereumGetPublicKey>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:hw.trezor.messages.ethereum.EthereumGetPublicKey)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:hw.trezor.messages.ethereum.EthereumGetPublicKey)
    MergeFrom(*source);
  }
}

void EthereumGetPublicKey::MergeFrom(const EthereumGetPublicKey& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:hw.trezor.messages.ethereum.EthereumGetPublicKey)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  address_n_.MergeFrom(from.address_n_);
  if (from.has_show_display()) {
    set_show_display(from.show_display());
  }
}

void EthereumGetPublicKey::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:hw.trezor.messages.ethereum.EthereumGetPublicKey)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void EthereumGetPublicKey::CopyFrom(const EthereumGetPublicKey& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:hw.trezor.messages.ethereum.EthereumGetPublicKey)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool EthereumGetPublicKey::IsInitialized() const {
  return true;
}

void EthereumGetPublicKey::Swap(EthereumGetPublicKey* other) {
  if (other == this) return;
  InternalSwap(other);
}
void EthereumGetPublicKey::InternalSwap(EthereumGetPublicKey* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  address_n_.InternalSwap(&other->address_n_);
  swap(show_display_, other->show_display_);
}

::google::protobuf::Metadata EthereumGetPublicKey::GetMetadata() const {
  ::google::protobuf::internal::AssignDescriptors(&::assign_descriptors_table_messages_2dethereum_2eproto);
  return ::file_level_metadata_messages_2dethereum_2eproto[kIndexInFileMessages];
}


// ===================================================================

void EthereumPublicKey::InitAsDefaultInstance() {
  ::hw::trezor::messages::ethereum::_EthereumPublicKey_default_instance_._instance.get_mutable()->node_ = const_cast< ::hw::trezor::messages::common::HDNodeType*>(
      ::hw::trezor::messages::common::HDNodeType::internal_default_instance());
}
class EthereumPublicKey::HasBitSetters {
 public:
  static const ::hw::trezor::messages::common::HDNodeType& node(const EthereumPublicKey* msg);
  static void set_has_node(EthereumPublicKey* msg) {
    msg->_has_bits_[0] |= 0x00000002u;
  }
  static void set_has_xpub(EthereumPublicKey* msg) {
    msg->_has_bits_[0] |= 0x00000001u;
  }
};

const ::hw::trezor::messages::common::HDNodeType&
EthereumPublicKey::HasBitSetters::node(const EthereumPublicKey* msg) {
  return *msg->node_;
}
void EthereumPublicKey::clear_node() {
  if (node_ != nullptr) node_->Clear();
  _has_bits_[0] &= ~0x00000002u;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int EthereumPublicKey::kNodeFieldNumber;
const int EthereumPublicKey::kXpubFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

EthereumPublicKey::EthereumPublicKey()
  : ::google::protobuf::Message(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:hw.trezor.messages.ethereum.EthereumPublicKey)
}
EthereumPublicKey::EthereumPublicKey(const EthereumPublicKey& from)
  : ::google::protobuf::Message(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  xpub_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (from.has_xpub()) {
    xpub_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.xpub_);
  }
  if (from.has_node()) {
    node_ = new ::hw::trezor::messages::common::HDNodeType(*from.node_);
  } else {
    node_ = nullptr;
  }
  // @@protoc_insertion_point(copy_constructor:hw.trezor.messages.ethereum.EthereumPublicKey)
}

void EthereumPublicKey::SharedCtor() {
  ::google::protobuf::internal::InitSCC(
      &scc_info_EthereumPublicKey_messages_2dethereum_2eproto.base);
  xpub_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  node_ = nullptr;
}

EthereumPublicKey::~EthereumPublicKey() {
  // @@protoc_insertion_point(destructor:hw.trezor.messages.ethereum.EthereumPublicKey)
  SharedDtor();
}

void EthereumPublicKey::SharedDtor() {
  xpub_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (this != internal_default_instance()) delete node_;
}

void EthereumPublicKey::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const EthereumPublicKey& EthereumPublicKey::default_instance() {
  ::google::protobuf::internal::InitSCC(&::scc_info_EthereumPublicKey_messages_2dethereum_2eproto.base);
  return *internal_default_instance();
}


void EthereumPublicKey::Clear() {
// @@protoc_insertion_point(message_clear_start:hw.trezor.messages.ethereum.EthereumPublicKey)
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      xpub_.ClearNonDefaultToEmptyNoArena();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(node_ != nullptr);
      node_->Clear();
    }
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* EthereumPublicKey::_InternalParse(const char* begin, const char* end, void* object,
                  ::google::protobuf::internal::ParseContext* ctx) {
  auto msg = static_cast<EthereumPublicKey*>(object);
  ::google::protobuf::int32 size; (void)size;
  int depth; (void)depth;
  ::google::protobuf::uint32 tag;
  ::google::protobuf::internal::ParseFunc parser_till_end; (void)parser_till_end;
  auto ptr = begin;
  while (ptr < end) {
    ptr = ::google::protobuf::io::Parse32(ptr, &tag);
    GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
    switch (tag >> 3) {
      // optional .hw.trezor.messages.common.HDNodeType node = 1;
      case 1: {
        if (static_cast<::google::protobuf::uint8>(tag) != 10) goto handle_unusual;
        ptr = ::google::protobuf::io::ReadSize(ptr, &size);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        parser_till_end = ::hw::trezor::messages::common::HDNodeType::_InternalParse;
        object = msg->mutable_node();
        if (size > end - ptr) goto len_delim_till_end;
        ptr += size;
        GOOGLE_PROTOBUF_PARSER_ASSERT(ctx->ParseExactRange(
            {parser_till_end, object}, ptr - size, ptr));
        break;
      }
      // optional string xpub = 2;
      case 2: {
        if (static_cast<::google::protobuf::uint8>(tag) != 18) goto handle_unusual;
        ptr = ::google::protobuf::io::ReadSize(ptr, &size);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        ctx->extra_parse_data().SetFieldName("hw.trezor.messages.ethereum.EthereumPublicKey.xpub");
        object = msg->mutable_xpub();
        if (size > end - ptr + ::google::protobuf::internal::ParseContext::kSlopBytes) {
          parser_till_end = ::google::protobuf::internal::GreedyStringParserUTF8Verify;
          goto string_till_end;
        }
        GOOGLE_PROTOBUF_PARSER_ASSERT(::google::protobuf::internal::StringCheckUTF8Verify(ptr, size, ctx));
        ::google::protobuf::internal::InlineGreedyStringParser(object, ptr, size, ctx);
        ptr += size;
        break;
      }
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->EndGroup(tag);
          return ptr;
        }
        auto res = UnknownFieldParse(tag, {_InternalParse, msg},
          ptr, end, msg->_internal_metadata_.mutable_unknown_fields(), ctx);
        ptr = res.first;
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr != nullptr);
        if (res.second) return ptr;
      }
    }  // switch
  }  // while
  return ptr;
string_till_end:
  static_cast<::std::string*>(object)->clear();
  static_cast<::std::string*>(object)->reserve(size);
  goto len_delim_till_end;
len_delim_till_end:
  return ctx->StoreAndTailCall(ptr, end, {_InternalParse, msg},
                               {parser_till_end, object}, size);
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool EthereumPublicKey::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:hw.trezor.messages.ethereum.EthereumPublicKey)
  for (;;) {
    ::std::pair<::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .hw.trezor.messages.common.HDNodeType node = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (10 & 0xFF)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessage(
               input, mutable_node()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional string xpub = 2;
      case 2: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (18 & 0xFF)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_xpub()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->xpub().data(), static_cast<int>(this->xpub().length()),
            ::google::protobuf::internal::WireFormat::PARSE,
            "hw.trezor.messages.ethereum.EthereumPublicKey.xpub");
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, _internal_metadata_.mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:hw.trezor.messages.ethereum.EthereumPublicKey)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:hw.trezor.messages.ethereum.EthereumPublicKey)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void EthereumPublicKey::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:hw.trezor.messages.ethereum.EthereumPublicKey)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional .hw.trezor.messages.common.HDNodeType node = 1;
  if (cached_has_bits & 0x00000002u) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, HasBitSetters::node(this), output);
  }

  // optional string xpub = 2;
  if (cached_has_bits & 0x00000001u) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->xpub().data(), static_cast<int>(this->xpub().length()),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "hw.trezor.messages.ethereum.EthereumPublicKey.xpub");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      2, this->xpub(), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        _internal_metadata_.unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:hw.trezor.messages.ethereum.EthereumPublicKey)
}

::google::protobuf::uint8* EthereumPublicKey::InternalSerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:hw.trezor.messages.ethereum.EthereumPublicKey)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional .hw.trezor.messages.common.HDNodeType node = 1;
  if (cached_has_bits & 0x00000002u) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageToArray(
        1, HasBitSetters::node(this), target);
  }

  // optional string xpub = 2;
  if (cached_has_bits & 0x00000001u) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->xpub().data(), static_cast<int>(this->xpub().length()),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "hw.trezor.messages.ethereum.EthereumPublicKey.xpub");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        2, this->xpub(), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:hw.trezor.messages.ethereum.EthereumPublicKey)
  return target;
}

size_t EthereumPublicKey::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:hw.trezor.messages.ethereum.EthereumPublicKey)
  size_t total_size = 0;

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        _internal_metadata_.unknown_fields());
  }
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional string xpub = 2;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->xpub());
    }

    // optional .hw.trezor.messages.common.HDNodeType node = 1;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSize(
          *node_);
    }

  }
  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void EthereumPublicKey::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:hw.trezor.messages.ethereum.EthereumPublicKey)
  GOOGLE_DCHECK_NE(&from, this);
  const EthereumPublicKey* source =
      ::google::protobuf::DynamicCastToGenerated<EthereumPublicKey>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:hw.trezor.messages.ethereum.EthereumPublicKey)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:hw.trezor.messages.ethereum.EthereumPublicKey)
    MergeFrom(*source);
  }
}

void EthereumPublicKey::MergeFrom(const EthereumPublicKey& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:hw.trezor.messages.ethereum.EthereumPublicKey)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _has_bits_[0] |= 0x00000001u;
      xpub_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.xpub_);
    }
    if (cached_has_bits & 0x00000002u) {
      mutable_node()->::hw::trezor::messages::common::HDNodeType::MergeFrom(from.node());
    }
  }
}

void EthereumPublicKey::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:hw.trezor.messages.ethereum.EthereumPublicKey)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void EthereumPublicKey::CopyFrom(const EthereumPublicKey& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:hw.trezor.messages.ethereum.EthereumPublicKey)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool EthereumPublicKey::IsInitialized() const {
  if (has_node()) {
    if (!this->node_->IsInitialized()) return false;
  }
  return true;
}

void EthereumPublicKey::Swap(EthereumPublicKey* other) {
  if (other == this) return;
  InternalSwap(other);
}
void EthereumPublicKey::InternalSwap(EthereumPublicKey* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  xpub_.Swap(&other->xpub_, &::google::protobuf::internal::GetEmptyStringAlreadyInited(),
    GetArenaNoVirtual());
  swap(node_, other->node_);
}

::google::protobuf::Metadata EthereumPublicKey::GetMetadata() const {
  ::google::protobuf::internal::AssignDescriptors(&::assign_descriptors_table_messages_2dethereum_2eproto);
  return ::file_level_metadata_messages_2dethereum_2eproto[kIndexInFileMessages];
}


// ===================================================================

void EthereumGetAddress::InitAsDefaultInstance() {
}
class EthereumGetAddress::HasBitSetters {
 public:
  static void set_has_show_display(EthereumGetAddress* msg) {
    msg->_has_bits_[0] |= 0x00000001u;
  }
};

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int EthereumGetAddress::kAddressNFieldNumber;
const int EthereumGetAddress::kShowDisplayFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

EthereumGetAddress::EthereumGetAddress()
  : ::google::protobuf::Message(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:hw.trezor.messages.ethereum.EthereumGetAddress)
}
EthereumGetAddress::EthereumGetAddress(const EthereumGetAddress& from)
  : ::google::protobuf::Message(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_),
      address_n_(from.address_n_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  show_display_ = from.show_display_;
  // @@protoc_insertion_point(copy_constructor:hw.trezor.messages.ethereum.EthereumGetAddress)
}

void EthereumGetAddress::SharedCtor() {
  show_display_ = false;
}

EthereumGetAddress::~EthereumGetAddress() {
  // @@protoc_insertion_point(destructor:hw.trezor.messages.ethereum.EthereumGetAddress)
  SharedDtor();
}

void EthereumGetAddress::SharedDtor() {
}

void EthereumGetAddress::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const EthereumGetAddress& EthereumGetAddress::default_instance() {
  ::google::protobuf::internal::InitSCC(&::scc_info_EthereumGetAddress_messages_2dethereum_2eproto.base);
  return *internal_default_instance();
}


void EthereumGetAddress::Clear() {
// @@protoc_insertion_point(message_clear_start:hw.trezor.messages.ethereum.EthereumGetAddress)
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  address_n_.Clear();
  show_display_ = false;
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* EthereumGetAddress::_InternalParse(const char* begin, const char* end, void* object,
                  ::google::protobuf::internal::ParseContext* ctx) {
  auto msg = static_cast<EthereumGetAddress*>(object);
  ::google::protobuf::int32 size; (void)size;
  int depth; (void)depth;
  ::google::protobuf::uint32 tag;
  ::google::protobuf::internal::ParseFunc parser_till_end; (void)parser_till_end;
  auto ptr = begin;
  while (ptr < end) {
    ptr = ::google::protobuf::io::Parse32(ptr, &tag);
    GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
    switch (tag >> 3) {
      // repeated uint32 address_n = 1;
      case 1: {
        if (static_cast<::google::protobuf::uint8>(tag) == 8) {
          do {
            msg->add_address_n(::google::protobuf::internal::ReadVarint(&ptr));
            GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
            if (ptr >= end) break;
          } while ((::google::protobuf::io::UnalignedLoad<::google::protobuf::uint64>(ptr) & 255) == 8 && (ptr += 1));
          break;
        } else if (static_cast<::google::protobuf::uint8>(tag) != 10) goto handle_unusual;
        ptr = ::google::protobuf::io::ReadSize(ptr, &size);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        parser_till_end = ::google::protobuf::internal::PackedUInt32Parser;
        object = msg->mutable_address_n();
        if (size > end - ptr) goto len_delim_till_end;
        auto newend = ptr + size;
        if (size) ptr = parser_till_end(ptr, newend, object, ctx);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr == newend);
        break;
      }
      // optional bool show_display = 2;
      case 2: {
        if (static_cast<::google::protobuf::uint8>(tag) != 16) goto handle_unusual;
        msg->set_show_display(::google::protobuf::internal::ReadVarint(&ptr));
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        break;
      }
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->EndGroup(tag);
          return ptr;
        }
        auto res = UnknownFieldParse(tag, {_InternalParse, msg},
          ptr, end, msg->_internal_metadata_.mutable_unknown_fields(), ctx);
        ptr = res.first;
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr != nullptr);
        if (res.second) return ptr;
      }
    }  // switch
  }  // while
  return ptr;
len_delim_till_end:
  return ctx->StoreAndTailCall(ptr, end, {_InternalParse, msg},
                               {parser_till_end, object}, size);
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool EthereumGetAddress::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:hw.trezor.messages.ethereum.EthereumGetAddress)
  for (;;) {
    ::std::pair<::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated uint32 address_n = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (8 & 0xFF)) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadRepeatedPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 1, 8u, input, this->mutable_address_n())));
        } else if (static_cast< ::google::protobuf::uint8>(tag) == (10 & 0xFF)) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPackedPrimitiveNoInline<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, this->mutable_address_n())));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional bool show_display = 2;
      case 2: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (16 & 0xFF)) {
          HasBitSetters::set_has_show_display(this);
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &show_display_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, _internal_metadata_.mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:hw.trezor.messages.ethereum.EthereumGetAddress)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:hw.trezor.messages.ethereum.EthereumGetAddress)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void EthereumGetAddress::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:hw.trezor.messages.ethereum.EthereumGetAddress)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated uint32 address_n = 1;
  for (int i = 0, n = this->address_n_size(); i < n; i++) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(
      1, this->address_n(i), output);
  }

  cached_has_bits = _has_bits_[0];
  // optional bool show_display = 2;
  if (cached_has_bits & 0x00000001u) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(2, this->show_display(), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        _internal_metadata_.unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:hw.trezor.messages.ethereum.EthereumGetAddress)
}

::google::protobuf::uint8* EthereumGetAddress::InternalSerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:hw.trezor.messages.ethereum.EthereumGetAddress)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated uint32 address_n = 1;
  target = ::google::protobuf::internal::WireFormatLite::
    WriteUInt32ToArray(1, this->address_n_, target);

  cached_has_bits = _has_bits_[0];
  // optional bool show_display = 2;
  if (cached_has_bits & 0x00000001u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteBoolToArray(2, this->show_display(), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:hw.trezor.messages.ethereum.EthereumGetAddress)
  return target;
}

size_t EthereumGetAddress::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:hw.trezor.messages.ethereum.EthereumGetAddress)
  size_t total_size = 0;

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        _internal_metadata_.unknown_fields());
  }
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated uint32 address_n = 1;
  {
    size_t data_size = ::google::protobuf::internal::WireFormatLite::
      UInt32Size(this->address_n_);
    total_size += 1 *
                  ::google::protobuf::internal::FromIntSize(this->address_n_size());
    total_size += data_size;
  }

  // optional bool show_display = 2;
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 + 1;
  }

  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void EthereumGetAddress::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:hw.trezor.messages.ethereum.EthereumGetAddress)
  GOOGLE_DCHECK_NE(&from, this);
  const EthereumGetAddress* source =
      ::google::protobuf::DynamicCastToGenerated<EthereumGetAddress>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:hw.trezor.messages.ethereum.EthereumGetAddress)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:hw.trezor.messages.ethereum.EthereumGetAddress)
    MergeFrom(*source);
  }
}

void EthereumGetAddress::MergeFrom(const EthereumGetAddress& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:hw.trezor.messages.ethereum.EthereumGetAddress)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  address_n_.MergeFrom(from.address_n_);
  if (from.has_show_display()) {
    set_show_display(from.show_display());
  }
}

void EthereumGetAddress::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:hw.trezor.messages.ethereum.EthereumGetAddress)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void EthereumGetAddress::CopyFrom(const EthereumGetAddress& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:hw.trezor.messages.ethereum.EthereumGetAddress)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool EthereumGetAddress::IsInitialized() const {
  return true;
}

void EthereumGetAddress::Swap(EthereumGetAddress* other) {
  if (other == this) return;
  InternalSwap(other);
}
void EthereumGetAddress::InternalSwap(EthereumGetAddress* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  address_n_.InternalSwap(&other->address_n_);
  swap(show_display_, other->show_display_);
}

::google::protobuf::Metadata EthereumGetAddress::GetMetadata() const {
  ::google::protobuf::internal::AssignDescriptors(&::assign_descriptors_table_messages_2dethereum_2eproto);
  return ::file_level_metadata_messages_2dethereum_2eproto[kIndexInFileMessages];
}


// ===================================================================

void EthereumAddress::InitAsDefaultInstance() {
}
class EthereumAddress::HasBitSetters {
 public:
  static void set_has_address(EthereumAddress* msg) {
    msg->_has_bits_[0] |= 0x00000001u;
  }
};

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int EthereumAddress::kAddressFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

EthereumAddress::EthereumAddress()
  : ::google::protobuf::Message(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:hw.trezor.messages.ethereum.EthereumAddress)
}
EthereumAddress::EthereumAddress(const EthereumAddress& from)
  : ::google::protobuf::Message(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  address_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (from.has_address()) {
    address_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.address_);
  }
  // @@protoc_insertion_point(copy_constructor:hw.trezor.messages.ethereum.EthereumAddress)
}

void EthereumAddress::SharedCtor() {
  ::google::protobuf::internal::InitSCC(
      &scc_info_EthereumAddress_messages_2dethereum_2eproto.base);
  address_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}

EthereumAddress::~EthereumAddress() {
  // @@protoc_insertion_point(destructor:hw.trezor.messages.ethereum.EthereumAddress)
  SharedDtor();
}

void EthereumAddress::SharedDtor() {
  address_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}

void EthereumAddress::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const EthereumAddress& EthereumAddress::default_instance() {
  ::google::protobuf::internal::InitSCC(&::scc_info_EthereumAddress_messages_2dethereum_2eproto.base);
  return *internal_default_instance();
}


void EthereumAddress::Clear() {
// @@protoc_insertion_point(message_clear_start:hw.trezor.messages.ethereum.EthereumAddress)
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    address_.ClearNonDefaultToEmptyNoArena();
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* EthereumAddress::_InternalParse(const char* begin, const char* end, void* object,
                  ::google::protobuf::internal::ParseContext* ctx) {
  auto msg = static_cast<EthereumAddress*>(object);
  ::google::protobuf::int32 size; (void)size;
  int depth; (void)depth;
  ::google::protobuf::uint32 tag;
  ::google::protobuf::internal::ParseFunc parser_till_end; (void)parser_till_end;
  auto ptr = begin;
  while (ptr < end) {
    ptr = ::google::protobuf::io::Parse32(ptr, &tag);
    GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
    switch (tag >> 3) {
      // optional string address = 2;
      case 2: {
        if (static_cast<::google::protobuf::uint8>(tag) != 18) goto handle_unusual;
        ptr = ::google::protobuf::io::ReadSize(ptr, &size);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        ctx->extra_parse_data().SetFieldName("hw.trezor.messages.ethereum.EthereumAddress.address");
        object = msg->mutable_address();
        if (size > end - ptr + ::google::protobuf::internal::ParseContext::kSlopBytes) {
          parser_till_end = ::google::protobuf::internal::GreedyStringParserUTF8Verify;
          goto string_till_end;
        }
        GOOGLE_PROTOBUF_PARSER_ASSERT(::google::protobuf::internal::StringCheckUTF8Verify(ptr, size, ctx));
        ::google::protobuf::internal::InlineGreedyStringParser(object, ptr, size, ctx);
        ptr += size;
        break;
      }
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->EndGroup(tag);
          return ptr;
        }
        auto res = UnknownFieldParse(tag, {_InternalParse, msg},
          ptr, end, msg->_internal_metadata_.mutable_unknown_fields(), ctx);
        ptr = res.first;
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr != nullptr);
        if (res.second) return ptr;
      }
    }  // switch
  }  // while
  return ptr;
string_till_end:
  static_cast<::std::string*>(object)->clear();
  static_cast<::std::string*>(object)->reserve(size);
  goto len_delim_till_end;
len_delim_till_end:
  return ctx->StoreAndTailCall(ptr, end, {_InternalParse, msg},
                               {parser_till_end, object}, size);
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool EthereumAddress::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:hw.trezor.messages.ethereum.EthereumAddress)
  for (;;) {
    ::std::pair<::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional string address = 2;
      case 2: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (18 & 0xFF)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_address()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->address().data(), static_cast<int>(this->address().length()),
            ::google::protobuf::internal::WireFormat::PARSE,
            "hw.trezor.messages.ethereum.EthereumAddress.address");
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, _internal_metadata_.mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:hw.trezor.messages.ethereum.EthereumAddress)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:hw.trezor.messages.ethereum.EthereumAddress)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void EthereumAddress::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:hw.trezor.messages.ethereum.EthereumAddress)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional string address = 2;
  if (cached_has_bits & 0x00000001u) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->address().data(), static_cast<int>(this->address().length()),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "hw.trezor.messages.ethereum.EthereumAddress.address");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      2, this->address(), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        _internal_metadata_.unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:hw.trezor.messages.ethereum.EthereumAddress)
}

::google::protobuf::uint8* EthereumAddress::InternalSerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:hw.trezor.messages.ethereum.EthereumAddress)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional string address = 2;
  if (cached_has_bits & 0x00000001u) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->address().data(), static_cast<int>(this->address().length()),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "hw.trezor.messages.ethereum.EthereumAddress.address");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        2, this->address(), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:hw.trezor.messages.ethereum.EthereumAddress)
  return target;
}

size_t EthereumAddress::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:hw.trezor.messages.ethereum.EthereumAddress)
  size_t total_size = 0;

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        _internal_metadata_.unknown_fields());
  }
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional string address = 2;
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::StringSize(
        this->address());
  }

  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void EthereumAddress::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:hw.trezor.messages.ethereum.EthereumAddress)
  GOOGLE_DCHECK_NE(&from, this);
  const EthereumAddress* source =
      ::google::protobuf::DynamicCastToGenerated<EthereumAddress>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:hw.trezor.messages.ethereum.EthereumAddress)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:hw.trezor.messages.ethereum.EthereumAddress)
    MergeFrom(*source);
  }
}

void EthereumAddress::MergeFrom(const EthereumAddress& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:hw.trezor.messages.ethereum.EthereumAddress)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  if (from.has_address()) {
    _has_bits_[0] |= 0x00000001u;
    address_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.address_);
  }
}

void EthereumAddress::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:hw.trezor.messages.ethereum.EthereumAddress)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void EthereumAddress::CopyFrom(const EthereumAddress& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:hw.trezor.messages.ethereum.EthereumAddress)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool EthereumAddress::IsInitialized() const {
  return true;
}

void EthereumAddress::Swap(EthereumAddress* other) {
  if (other == this) return;
  InternalSwap(other);
}
void EthereumAddress::InternalSwap(EthereumAddress* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  address_.Swap(&other->address_, &::google::protobuf::internal::GetEmptyStringAlreadyInited(),
    GetArenaNoVirtual());
}

::google::protobuf::Metadata EthereumAddress::GetMetadata() const {
  ::google::protobuf::internal::AssignDescriptors(&::assign_descriptors_table_messages_2dethereum_2eproto);
  return ::file_level_metadata_messages_2dethereum_2eproto[kIndexInFileMessages];
}


// ===================================================================

void EthereumSignTx::InitAsDefaultInstance() {
}
class EthereumSignTx::HasBitSetters {
 public:
  static void set_has_nonce(EthereumSignTx* msg) {
    msg->_has_bits_[0] |= 0x00000001u;
  }
  static void set_has_gas_price(EthereumSignTx* msg) {
    msg->_has_bits_[0] |= 0x00000002u;
  }
  static void set_has_gas_limit(EthereumSignTx* msg) {
    msg->_has_bits_[0] |= 0x00000004u;
  }
  static void set_has_to(EthereumSignTx* msg) {
    msg->_has_bits_[0] |= 0x00000020u;
  }
  static void set_has_value(EthereumSignTx* msg) {
    msg->_has_bits_[0] |= 0x00000008u;
  }
  static void set_has_data_initial_chunk(EthereumSignTx* msg) {
    msg->_has_bits_[0] |= 0x00000010u;
  }
  static void set_has_data_length(EthereumSignTx* msg) {
    msg->_has_bits_[0] |= 0x00000040u;
  }
  static void set_has_chain_id(EthereumSignTx* msg) {
    msg->_has_bits_[0] |= 0x00000080u;
  }
  static void set_has_tx_type(EthereumSignTx* msg) {
    msg->_has_bits_[0] |= 0x00000100u;
  }
};

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int EthereumSignTx::kAddressNFieldNumber;
const int EthereumSignTx::kNonceFieldNumber;
const int EthereumSignTx::kGasPriceFieldNumber;
const int EthereumSignTx::kGasLimitFieldNumber;
const int EthereumSignTx::kToFieldNumber;
const int EthereumSignTx::kValueFieldNumber;
const int EthereumSignTx::kDataInitialChunkFieldNumber;
const int EthereumSignTx::kDataLengthFieldNumber;
const int EthereumSignTx::kChainIdFieldNumber;
const int EthereumSignTx::kTxTypeFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

EthereumSignTx::EthereumSignTx()
  : ::google::protobuf::Message(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:hw.trezor.messages.ethereum.EthereumSignTx)
}
EthereumSignTx::EthereumSignTx(const EthereumSignTx& from)
  : ::google::protobuf::Message(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_),
      address_n_(from.address_n_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  nonce_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (from.has_nonce()) {
    nonce_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.nonce_);
  }
  gas_price_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (from.has_gas_price()) {
    gas_price_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.gas_price_);
  }
  gas_limit_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (from.has_gas_limit()) {
    gas_limit_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.gas_limit_);
  }
  value_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (from.has_value()) {
    value_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.value_);
  }
  data_initial_chunk_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (from.has_data_initial_chunk()) {
    data_initial_chunk_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.data_initial_chunk_);
  }
  to_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (from.has_to()) {
    to_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.to_);
  }
  ::memcpy(&data_length_, &from.data_length_,
    static_cast<size_t>(reinterpret_cast<char*>(&tx_type_) -
    reinterpret_cast<char*>(&data_length_)) + sizeof(tx_type_));
  // @@protoc_insertion_point(copy_constructor:hw.trezor.messages.ethereum.EthereumSignTx)
}

void EthereumSignTx::SharedCtor() {
  ::google::protobuf::internal::InitSCC(
      &scc_info_EthereumSignTx_messages_2dethereum_2eproto.base);
  nonce_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  gas_price_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  gas_limit_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  value_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  data_initial_chunk_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  to_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  ::memset(&data_length_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&tx_type_) -
      reinterpret_cast<char*>(&data_length_)) + sizeof(tx_type_));
}

EthereumSignTx::~EthereumSignTx() {
  // @@protoc_insertion_point(destructor:hw.trezor.messages.ethereum.EthereumSignTx)
  SharedDtor();
}

void EthereumSignTx::SharedDtor() {
  nonce_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  gas_price_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  gas_limit_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  value_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  data_initial_chunk_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  to_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}

void EthereumSignTx::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const EthereumSignTx& EthereumSignTx::default_instance() {
  ::google::protobuf::internal::InitSCC(&::scc_info_EthereumSignTx_messages_2dethereum_2eproto.base);
  return *internal_default_instance();
}


void EthereumSignTx::Clear() {
// @@protoc_insertion_point(message_clear_start:hw.trezor.messages.ethereum.EthereumSignTx)
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  address_n_.Clear();
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    if (cached_has_bits & 0x00000001u) {
      nonce_.ClearNonDefaultToEmptyNoArena();
    }
    if (cached_has_bits & 0x00000002u) {
      gas_price_.ClearNonDefaultToEmptyNoArena();
    }
    if (cached_has_bits & 0x00000004u) {
      gas_limit_.ClearNonDefaultToEmptyNoArena();
    }
    if (cached_has_bits & 0x00000008u) {
      value_.ClearNonDefaultToEmptyNoArena();
    }
    if (cached_has_bits & 0x00000010u) {
      data_initial_chunk_.ClearNonDefaultToEmptyNoArena();
    }
    if (cached_has_bits & 0x00000020u) {
      to_.ClearNonDefaultToEmptyNoArena();
    }
  }
  if (cached_has_bits & 0x000000c0u) {
    ::memset(&data_length_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&chain_id_) -
        reinterpret_cast<char*>(&data_length_)) + sizeof(chain_id_));
  }
  tx_type_ = 0u;
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* EthereumSignTx::_InternalParse(const char* begin, const char* end, void* object,
                  ::google::protobuf::internal::ParseContext* ctx) {
  auto msg = static_cast<EthereumSignTx*>(object);
  ::google::protobuf::int32 size; (void)size;
  int depth; (void)depth;
  ::google::protobuf::uint32 tag;
  ::google::protobuf::internal::ParseFunc parser_till_end; (void)parser_till_end;
  auto ptr = begin;
  while (ptr < end) {
    ptr = ::google::protobuf::io::Parse32(ptr, &tag);
    GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
    switch (tag >> 3) {
      // repeated uint32 address_n = 1;
      case 1: {
        if (static_cast<::google::protobuf::uint8>(tag) == 8) {
          do {
            msg->add_address_n(::google::protobuf::internal::ReadVarint(&ptr));
            GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
            if (ptr >= end) break;
          } while ((::google::protobuf::io::UnalignedLoad<::google::protobuf::uint64>(ptr) & 255) == 8 && (ptr += 1));
          break;
        } else if (static_cast<::google::protobuf::uint8>(tag) != 10) goto handle_unusual;
        ptr = ::google::protobuf::io::ReadSize(ptr, &size);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        parser_till_end = ::google::protobuf::internal::PackedUInt32Parser;
        object = msg->mutable_address_n();
        if (size > end - ptr) goto len_delim_till_end;
        auto newend = ptr + size;
        if (size) ptr = parser_till_end(ptr, newend, object, ctx);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr == newend);
        break;
      }
      // optional bytes nonce = 2;
      case 2: {
        if (static_cast<::google::protobuf::uint8>(tag) != 18) goto handle_unusual;
        ptr = ::google::protobuf::io::ReadSize(ptr, &size);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        object = msg->mutable_nonce();
        if (size > end - ptr + ::google::protobuf::internal::ParseContext::kSlopBytes) {
          parser_till_end = ::google::protobuf::internal::GreedyStringParser;
          goto string_till_end;
        }
        GOOGLE_PROTOBUF_PARSER_ASSERT(::google::protobuf::internal::StringCheck(ptr, size, ctx));
        ::google::protobuf::internal::InlineGreedyStringParser(object, ptr, size, ctx);
        ptr += size;
        break;
      }
      // optional bytes gas_price = 3;
      case 3: {
        if (static_cast<::google::protobuf::uint8>(tag) != 26) goto handle_unusual;
        ptr = ::google::protobuf::io::ReadSize(ptr, &size);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        object = msg->mutable_gas_price();
        if (size > end - ptr + ::google::protobuf::internal::ParseContext::kSlopBytes) {
          parser_till_end = ::google::protobuf::internal::GreedyStringParser;
          goto string_till_end;
        }
        GOOGLE_PROTOBUF_PARSER_ASSERT(::google::protobuf::internal::StringCheck(ptr, size, ctx));
        ::google::protobuf::internal::InlineGreedyStringParser(object, ptr, size, ctx);
        ptr += size;
        break;
      }
      // optional bytes gas_limit = 4;
      case 4: {
        if (static_cast<::google::protobuf::uint8>(tag) != 34) goto handle_unusual;
        ptr = ::google::protobuf::io::ReadSize(ptr, &size);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        object = msg->mutable_gas_limit();
        if (size > end - ptr + ::google::protobuf::internal::ParseContext::kSlopBytes) {
          parser_till_end = ::google::protobuf::internal::GreedyStringParser;
          goto string_till_end;
        }
        GOOGLE_PROTOBUF_PARSER_ASSERT(::google::protobuf::internal::StringCheck(ptr, size, ctx));
        ::google::protobuf::internal::InlineGreedyStringParser(object, ptr, size, ctx);
        ptr += size;
        break;
      }
      // optional bytes value = 6;
      case 6: {
        if (static_cast<::google::protobuf::uint8>(tag) != 50) goto handle_unusual;
        ptr = ::google::protobuf::io::ReadSize(ptr, &size);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        object = msg->mutable_value();
        if (size > end - ptr + ::google::protobuf::internal::ParseContext::kSlopBytes) {
          parser_till_end = ::google::protobuf::internal::GreedyStringParser;
          goto string_till_end;
        }
        GOOGLE_PROTOBUF_PARSER_ASSERT(::google::protobuf::internal::StringCheck(ptr, size, ctx));
        ::google::protobuf::internal::InlineGreedyStringParser(object, ptr, size, ctx);
        ptr += size;
        break;
      }
      // optional bytes data_initial_chunk = 7;
      case 7: {
        if (static_cast<::google::protobuf::uint8>(tag) != 58) goto handle_unusual;
        ptr = ::google::protobuf::io::ReadSize(ptr, &size);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        object = msg->mutable_data_initial_chunk();
        if (size > end - ptr + ::google::protobuf::internal::ParseContext::kSlopBytes) {
          parser_till_end = ::google::protobuf::internal::GreedyStringParser;
          goto string_till_end;
        }
        GOOGLE_PROTOBUF_PARSER_ASSERT(::google::protobuf::internal::StringCheck(ptr, size, ctx));
        ::google::protobuf::internal::InlineGreedyStringParser(object, ptr, size, ctx);
        ptr += size;
        break;
      }
      // optional uint32 data_length = 8;
      case 8: {
        if (static_cast<::google::protobuf::uint8>(tag) != 64) goto handle_unusual;
        msg->set_data_length(::google::protobuf::internal::ReadVarint(&ptr));
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        break;
      }
      // optional uint32 chain_id = 9;
      case 9: {
        if (static_cast<::google::protobuf::uint8>(tag) != 72) goto handle_unusual;
        msg->set_chain_id(::google::protobuf::internal::ReadVarint(&ptr));
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        break;
      }
      // optional uint32 tx_type = 10;
      case 10: {
        if (static_cast<::google::protobuf::uint8>(tag) != 80) goto handle_unusual;
        msg->set_tx_type(::google::protobuf::internal::ReadVarint(&ptr));
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        break;
      }
      // optional string to = 11;
      case 11: {
        if (static_cast<::google::protobuf::uint8>(tag) != 90) goto handle_unusual;
        ptr = ::google::protobuf::io::ReadSize(ptr, &size);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        ctx->extra_parse_data().SetFieldName("hw.trezor.messages.ethereum.EthereumSignTx.to");
        object = msg->mutable_to();
        if (size > end - ptr + ::google::protobuf::internal::ParseContext::kSlopBytes) {
          parser_till_end = ::google::protobuf::internal::GreedyStringParserUTF8Verify;
          goto string_till_end;
        }
        GOOGLE_PROTOBUF_PARSER_ASSERT(::google::protobuf::internal::StringCheckUTF8Verify(ptr, size, ctx));
        ::google::protobuf::internal::InlineGreedyStringParser(object, ptr, size, ctx);
        ptr += size;
        break;
      }
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->EndGroup(tag);
          return ptr;
        }
        auto res = UnknownFieldParse(tag, {_InternalParse, msg},
          ptr, end, msg->_internal_metadata_.mutable_unknown_fields(), ctx);
        ptr = res.first;
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr != nullptr);
        if (res.second) return ptr;
      }
    }  // switch
  }  // while
  return ptr;
string_till_end:
  static_cast<::std::string*>(object)->clear();
  static_cast<::std::string*>(object)->reserve(size);
  goto len_delim_till_end;
len_delim_till_end:
  return ctx->StoreAndTailCall(ptr, end, {_InternalParse, msg},
                               {parser_till_end, object}, size);
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool EthereumSignTx::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:hw.trezor.messages.ethereum.EthereumSignTx)
  for (;;) {
    ::std::pair<::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated uint32 address_n = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (8 & 0xFF)) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadRepeatedPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 1, 8u, input, this->mutable_address_n())));
        } else if (static_cast< ::google::protobuf::uint8>(tag) == (10 & 0xFF)) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPackedPrimitiveNoInline<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, this->mutable_address_n())));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional bytes nonce = 2;
      case 2: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (18 & 0xFF)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_nonce()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional bytes gas_price = 3;
      case 3: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (26 & 0xFF)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_gas_price()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional bytes gas_limit = 4;
      case 4: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (34 & 0xFF)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_gas_limit()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional bytes value = 6;
      case 6: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (50 & 0xFF)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_value()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional bytes data_initial_chunk = 7;
      case 7: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (58 & 0xFF)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_data_initial_chunk()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional uint32 data_length = 8;
      case 8: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (64 & 0xFF)) {
          HasBitSetters::set_has_data_length(this);
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &data_length_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional uint32 chain_id = 9;
      case 9: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (72 & 0xFF)) {
          HasBitSetters::set_has_chain_id(this);
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &chain_id_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional uint32 tx_type = 10;
      case 10: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (80 & 0xFF)) {
          HasBitSetters::set_has_tx_type(this);
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &tx_type_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional string to = 11;
      case 11: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (90 & 0xFF)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_to()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->to().data(), static_cast<int>(this->to().length()),
            ::google::protobuf::internal::WireFormat::PARSE,
            "hw.trezor.messages.ethereum.EthereumSignTx.to");
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, _internal_metadata_.mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:hw.trezor.messages.ethereum.EthereumSignTx)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:hw.trezor.messages.ethereum.EthereumSignTx)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void EthereumSignTx::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:hw.trezor.messages.ethereum.EthereumSignTx)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated uint32 address_n = 1;
  for (int i = 0, n = this->address_n_size(); i < n; i++) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(
      1, this->address_n(i), output);
  }

  cached_has_bits = _has_bits_[0];
  // optional bytes nonce = 2;
  if (cached_has_bits & 0x00000001u) {
    ::google::protobuf::internal::WireFormatLite::WriteBytesMaybeAliased(
      2, this->nonce(), output);
  }

  // optional bytes gas_price = 3;
  if (cached_has_bits & 0x00000002u) {
    ::google::protobuf::internal::WireFormatLite::WriteBytesMaybeAliased(
      3, this->gas_price(), output);
  }

  // optional bytes gas_limit = 4;
  if (cached_has_bits & 0x00000004u) {
    ::google::protobuf::internal::WireFormatLite::WriteBytesMaybeAliased(
      4, this->gas_limit(), output);
  }

  // optional bytes value = 6;
  if (cached_has_bits & 0x00000008u) {
    ::google::protobuf::internal::WireFormatLite::WriteBytesMaybeAliased(
      6, this->value(), output);
  }

  // optional bytes data_initial_chunk = 7;
  if (cached_has_bits & 0x00000010u) {
    ::google::protobuf::internal::WireFormatLite::WriteBytesMaybeAliased(
      7, this->data_initial_chunk(), output);
  }

  // optional uint32 data_length = 8;
  if (cached_has_bits & 0x00000040u) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(8, this->data_length(), output);
  }

  // optional uint32 chain_id = 9;
  if (cached_has_bits & 0x00000080u) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(9, this->chain_id(), output);
  }

  // optional uint32 tx_type = 10;
  if (cached_has_bits & 0x00000100u) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(10, this->tx_type(), output);
  }

  // optional string to = 11;
  if (cached_has_bits & 0x00000020u) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->to().data(), static_cast<int>(this->to().length()),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "hw.trezor.messages.ethereum.EthereumSignTx.to");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      11, this->to(), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        _internal_metadata_.unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:hw.trezor.messages.ethereum.EthereumSignTx)
}

::google::protobuf::uint8* EthereumSignTx::InternalSerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:hw.trezor.messages.ethereum.EthereumSignTx)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated uint32 address_n = 1;
  target = ::google::protobuf::internal::WireFormatLite::
    WriteUInt32ToArray(1, this->address_n_, target);

  cached_has_bits = _has_bits_[0];
  // optional bytes nonce = 2;
  if (cached_has_bits & 0x00000001u) {
    target =
      ::google::protobuf::internal::WireFormatLite::WriteBytesToArray(
        2, this->nonce(), target);
  }

  // optional bytes gas_price = 3;
  if (cached_has_bits & 0x00000002u) {
    target =
      ::google::protobuf::internal::WireFormatLite::WriteBytesToArray(
        3, this->gas_price(), target);
  }

  // optional bytes gas_limit = 4;
  if (cached_has_bits & 0x00000004u) {
    target =
      ::google::protobuf::internal::WireFormatLite::WriteBytesToArray(
        4, this->gas_limit(), target);
  }

  // optional bytes value = 6;
  if (cached_has_bits & 0x00000008u) {
    target =
      ::google::protobuf::internal::WireFormatLite::WriteBytesToArray(
        6, this->value(), target);
  }

  // optional bytes data_initial_chunk = 7;
  if (cached_has_bits & 0x00000010u) {
    target =
      ::google::protobuf::internal::WireFormatLite::WriteBytesToArray(
        7, this->data_initial_chunk(), target);
  }

  // optional uint32 data_length = 8;
  if (cached_has_bits & 0x00000040u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(8, this->data_length(), target);
  }

  // optional uint32 chain_id = 9;
  if (cached_has_bits & 0x00000080u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(9, this->chain_id(), target);
  }

  // optional uint32 tx_type = 10;
  if (cached_has_bits & 0x00000100u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(10, this->tx_type(), target);
  }

  // optional string to = 11;
  if (cached_has_bits & 0x00000020u) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->to().data(), static_cast<int>(this->to().length()),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "hw.trezor.messages.ethereum.EthereumSignTx.to");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        11, this->to(), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:hw.trezor.messages.ethereum.EthereumSignTx)
  return target;
}

size_t EthereumSignTx::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:hw.trezor.messages.ethereum.EthereumSignTx)
  size_t total_size = 0;

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        _internal_metadata_.unknown_fields());
  }
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated uint32 address_n = 1;
  {
    size_t data_size = ::google::protobuf::internal::WireFormatLite::
      UInt32Size(this->address_n_);
    total_size += 1 *
                  ::google::protobuf::internal::FromIntSize(this->address_n_size());
    total_size += data_size;
  }

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    // optional bytes nonce = 2;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->nonce());
    }

    // optional bytes gas_price = 3;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->gas_price());
    }

    // optional bytes gas_limit = 4;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->gas_limit());
    }

    // optional bytes value = 6;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->value());
    }

    // optional bytes data_initial_chunk = 7;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->data_initial_chunk());
    }

    // optional string to = 11;
    if (cached_has_bits & 0x00000020u) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->to());
    }

    // optional uint32 data_length = 8;
    if (cached_has_bits & 0x00000040u) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->data_length());
    }

    // optional uint32 chain_id = 9;
    if (cached_has_bits & 0x00000080u) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->chain_id());
    }

  }
  // optional uint32 tx_type = 10;
  if (cached_has_bits & 0x00000100u) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::UInt32Size(
        this->tx_type());
  }

  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void EthereumSignTx::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:hw.trezor.messages.ethereum.EthereumSignTx)
  GOOGLE_DCHECK_NE(&from, this);
  const EthereumSignTx* source =
      ::google::protobuf::DynamicCastToGenerated<EthereumSignTx>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:hw.trezor.messages.ethereum.EthereumSignTx)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:hw.trezor.messages.ethereum.EthereumSignTx)
    MergeFrom(*source);
  }
}

void EthereumSignTx::MergeFrom(const EthereumSignTx& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:hw.trezor.messages.ethereum.EthereumSignTx)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  address_n_.MergeFrom(from.address_n_);
  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      _has_bits_[0] |= 0x00000001u;
      nonce_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.nonce_);
    }
    if (cached_has_bits & 0x00000002u) {
      _has_bits_[0] |= 0x00000002u;
      gas_price_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.gas_price_);
    }
    if (cached_has_bits & 0x00000004u) {
      _has_bits_[0] |= 0x00000004u;
      gas_limit_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.gas_limit_);
    }
    if (cached_has_bits & 0x00000008u) {
      _has_bits_[0] |= 0x00000008u;
      value_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.value_);
    }
    if (cached_has_bits & 0x00000010u) {
      _has_bits_[0] |= 0x00000010u;
      data_initial_chunk_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.data_initial_chunk_);
    }
    if (cached_has_bits & 0x00000020u) {
      _has_bits_[0] |= 0x00000020u;
      to_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.to_);
    }
    if (cached_has_bits & 0x00000040u) {
      data_length_ = from.data_length_;
    }
    if (cached_has_bits & 0x00000080u) {
      chain_id_ = from.chain_id_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  if (cached_has_bits & 0x00000100u) {
    set_tx_type(from.tx_type());
  }
}

void EthereumSignTx::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:hw.trezor.messages.ethereum.EthereumSignTx)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void EthereumSignTx::CopyFrom(const EthereumSignTx& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:hw.trezor.messages.ethereum.EthereumSignTx)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool EthereumSignTx::IsInitialized() const {
  return true;
}

void EthereumSignTx::Swap(EthereumSignTx* other) {
  if (other == this) return;
  InternalSwap(other);
}
void EthereumSignTx::InternalSwap(EthereumSignTx* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  address_n_.InternalSwap(&other->address_n_);
  nonce_.Swap(&other->nonce_, &::google::protobuf::internal::GetEmptyStringAlreadyInited(),
    GetArenaNoVirtual());
  gas_price_.Swap(&other->gas_price_, &::google::protobuf::internal::GetEmptyStringAlreadyInited(),
    GetArenaNoVirtual());
  gas_limit_.Swap(&other->gas_limit_, &::google::protobuf::internal::GetEmptyStringAlreadyInited(),
    GetArenaNoVirtual());
  value_.Swap(&other->value_, &::google::protobuf::internal::GetEmptyStringAlreadyInited(),
    GetArenaNoVirtual());
  data_initial_chunk_.Swap(&other->data_initial_chunk_, &::google::protobuf::internal::GetEmptyStringAlreadyInited(),
    GetArenaNoVirtual());
  to_.Swap(&other->to_, &::google::protobuf::internal::GetEmptyStringAlreadyInited(),
    GetArenaNoVirtual());
  swap(data_length_, other->data_length_);
  swap(chain_id_, other->chain_id_);
  swap(tx_type_, other->tx_type_);
}

::google::protobuf::Metadata EthereumSignTx::GetMetadata() const {
  ::google::protobuf::internal::AssignDescriptors(&::assign_descriptors_table_messages_2dethereum_2eproto);
  return ::file_level_metadata_messages_2dethereum_2eproto[kIndexInFileMessages];
}


// ===================================================================

void EthereumTxRequest::InitAsDefaultInstance() {
}
class EthereumTxRequest::HasBitSetters {
 public:
  static void set_has_data_length(EthereumTxRequest* msg) {
    msg->_has_bits_[0] |= 0x00000004u;
  }
  static void set_has_signature_v(EthereumTxRequest* msg) {
    msg->_has_bits_[0] |= 0x00000008u;
  }
  static void set_has_signature_r(EthereumTxRequest* msg) {
    msg->_has_bits_[0] |= 0x00000001u;
  }
  static void set_has_signature_s(EthereumTxRequest* msg) {
    msg->_has_bits_[0] |= 0x00000002u;
  }
};

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int EthereumTxRequest::kDataLengthFieldNumber;
const int EthereumTxRequest::kSignatureVFieldNumber;
const int EthereumTxRequest::kSignatureRFieldNumber;
const int EthereumTxRequest::kSignatureSFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

EthereumTxRequest::EthereumTxRequest()
  : ::google::protobuf::Message(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:hw.trezor.messages.ethereum.EthereumTxRequest)
}
EthereumTxRequest::EthereumTxRequest(const EthereumTxRequest& from)
  : ::google::protobuf::Message(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  signature_r_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (from.has_signature_r()) {
    signature_r_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.signature_r_);
  }
  signature_s_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (from.has_signature_s()) {
    signature_s_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.signature_s_);
  }
  ::memcpy(&data_length_, &from.data_length_,
    static_cast<size_t>(reinterpret_cast<char*>(&signature_v_) -
    reinterpret_cast<char*>(&data_length_)) + sizeof(signature_v_));
  // @@protoc_insertion_point(copy_constructor:hw.trezor.messages.ethereum.EthereumTxRequest)
}

void EthereumTxRequest::SharedCtor() {
  ::google::protobuf::internal::InitSCC(
      &scc_info_EthereumTxRequest_messages_2dethereum_2eproto.base);
  signature_r_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  signature_s_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  ::memset(&data_length_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&signature_v_) -
      reinterpret_cast<char*>(&data_length_)) + sizeof(signature_v_));
}

EthereumTxRequest::~EthereumTxRequest() {
  // @@protoc_insertion_point(destructor:hw.trezor.messages.ethereum.EthereumTxRequest)
  SharedDtor();
}

void EthereumTxRequest::SharedDtor() {
  signature_r_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  signature_s_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}

void EthereumTxRequest::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const EthereumTxRequest& EthereumTxRequest::default_instance() {
  ::google::protobuf::internal::InitSCC(&::scc_info_EthereumTxRequest_messages_2dethereum_2eproto.base);
  return *internal_default_instance();
}


void EthereumTxRequest::Clear() {
// @@protoc_insertion_point(message_clear_start:hw.trezor.messages.ethereum.EthereumTxRequest)
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      signature_r_.ClearNonDefaultToEmptyNoArena();
    }
    if (cached_has_bits & 0x00000002u) {
      signature_s_.ClearNonDefaultToEmptyNoArena();
    }
  }
  if (cached_has_bits & 0x0000000cu) {
    ::memset(&data_length_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&signature_v_) -
        reinterpret_cast<char*>(&data_length_)) + sizeof(signature_v_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* EthereumTxRequest::_InternalParse(const char* begin, const char* end, void* object,
                  ::google::protobuf::internal::ParseContext* ctx) {
  auto msg = static_cast<EthereumTxRequest*>(object);
  ::google::protobuf::int32 size; (void)size;
  int depth; (void)depth;
  ::google::protobuf::uint32 tag;
  ::google::protobuf::internal::ParseFunc parser_till_end; (void)parser_till_end;
  auto ptr = begin;
  while (ptr < end) {
    ptr = ::google::protobuf::io::Parse32(ptr, &tag);
    GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
    switch (tag >> 3) {
      // optional uint32 data_length = 1;
      case 1: {
        if (static_cast<::google::protobuf::uint8>(tag) != 8) goto handle_unusual;
        msg->set_data_length(::google::protobuf::internal::ReadVarint(&ptr));
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        break;
      }
      // optional uint32 signature_v = 2;
      case 2: {
        if (static_cast<::google::protobuf::uint8>(tag) != 16) goto handle_unusual;
        msg->set_signature_v(::google::protobuf::internal::ReadVarint(&ptr));
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        break;
      }
      // optional bytes signature_r = 3;
      case 3: {
        if (static_cast<::google::protobuf::uint8>(tag) != 26) goto handle_unusual;
        ptr = ::google::protobuf::io::ReadSize(ptr, &size);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        object = msg->mutable_signature_r();
        if (size > end - ptr + ::google::protobuf::internal::ParseContext::kSlopBytes) {
          parser_till_end = ::google::protobuf::internal::GreedyStringParser;
          goto string_till_end;
        }
        GOOGLE_PROTOBUF_PARSER_ASSERT(::google::protobuf::internal::StringCheck(ptr, size, ctx));
        ::google::protobuf::internal::InlineGreedyStringParser(object, ptr, size, ctx);
        ptr += size;
        break;
      }
      // optional bytes signature_s = 4;
      case 4: {
        if (static_cast<::google::protobuf::uint8>(tag) != 34) goto handle_unusual;
        ptr = ::google::protobuf::io::ReadSize(ptr, &size);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        object = msg->mutable_signature_s();
        if (size > end - ptr + ::google::protobuf::internal::ParseContext::kSlopBytes) {
          parser_till_end = ::google::protobuf::internal::GreedyStringParser;
          goto string_till_end;
        }
        GOOGLE_PROTOBUF_PARSER_ASSERT(::google::protobuf::internal::StringCheck(ptr, size, ctx));
        ::google::protobuf::internal::InlineGreedyStringParser(object, ptr, size, ctx);
        ptr += size;
        break;
      }
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->EndGroup(tag);
          return ptr;
        }
        auto res = UnknownFieldParse(tag, {_InternalParse, msg},
          ptr, end, msg->_internal_metadata_.mutable_unknown_fields(), ctx);
        ptr = res.first;
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr != nullptr);
        if (res.second) return ptr;
      }
    }  // switch
  }  // while
  return ptr;
string_till_end:
  static_cast<::std::string*>(object)->clear();
  static_cast<::std::string*>(object)->reserve(size);
  goto len_delim_till_end;
len_delim_till_end:
  return ctx->StoreAndTailCall(ptr, end, {_InternalParse, msg},
                               {parser_till_end, object}, size);
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool EthereumTxRequest::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:hw.trezor.messages.ethereum.EthereumTxRequest)
  for (;;) {
    ::std::pair<::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional uint32 data_length = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (8 & 0xFF)) {
          HasBitSetters::set_has_data_length(this);
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &data_length_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional uint32 signature_v = 2;
      case 2: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (16 & 0xFF)) {
          HasBitSetters::set_has_signature_v(this);
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &signature_v_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional bytes signature_r = 3;
      case 3: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (26 & 0xFF)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_signature_r()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional bytes signature_s = 4;
      case 4: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (34 & 0xFF)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_signature_s()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, _internal_metadata_.mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:hw.trezor.messages.ethereum.EthereumTxRequest)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:hw.trezor.messages.ethereum.EthereumTxRequest)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void EthereumTxRequest::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:hw.trezor.messages.ethereum.EthereumTxRequest)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional uint32 data_length = 1;
  if (cached_has_bits & 0x00000004u) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->data_length(), output);
  }

  // optional uint32 signature_v = 2;
  if (cached_has_bits & 0x00000008u) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->signature_v(), output);
  }

  // optional bytes signature_r = 3;
  if (cached_has_bits & 0x00000001u) {
    ::google::protobuf::internal::WireFormatLite::WriteBytesMaybeAliased(
      3, this->signature_r(), output);
  }

  // optional bytes signature_s = 4;
  if (cached_has_bits & 0x00000002u) {
    ::google::protobuf::internal::WireFormatLite::WriteBytesMaybeAliased(
      4, this->signature_s(), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        _internal_metadata_.unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:hw.trezor.messages.ethereum.EthereumTxRequest)
}

::google::protobuf::uint8* EthereumTxRequest::InternalSerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:hw.trezor.messages.ethereum.EthereumTxRequest)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional uint32 data_length = 1;
  if (cached_has_bits & 0x00000004u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(1, this->data_length(), target);
  }

  // optional uint32 signature_v = 2;
  if (cached_has_bits & 0x00000008u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(2, this->signature_v(), target);
  }

  // optional bytes signature_r = 3;
  if (cached_has_bits & 0x00000001u) {
    target =
      ::google::protobuf::internal::WireFormatLite::WriteBytesToArray(
        3, this->signature_r(), target);
  }

  // optional bytes signature_s = 4;
  if (cached_has_bits & 0x00000002u) {
    target =
      ::google::protobuf::internal::WireFormatLite::WriteBytesToArray(
        4, this->signature_s(), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:hw.trezor.messages.ethereum.EthereumTxRequest)
  return target;
}

size_t EthereumTxRequest::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:hw.trezor.messages.ethereum.EthereumTxRequest)
  size_t total_size = 0;

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        _internal_metadata_.unknown_fields());
  }
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    // optional bytes signature_r = 3;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->signature_r());
    }

    // optional bytes signature_s = 4;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->signature_s());
    }

    // optional uint32 data_length = 1;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->data_length());
    }

    // optional uint32 signature_v = 2;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->signature_v());
    }

  }
  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void EthereumTxRequest::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:hw.trezor.messages.ethereum.EthereumTxRequest)
  GOOGLE_DCHECK_NE(&from, this);
  const EthereumTxRequest* source =
      ::google::protobuf::DynamicCastToGenerated<EthereumTxRequest>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:hw.trezor.messages.ethereum.EthereumTxRequest)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:hw.trezor.messages.ethereum.EthereumTxRequest)
    MergeFrom(*source);
  }
}

void EthereumTxRequest::MergeFrom(const EthereumTxRequest& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:hw.trezor.messages.ethereum.EthereumTxRequest)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      _has_bits_[0] |= 0x00000001u;
      signature_r_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.signature_r_);
    }
    if (cached_has_bits & 0x00000002u) {
      _has_bits_[0] |= 0x00000002u;
      signature_s_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.signature_s_);
    }
    if (cached_has_bits & 0x00000004u) {
      data_length_ = from.data_length_;
    }
    if (cached_has_bits & 0x00000008u) {
      signature_v_ = from.signature_v_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void EthereumTxRequest::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:hw.trezor.messages.ethereum.EthereumTxRequest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void EthereumTxRequest::CopyFrom(const EthereumTxRequest& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:hw.trezor.messages.ethereum.EthereumTxRequest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool EthereumTxRequest::IsInitialized() const {
  return true;
}

void EthereumTxRequest::Swap(EthereumTxRequest* other) {
  if (other == this) return;
  InternalSwap(other);
}
void EthereumTxRequest::InternalSwap(EthereumTxRequest* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  signature_r_.Swap(&other->signature_r_, &::google::protobuf::internal::GetEmptyStringAlreadyInited(),
    GetArenaNoVirtual());
  signature_s_.Swap(&other->signature_s_, &::google::protobuf::internal::GetEmptyStringAlreadyInited(),
    GetArenaNoVirtual());
  swap(data_length_, other->data_length_);
  swap(signature_v_, other->signature_v_);
}

::google::protobuf::Metadata EthereumTxRequest::GetMetadata() const {
  ::google::protobuf::internal::AssignDescriptors(&::assign_descriptors_table_messages_2dethereum_2eproto);
  return ::file_level_metadata_messages_2dethereum_2eproto[kIndexInFileMessages];
}


// ===================================================================

void EthereumTxAck::InitAsDefaultInstance() {
}
class EthereumTxAck::HasBitSetters {
 public:
  static void set_has_data_chunk(EthereumTxAck* msg) {
    msg->_has_bits_[0] |= 0x00000001u;
  }
};

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int EthereumTxAck::kDataChunkFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

EthereumTxAck::EthereumTxAck()
  : ::google::protobuf::Message(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:hw.trezor.messages.ethereum.EthereumTxAck)
}
EthereumTxAck::EthereumTxAck(const EthereumTxAck& from)
  : ::google::protobuf::Message(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  data_chunk_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (from.has_data_chunk()) {
    data_chunk_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.data_chunk_);
  }
  // @@protoc_insertion_point(copy_constructor:hw.trezor.messages.ethereum.EthereumTxAck)
}

void EthereumTxAck::SharedCtor() {
  ::google::protobuf::internal::InitSCC(
      &scc_info_EthereumTxAck_messages_2dethereum_2eproto.base);
  data_chunk_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}

EthereumTxAck::~EthereumTxAck() {
  // @@protoc_insertion_point(destructor:hw.trezor.messages.ethereum.EthereumTxAck)
  SharedDtor();
}

void EthereumTxAck::SharedDtor() {
  data_chunk_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}

void EthereumTxAck::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const EthereumTxAck& EthereumTxAck::default_instance() {
  ::google::protobuf::internal::InitSCC(&::scc_info_EthereumTxAck_messages_2dethereum_2eproto.base);
  return *internal_default_instance();
}


void EthereumTxAck::Clear() {
// @@protoc_insertion_point(message_clear_start:hw.trezor.messages.ethereum.EthereumTxAck)
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    data_chunk_.ClearNonDefaultToEmptyNoArena();
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* EthereumTxAck::_InternalParse(const char* begin, const char* end, void* object,
                  ::google::protobuf::internal::ParseContext* ctx) {
  auto msg = static_cast<EthereumTxAck*>(object);
  ::google::protobuf::int32 size; (void)size;
  int depth; (void)depth;
  ::google::protobuf::uint32 tag;
  ::google::protobuf::internal::ParseFunc parser_till_end; (void)parser_till_end;
  auto ptr = begin;
  while (ptr < end) {
    ptr = ::google::protobuf::io::Parse32(ptr, &tag);
    GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
    switch (tag >> 3) {
      // optional bytes data_chunk = 1;
      case 1: {
        if (static_cast<::google::protobuf::uint8>(tag) != 10) goto handle_unusual;
        ptr = ::google::protobuf::io::ReadSize(ptr, &size);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        object = msg->mutable_data_chunk();
        if (size > end - ptr + ::google::protobuf::internal::ParseContext::kSlopBytes) {
          parser_till_end = ::google::protobuf::internal::GreedyStringParser;
          goto string_till_end;
        }
        GOOGLE_PROTOBUF_PARSER_ASSERT(::google::protobuf::internal::StringCheck(ptr, size, ctx));
        ::google::protobuf::internal::InlineGreedyStringParser(object, ptr, size, ctx);
        ptr += size;
        break;
      }
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->EndGroup(tag);
          return ptr;
        }
        auto res = UnknownFieldParse(tag, {_InternalParse, msg},
          ptr, end, msg->_internal_metadata_.mutable_unknown_fields(), ctx);
        ptr = res.first;
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr != nullptr);
        if (res.second) return ptr;
      }
    }  // switch
  }  // while
  return ptr;
string_till_end:
  static_cast<::std::string*>(object)->clear();
  static_cast<::std::string*>(object)->reserve(size);
  goto len_delim_till_end;
len_delim_till_end:
  return ctx->StoreAndTailCall(ptr, end, {_InternalParse, msg},
                               {parser_till_end, object}, size);
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool EthereumTxAck::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:hw.trezor.messages.ethereum.EthereumTxAck)
  for (;;) {
    ::std::pair<::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional bytes data_chunk = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (10 & 0xFF)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_data_chunk()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, _internal_metadata_.mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:hw.trezor.messages.ethereum.EthereumTxAck)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:hw.trezor.messages.ethereum.EthereumTxAck)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void EthereumTxAck::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:hw.trezor.messages.ethereum.EthereumTxAck)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional bytes data_chunk = 1;
  if (cached_has_bits & 0x00000001u) {
    ::google::protobuf::internal::WireFormatLite::WriteBytesMaybeAliased(
      1, this->data_chunk(), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        _internal_metadata_.unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:hw.trezor.messages.ethereum.EthereumTxAck)
}

::google::protobuf::uint8* EthereumTxAck::InternalSerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:hw.trezor.messages.ethereum.EthereumTxAck)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional bytes data_chunk = 1;
  if (cached_has_bits & 0x00000001u) {
    target =
      ::google::protobuf::internal::WireFormatLite::WriteBytesToArray(
        1, this->data_chunk(), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:hw.trezor.messages.ethereum.EthereumTxAck)
  return target;
}

size_t EthereumTxAck::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:hw.trezor.messages.ethereum.EthereumTxAck)
  size_t total_size = 0;

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        _internal_metadata_.unknown_fields());
  }
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional bytes data_chunk = 1;
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::BytesSize(
        this->data_chunk());
  }

  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void EthereumTxAck::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:hw.trezor.messages.ethereum.EthereumTxAck)
  GOOGLE_DCHECK_NE(&from, this);
  const EthereumTxAck* source =
      ::google::protobuf::DynamicCastToGenerated<EthereumTxAck>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:hw.trezor.messages.ethereum.EthereumTxAck)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:hw.trezor.messages.ethereum.EthereumTxAck)
    MergeFrom(*source);
  }
}

void EthereumTxAck::MergeFrom(const EthereumTxAck& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:hw.trezor.messages.ethereum.EthereumTxAck)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  if (from.has_data_chunk()) {
    _has_bits_[0] |= 0x00000001u;
    data_chunk_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.data_chunk_);
  }
}

void EthereumTxAck::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:hw.trezor.messages.ethereum.EthereumTxAck)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void EthereumTxAck::CopyFrom(const EthereumTxAck& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:hw.trezor.messages.ethereum.EthereumTxAck)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool EthereumTxAck::IsInitialized() const {
  return true;
}

void EthereumTxAck::Swap(EthereumTxAck* other) {
  if (other == this) return;
  InternalSwap(other);
}
void EthereumTxAck::InternalSwap(EthereumTxAck* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  data_chunk_.Swap(&other->data_chunk_, &::google::protobuf::internal::GetEmptyStringAlreadyInited(),
    GetArenaNoVirtual());
}

::google::protobuf::Metadata EthereumTxAck::GetMetadata() const {
  ::google::protobuf::internal::AssignDescriptors(&::assign_descriptors_table_messages_2dethereum_2eproto);
  return ::file_level_metadata_messages_2dethereum_2eproto[kIndexInFileMessages];
}


// ===================================================================

void EthereumSignMessage::InitAsDefaultInstance() {
}
class EthereumSignMessage::HasBitSetters {
 public:
  static void set_has_message(EthereumSignMessage* msg) {
    msg->_has_bits_[0] |= 0x00000001u;
  }
};

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int EthereumSignMessage::kAddressNFieldNumber;
const int EthereumSignMessage::kMessageFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

EthereumSignMessage::EthereumSignMessage()
  : ::google::protobuf::Message(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:hw.trezor.messages.ethereum.EthereumSignMessage)
}
EthereumSignMessage::EthereumSignMessage(const EthereumSignMessage& from)
  : ::google::protobuf::Message(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_),
      address_n_(from.address_n_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  message_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (from.has_message()) {
    message_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.message_);
  }
  // @@protoc_insertion_point(copy_constructor:hw.trezor.messages.ethereum.EthereumSignMessage)
}

void EthereumSignMessage::SharedCtor() {
  ::google::protobuf::internal::InitSCC(
      &scc_info_EthereumSignMessage_messages_2dethereum_2eproto.base);
  message_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}

EthereumSignMessage::~EthereumSignMessage() {
  // @@protoc_insertion_point(destructor:hw.trezor.messages.ethereum.EthereumSignMessage)
  SharedDtor();
}

void EthereumSignMessage::SharedDtor() {
  message_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}

void EthereumSignMessage::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const EthereumSignMessage& EthereumSignMessage::default_instance() {
  ::google::protobuf::internal::InitSCC(&::scc_info_EthereumSignMessage_messages_2dethereum_2eproto.base);
  return *internal_default_instance();
}


void EthereumSignMessage::Clear() {
// @@protoc_insertion_point(message_clear_start:hw.trezor.messages.ethereum.EthereumSignMessage)
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  address_n_.Clear();
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    message_.ClearNonDefaultToEmptyNoArena();
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* EthereumSignMessage::_InternalParse(const char* begin, const char* end, void* object,
                  ::google::protobuf::internal::ParseContext* ctx) {
  auto msg = static_cast<EthereumSignMessage*>(object);
  ::google::protobuf::int32 size; (void)size;
  int depth; (void)depth;
  ::google::protobuf::uint32 tag;
  ::google::protobuf::internal::ParseFunc parser_till_end; (void)parser_till_end;
  auto ptr = begin;
  while (ptr < end) {
    ptr = ::google::protobuf::io::Parse32(ptr, &tag);
    GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
    switch (tag >> 3) {
      // repeated uint32 address_n = 1;
      case 1: {
        if (static_cast<::google::protobuf::uint8>(tag) == 8) {
          do {
            msg->add_address_n(::google::protobuf::internal::ReadVarint(&ptr));
            GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
            if (ptr >= end) break;
          } while ((::google::protobuf::io::UnalignedLoad<::google::protobuf::uint64>(ptr) & 255) == 8 && (ptr += 1));
          break;
        } else if (static_cast<::google::protobuf::uint8>(tag) != 10) goto handle_unusual;
        ptr = ::google::protobuf::io::ReadSize(ptr, &size);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        parser_till_end = ::google::protobuf::internal::PackedUInt32Parser;
        object = msg->mutable_address_n();
        if (size > end - ptr) goto len_delim_till_end;
        auto newend = ptr + size;
        if (size) ptr = parser_till_end(ptr, newend, object, ctx);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr == newend);
        break;
      }
      // optional bytes message = 2;
      case 2: {
        if (static_cast<::google::protobuf::uint8>(tag) != 18) goto handle_unusual;
        ptr = ::google::protobuf::io::ReadSize(ptr, &size);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        object = msg->mutable_message();
        if (size > end - ptr + ::google::protobuf::internal::ParseContext::kSlopBytes) {
          parser_till_end = ::google::protobuf::internal::GreedyStringParser;
          goto string_till_end;
        }
        GOOGLE_PROTOBUF_PARSER_ASSERT(::google::protobuf::internal::StringCheck(ptr, size, ctx));
        ::google::protobuf::internal::InlineGreedyStringParser(object, ptr, size, ctx);
        ptr += size;
        break;
      }
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->EndGroup(tag);
          return ptr;
        }
        auto res = UnknownFieldParse(tag, {_InternalParse, msg},
          ptr, end, msg->_internal_metadata_.mutable_unknown_fields(), ctx);
        ptr = res.first;
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr != nullptr);
        if (res.second) return ptr;
      }
    }  // switch
  }  // while
  return ptr;
string_till_end:
  static_cast<::std::string*>(object)->clear();
  static_cast<::std::string*>(object)->reserve(size);
  goto len_delim_till_end;
len_delim_till_end:
  return ctx->StoreAndTailCall(ptr, end, {_InternalParse, msg},
                               {parser_till_end, object}, size);
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool EthereumSignMessage::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:hw.trezor.messages.ethereum.EthereumSignMessage)
  for (;;) {
    ::std::pair<::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated uint32 address_n = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (8 & 0xFF)) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadRepeatedPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 1, 8u, input, this->mutable_address_n())));
        } else if (static_cast< ::google::protobuf::uint8>(tag) == (10 & 0xFF)) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPackedPrimitiveNoInline<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, this->mutable_address_n())));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional bytes message = 2;
      case 2: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (18 & 0xFF)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_message()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, _internal_metadata_.mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:hw.trezor.messages.ethereum.EthereumSignMessage)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:hw.trezor.messages.ethereum.EthereumSignMessage)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void EthereumSignMessage::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:hw.trezor.messages.ethereum.EthereumSignMessage)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated uint32 address_n = 1;
  for (int i = 0, n = this->address_n_size(); i < n; i++) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(
      1, this->address_n(i), output);
  }

  cached_has_bits = _has_bits_[0];
  // optional bytes message = 2;
  if (cached_has_bits & 0x00000001u) {
    ::google::protobuf::internal::WireFormatLite::WriteBytesMaybeAliased(
      2, this->message(), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        _internal_metadata_.unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:hw.trezor.messages.ethereum.EthereumSignMessage)
}

::google::protobuf::uint8* EthereumSignMessage::InternalSerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:hw.trezor.messages.ethereum.EthereumSignMessage)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated uint32 address_n = 1;
  target = ::google::protobuf::internal::WireFormatLite::
    WriteUInt32ToArray(1, this->address_n_, target);

  cached_has_bits = _has_bits_[0];
  // optional bytes message = 2;
  if (cached_has_bits & 0x00000001u) {
    target =
      ::google::protobuf::internal::WireFormatLite::WriteBytesToArray(
        2, this->message(), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:hw.trezor.messages.ethereum.EthereumSignMessage)
  return target;
}

size_t EthereumSignMessage::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:hw.trezor.messages.ethereum.EthereumSignMessage)
  size_t total_size = 0;

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        _internal_metadata_.unknown_fields());
  }
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated uint32 address_n = 1;
  {
    size_t data_size = ::google::protobuf::internal::WireFormatLite::
      UInt32Size(this->address_n_);
    total_size += 1 *
                  ::google::protobuf::internal::FromIntSize(this->address_n_size());
    total_size += data_size;
  }

  // optional bytes message = 2;
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::BytesSize(
        this->message());
  }

  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void EthereumSignMessage::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:hw.trezor.messages.ethereum.EthereumSignMessage)
  GOOGLE_DCHECK_NE(&from, this);
  const EthereumSignMessage* source =
      ::google::protobuf::DynamicCastToGenerated<EthereumSignMessage>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:hw.trezor.messages.ethereum.EthereumSignMessage)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:hw.trezor.messages.ethereum.EthereumSignMessage)
    MergeFrom(*source);
  }
}

void EthereumSignMessage::MergeFrom(const EthereumSignMessage& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:hw.trezor.messages.ethereum.EthereumSignMessage)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  address_n_.MergeFrom(from.address_n_);
  if (from.has_message()) {
    _has_bits_[0] |= 0x00000001u;
    message_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.message_);
  }
}

void EthereumSignMessage::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:hw.trezor.messages.ethereum.EthereumSignMessage)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void EthereumSignMessage::CopyFrom(const EthereumSignMessage& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:hw.trezor.messages.ethereum.EthereumSignMessage)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool EthereumSignMessage::IsInitialized() const {
  return true;
}

void EthereumSignMessage::Swap(EthereumSignMessage* other) {
  if (other == this) return;
  InternalSwap(other);
}
void EthereumSignMessage::InternalSwap(EthereumSignMessage* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  address_n_.InternalSwap(&other->address_n_);
  message_.Swap(&other->message_, &::google::protobuf::internal::GetEmptyStringAlreadyInited(),
    GetArenaNoVirtual());
}

::google::protobuf::Metadata EthereumSignMessage::GetMetadata() const {
  ::google::protobuf::internal::AssignDescriptors(&::assign_descriptors_table_messages_2dethereum_2eproto);
  return ::file_level_metadata_messages_2dethereum_2eproto[kIndexInFileMessages];
}


// ===================================================================

void EthereumMessageSignature::InitAsDefaultInstance() {
}
class EthereumMessageSignature::HasBitSetters {
 public:
  static void set_has_signature(EthereumMessageSignature* msg) {
    msg->_has_bits_[0] |= 0x00000001u;
  }
  static void set_has_address(EthereumMessageSignature* msg) {
    msg->_has_bits_[0] |= 0x00000002u;
  }
};

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int EthereumMessageSignature::kSignatureFieldNumber;
const int EthereumMessageSignature::kAddressFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

EthereumMessageSignature::EthereumMessageSignature()
  : ::google::protobuf::Message(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:hw.trezor.messages.ethereum.EthereumMessageSignature)
}
EthereumMessageSignature::EthereumMessageSignature(const EthereumMessageSignature& from)
  : ::google::protobuf::Message(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  signature_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (from.has_signature()) {
    signature_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.signature_);
  }
  address_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (from.has_address()) {
    address_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.address_);
  }
  // @@protoc_insertion_point(copy_constructor:hw.trezor.messages.ethereum.EthereumMessageSignature)
}

void EthereumMessageSignature::SharedCtor() {
  ::google::protobuf::internal::InitSCC(
      &scc_info_EthereumMessageSignature_messages_2dethereum_2eproto.base);
  signature_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  address_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}

EthereumMessageSignature::~EthereumMessageSignature() {
  // @@protoc_insertion_point(destructor:hw.trezor.messages.ethereum.EthereumMessageSignature)
  SharedDtor();
}

void EthereumMessageSignature::SharedDtor() {
  signature_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  address_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}

void EthereumMessageSignature::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const EthereumMessageSignature& EthereumMessageSignature::default_instance() {
  ::google::protobuf::internal::InitSCC(&::scc_info_EthereumMessageSignature_messages_2dethereum_2eproto.base);
  return *internal_default_instance();
}


void EthereumMessageSignature::Clear() {
// @@protoc_insertion_point(message_clear_start:hw.trezor.messages.ethereum.EthereumMessageSignature)
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      signature_.ClearNonDefaultToEmptyNoArena();
    }
    if (cached_has_bits & 0x00000002u) {
      address_.ClearNonDefaultToEmptyNoArena();
    }
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* EthereumMessageSignature::_InternalParse(const char* begin, const char* end, void* object,
                  ::google::protobuf::internal::ParseContext* ctx) {
  auto msg = static_cast<EthereumMessageSignature*>(object);
  ::google::protobuf::int32 size; (void)size;
  int depth; (void)depth;
  ::google::protobuf::uint32 tag;
  ::google::protobuf::internal::ParseFunc parser_till_end; (void)parser_till_end;
  auto ptr = begin;
  while (ptr < end) {
    ptr = ::google::protobuf::io::Parse32(ptr, &tag);
    GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
    switch (tag >> 3) {
      // optional bytes signature = 2;
      case 2: {
        if (static_cast<::google::protobuf::uint8>(tag) != 18) goto handle_unusual;
        ptr = ::google::protobuf::io::ReadSize(ptr, &size);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        object = msg->mutable_signature();
        if (size > end - ptr + ::google::protobuf::internal::ParseContext::kSlopBytes) {
          parser_till_end = ::google::protobuf::internal::GreedyStringParser;
          goto string_till_end;
        }
        GOOGLE_PROTOBUF_PARSER_ASSERT(::google::protobuf::internal::StringCheck(ptr, size, ctx));
        ::google::protobuf::internal::InlineGreedyStringParser(object, ptr, size, ctx);
        ptr += size;
        break;
      }
      // optional string address = 3;
      case 3: {
        if (static_cast<::google::protobuf::uint8>(tag) != 26) goto handle_unusual;
        ptr = ::google::protobuf::io::ReadSize(ptr, &size);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        ctx->extra_parse_data().SetFieldName("hw.trezor.messages.ethereum.EthereumMessageSignature.address");
        object = msg->mutable_address();
        if (size > end - ptr + ::google::protobuf::internal::ParseContext::kSlopBytes) {
          parser_till_end = ::google::protobuf::internal::GreedyStringParserUTF8Verify;
          goto string_till_end;
        }
        GOOGLE_PROTOBUF_PARSER_ASSERT(::google::protobuf::internal::StringCheckUTF8Verify(ptr, size, ctx));
        ::google::protobuf::internal::InlineGreedyStringParser(object, ptr, size, ctx);
        ptr += size;
        break;
      }
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->EndGroup(tag);
          return ptr;
        }
        auto res = UnknownFieldParse(tag, {_InternalParse, msg},
          ptr, end, msg->_internal_metadata_.mutable_unknown_fields(), ctx);
        ptr = res.first;
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr != nullptr);
        if (res.second) return ptr;
      }
    }  // switch
  }  // while
  return ptr;
string_till_end:
  static_cast<::std::string*>(object)->clear();
  static_cast<::std::string*>(object)->reserve(size);
  goto len_delim_till_end;
len_delim_till_end:
  return ctx->StoreAndTailCall(ptr, end, {_InternalParse, msg},
                               {parser_till_end, object}, size);
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool EthereumMessageSignature::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:hw.trezor.messages.ethereum.EthereumMessageSignature)
  for (;;) {
    ::std::pair<::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional bytes signature = 2;
      case 2: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (18 & 0xFF)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_signature()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional string address = 3;
      case 3: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (26 & 0xFF)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_address()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->address().data(), static_cast<int>(this->address().length()),
            ::google::protobuf::internal::WireFormat::PARSE,
            "hw.trezor.messages.ethereum.EthereumMessageSignature.address");
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, _internal_metadata_.mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:hw.trezor.messages.ethereum.EthereumMessageSignature)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:hw.trezor.messages.ethereum.EthereumMessageSignature)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void EthereumMessageSignature::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:hw.trezor.messages.ethereum.EthereumMessageSignature)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional bytes signature = 2;
  if (cached_has_bits & 0x00000001u) {
    ::google::protobuf::internal::WireFormatLite::WriteBytesMaybeAliased(
      2, this->signature(), output);
  }

  // optional string address = 3;
  if (cached_has_bits & 0x00000002u) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->address().data(), static_cast<int>(this->address().length()),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "hw.trezor.messages.ethereum.EthereumMessageSignature.address");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      3, this->address(), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        _internal_metadata_.unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:hw.trezor.messages.ethereum.EthereumMessageSignature)
}

::google::protobuf::uint8* EthereumMessageSignature::InternalSerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:hw.trezor.messages.ethereum.EthereumMessageSignature)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional bytes signature = 2;
  if (cached_has_bits & 0x00000001u) {
    target =
      ::google::protobuf::internal::WireFormatLite::WriteBytesToArray(
        2, this->signature(), target);
  }

  // optional string address = 3;
  if (cached_has_bits & 0x00000002u) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->address().data(), static_cast<int>(this->address().length()),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "hw.trezor.messages.ethereum.EthereumMessageSignature.address");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        3, this->address(), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:hw.trezor.messages.ethereum.EthereumMessageSignature)
  return target;
}

size_t EthereumMessageSignature::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:hw.trezor.messages.ethereum.EthereumMessageSignature)
  size_t total_size = 0;

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        _internal_metadata_.unknown_fields());
  }
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional bytes signature = 2;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->signature());
    }

    // optional string address = 3;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->address());
    }

  }
  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void EthereumMessageSignature::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:hw.trezor.messages.ethereum.EthereumMessageSignature)
  GOOGLE_DCHECK_NE(&from, this);
  const EthereumMessageSignature* source =
      ::google::protobuf::DynamicCastToGenerated<EthereumMessageSignature>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:hw.trezor.messages.ethereum.EthereumMessageSignature)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:hw.trezor.messages.ethereum.EthereumMessageSignature)
    MergeFrom(*source);
  }
}

void EthereumMessageSignature::MergeFrom(const EthereumMessageSignature& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:hw.trezor.messages.ethereum.EthereumMessageSignature)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _has_bits_[0] |= 0x00000001u;
      signature_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.signature_);
    }
    if (cached_has_bits & 0x00000002u) {
      _has_bits_[0] |= 0x00000002u;
      address_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.address_);
    }
  }
}

void EthereumMessageSignature::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:hw.trezor.messages.ethereum.EthereumMessageSignature)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void EthereumMessageSignature::CopyFrom(const EthereumMessageSignature& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:hw.trezor.messages.ethereum.EthereumMessageSignature)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool EthereumMessageSignature::IsInitialized() const {
  return true;
}

void EthereumMessageSignature::Swap(EthereumMessageSignature* other) {
  if (other == this) return;
  InternalSwap(other);
}
void EthereumMessageSignature::InternalSwap(EthereumMessageSignature* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  signature_.Swap(&other->signature_, &::google::protobuf::internal::GetEmptyStringAlreadyInited(),
    GetArenaNoVirtual());
  address_.Swap(&other->address_, &::google::protobuf::internal::GetEmptyStringAlreadyInited(),
    GetArenaNoVirtual());
}

::google::protobuf::Metadata EthereumMessageSignature::GetMetadata() const {
  ::google::protobuf::internal::AssignDescriptors(&::assign_descriptors_table_messages_2dethereum_2eproto);
  return ::file_level_metadata_messages_2dethereum_2eproto[kIndexInFileMessages];
}


// ===================================================================

void EthereumVerifyMessage::InitAsDefaultInstance() {
}
class EthereumVerifyMessage::HasBitSetters {
 public:
  static void set_has_signature(EthereumVerifyMessage* msg) {
    msg->_has_bits_[0] |= 0x00000001u;
  }
  static void set_has_message(EthereumVerifyMessage* msg) {
    msg->_has_bits_[0] |= 0x00000002u;
  }
  static void set_has_address(EthereumVerifyMessage* msg) {
    msg->_has_bits_[0] |= 0x00000004u;
  }
};

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int EthereumVerifyMessage::kSignatureFieldNumber;
const int EthereumVerifyMessage::kMessageFieldNumber;
const int EthereumVerifyMessage::kAddressFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

EthereumVerifyMessage::EthereumVerifyMessage()
  : ::google::protobuf::Message(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:hw.trezor.messages.ethereum.EthereumVerifyMessage)
}
EthereumVerifyMessage::EthereumVerifyMessage(const EthereumVerifyMessage& from)
  : ::google::protobuf::Message(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  signature_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (from.has_signature()) {
    signature_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.signature_);
  }
  message_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (from.has_message()) {
    message_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.message_);
  }
  address_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (from.has_address()) {
    address_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.address_);
  }
  // @@protoc_insertion_point(copy_constructor:hw.trezor.messages.ethereum.EthereumVerifyMessage)
}

void EthereumVerifyMessage::SharedCtor() {
  ::google::protobuf::internal::InitSCC(
      &scc_info_EthereumVerifyMessage_messages_2dethereum_2eproto.base);
  signature_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  message_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  address_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}

EthereumVerifyMessage::~EthereumVerifyMessage() {
  // @@protoc_insertion_point(destructor:hw.trezor.messages.ethereum.EthereumVerifyMessage)
  SharedDtor();
}

void EthereumVerifyMessage::SharedDtor() {
  signature_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  message_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  address_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}

void EthereumVerifyMessage::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const EthereumVerifyMessage& EthereumVerifyMessage::default_instance() {
  ::google::protobuf::internal::InitSCC(&::scc_info_EthereumVerifyMessage_messages_2dethereum_2eproto.base);
  return *internal_default_instance();
}


void EthereumVerifyMessage::Clear() {
// @@protoc_insertion_point(message_clear_start:hw.trezor.messages.ethereum.EthereumVerifyMessage)
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      signature_.ClearNonDefaultToEmptyNoArena();
    }
    if (cached_has_bits & 0x00000002u) {
      message_.ClearNonDefaultToEmptyNoArena();
    }
    if (cached_has_bits & 0x00000004u) {
      address_.ClearNonDefaultToEmptyNoArena();
    }
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* EthereumVerifyMessage::_InternalParse(const char* begin, const char* end, void* object,
                  ::google::protobuf::internal::ParseContext* ctx) {
  auto msg = static_cast<EthereumVerifyMessage*>(object);
  ::google::protobuf::int32 size; (void)size;
  int depth; (void)depth;
  ::google::protobuf::uint32 tag;
  ::google::protobuf::internal::ParseFunc parser_till_end; (void)parser_till_end;
  auto ptr = begin;
  while (ptr < end) {
    ptr = ::google::protobuf::io::Parse32(ptr, &tag);
    GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
    switch (tag >> 3) {
      // optional bytes signature = 2;
      case 2: {
        if (static_cast<::google::protobuf::uint8>(tag) != 18) goto handle_unusual;
        ptr = ::google::protobuf::io::ReadSize(ptr, &size);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        object = msg->mutable_signature();
        if (size > end - ptr + ::google::protobuf::internal::ParseContext::kSlopBytes) {
          parser_till_end = ::google::protobuf::internal::GreedyStringParser;
          goto string_till_end;
        }
        GOOGLE_PROTOBUF_PARSER_ASSERT(::google::protobuf::internal::StringCheck(ptr, size, ctx));
        ::google::protobuf::internal::InlineGreedyStringParser(object, ptr, size, ctx);
        ptr += size;
        break;
      }
      // optional bytes message = 3;
      case 3: {
        if (static_cast<::google::protobuf::uint8>(tag) != 26) goto handle_unusual;
        ptr = ::google::protobuf::io::ReadSize(ptr, &size);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        object = msg->mutable_message();
        if (size > end - ptr + ::google::protobuf::internal::ParseContext::kSlopBytes) {
          parser_till_end = ::google::protobuf::internal::GreedyStringParser;
          goto string_till_end;
        }
        GOOGLE_PROTOBUF_PARSER_ASSERT(::google::protobuf::internal::StringCheck(ptr, size, ctx));
        ::google::protobuf::internal::InlineGreedyStringParser(object, ptr, size, ctx);
        ptr += size;
        break;
      }
      // optional string address = 4;
      case 4: {
        if (static_cast<::google::protobuf::uint8>(tag) != 34) goto handle_unusual;
        ptr = ::google::protobuf::io::ReadSize(ptr, &size);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        ctx->extra_parse_data().SetFieldName("hw.trezor.messages.ethereum.EthereumVerifyMessage.address");
        object = msg->mutable_address();
        if (size > end - ptr + ::google::protobuf::internal::ParseContext::kSlopBytes) {
          parser_till_end = ::google::protobuf::internal::GreedyStringParserUTF8Verify;
          goto string_till_end;
        }
        GOOGLE_PROTOBUF_PARSER_ASSERT(::google::protobuf::internal::StringCheckUTF8Verify(ptr, size, ctx));
        ::google::protobuf::internal::InlineGreedyStringParser(object, ptr, size, ctx);
        ptr += size;
        break;
      }
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->EndGroup(tag);
          return ptr;
        }
        auto res = UnknownFieldParse(tag, {_InternalParse, msg},
          ptr, end, msg->_internal_metadata_.mutable_unknown_fields(), ctx);
        ptr = res.first;
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr != nullptr);
        if (res.second) return ptr;
      }
    }  // switch
  }  // while
  return ptr;
string_till_end:
  static_cast<::std::string*>(object)->clear();
  static_cast<::std::string*>(object)->reserve(size);
  goto len_delim_till_end;
len_delim_till_end:
  return ctx->StoreAndTailCall(ptr, end, {_InternalParse, msg},
                               {parser_till_end, object}, size);
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool EthereumVerifyMessage::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:hw.trezor.messages.ethereum.EthereumVerifyMessage)
  for (;;) {
    ::std::pair<::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional bytes signature = 2;
      case 2: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (18 & 0xFF)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_signature()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional bytes message = 3;
      case 3: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (26 & 0xFF)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_message()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional string address = 4;
      case 4: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (34 & 0xFF)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_address()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->address().data(), static_cast<int>(this->address().length()),
            ::google::protobuf::internal::WireFormat::PARSE,
            "hw.trezor.messages.ethereum.EthereumVerifyMessage.address");
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, _internal_metadata_.mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:hw.trezor.messages.ethereum.EthereumVerifyMessage)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:hw.trezor.messages.ethereum.EthereumVerifyMessage)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void EthereumVerifyMessage::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:hw.trezor.messages.ethereum.EthereumVerifyMessage)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional bytes signature = 2;
  if (cached_has_bits & 0x00000001u) {
    ::google::protobuf::internal::WireFormatLite::WriteBytesMaybeAliased(
      2, this->signature(), output);
  }

  // optional bytes message = 3;
  if (cached_has_bits & 0x00000002u) {
    ::google::protobuf::internal::WireFormatLite::WriteBytesMaybeAliased(
      3, this->message(), output);
  }

  // optional string address = 4;
  if (cached_has_bits & 0x00000004u) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->address().data(), static_cast<int>(this->address().length()),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "hw.trezor.messages.ethereum.EthereumVerifyMessage.address");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      4, this->address(), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        _internal_metadata_.unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:hw.trezor.messages.ethereum.EthereumVerifyMessage)
}

::google::protobuf::uint8* EthereumVerifyMessage::InternalSerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:hw.trezor.messages.ethereum.EthereumVerifyMessage)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional bytes signature = 2;
  if (cached_has_bits & 0x00000001u) {
    target =
      ::google::protobuf::internal::WireFormatLite::WriteBytesToArray(
        2, this->signature(), target);
  }

  // optional bytes message = 3;
  if (cached_has_bits & 0x00000002u) {
    target =
      ::google::protobuf::internal::WireFormatLite::WriteBytesToArray(
        3, this->message(), target);
  }

  // optional string address = 4;
  if (cached_has_bits & 0x00000004u) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->address().data(), static_cast<int>(this->address().length()),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "hw.trezor.messages.ethereum.EthereumVerifyMessage.address");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        4, this->address(), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:hw.trezor.messages.ethereum.EthereumVerifyMessage)
  return target;
}

size_t EthereumVerifyMessage::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:hw.trezor.messages.ethereum.EthereumVerifyMessage)
  size_t total_size = 0;

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        _internal_metadata_.unknown_fields());
  }
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional bytes signature = 2;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->signature());
    }

    // optional bytes message = 3;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->message());
    }

    // optional string address = 4;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->address());
    }

  }
  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void EthereumVerifyMessage::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:hw.trezor.messages.ethereum.EthereumVerifyMessage)
  GOOGLE_DCHECK_NE(&from, this);
  const EthereumVerifyMessage* source =
      ::google::protobuf::DynamicCastToGenerated<EthereumVerifyMessage>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:hw.trezor.messages.ethereum.EthereumVerifyMessage)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:hw.trezor.messages.ethereum.EthereumVerifyMessage)
    MergeFrom(*source);
  }
}

void EthereumVerifyMessage::MergeFrom(const EthereumVerifyMessage& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:hw.trezor.messages.ethereum.EthereumVerifyMessage)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _has_bits_[0] |= 0x00000001u;
      signature_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.signature_);
    }
    if (cached_has_bits & 0x00000002u) {
      _has_bits_[0] |= 0x00000002u;
      message_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.message_);
    }
    if (cached_has_bits & 0x00000004u) {
      _has_bits_[0] |= 0x00000004u;
      address_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.address_);
    }
  }
}

void EthereumVerifyMessage::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:hw.trezor.messages.ethereum.EthereumVerifyMessage)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void EthereumVerifyMessage::CopyFrom(const EthereumVerifyMessage& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:hw.trezor.messages.ethereum.EthereumVerifyMessage)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool EthereumVerifyMessage::IsInitialized() const {
  return true;
}

void EthereumVerifyMessage::Swap(EthereumVerifyMessage* other) {
  if (other == this) return;
  InternalSwap(other);
}
void EthereumVerifyMessage::InternalSwap(EthereumVerifyMessage* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  signature_.Swap(&other->signature_, &::google::protobuf::internal::GetEmptyStringAlreadyInited(),
    GetArenaNoVirtual());
  message_.Swap(&other->message_, &::google::protobuf::internal::GetEmptyStringAlreadyInited(),
    GetArenaNoVirtual());
  address_.Swap(&other->address_, &::google::protobuf::internal::GetEmptyStringAlreadyInited(),
    GetArenaNoVirtual());
}

::google::protobuf::Metadata EthereumVerifyMessage::GetMetadata() const {
  ::google::protobuf::internal::AssignDescriptors(&::assign_descriptors_table_messages_2dethereum_2eproto);
  return ::file_level_metadata_messages_2dethereum_2eproto[kIndexInFileMessages];
}


// @@protoc_insertion_point(namespace_scope)
}  // namespace ethereum
}  // namespace messages
}  // namespace trezor
}  // namespace hw
namespace google {
namespace protobuf {
template<> PROTOBUF_NOINLINE ::hw::trezor::messages::ethereum::EthereumGetPublicKey* Arena::CreateMaybeMessage< ::hw::trezor::messages::ethereum::EthereumGetPublicKey >(Arena* arena) {
  return Arena::CreateInternal< ::hw::trezor::messages::ethereum::EthereumGetPublicKey >(arena);
}
template<> PROTOBUF_NOINLINE ::hw::trezor::messages::ethereum::EthereumPublicKey* Arena::CreateMaybeMessage< ::hw::trezor::messages::ethereum::EthereumPublicKey >(Arena* arena) {
  return Arena::CreateInternal< ::hw::trezor::messages::ethereum::EthereumPublicKey >(arena);
}
template<> PROTOBUF_NOINLINE ::hw::trezor::messages::ethereum::EthereumGetAddress* Arena::CreateMaybeMessage< ::hw::trezor::messages::ethereum::EthereumGetAddress >(Arena* arena) {
  return Arena::CreateInternal< ::hw::trezor::messages::ethereum::EthereumGetAddress >(arena);
}
template<> PROTOBUF_NOINLINE ::hw::trezor::messages::ethereum::EthereumAddress* Arena::CreateMaybeMessage< ::hw::trezor::messages::ethereum::EthereumAddress >(Arena* arena) {
  return Arena::CreateInternal< ::hw::trezor::messages::ethereum::EthereumAddress >(arena);
}
template<> PROTOBUF_NOINLINE ::hw::trezor::messages::ethereum::EthereumSignTx* Arena::CreateMaybeMessage< ::hw::trezor::messages::ethereum::EthereumSignTx >(Arena* arena) {
  return Arena::CreateInternal< ::hw::trezor::messages::ethereum::EthereumSignTx >(arena);
}
template<> PROTOBUF_NOINLINE ::hw::trezor::messages::ethereum::EthereumTxRequest* Arena::CreateMaybeMessage< ::hw::trezor::messages::ethereum::EthereumTxRequest >(Arena* arena) {
  return Arena::CreateInternal< ::hw::trezor::messages::ethereum::EthereumTxRequest >(arena);
}
template<> PROTOBUF_NOINLINE ::hw::trezor::messages::ethereum::EthereumTxAck* Arena::CreateMaybeMessage< ::hw::trezor::messages::ethereum::EthereumTxAck >(Arena* arena) {
  return Arena::CreateInternal< ::hw::trezor::messages::ethereum::EthereumTxAck >(arena);
}
template<> PROTOBUF_NOINLINE ::hw::trezor::messages::ethereum::EthereumSignMessage* Arena::CreateMaybeMessage< ::hw::trezor::messages::ethereum::EthereumSignMessage >(Arena* arena) {
  return Arena::CreateInternal< ::hw::trezor::messages::ethereum::EthereumSignMessage >(arena);
}
template<> PROTOBUF_NOINLINE ::hw::trezor::messages::ethereum::EthereumMessageSignature* Arena::CreateMaybeMessage< ::hw::trezor::messages::ethereum::EthereumMessageSignature >(Arena* arena) {
  return Arena::CreateInternal< ::hw::trezor::messages::ethereum::EthereumMessageSignature >(arena);
}
template<> PROTOBUF_NOINLINE ::hw::trezor::messages::ethereum::EthereumVerifyMessage* Arena::CreateMaybeMessage< ::hw::trezor::messages::ethereum::EthereumVerifyMessage >(Arena* arena) {
  return Arena::CreateInternal< ::hw::trezor::messages::ethereum::EthereumVerifyMessage >(arena);
}
}  // namespace protobuf
}  // namespace google

// @@protoc_insertion_point(global_scope)
#include <google/protobuf/port_undef.inc>
