// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: messages-cardano.proto

#ifndef PROTOBUF_INCLUDED_messages_2dcardano_2eproto
#define PROTOBUF_INCLUDED_messages_2dcardano_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3007000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3007000 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/unknown_field_set.h>
#include "messages-common.pb.h"
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_messages_2dcardano_2eproto

// Internal implementation detail -- do not use these members.
struct TableStruct_messages_2dcardano_2eproto {
  static const ::google::protobuf::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::google::protobuf::internal::ParseTable schema[10]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::google::protobuf::internal::FieldMetadata field_metadata[];
  static const ::google::protobuf::internal::SerializationTable serialization_table[];
  static const ::google::protobuf::uint32 offsets[];
};
void AddDescriptors_messages_2dcardano_2eproto();
namespace hw {
namespace trezor {
namespace messages {
namespace cardano {
class CardanoAddress;
class CardanoAddressDefaultTypeInternal;
extern CardanoAddressDefaultTypeInternal _CardanoAddress_default_instance_;
class CardanoGetAddress;
class CardanoGetAddressDefaultTypeInternal;
extern CardanoGetAddressDefaultTypeInternal _CardanoGetAddress_default_instance_;
class CardanoGetPublicKey;
class CardanoGetPublicKeyDefaultTypeInternal;
extern CardanoGetPublicKeyDefaultTypeInternal _CardanoGetPublicKey_default_instance_;
class CardanoPublicKey;
class CardanoPublicKeyDefaultTypeInternal;
extern CardanoPublicKeyDefaultTypeInternal _CardanoPublicKey_default_instance_;
class CardanoSignTx;
class CardanoSignTxDefaultTypeInternal;
extern CardanoSignTxDefaultTypeInternal _CardanoSignTx_default_instance_;
class CardanoSignTx_CardanoTxInputType;
class CardanoSignTx_CardanoTxInputTypeDefaultTypeInternal;
extern CardanoSignTx_CardanoTxInputTypeDefaultTypeInternal _CardanoSignTx_CardanoTxInputType_default_instance_;
class CardanoSignTx_CardanoTxOutputType;
class CardanoSignTx_CardanoTxOutputTypeDefaultTypeInternal;
extern CardanoSignTx_CardanoTxOutputTypeDefaultTypeInternal _CardanoSignTx_CardanoTxOutputType_default_instance_;
class CardanoSignedTx;
class CardanoSignedTxDefaultTypeInternal;
extern CardanoSignedTxDefaultTypeInternal _CardanoSignedTx_default_instance_;
class CardanoTxAck;
class CardanoTxAckDefaultTypeInternal;
extern CardanoTxAckDefaultTypeInternal _CardanoTxAck_default_instance_;
class CardanoTxRequest;
class CardanoTxRequestDefaultTypeInternal;
extern CardanoTxRequestDefaultTypeInternal _CardanoTxRequest_default_instance_;
}  // namespace cardano
}  // namespace messages
}  // namespace trezor
}  // namespace hw
namespace google {
namespace protobuf {
template<> ::hw::trezor::messages::cardano::CardanoAddress* Arena::CreateMaybeMessage<::hw::trezor::messages::cardano::CardanoAddress>(Arena*);
template<> ::hw::trezor::messages::cardano::CardanoGetAddress* Arena::CreateMaybeMessage<::hw::trezor::messages::cardano::CardanoGetAddress>(Arena*);
template<> ::hw::trezor::messages::cardano::CardanoGetPublicKey* Arena::CreateMaybeMessage<::hw::trezor::messages::cardano::CardanoGetPublicKey>(Arena*);
template<> ::hw::trezor::messages::cardano::CardanoPublicKey* Arena::CreateMaybeMessage<::hw::trezor::messages::cardano::CardanoPublicKey>(Arena*);
template<> ::hw::trezor::messages::cardano::CardanoSignTx* Arena::CreateMaybeMessage<::hw::trezor::messages::cardano::CardanoSignTx>(Arena*);
template<> ::hw::trezor::messages::cardano::CardanoSignTx_CardanoTxInputType* Arena::CreateMaybeMessage<::hw::trezor::messages::cardano::CardanoSignTx_CardanoTxInputType>(Arena*);
template<> ::hw::trezor::messages::cardano::CardanoSignTx_CardanoTxOutputType* Arena::CreateMaybeMessage<::hw::trezor::messages::cardano::CardanoSignTx_CardanoTxOutputType>(Arena*);
template<> ::hw::trezor::messages::cardano::CardanoSignedTx* Arena::CreateMaybeMessage<::hw::trezor::messages::cardano::CardanoSignedTx>(Arena*);
template<> ::hw::trezor::messages::cardano::CardanoTxAck* Arena::CreateMaybeMessage<::hw::trezor::messages::cardano::CardanoTxAck>(Arena*);
template<> ::hw::trezor::messages::cardano::CardanoTxRequest* Arena::CreateMaybeMessage<::hw::trezor::messages::cardano::CardanoTxRequest>(Arena*);
}  // namespace protobuf
}  // namespace google
namespace hw {
namespace trezor {
namespace messages {
namespace cardano {

// ===================================================================

class CardanoGetAddress final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:hw.trezor.messages.cardano.CardanoGetAddress) */ {
 public:
  CardanoGetAddress();
  virtual ~CardanoGetAddress();

  CardanoGetAddress(const CardanoGetAddress& from);

  inline CardanoGetAddress& operator=(const CardanoGetAddress& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  CardanoGetAddress(CardanoGetAddress&& from) noexcept
    : CardanoGetAddress() {
    *this = ::std::move(from);
  }

  inline CardanoGetAddress& operator=(CardanoGetAddress&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const CardanoGetAddress& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CardanoGetAddress* internal_default_instance() {
    return reinterpret_cast<const CardanoGetAddress*>(
               &_CardanoGetAddress_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  void Swap(CardanoGetAddress* other);
  friend void swap(CardanoGetAddress& a, CardanoGetAddress& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline CardanoGetAddress* New() const final {
    return CreateMaybeMessage<CardanoGetAddress>(nullptr);
  }

  CardanoGetAddress* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<CardanoGetAddress>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const CardanoGetAddress& from);
  void MergeFrom(const CardanoGetAddress& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CardanoGetAddress* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated uint32 address_n = 1;
  int address_n_size() const;
  void clear_address_n();
  static const int kAddressNFieldNumber = 1;
  ::google::protobuf::uint32 address_n(int index) const;
  void set_address_n(int index, ::google::protobuf::uint32 value);
  void add_address_n(::google::protobuf::uint32 value);
  const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      address_n() const;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable_address_n();

  // optional bool show_display = 2;
  bool has_show_display() const;
  void clear_show_display();
  static const int kShowDisplayFieldNumber = 2;
  bool show_display() const;
  void set_show_display(bool value);

  // @@protoc_insertion_point(class_scope:hw.trezor.messages.cardano.CardanoGetAddress)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > address_n_;
  bool show_display_;
  friend struct ::TableStruct_messages_2dcardano_2eproto;
};
// -------------------------------------------------------------------

class CardanoAddress final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:hw.trezor.messages.cardano.CardanoAddress) */ {
 public:
  CardanoAddress();
  virtual ~CardanoAddress();

  CardanoAddress(const CardanoAddress& from);

  inline CardanoAddress& operator=(const CardanoAddress& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  CardanoAddress(CardanoAddress&& from) noexcept
    : CardanoAddress() {
    *this = ::std::move(from);
  }

  inline CardanoAddress& operator=(CardanoAddress&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const CardanoAddress& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CardanoAddress* internal_default_instance() {
    return reinterpret_cast<const CardanoAddress*>(
               &_CardanoAddress_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  void Swap(CardanoAddress* other);
  friend void swap(CardanoAddress& a, CardanoAddress& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline CardanoAddress* New() const final {
    return CreateMaybeMessage<CardanoAddress>(nullptr);
  }

  CardanoAddress* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<CardanoAddress>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const CardanoAddress& from);
  void MergeFrom(const CardanoAddress& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CardanoAddress* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string address = 1;
  bool has_address() const;
  void clear_address();
  static const int kAddressFieldNumber = 1;
  const ::std::string& address() const;
  void set_address(const ::std::string& value);
  #if LANG_CXX11
  void set_address(::std::string&& value);
  #endif
  void set_address(const char* value);
  void set_address(const char* value, size_t size);
  ::std::string* mutable_address();
  ::std::string* release_address();
  void set_allocated_address(::std::string* address);

  // @@protoc_insertion_point(class_scope:hw.trezor.messages.cardano.CardanoAddress)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr address_;
  friend struct ::TableStruct_messages_2dcardano_2eproto;
};
// -------------------------------------------------------------------

class CardanoGetPublicKey final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:hw.trezor.messages.cardano.CardanoGetPublicKey) */ {
 public:
  CardanoGetPublicKey();
  virtual ~CardanoGetPublicKey();

  CardanoGetPublicKey(const CardanoGetPublicKey& from);

  inline CardanoGetPublicKey& operator=(const CardanoGetPublicKey& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  CardanoGetPublicKey(CardanoGetPublicKey&& from) noexcept
    : CardanoGetPublicKey() {
    *this = ::std::move(from);
  }

  inline CardanoGetPublicKey& operator=(CardanoGetPublicKey&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const CardanoGetPublicKey& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CardanoGetPublicKey* internal_default_instance() {
    return reinterpret_cast<const CardanoGetPublicKey*>(
               &_CardanoGetPublicKey_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  void Swap(CardanoGetPublicKey* other);
  friend void swap(CardanoGetPublicKey& a, CardanoGetPublicKey& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline CardanoGetPublicKey* New() const final {
    return CreateMaybeMessage<CardanoGetPublicKey>(nullptr);
  }

  CardanoGetPublicKey* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<CardanoGetPublicKey>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const CardanoGetPublicKey& from);
  void MergeFrom(const CardanoGetPublicKey& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CardanoGetPublicKey* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated uint32 address_n = 1;
  int address_n_size() const;
  void clear_address_n();
  static const int kAddressNFieldNumber = 1;
  ::google::protobuf::uint32 address_n(int index) const;
  void set_address_n(int index, ::google::protobuf::uint32 value);
  void add_address_n(::google::protobuf::uint32 value);
  const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      address_n() const;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable_address_n();

  // optional bool show_display = 2;
  bool has_show_display() const;
  void clear_show_display();
  static const int kShowDisplayFieldNumber = 2;
  bool show_display() const;
  void set_show_display(bool value);

  // @@protoc_insertion_point(class_scope:hw.trezor.messages.cardano.CardanoGetPublicKey)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > address_n_;
  bool show_display_;
  friend struct ::TableStruct_messages_2dcardano_2eproto;
};
// -------------------------------------------------------------------

class CardanoPublicKey final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:hw.trezor.messages.cardano.CardanoPublicKey) */ {
 public:
  CardanoPublicKey();
  virtual ~CardanoPublicKey();

  CardanoPublicKey(const CardanoPublicKey& from);

  inline CardanoPublicKey& operator=(const CardanoPublicKey& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  CardanoPublicKey(CardanoPublicKey&& from) noexcept
    : CardanoPublicKey() {
    *this = ::std::move(from);
  }

  inline CardanoPublicKey& operator=(CardanoPublicKey&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const CardanoPublicKey& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CardanoPublicKey* internal_default_instance() {
    return reinterpret_cast<const CardanoPublicKey*>(
               &_CardanoPublicKey_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  void Swap(CardanoPublicKey* other);
  friend void swap(CardanoPublicKey& a, CardanoPublicKey& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline CardanoPublicKey* New() const final {
    return CreateMaybeMessage<CardanoPublicKey>(nullptr);
  }

  CardanoPublicKey* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<CardanoPublicKey>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const CardanoPublicKey& from);
  void MergeFrom(const CardanoPublicKey& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CardanoPublicKey* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string xpub = 1;
  bool has_xpub() const;
  void clear_xpub();
  static const int kXpubFieldNumber = 1;
  const ::std::string& xpub() const;
  void set_xpub(const ::std::string& value);
  #if LANG_CXX11
  void set_xpub(::std::string&& value);
  #endif
  void set_xpub(const char* value);
  void set_xpub(const char* value, size_t size);
  ::std::string* mutable_xpub();
  ::std::string* release_xpub();
  void set_allocated_xpub(::std::string* xpub);

  // optional .hw.trezor.messages.common.HDNodeType node = 2;
  bool has_node() const;
  void clear_node();
  static const int kNodeFieldNumber = 2;
  const ::hw::trezor::messages::common::HDNodeType& node() const;
  ::hw::trezor::messages::common::HDNodeType* release_node();
  ::hw::trezor::messages::common::HDNodeType* mutable_node();
  void set_allocated_node(::hw::trezor::messages::common::HDNodeType* node);

  // @@protoc_insertion_point(class_scope:hw.trezor.messages.cardano.CardanoPublicKey)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr xpub_;
  ::hw::trezor::messages::common::HDNodeType* node_;
  friend struct ::TableStruct_messages_2dcardano_2eproto;
};
// -------------------------------------------------------------------

class CardanoSignTx_CardanoTxInputType final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:hw.trezor.messages.cardano.CardanoSignTx.CardanoTxInputType) */ {
 public:
  CardanoSignTx_CardanoTxInputType();
  virtual ~CardanoSignTx_CardanoTxInputType();

  CardanoSignTx_CardanoTxInputType(const CardanoSignTx_CardanoTxInputType& from);

  inline CardanoSignTx_CardanoTxInputType& operator=(const CardanoSignTx_CardanoTxInputType& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  CardanoSignTx_CardanoTxInputType(CardanoSignTx_CardanoTxInputType&& from) noexcept
    : CardanoSignTx_CardanoTxInputType() {
    *this = ::std::move(from);
  }

  inline CardanoSignTx_CardanoTxInputType& operator=(CardanoSignTx_CardanoTxInputType&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const CardanoSignTx_CardanoTxInputType& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CardanoSignTx_CardanoTxInputType* internal_default_instance() {
    return reinterpret_cast<const CardanoSignTx_CardanoTxInputType*>(
               &_CardanoSignTx_CardanoTxInputType_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  void Swap(CardanoSignTx_CardanoTxInputType* other);
  friend void swap(CardanoSignTx_CardanoTxInputType& a, CardanoSignTx_CardanoTxInputType& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline CardanoSignTx_CardanoTxInputType* New() const final {
    return CreateMaybeMessage<CardanoSignTx_CardanoTxInputType>(nullptr);
  }

  CardanoSignTx_CardanoTxInputType* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<CardanoSignTx_CardanoTxInputType>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const CardanoSignTx_CardanoTxInputType& from);
  void MergeFrom(const CardanoSignTx_CardanoTxInputType& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CardanoSignTx_CardanoTxInputType* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated uint32 address_n = 1;
  int address_n_size() const;
  void clear_address_n();
  static const int kAddressNFieldNumber = 1;
  ::google::protobuf::uint32 address_n(int index) const;
  void set_address_n(int index, ::google::protobuf::uint32 value);
  void add_address_n(::google::protobuf::uint32 value);
  const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      address_n() const;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable_address_n();

  // optional bytes prev_hash = 2;
  bool has_prev_hash() const;
  void clear_prev_hash();
  static const int kPrevHashFieldNumber = 2;
  const ::std::string& prev_hash() const;
  void set_prev_hash(const ::std::string& value);
  #if LANG_CXX11
  void set_prev_hash(::std::string&& value);
  #endif
  void set_prev_hash(const char* value);
  void set_prev_hash(const void* value, size_t size);
  ::std::string* mutable_prev_hash();
  ::std::string* release_prev_hash();
  void set_allocated_prev_hash(::std::string* prev_hash);

  // optional uint32 prev_index = 3;
  bool has_prev_index() const;
  void clear_prev_index();
  static const int kPrevIndexFieldNumber = 3;
  ::google::protobuf::uint32 prev_index() const;
  void set_prev_index(::google::protobuf::uint32 value);

  // optional uint32 type = 4;
  bool has_type() const;
  void clear_type();
  static const int kTypeFieldNumber = 4;
  ::google::protobuf::uint32 type() const;
  void set_type(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:hw.trezor.messages.cardano.CardanoSignTx.CardanoTxInputType)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > address_n_;
  ::google::protobuf::internal::ArenaStringPtr prev_hash_;
  ::google::protobuf::uint32 prev_index_;
  ::google::protobuf::uint32 type_;
  friend struct ::TableStruct_messages_2dcardano_2eproto;
};
// -------------------------------------------------------------------

class CardanoSignTx_CardanoTxOutputType final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:hw.trezor.messages.cardano.CardanoSignTx.CardanoTxOutputType) */ {
 public:
  CardanoSignTx_CardanoTxOutputType();
  virtual ~CardanoSignTx_CardanoTxOutputType();

  CardanoSignTx_CardanoTxOutputType(const CardanoSignTx_CardanoTxOutputType& from);

  inline CardanoSignTx_CardanoTxOutputType& operator=(const CardanoSignTx_CardanoTxOutputType& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  CardanoSignTx_CardanoTxOutputType(CardanoSignTx_CardanoTxOutputType&& from) noexcept
    : CardanoSignTx_CardanoTxOutputType() {
    *this = ::std::move(from);
  }

  inline CardanoSignTx_CardanoTxOutputType& operator=(CardanoSignTx_CardanoTxOutputType&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const CardanoSignTx_CardanoTxOutputType& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CardanoSignTx_CardanoTxOutputType* internal_default_instance() {
    return reinterpret_cast<const CardanoSignTx_CardanoTxOutputType*>(
               &_CardanoSignTx_CardanoTxOutputType_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  void Swap(CardanoSignTx_CardanoTxOutputType* other);
  friend void swap(CardanoSignTx_CardanoTxOutputType& a, CardanoSignTx_CardanoTxOutputType& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline CardanoSignTx_CardanoTxOutputType* New() const final {
    return CreateMaybeMessage<CardanoSignTx_CardanoTxOutputType>(nullptr);
  }

  CardanoSignTx_CardanoTxOutputType* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<CardanoSignTx_CardanoTxOutputType>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const CardanoSignTx_CardanoTxOutputType& from);
  void MergeFrom(const CardanoSignTx_CardanoTxOutputType& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CardanoSignTx_CardanoTxOutputType* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated uint32 address_n = 2;
  int address_n_size() const;
  void clear_address_n();
  static const int kAddressNFieldNumber = 2;
  ::google::protobuf::uint32 address_n(int index) const;
  void set_address_n(int index, ::google::protobuf::uint32 value);
  void add_address_n(::google::protobuf::uint32 value);
  const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      address_n() const;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable_address_n();

  // optional string address = 1;
  bool has_address() const;
  void clear_address();
  static const int kAddressFieldNumber = 1;
  const ::std::string& address() const;
  void set_address(const ::std::string& value);
  #if LANG_CXX11
  void set_address(::std::string&& value);
  #endif
  void set_address(const char* value);
  void set_address(const char* value, size_t size);
  ::std::string* mutable_address();
  ::std::string* release_address();
  void set_allocated_address(::std::string* address);

  // optional uint64 amount = 3;
  bool has_amount() const;
  void clear_amount();
  static const int kAmountFieldNumber = 3;
  ::google::protobuf::uint64 amount() const;
  void set_amount(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:hw.trezor.messages.cardano.CardanoSignTx.CardanoTxOutputType)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > address_n_;
  ::google::protobuf::internal::ArenaStringPtr address_;
  ::google::protobuf::uint64 amount_;
  friend struct ::TableStruct_messages_2dcardano_2eproto;
};
// -------------------------------------------------------------------

class CardanoSignTx final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:hw.trezor.messages.cardano.CardanoSignTx) */ {
 public:
  CardanoSignTx();
  virtual ~CardanoSignTx();

  CardanoSignTx(const CardanoSignTx& from);

  inline CardanoSignTx& operator=(const CardanoSignTx& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  CardanoSignTx(CardanoSignTx&& from) noexcept
    : CardanoSignTx() {
    *this = ::std::move(from);
  }

  inline CardanoSignTx& operator=(CardanoSignTx&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const CardanoSignTx& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CardanoSignTx* internal_default_instance() {
    return reinterpret_cast<const CardanoSignTx*>(
               &_CardanoSignTx_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  void Swap(CardanoSignTx* other);
  friend void swap(CardanoSignTx& a, CardanoSignTx& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline CardanoSignTx* New() const final {
    return CreateMaybeMessage<CardanoSignTx>(nullptr);
  }

  CardanoSignTx* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<CardanoSignTx>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const CardanoSignTx& from);
  void MergeFrom(const CardanoSignTx& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CardanoSignTx* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef CardanoSignTx_CardanoTxInputType CardanoTxInputType;
  typedef CardanoSignTx_CardanoTxOutputType CardanoTxOutputType;

  // accessors -------------------------------------------------------

  // repeated .hw.trezor.messages.cardano.CardanoSignTx.CardanoTxInputType inputs = 1;
  int inputs_size() const;
  void clear_inputs();
  static const int kInputsFieldNumber = 1;
  ::hw::trezor::messages::cardano::CardanoSignTx_CardanoTxInputType* mutable_inputs(int index);
  ::google::protobuf::RepeatedPtrField< ::hw::trezor::messages::cardano::CardanoSignTx_CardanoTxInputType >*
      mutable_inputs();
  const ::hw::trezor::messages::cardano::CardanoSignTx_CardanoTxInputType& inputs(int index) const;
  ::hw::trezor::messages::cardano::CardanoSignTx_CardanoTxInputType* add_inputs();
  const ::google::protobuf::RepeatedPtrField< ::hw::trezor::messages::cardano::CardanoSignTx_CardanoTxInputType >&
      inputs() const;

  // repeated .hw.trezor.messages.cardano.CardanoSignTx.CardanoTxOutputType outputs = 2;
  int outputs_size() const;
  void clear_outputs();
  static const int kOutputsFieldNumber = 2;
  ::hw::trezor::messages::cardano::CardanoSignTx_CardanoTxOutputType* mutable_outputs(int index);
  ::google::protobuf::RepeatedPtrField< ::hw::trezor::messages::cardano::CardanoSignTx_CardanoTxOutputType >*
      mutable_outputs();
  const ::hw::trezor::messages::cardano::CardanoSignTx_CardanoTxOutputType& outputs(int index) const;
  ::hw::trezor::messages::cardano::CardanoSignTx_CardanoTxOutputType* add_outputs();
  const ::google::protobuf::RepeatedPtrField< ::hw::trezor::messages::cardano::CardanoSignTx_CardanoTxOutputType >&
      outputs() const;

  // optional uint32 transactions_count = 3;
  bool has_transactions_count() const;
  void clear_transactions_count();
  static const int kTransactionsCountFieldNumber = 3;
  ::google::protobuf::uint32 transactions_count() const;
  void set_transactions_count(::google::protobuf::uint32 value);

  // optional uint32 protocol_magic = 5;
  bool has_protocol_magic() const;
  void clear_protocol_magic();
  static const int kProtocolMagicFieldNumber = 5;
  ::google::protobuf::uint32 protocol_magic() const;
  void set_protocol_magic(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:hw.trezor.messages.cardano.CardanoSignTx)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::hw::trezor::messages::cardano::CardanoSignTx_CardanoTxInputType > inputs_;
  ::google::protobuf::RepeatedPtrField< ::hw::trezor::messages::cardano::CardanoSignTx_CardanoTxOutputType > outputs_;
  ::google::protobuf::uint32 transactions_count_;
  ::google::protobuf::uint32 protocol_magic_;
  friend struct ::TableStruct_messages_2dcardano_2eproto;
};
// -------------------------------------------------------------------

class CardanoTxRequest final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:hw.trezor.messages.cardano.CardanoTxRequest) */ {
 public:
  CardanoTxRequest();
  virtual ~CardanoTxRequest();

  CardanoTxRequest(const CardanoTxRequest& from);

  inline CardanoTxRequest& operator=(const CardanoTxRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  CardanoTxRequest(CardanoTxRequest&& from) noexcept
    : CardanoTxRequest() {
    *this = ::std::move(from);
  }

  inline CardanoTxRequest& operator=(CardanoTxRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const CardanoTxRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CardanoTxRequest* internal_default_instance() {
    return reinterpret_cast<const CardanoTxRequest*>(
               &_CardanoTxRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  void Swap(CardanoTxRequest* other);
  friend void swap(CardanoTxRequest& a, CardanoTxRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline CardanoTxRequest* New() const final {
    return CreateMaybeMessage<CardanoTxRequest>(nullptr);
  }

  CardanoTxRequest* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<CardanoTxRequest>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const CardanoTxRequest& from);
  void MergeFrom(const CardanoTxRequest& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CardanoTxRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bytes tx_hash = 2;
  bool has_tx_hash() const;
  void clear_tx_hash();
  static const int kTxHashFieldNumber = 2;
  const ::std::string& tx_hash() const;
  void set_tx_hash(const ::std::string& value);
  #if LANG_CXX11
  void set_tx_hash(::std::string&& value);
  #endif
  void set_tx_hash(const char* value);
  void set_tx_hash(const void* value, size_t size);
  ::std::string* mutable_tx_hash();
  ::std::string* release_tx_hash();
  void set_allocated_tx_hash(::std::string* tx_hash);

  // optional bytes tx_body = 3;
  bool has_tx_body() const;
  void clear_tx_body();
  static const int kTxBodyFieldNumber = 3;
  const ::std::string& tx_body() const;
  void set_tx_body(const ::std::string& value);
  #if LANG_CXX11
  void set_tx_body(::std::string&& value);
  #endif
  void set_tx_body(const char* value);
  void set_tx_body(const void* value, size_t size);
  ::std::string* mutable_tx_body();
  ::std::string* release_tx_body();
  void set_allocated_tx_body(::std::string* tx_body);

  // optional uint32 tx_index = 1;
  bool has_tx_index() const;
  void clear_tx_index();
  static const int kTxIndexFieldNumber = 1;
  ::google::protobuf::uint32 tx_index() const;
  void set_tx_index(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:hw.trezor.messages.cardano.CardanoTxRequest)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr tx_hash_;
  ::google::protobuf::internal::ArenaStringPtr tx_body_;
  ::google::protobuf::uint32 tx_index_;
  friend struct ::TableStruct_messages_2dcardano_2eproto;
};
// -------------------------------------------------------------------

class CardanoTxAck final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:hw.trezor.messages.cardano.CardanoTxAck) */ {
 public:
  CardanoTxAck();
  virtual ~CardanoTxAck();

  CardanoTxAck(const CardanoTxAck& from);

  inline CardanoTxAck& operator=(const CardanoTxAck& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  CardanoTxAck(CardanoTxAck&& from) noexcept
    : CardanoTxAck() {
    *this = ::std::move(from);
  }

  inline CardanoTxAck& operator=(CardanoTxAck&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const CardanoTxAck& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CardanoTxAck* internal_default_instance() {
    return reinterpret_cast<const CardanoTxAck*>(
               &_CardanoTxAck_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  void Swap(CardanoTxAck* other);
  friend void swap(CardanoTxAck& a, CardanoTxAck& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline CardanoTxAck* New() const final {
    return CreateMaybeMessage<CardanoTxAck>(nullptr);
  }

  CardanoTxAck* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<CardanoTxAck>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const CardanoTxAck& from);
  void MergeFrom(const CardanoTxAck& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CardanoTxAck* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bytes transaction = 1;
  bool has_transaction() const;
  void clear_transaction();
  static const int kTransactionFieldNumber = 1;
  const ::std::string& transaction() const;
  void set_transaction(const ::std::string& value);
  #if LANG_CXX11
  void set_transaction(::std::string&& value);
  #endif
  void set_transaction(const char* value);
  void set_transaction(const void* value, size_t size);
  ::std::string* mutable_transaction();
  ::std::string* release_transaction();
  void set_allocated_transaction(::std::string* transaction);

  // @@protoc_insertion_point(class_scope:hw.trezor.messages.cardano.CardanoTxAck)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr transaction_;
  friend struct ::TableStruct_messages_2dcardano_2eproto;
};
// -------------------------------------------------------------------

class CardanoSignedTx final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:hw.trezor.messages.cardano.CardanoSignedTx) */ {
 public:
  CardanoSignedTx();
  virtual ~CardanoSignedTx();

  CardanoSignedTx(const CardanoSignedTx& from);

  inline CardanoSignedTx& operator=(const CardanoSignedTx& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  CardanoSignedTx(CardanoSignedTx&& from) noexcept
    : CardanoSignedTx() {
    *this = ::std::move(from);
  }

  inline CardanoSignedTx& operator=(CardanoSignedTx&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const CardanoSignedTx& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CardanoSignedTx* internal_default_instance() {
    return reinterpret_cast<const CardanoSignedTx*>(
               &_CardanoSignedTx_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  void Swap(CardanoSignedTx* other);
  friend void swap(CardanoSignedTx& a, CardanoSignedTx& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline CardanoSignedTx* New() const final {
    return CreateMaybeMessage<CardanoSignedTx>(nullptr);
  }

  CardanoSignedTx* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<CardanoSignedTx>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const CardanoSignedTx& from);
  void MergeFrom(const CardanoSignedTx& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CardanoSignedTx* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bytes tx_hash = 1;
  bool has_tx_hash() const;
  void clear_tx_hash();
  static const int kTxHashFieldNumber = 1;
  const ::std::string& tx_hash() const;
  void set_tx_hash(const ::std::string& value);
  #if LANG_CXX11
  void set_tx_hash(::std::string&& value);
  #endif
  void set_tx_hash(const char* value);
  void set_tx_hash(const void* value, size_t size);
  ::std::string* mutable_tx_hash();
  ::std::string* release_tx_hash();
  void set_allocated_tx_hash(::std::string* tx_hash);

  // optional bytes tx_body = 2;
  bool has_tx_body() const;
  void clear_tx_body();
  static const int kTxBodyFieldNumber = 2;
  const ::std::string& tx_body() const;
  void set_tx_body(const ::std::string& value);
  #if LANG_CXX11
  void set_tx_body(::std::string&& value);
  #endif
  void set_tx_body(const char* value);
  void set_tx_body(const void* value, size_t size);
  ::std::string* mutable_tx_body();
  ::std::string* release_tx_body();
  void set_allocated_tx_body(::std::string* tx_body);

  // @@protoc_insertion_point(class_scope:hw.trezor.messages.cardano.CardanoSignedTx)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr tx_hash_;
  ::google::protobuf::internal::ArenaStringPtr tx_body_;
  friend struct ::TableStruct_messages_2dcardano_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// CardanoGetAddress

// repeated uint32 address_n = 1;
inline int CardanoGetAddress::address_n_size() const {
  return address_n_.size();
}
inline void CardanoGetAddress::clear_address_n() {
  address_n_.Clear();
}
inline ::google::protobuf::uint32 CardanoGetAddress::address_n(int index) const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.cardano.CardanoGetAddress.address_n)
  return address_n_.Get(index);
}
inline void CardanoGetAddress::set_address_n(int index, ::google::protobuf::uint32 value) {
  address_n_.Set(index, value);
  // @@protoc_insertion_point(field_set:hw.trezor.messages.cardano.CardanoGetAddress.address_n)
}
inline void CardanoGetAddress::add_address_n(::google::protobuf::uint32 value) {
  address_n_.Add(value);
  // @@protoc_insertion_point(field_add:hw.trezor.messages.cardano.CardanoGetAddress.address_n)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
CardanoGetAddress::address_n() const {
  // @@protoc_insertion_point(field_list:hw.trezor.messages.cardano.CardanoGetAddress.address_n)
  return address_n_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
CardanoGetAddress::mutable_address_n() {
  // @@protoc_insertion_point(field_mutable_list:hw.trezor.messages.cardano.CardanoGetAddress.address_n)
  return &address_n_;
}

// optional bool show_display = 2;
inline bool CardanoGetAddress::has_show_display() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CardanoGetAddress::clear_show_display() {
  show_display_ = false;
  _has_bits_[0] &= ~0x00000001u;
}
inline bool CardanoGetAddress::show_display() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.cardano.CardanoGetAddress.show_display)
  return show_display_;
}
inline void CardanoGetAddress::set_show_display(bool value) {
  _has_bits_[0] |= 0x00000001u;
  show_display_ = value;
  // @@protoc_insertion_point(field_set:hw.trezor.messages.cardano.CardanoGetAddress.show_display)
}

// -------------------------------------------------------------------

// CardanoAddress

// optional string address = 1;
inline bool CardanoAddress::has_address() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CardanoAddress::clear_address() {
  address_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::std::string& CardanoAddress::address() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.cardano.CardanoAddress.address)
  return address_.GetNoArena();
}
inline void CardanoAddress::set_address(const ::std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  address_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:hw.trezor.messages.cardano.CardanoAddress.address)
}
#if LANG_CXX11
inline void CardanoAddress::set_address(::std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  address_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:hw.trezor.messages.cardano.CardanoAddress.address)
}
#endif
inline void CardanoAddress::set_address(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  address_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:hw.trezor.messages.cardano.CardanoAddress.address)
}
inline void CardanoAddress::set_address(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000001u;
  address_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:hw.trezor.messages.cardano.CardanoAddress.address)
}
inline ::std::string* CardanoAddress::mutable_address() {
  _has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_mutable:hw.trezor.messages.cardano.CardanoAddress.address)
  return address_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* CardanoAddress::release_address() {
  // @@protoc_insertion_point(field_release:hw.trezor.messages.cardano.CardanoAddress.address)
  if (!has_address()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return address_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void CardanoAddress::set_allocated_address(::std::string* address) {
  if (address != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  address_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), address);
  // @@protoc_insertion_point(field_set_allocated:hw.trezor.messages.cardano.CardanoAddress.address)
}

// -------------------------------------------------------------------

// CardanoGetPublicKey

// repeated uint32 address_n = 1;
inline int CardanoGetPublicKey::address_n_size() const {
  return address_n_.size();
}
inline void CardanoGetPublicKey::clear_address_n() {
  address_n_.Clear();
}
inline ::google::protobuf::uint32 CardanoGetPublicKey::address_n(int index) const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.cardano.CardanoGetPublicKey.address_n)
  return address_n_.Get(index);
}
inline void CardanoGetPublicKey::set_address_n(int index, ::google::protobuf::uint32 value) {
  address_n_.Set(index, value);
  // @@protoc_insertion_point(field_set:hw.trezor.messages.cardano.CardanoGetPublicKey.address_n)
}
inline void CardanoGetPublicKey::add_address_n(::google::protobuf::uint32 value) {
  address_n_.Add(value);
  // @@protoc_insertion_point(field_add:hw.trezor.messages.cardano.CardanoGetPublicKey.address_n)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
CardanoGetPublicKey::address_n() const {
  // @@protoc_insertion_point(field_list:hw.trezor.messages.cardano.CardanoGetPublicKey.address_n)
  return address_n_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
CardanoGetPublicKey::mutable_address_n() {
  // @@protoc_insertion_point(field_mutable_list:hw.trezor.messages.cardano.CardanoGetPublicKey.address_n)
  return &address_n_;
}

// optional bool show_display = 2;
inline bool CardanoGetPublicKey::has_show_display() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CardanoGetPublicKey::clear_show_display() {
  show_display_ = false;
  _has_bits_[0] &= ~0x00000001u;
}
inline bool CardanoGetPublicKey::show_display() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.cardano.CardanoGetPublicKey.show_display)
  return show_display_;
}
inline void CardanoGetPublicKey::set_show_display(bool value) {
  _has_bits_[0] |= 0x00000001u;
  show_display_ = value;
  // @@protoc_insertion_point(field_set:hw.trezor.messages.cardano.CardanoGetPublicKey.show_display)
}

// -------------------------------------------------------------------

// CardanoPublicKey

// optional string xpub = 1;
inline bool CardanoPublicKey::has_xpub() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CardanoPublicKey::clear_xpub() {
  xpub_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::std::string& CardanoPublicKey::xpub() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.cardano.CardanoPublicKey.xpub)
  return xpub_.GetNoArena();
}
inline void CardanoPublicKey::set_xpub(const ::std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  xpub_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:hw.trezor.messages.cardano.CardanoPublicKey.xpub)
}
#if LANG_CXX11
inline void CardanoPublicKey::set_xpub(::std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  xpub_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:hw.trezor.messages.cardano.CardanoPublicKey.xpub)
}
#endif
inline void CardanoPublicKey::set_xpub(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  xpub_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:hw.trezor.messages.cardano.CardanoPublicKey.xpub)
}
inline void CardanoPublicKey::set_xpub(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000001u;
  xpub_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:hw.trezor.messages.cardano.CardanoPublicKey.xpub)
}
inline ::std::string* CardanoPublicKey::mutable_xpub() {
  _has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_mutable:hw.trezor.messages.cardano.CardanoPublicKey.xpub)
  return xpub_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* CardanoPublicKey::release_xpub() {
  // @@protoc_insertion_point(field_release:hw.trezor.messages.cardano.CardanoPublicKey.xpub)
  if (!has_xpub()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return xpub_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void CardanoPublicKey::set_allocated_xpub(::std::string* xpub) {
  if (xpub != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  xpub_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), xpub);
  // @@protoc_insertion_point(field_set_allocated:hw.trezor.messages.cardano.CardanoPublicKey.xpub)
}

// optional .hw.trezor.messages.common.HDNodeType node = 2;
inline bool CardanoPublicKey::has_node() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline const ::hw::trezor::messages::common::HDNodeType& CardanoPublicKey::node() const {
  const ::hw::trezor::messages::common::HDNodeType* p = node_;
  // @@protoc_insertion_point(field_get:hw.trezor.messages.cardano.CardanoPublicKey.node)
  return p != nullptr ? *p : *reinterpret_cast<const ::hw::trezor::messages::common::HDNodeType*>(
      &::hw::trezor::messages::common::_HDNodeType_default_instance_);
}
inline ::hw::trezor::messages::common::HDNodeType* CardanoPublicKey::release_node() {
  // @@protoc_insertion_point(field_release:hw.trezor.messages.cardano.CardanoPublicKey.node)
  _has_bits_[0] &= ~0x00000002u;
  ::hw::trezor::messages::common::HDNodeType* temp = node_;
  node_ = nullptr;
  return temp;
}
inline ::hw::trezor::messages::common::HDNodeType* CardanoPublicKey::mutable_node() {
  _has_bits_[0] |= 0x00000002u;
  if (node_ == nullptr) {
    auto* p = CreateMaybeMessage<::hw::trezor::messages::common::HDNodeType>(GetArenaNoVirtual());
    node_ = p;
  }
  // @@protoc_insertion_point(field_mutable:hw.trezor.messages.cardano.CardanoPublicKey.node)
  return node_;
}
inline void CardanoPublicKey::set_allocated_node(::hw::trezor::messages::common::HDNodeType* node) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(node_);
  }
  if (node) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      node = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, node, submessage_arena);
    }
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  node_ = node;
  // @@protoc_insertion_point(field_set_allocated:hw.trezor.messages.cardano.CardanoPublicKey.node)
}

// -------------------------------------------------------------------

// CardanoSignTx_CardanoTxInputType

// repeated uint32 address_n = 1;
inline int CardanoSignTx_CardanoTxInputType::address_n_size() const {
  return address_n_.size();
}
inline void CardanoSignTx_CardanoTxInputType::clear_address_n() {
  address_n_.Clear();
}
inline ::google::protobuf::uint32 CardanoSignTx_CardanoTxInputType::address_n(int index) const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.cardano.CardanoSignTx.CardanoTxInputType.address_n)
  return address_n_.Get(index);
}
inline void CardanoSignTx_CardanoTxInputType::set_address_n(int index, ::google::protobuf::uint32 value) {
  address_n_.Set(index, value);
  // @@protoc_insertion_point(field_set:hw.trezor.messages.cardano.CardanoSignTx.CardanoTxInputType.address_n)
}
inline void CardanoSignTx_CardanoTxInputType::add_address_n(::google::protobuf::uint32 value) {
  address_n_.Add(value);
  // @@protoc_insertion_point(field_add:hw.trezor.messages.cardano.CardanoSignTx.CardanoTxInputType.address_n)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
CardanoSignTx_CardanoTxInputType::address_n() const {
  // @@protoc_insertion_point(field_list:hw.trezor.messages.cardano.CardanoSignTx.CardanoTxInputType.address_n)
  return address_n_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
CardanoSignTx_CardanoTxInputType::mutable_address_n() {
  // @@protoc_insertion_point(field_mutable_list:hw.trezor.messages.cardano.CardanoSignTx.CardanoTxInputType.address_n)
  return &address_n_;
}

// optional bytes prev_hash = 2;
inline bool CardanoSignTx_CardanoTxInputType::has_prev_hash() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CardanoSignTx_CardanoTxInputType::clear_prev_hash() {
  prev_hash_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::std::string& CardanoSignTx_CardanoTxInputType::prev_hash() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.cardano.CardanoSignTx.CardanoTxInputType.prev_hash)
  return prev_hash_.GetNoArena();
}
inline void CardanoSignTx_CardanoTxInputType::set_prev_hash(const ::std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  prev_hash_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:hw.trezor.messages.cardano.CardanoSignTx.CardanoTxInputType.prev_hash)
}
#if LANG_CXX11
inline void CardanoSignTx_CardanoTxInputType::set_prev_hash(::std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  prev_hash_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:hw.trezor.messages.cardano.CardanoSignTx.CardanoTxInputType.prev_hash)
}
#endif
inline void CardanoSignTx_CardanoTxInputType::set_prev_hash(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  prev_hash_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:hw.trezor.messages.cardano.CardanoSignTx.CardanoTxInputType.prev_hash)
}
inline void CardanoSignTx_CardanoTxInputType::set_prev_hash(const void* value, size_t size) {
  _has_bits_[0] |= 0x00000001u;
  prev_hash_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:hw.trezor.messages.cardano.CardanoSignTx.CardanoTxInputType.prev_hash)
}
inline ::std::string* CardanoSignTx_CardanoTxInputType::mutable_prev_hash() {
  _has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_mutable:hw.trezor.messages.cardano.CardanoSignTx.CardanoTxInputType.prev_hash)
  return prev_hash_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* CardanoSignTx_CardanoTxInputType::release_prev_hash() {
  // @@protoc_insertion_point(field_release:hw.trezor.messages.cardano.CardanoSignTx.CardanoTxInputType.prev_hash)
  if (!has_prev_hash()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return prev_hash_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void CardanoSignTx_CardanoTxInputType::set_allocated_prev_hash(::std::string* prev_hash) {
  if (prev_hash != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  prev_hash_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), prev_hash);
  // @@protoc_insertion_point(field_set_allocated:hw.trezor.messages.cardano.CardanoSignTx.CardanoTxInputType.prev_hash)
}

// optional uint32 prev_index = 3;
inline bool CardanoSignTx_CardanoTxInputType::has_prev_index() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CardanoSignTx_CardanoTxInputType::clear_prev_index() {
  prev_index_ = 0u;
  _has_bits_[0] &= ~0x00000002u;
}
inline ::google::protobuf::uint32 CardanoSignTx_CardanoTxInputType::prev_index() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.cardano.CardanoSignTx.CardanoTxInputType.prev_index)
  return prev_index_;
}
inline void CardanoSignTx_CardanoTxInputType::set_prev_index(::google::protobuf::uint32 value) {
  _has_bits_[0] |= 0x00000002u;
  prev_index_ = value;
  // @@protoc_insertion_point(field_set:hw.trezor.messages.cardano.CardanoSignTx.CardanoTxInputType.prev_index)
}

// optional uint32 type = 4;
inline bool CardanoSignTx_CardanoTxInputType::has_type() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CardanoSignTx_CardanoTxInputType::clear_type() {
  type_ = 0u;
  _has_bits_[0] &= ~0x00000004u;
}
inline ::google::protobuf::uint32 CardanoSignTx_CardanoTxInputType::type() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.cardano.CardanoSignTx.CardanoTxInputType.type)
  return type_;
}
inline void CardanoSignTx_CardanoTxInputType::set_type(::google::protobuf::uint32 value) {
  _has_bits_[0] |= 0x00000004u;
  type_ = value;
  // @@protoc_insertion_point(field_set:hw.trezor.messages.cardano.CardanoSignTx.CardanoTxInputType.type)
}

// -------------------------------------------------------------------

// CardanoSignTx_CardanoTxOutputType

// optional string address = 1;
inline bool CardanoSignTx_CardanoTxOutputType::has_address() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CardanoSignTx_CardanoTxOutputType::clear_address() {
  address_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::std::string& CardanoSignTx_CardanoTxOutputType::address() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.cardano.CardanoSignTx.CardanoTxOutputType.address)
  return address_.GetNoArena();
}
inline void CardanoSignTx_CardanoTxOutputType::set_address(const ::std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  address_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:hw.trezor.messages.cardano.CardanoSignTx.CardanoTxOutputType.address)
}
#if LANG_CXX11
inline void CardanoSignTx_CardanoTxOutputType::set_address(::std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  address_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:hw.trezor.messages.cardano.CardanoSignTx.CardanoTxOutputType.address)
}
#endif
inline void CardanoSignTx_CardanoTxOutputType::set_address(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  address_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:hw.trezor.messages.cardano.CardanoSignTx.CardanoTxOutputType.address)
}
inline void CardanoSignTx_CardanoTxOutputType::set_address(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000001u;
  address_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:hw.trezor.messages.cardano.CardanoSignTx.CardanoTxOutputType.address)
}
inline ::std::string* CardanoSignTx_CardanoTxOutputType::mutable_address() {
  _has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_mutable:hw.trezor.messages.cardano.CardanoSignTx.CardanoTxOutputType.address)
  return address_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* CardanoSignTx_CardanoTxOutputType::release_address() {
  // @@protoc_insertion_point(field_release:hw.trezor.messages.cardano.CardanoSignTx.CardanoTxOutputType.address)
  if (!has_address()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return address_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void CardanoSignTx_CardanoTxOutputType::set_allocated_address(::std::string* address) {
  if (address != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  address_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), address);
  // @@protoc_insertion_point(field_set_allocated:hw.trezor.messages.cardano.CardanoSignTx.CardanoTxOutputType.address)
}

// repeated uint32 address_n = 2;
inline int CardanoSignTx_CardanoTxOutputType::address_n_size() const {
  return address_n_.size();
}
inline void CardanoSignTx_CardanoTxOutputType::clear_address_n() {
  address_n_.Clear();
}
inline ::google::protobuf::uint32 CardanoSignTx_CardanoTxOutputType::address_n(int index) const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.cardano.CardanoSignTx.CardanoTxOutputType.address_n)
  return address_n_.Get(index);
}
inline void CardanoSignTx_CardanoTxOutputType::set_address_n(int index, ::google::protobuf::uint32 value) {
  address_n_.Set(index, value);
  // @@protoc_insertion_point(field_set:hw.trezor.messages.cardano.CardanoSignTx.CardanoTxOutputType.address_n)
}
inline void CardanoSignTx_CardanoTxOutputType::add_address_n(::google::protobuf::uint32 value) {
  address_n_.Add(value);
  // @@protoc_insertion_point(field_add:hw.trezor.messages.cardano.CardanoSignTx.CardanoTxOutputType.address_n)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
CardanoSignTx_CardanoTxOutputType::address_n() const {
  // @@protoc_insertion_point(field_list:hw.trezor.messages.cardano.CardanoSignTx.CardanoTxOutputType.address_n)
  return address_n_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
CardanoSignTx_CardanoTxOutputType::mutable_address_n() {
  // @@protoc_insertion_point(field_mutable_list:hw.trezor.messages.cardano.CardanoSignTx.CardanoTxOutputType.address_n)
  return &address_n_;
}

// optional uint64 amount = 3;
inline bool CardanoSignTx_CardanoTxOutputType::has_amount() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CardanoSignTx_CardanoTxOutputType::clear_amount() {
  amount_ = PROTOBUF_ULONGLONG(0);
  _has_bits_[0] &= ~0x00000002u;
}
inline ::google::protobuf::uint64 CardanoSignTx_CardanoTxOutputType::amount() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.cardano.CardanoSignTx.CardanoTxOutputType.amount)
  return amount_;
}
inline void CardanoSignTx_CardanoTxOutputType::set_amount(::google::protobuf::uint64 value) {
  _has_bits_[0] |= 0x00000002u;
  amount_ = value;
  // @@protoc_insertion_point(field_set:hw.trezor.messages.cardano.CardanoSignTx.CardanoTxOutputType.amount)
}

// -------------------------------------------------------------------

// CardanoSignTx

// repeated .hw.trezor.messages.cardano.CardanoSignTx.CardanoTxInputType inputs = 1;
inline int CardanoSignTx::inputs_size() const {
  return inputs_.size();
}
inline void CardanoSignTx::clear_inputs() {
  inputs_.Clear();
}
inline ::hw::trezor::messages::cardano::CardanoSignTx_CardanoTxInputType* CardanoSignTx::mutable_inputs(int index) {
  // @@protoc_insertion_point(field_mutable:hw.trezor.messages.cardano.CardanoSignTx.inputs)
  return inputs_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::hw::trezor::messages::cardano::CardanoSignTx_CardanoTxInputType >*
CardanoSignTx::mutable_inputs() {
  // @@protoc_insertion_point(field_mutable_list:hw.trezor.messages.cardano.CardanoSignTx.inputs)
  return &inputs_;
}
inline const ::hw::trezor::messages::cardano::CardanoSignTx_CardanoTxInputType& CardanoSignTx::inputs(int index) const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.cardano.CardanoSignTx.inputs)
  return inputs_.Get(index);
}
inline ::hw::trezor::messages::cardano::CardanoSignTx_CardanoTxInputType* CardanoSignTx::add_inputs() {
  // @@protoc_insertion_point(field_add:hw.trezor.messages.cardano.CardanoSignTx.inputs)
  return inputs_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::hw::trezor::messages::cardano::CardanoSignTx_CardanoTxInputType >&
CardanoSignTx::inputs() const {
  // @@protoc_insertion_point(field_list:hw.trezor.messages.cardano.CardanoSignTx.inputs)
  return inputs_;
}

// repeated .hw.trezor.messages.cardano.CardanoSignTx.CardanoTxOutputType outputs = 2;
inline int CardanoSignTx::outputs_size() const {
  return outputs_.size();
}
inline void CardanoSignTx::clear_outputs() {
  outputs_.Clear();
}
inline ::hw::trezor::messages::cardano::CardanoSignTx_CardanoTxOutputType* CardanoSignTx::mutable_outputs(int index) {
  // @@protoc_insertion_point(field_mutable:hw.trezor.messages.cardano.CardanoSignTx.outputs)
  return outputs_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::hw::trezor::messages::cardano::CardanoSignTx_CardanoTxOutputType >*
CardanoSignTx::mutable_outputs() {
  // @@protoc_insertion_point(field_mutable_list:hw.trezor.messages.cardano.CardanoSignTx.outputs)
  return &outputs_;
}
inline const ::hw::trezor::messages::cardano::CardanoSignTx_CardanoTxOutputType& CardanoSignTx::outputs(int index) const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.cardano.CardanoSignTx.outputs)
  return outputs_.Get(index);
}
inline ::hw::trezor::messages::cardano::CardanoSignTx_CardanoTxOutputType* CardanoSignTx::add_outputs() {
  // @@protoc_insertion_point(field_add:hw.trezor.messages.cardano.CardanoSignTx.outputs)
  return outputs_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::hw::trezor::messages::cardano::CardanoSignTx_CardanoTxOutputType >&
CardanoSignTx::outputs() const {
  // @@protoc_insertion_point(field_list:hw.trezor.messages.cardano.CardanoSignTx.outputs)
  return outputs_;
}

// optional uint32 transactions_count = 3;
inline bool CardanoSignTx::has_transactions_count() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CardanoSignTx::clear_transactions_count() {
  transactions_count_ = 0u;
  _has_bits_[0] &= ~0x00000001u;
}
inline ::google::protobuf::uint32 CardanoSignTx::transactions_count() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.cardano.CardanoSignTx.transactions_count)
  return transactions_count_;
}
inline void CardanoSignTx::set_transactions_count(::google::protobuf::uint32 value) {
  _has_bits_[0] |= 0x00000001u;
  transactions_count_ = value;
  // @@protoc_insertion_point(field_set:hw.trezor.messages.cardano.CardanoSignTx.transactions_count)
}

// optional uint32 protocol_magic = 5;
inline bool CardanoSignTx::has_protocol_magic() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CardanoSignTx::clear_protocol_magic() {
  protocol_magic_ = 0u;
  _has_bits_[0] &= ~0x00000002u;
}
inline ::google::protobuf::uint32 CardanoSignTx::protocol_magic() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.cardano.CardanoSignTx.protocol_magic)
  return protocol_magic_;
}
inline void CardanoSignTx::set_protocol_magic(::google::protobuf::uint32 value) {
  _has_bits_[0] |= 0x00000002u;
  protocol_magic_ = value;
  // @@protoc_insertion_point(field_set:hw.trezor.messages.cardano.CardanoSignTx.protocol_magic)
}

// -------------------------------------------------------------------

// CardanoTxRequest

// optional uint32 tx_index = 1;
inline bool CardanoTxRequest::has_tx_index() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CardanoTxRequest::clear_tx_index() {
  tx_index_ = 0u;
  _has_bits_[0] &= ~0x00000004u;
}
inline ::google::protobuf::uint32 CardanoTxRequest::tx_index() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.cardano.CardanoTxRequest.tx_index)
  return tx_index_;
}
inline void CardanoTxRequest::set_tx_index(::google::protobuf::uint32 value) {
  _has_bits_[0] |= 0x00000004u;
  tx_index_ = value;
  // @@protoc_insertion_point(field_set:hw.trezor.messages.cardano.CardanoTxRequest.tx_index)
}

// optional bytes tx_hash = 2;
inline bool CardanoTxRequest::has_tx_hash() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CardanoTxRequest::clear_tx_hash() {
  tx_hash_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::std::string& CardanoTxRequest::tx_hash() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.cardano.CardanoTxRequest.tx_hash)
  return tx_hash_.GetNoArena();
}
inline void CardanoTxRequest::set_tx_hash(const ::std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  tx_hash_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:hw.trezor.messages.cardano.CardanoTxRequest.tx_hash)
}
#if LANG_CXX11
inline void CardanoTxRequest::set_tx_hash(::std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  tx_hash_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:hw.trezor.messages.cardano.CardanoTxRequest.tx_hash)
}
#endif
inline void CardanoTxRequest::set_tx_hash(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  tx_hash_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:hw.trezor.messages.cardano.CardanoTxRequest.tx_hash)
}
inline void CardanoTxRequest::set_tx_hash(const void* value, size_t size) {
  _has_bits_[0] |= 0x00000001u;
  tx_hash_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:hw.trezor.messages.cardano.CardanoTxRequest.tx_hash)
}
inline ::std::string* CardanoTxRequest::mutable_tx_hash() {
  _has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_mutable:hw.trezor.messages.cardano.CardanoTxRequest.tx_hash)
  return tx_hash_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* CardanoTxRequest::release_tx_hash() {
  // @@protoc_insertion_point(field_release:hw.trezor.messages.cardano.CardanoTxRequest.tx_hash)
  if (!has_tx_hash()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return tx_hash_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void CardanoTxRequest::set_allocated_tx_hash(::std::string* tx_hash) {
  if (tx_hash != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  tx_hash_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), tx_hash);
  // @@protoc_insertion_point(field_set_allocated:hw.trezor.messages.cardano.CardanoTxRequest.tx_hash)
}

// optional bytes tx_body = 3;
inline bool CardanoTxRequest::has_tx_body() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CardanoTxRequest::clear_tx_body() {
  tx_body_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000002u;
}
inline const ::std::string& CardanoTxRequest::tx_body() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.cardano.CardanoTxRequest.tx_body)
  return tx_body_.GetNoArena();
}
inline void CardanoTxRequest::set_tx_body(const ::std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  tx_body_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:hw.trezor.messages.cardano.CardanoTxRequest.tx_body)
}
#if LANG_CXX11
inline void CardanoTxRequest::set_tx_body(::std::string&& value) {
  _has_bits_[0] |= 0x00000002u;
  tx_body_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:hw.trezor.messages.cardano.CardanoTxRequest.tx_body)
}
#endif
inline void CardanoTxRequest::set_tx_body(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000002u;
  tx_body_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:hw.trezor.messages.cardano.CardanoTxRequest.tx_body)
}
inline void CardanoTxRequest::set_tx_body(const void* value, size_t size) {
  _has_bits_[0] |= 0x00000002u;
  tx_body_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:hw.trezor.messages.cardano.CardanoTxRequest.tx_body)
}
inline ::std::string* CardanoTxRequest::mutable_tx_body() {
  _has_bits_[0] |= 0x00000002u;
  // @@protoc_insertion_point(field_mutable:hw.trezor.messages.cardano.CardanoTxRequest.tx_body)
  return tx_body_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* CardanoTxRequest::release_tx_body() {
  // @@protoc_insertion_point(field_release:hw.trezor.messages.cardano.CardanoTxRequest.tx_body)
  if (!has_tx_body()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  return tx_body_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void CardanoTxRequest::set_allocated_tx_body(::std::string* tx_body) {
  if (tx_body != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  tx_body_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), tx_body);
  // @@protoc_insertion_point(field_set_allocated:hw.trezor.messages.cardano.CardanoTxRequest.tx_body)
}

// -------------------------------------------------------------------

// CardanoTxAck

// optional bytes transaction = 1;
inline bool CardanoTxAck::has_transaction() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CardanoTxAck::clear_transaction() {
  transaction_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::std::string& CardanoTxAck::transaction() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.cardano.CardanoTxAck.transaction)
  return transaction_.GetNoArena();
}
inline void CardanoTxAck::set_transaction(const ::std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  transaction_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:hw.trezor.messages.cardano.CardanoTxAck.transaction)
}
#if LANG_CXX11
inline void CardanoTxAck::set_transaction(::std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  transaction_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:hw.trezor.messages.cardano.CardanoTxAck.transaction)
}
#endif
inline void CardanoTxAck::set_transaction(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  transaction_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:hw.trezor.messages.cardano.CardanoTxAck.transaction)
}
inline void CardanoTxAck::set_transaction(const void* value, size_t size) {
  _has_bits_[0] |= 0x00000001u;
  transaction_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:hw.trezor.messages.cardano.CardanoTxAck.transaction)
}
inline ::std::string* CardanoTxAck::mutable_transaction() {
  _has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_mutable:hw.trezor.messages.cardano.CardanoTxAck.transaction)
  return transaction_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* CardanoTxAck::release_transaction() {
  // @@protoc_insertion_point(field_release:hw.trezor.messages.cardano.CardanoTxAck.transaction)
  if (!has_transaction()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return transaction_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void CardanoTxAck::set_allocated_transaction(::std::string* transaction) {
  if (transaction != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  transaction_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), transaction);
  // @@protoc_insertion_point(field_set_allocated:hw.trezor.messages.cardano.CardanoTxAck.transaction)
}

// -------------------------------------------------------------------

// CardanoSignedTx

// optional bytes tx_hash = 1;
inline bool CardanoSignedTx::has_tx_hash() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CardanoSignedTx::clear_tx_hash() {
  tx_hash_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::std::string& CardanoSignedTx::tx_hash() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.cardano.CardanoSignedTx.tx_hash)
  return tx_hash_.GetNoArena();
}
inline void CardanoSignedTx::set_tx_hash(const ::std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  tx_hash_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:hw.trezor.messages.cardano.CardanoSignedTx.tx_hash)
}
#if LANG_CXX11
inline void CardanoSignedTx::set_tx_hash(::std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  tx_hash_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:hw.trezor.messages.cardano.CardanoSignedTx.tx_hash)
}
#endif
inline void CardanoSignedTx::set_tx_hash(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  tx_hash_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:hw.trezor.messages.cardano.CardanoSignedTx.tx_hash)
}
inline void CardanoSignedTx::set_tx_hash(const void* value, size_t size) {
  _has_bits_[0] |= 0x00000001u;
  tx_hash_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:hw.trezor.messages.cardano.CardanoSignedTx.tx_hash)
}
inline ::std::string* CardanoSignedTx::mutable_tx_hash() {
  _has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_mutable:hw.trezor.messages.cardano.CardanoSignedTx.tx_hash)
  return tx_hash_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* CardanoSignedTx::release_tx_hash() {
  // @@protoc_insertion_point(field_release:hw.trezor.messages.cardano.CardanoSignedTx.tx_hash)
  if (!has_tx_hash()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return tx_hash_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void CardanoSignedTx::set_allocated_tx_hash(::std::string* tx_hash) {
  if (tx_hash != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  tx_hash_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), tx_hash);
  // @@protoc_insertion_point(field_set_allocated:hw.trezor.messages.cardano.CardanoSignedTx.tx_hash)
}

// optional bytes tx_body = 2;
inline bool CardanoSignedTx::has_tx_body() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CardanoSignedTx::clear_tx_body() {
  tx_body_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000002u;
}
inline const ::std::string& CardanoSignedTx::tx_body() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.cardano.CardanoSignedTx.tx_body)
  return tx_body_.GetNoArena();
}
inline void CardanoSignedTx::set_tx_body(const ::std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  tx_body_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:hw.trezor.messages.cardano.CardanoSignedTx.tx_body)
}
#if LANG_CXX11
inline void CardanoSignedTx::set_tx_body(::std::string&& value) {
  _has_bits_[0] |= 0x00000002u;
  tx_body_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:hw.trezor.messages.cardano.CardanoSignedTx.tx_body)
}
#endif
inline void CardanoSignedTx::set_tx_body(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000002u;
  tx_body_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:hw.trezor.messages.cardano.CardanoSignedTx.tx_body)
}
inline void CardanoSignedTx::set_tx_body(const void* value, size_t size) {
  _has_bits_[0] |= 0x00000002u;
  tx_body_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:hw.trezor.messages.cardano.CardanoSignedTx.tx_body)
}
inline ::std::string* CardanoSignedTx::mutable_tx_body() {
  _has_bits_[0] |= 0x00000002u;
  // @@protoc_insertion_point(field_mutable:hw.trezor.messages.cardano.CardanoSignedTx.tx_body)
  return tx_body_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* CardanoSignedTx::release_tx_body() {
  // @@protoc_insertion_point(field_release:hw.trezor.messages.cardano.CardanoSignedTx.tx_body)
  if (!has_tx_body()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  return tx_body_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void CardanoSignedTx::set_allocated_tx_body(::std::string* tx_body) {
  if (tx_body != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  tx_body_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), tx_body);
  // @@protoc_insertion_point(field_set_allocated:hw.trezor.messages.cardano.CardanoSignedTx.tx_body)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace cardano
}  // namespace messages
}  // namespace trezor
}  // namespace hw

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // PROTOBUF_INCLUDED_messages_2dcardano_2eproto
