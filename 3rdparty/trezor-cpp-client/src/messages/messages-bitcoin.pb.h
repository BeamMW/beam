// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: messages-bitcoin.proto

#ifndef PROTOBUF_INCLUDED_messages_2dbitcoin_2eproto
#define PROTOBUF_INCLUDED_messages_2dbitcoin_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3007000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3007000 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include "messages-common.pb.h"
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_messages_2dbitcoin_2eproto

// Internal implementation detail -- do not use these members.
struct TableStruct_messages_2dbitcoin_2eproto {
  static const ::google::protobuf::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::google::protobuf::internal::ParseTable schema[18]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::google::protobuf::internal::FieldMetadata field_metadata[];
  static const ::google::protobuf::internal::SerializationTable serialization_table[];
  static const ::google::protobuf::uint32 offsets[];
};
void AddDescriptors_messages_2dbitcoin_2eproto();
namespace hw {
namespace trezor {
namespace messages {
namespace bitcoin {
class Address;
class AddressDefaultTypeInternal;
extern AddressDefaultTypeInternal _Address_default_instance_;
class GetAddress;
class GetAddressDefaultTypeInternal;
extern GetAddressDefaultTypeInternal _GetAddress_default_instance_;
class GetPublicKey;
class GetPublicKeyDefaultTypeInternal;
extern GetPublicKeyDefaultTypeInternal _GetPublicKey_default_instance_;
class MessageSignature;
class MessageSignatureDefaultTypeInternal;
extern MessageSignatureDefaultTypeInternal _MessageSignature_default_instance_;
class MultisigRedeemScriptType;
class MultisigRedeemScriptTypeDefaultTypeInternal;
extern MultisigRedeemScriptTypeDefaultTypeInternal _MultisigRedeemScriptType_default_instance_;
class MultisigRedeemScriptType_HDNodePathType;
class MultisigRedeemScriptType_HDNodePathTypeDefaultTypeInternal;
extern MultisigRedeemScriptType_HDNodePathTypeDefaultTypeInternal _MultisigRedeemScriptType_HDNodePathType_default_instance_;
class PublicKey;
class PublicKeyDefaultTypeInternal;
extern PublicKeyDefaultTypeInternal _PublicKey_default_instance_;
class SignMessage;
class SignMessageDefaultTypeInternal;
extern SignMessageDefaultTypeInternal _SignMessage_default_instance_;
class SignTx;
class SignTxDefaultTypeInternal;
extern SignTxDefaultTypeInternal _SignTx_default_instance_;
class TxAck;
class TxAckDefaultTypeInternal;
extern TxAckDefaultTypeInternal _TxAck_default_instance_;
class TxAck_TransactionType;
class TxAck_TransactionTypeDefaultTypeInternal;
extern TxAck_TransactionTypeDefaultTypeInternal _TxAck_TransactionType_default_instance_;
class TxAck_TransactionType_TxInputType;
class TxAck_TransactionType_TxInputTypeDefaultTypeInternal;
extern TxAck_TransactionType_TxInputTypeDefaultTypeInternal _TxAck_TransactionType_TxInputType_default_instance_;
class TxAck_TransactionType_TxOutputBinType;
class TxAck_TransactionType_TxOutputBinTypeDefaultTypeInternal;
extern TxAck_TransactionType_TxOutputBinTypeDefaultTypeInternal _TxAck_TransactionType_TxOutputBinType_default_instance_;
class TxAck_TransactionType_TxOutputType;
class TxAck_TransactionType_TxOutputTypeDefaultTypeInternal;
extern TxAck_TransactionType_TxOutputTypeDefaultTypeInternal _TxAck_TransactionType_TxOutputType_default_instance_;
class TxRequest;
class TxRequestDefaultTypeInternal;
extern TxRequestDefaultTypeInternal _TxRequest_default_instance_;
class TxRequest_TxRequestDetailsType;
class TxRequest_TxRequestDetailsTypeDefaultTypeInternal;
extern TxRequest_TxRequestDetailsTypeDefaultTypeInternal _TxRequest_TxRequestDetailsType_default_instance_;
class TxRequest_TxRequestSerializedType;
class TxRequest_TxRequestSerializedTypeDefaultTypeInternal;
extern TxRequest_TxRequestSerializedTypeDefaultTypeInternal _TxRequest_TxRequestSerializedType_default_instance_;
class VerifyMessage;
class VerifyMessageDefaultTypeInternal;
extern VerifyMessageDefaultTypeInternal _VerifyMessage_default_instance_;
}  // namespace bitcoin
}  // namespace messages
}  // namespace trezor
}  // namespace hw
namespace google {
namespace protobuf {
template<> ::hw::trezor::messages::bitcoin::Address* Arena::CreateMaybeMessage<::hw::trezor::messages::bitcoin::Address>(Arena*);
template<> ::hw::trezor::messages::bitcoin::GetAddress* Arena::CreateMaybeMessage<::hw::trezor::messages::bitcoin::GetAddress>(Arena*);
template<> ::hw::trezor::messages::bitcoin::GetPublicKey* Arena::CreateMaybeMessage<::hw::trezor::messages::bitcoin::GetPublicKey>(Arena*);
template<> ::hw::trezor::messages::bitcoin::MessageSignature* Arena::CreateMaybeMessage<::hw::trezor::messages::bitcoin::MessageSignature>(Arena*);
template<> ::hw::trezor::messages::bitcoin::MultisigRedeemScriptType* Arena::CreateMaybeMessage<::hw::trezor::messages::bitcoin::MultisigRedeemScriptType>(Arena*);
template<> ::hw::trezor::messages::bitcoin::MultisigRedeemScriptType_HDNodePathType* Arena::CreateMaybeMessage<::hw::trezor::messages::bitcoin::MultisigRedeemScriptType_HDNodePathType>(Arena*);
template<> ::hw::trezor::messages::bitcoin::PublicKey* Arena::CreateMaybeMessage<::hw::trezor::messages::bitcoin::PublicKey>(Arena*);
template<> ::hw::trezor::messages::bitcoin::SignMessage* Arena::CreateMaybeMessage<::hw::trezor::messages::bitcoin::SignMessage>(Arena*);
template<> ::hw::trezor::messages::bitcoin::SignTx* Arena::CreateMaybeMessage<::hw::trezor::messages::bitcoin::SignTx>(Arena*);
template<> ::hw::trezor::messages::bitcoin::TxAck* Arena::CreateMaybeMessage<::hw::trezor::messages::bitcoin::TxAck>(Arena*);
template<> ::hw::trezor::messages::bitcoin::TxAck_TransactionType* Arena::CreateMaybeMessage<::hw::trezor::messages::bitcoin::TxAck_TransactionType>(Arena*);
template<> ::hw::trezor::messages::bitcoin::TxAck_TransactionType_TxInputType* Arena::CreateMaybeMessage<::hw::trezor::messages::bitcoin::TxAck_TransactionType_TxInputType>(Arena*);
template<> ::hw::trezor::messages::bitcoin::TxAck_TransactionType_TxOutputBinType* Arena::CreateMaybeMessage<::hw::trezor::messages::bitcoin::TxAck_TransactionType_TxOutputBinType>(Arena*);
template<> ::hw::trezor::messages::bitcoin::TxAck_TransactionType_TxOutputType* Arena::CreateMaybeMessage<::hw::trezor::messages::bitcoin::TxAck_TransactionType_TxOutputType>(Arena*);
template<> ::hw::trezor::messages::bitcoin::TxRequest* Arena::CreateMaybeMessage<::hw::trezor::messages::bitcoin::TxRequest>(Arena*);
template<> ::hw::trezor::messages::bitcoin::TxRequest_TxRequestDetailsType* Arena::CreateMaybeMessage<::hw::trezor::messages::bitcoin::TxRequest_TxRequestDetailsType>(Arena*);
template<> ::hw::trezor::messages::bitcoin::TxRequest_TxRequestSerializedType* Arena::CreateMaybeMessage<::hw::trezor::messages::bitcoin::TxRequest_TxRequestSerializedType>(Arena*);
template<> ::hw::trezor::messages::bitcoin::VerifyMessage* Arena::CreateMaybeMessage<::hw::trezor::messages::bitcoin::VerifyMessage>(Arena*);
}  // namespace protobuf
}  // namespace google
namespace hw {
namespace trezor {
namespace messages {
namespace bitcoin {

enum TxRequest_RequestType {
  TxRequest_RequestType_TXINPUT = 0,
  TxRequest_RequestType_TXOUTPUT = 1,
  TxRequest_RequestType_TXMETA = 2,
  TxRequest_RequestType_TXFINISHED = 3,
  TxRequest_RequestType_TXEXTRADATA = 4
};
bool TxRequest_RequestType_IsValid(int value);
const TxRequest_RequestType TxRequest_RequestType_RequestType_MIN = TxRequest_RequestType_TXINPUT;
const TxRequest_RequestType TxRequest_RequestType_RequestType_MAX = TxRequest_RequestType_TXEXTRADATA;
const int TxRequest_RequestType_RequestType_ARRAYSIZE = TxRequest_RequestType_RequestType_MAX + 1;

const ::google::protobuf::EnumDescriptor* TxRequest_RequestType_descriptor();
inline const ::std::string& TxRequest_RequestType_Name(TxRequest_RequestType value) {
  return ::google::protobuf::internal::NameOfEnum(
    TxRequest_RequestType_descriptor(), value);
}
inline bool TxRequest_RequestType_Parse(
    const ::std::string& name, TxRequest_RequestType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<TxRequest_RequestType>(
    TxRequest_RequestType_descriptor(), name, value);
}
enum TxAck_TransactionType_TxOutputType_OutputScriptType {
  TxAck_TransactionType_TxOutputType_OutputScriptType_PAYTOADDRESS = 0,
  TxAck_TransactionType_TxOutputType_OutputScriptType_PAYTOSCRIPTHASH = 1,
  TxAck_TransactionType_TxOutputType_OutputScriptType_PAYTOMULTISIG = 2,
  TxAck_TransactionType_TxOutputType_OutputScriptType_PAYTOOPRETURN = 3,
  TxAck_TransactionType_TxOutputType_OutputScriptType_PAYTOWITNESS = 4,
  TxAck_TransactionType_TxOutputType_OutputScriptType_PAYTOP2SHWITNESS = 5
};
bool TxAck_TransactionType_TxOutputType_OutputScriptType_IsValid(int value);
const TxAck_TransactionType_TxOutputType_OutputScriptType TxAck_TransactionType_TxOutputType_OutputScriptType_OutputScriptType_MIN = TxAck_TransactionType_TxOutputType_OutputScriptType_PAYTOADDRESS;
const TxAck_TransactionType_TxOutputType_OutputScriptType TxAck_TransactionType_TxOutputType_OutputScriptType_OutputScriptType_MAX = TxAck_TransactionType_TxOutputType_OutputScriptType_PAYTOP2SHWITNESS;
const int TxAck_TransactionType_TxOutputType_OutputScriptType_OutputScriptType_ARRAYSIZE = TxAck_TransactionType_TxOutputType_OutputScriptType_OutputScriptType_MAX + 1;

const ::google::protobuf::EnumDescriptor* TxAck_TransactionType_TxOutputType_OutputScriptType_descriptor();
inline const ::std::string& TxAck_TransactionType_TxOutputType_OutputScriptType_Name(TxAck_TransactionType_TxOutputType_OutputScriptType value) {
  return ::google::protobuf::internal::NameOfEnum(
    TxAck_TransactionType_TxOutputType_OutputScriptType_descriptor(), value);
}
inline bool TxAck_TransactionType_TxOutputType_OutputScriptType_Parse(
    const ::std::string& name, TxAck_TransactionType_TxOutputType_OutputScriptType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<TxAck_TransactionType_TxOutputType_OutputScriptType>(
    TxAck_TransactionType_TxOutputType_OutputScriptType_descriptor(), name, value);
}
enum InputScriptType {
  SPENDADDRESS = 0,
  SPENDMULTISIG = 1,
  EXTERNAL = 2,
  SPENDWITNESS = 3,
  SPENDP2SHWITNESS = 4
};
bool InputScriptType_IsValid(int value);
const InputScriptType InputScriptType_MIN = SPENDADDRESS;
const InputScriptType InputScriptType_MAX = SPENDP2SHWITNESS;
const int InputScriptType_ARRAYSIZE = InputScriptType_MAX + 1;

const ::google::protobuf::EnumDescriptor* InputScriptType_descriptor();
inline const ::std::string& InputScriptType_Name(InputScriptType value) {
  return ::google::protobuf::internal::NameOfEnum(
    InputScriptType_descriptor(), value);
}
inline bool InputScriptType_Parse(
    const ::std::string& name, InputScriptType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<InputScriptType>(
    InputScriptType_descriptor(), name, value);
}
// ===================================================================

class MultisigRedeemScriptType_HDNodePathType final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:hw.trezor.messages.bitcoin.MultisigRedeemScriptType.HDNodePathType) */ {
 public:
  MultisigRedeemScriptType_HDNodePathType();
  virtual ~MultisigRedeemScriptType_HDNodePathType();

  MultisigRedeemScriptType_HDNodePathType(const MultisigRedeemScriptType_HDNodePathType& from);

  inline MultisigRedeemScriptType_HDNodePathType& operator=(const MultisigRedeemScriptType_HDNodePathType& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  MultisigRedeemScriptType_HDNodePathType(MultisigRedeemScriptType_HDNodePathType&& from) noexcept
    : MultisigRedeemScriptType_HDNodePathType() {
    *this = ::std::move(from);
  }

  inline MultisigRedeemScriptType_HDNodePathType& operator=(MultisigRedeemScriptType_HDNodePathType&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const MultisigRedeemScriptType_HDNodePathType& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const MultisigRedeemScriptType_HDNodePathType* internal_default_instance() {
    return reinterpret_cast<const MultisigRedeemScriptType_HDNodePathType*>(
               &_MultisigRedeemScriptType_HDNodePathType_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  void Swap(MultisigRedeemScriptType_HDNodePathType* other);
  friend void swap(MultisigRedeemScriptType_HDNodePathType& a, MultisigRedeemScriptType_HDNodePathType& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline MultisigRedeemScriptType_HDNodePathType* New() const final {
    return CreateMaybeMessage<MultisigRedeemScriptType_HDNodePathType>(nullptr);
  }

  MultisigRedeemScriptType_HDNodePathType* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<MultisigRedeemScriptType_HDNodePathType>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const MultisigRedeemScriptType_HDNodePathType& from);
  void MergeFrom(const MultisigRedeemScriptType_HDNodePathType& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MultisigRedeemScriptType_HDNodePathType* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated uint32 address_n = 2;
  int address_n_size() const;
  void clear_address_n();
  static const int kAddressNFieldNumber = 2;
  ::google::protobuf::uint32 address_n(int index) const;
  void set_address_n(int index, ::google::protobuf::uint32 value);
  void add_address_n(::google::protobuf::uint32 value);
  const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      address_n() const;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable_address_n();

  // required .hw.trezor.messages.common.HDNodeType node = 1;
  bool has_node() const;
  void clear_node();
  static const int kNodeFieldNumber = 1;
  const ::hw::trezor::messages::common::HDNodeType& node() const;
  ::hw::trezor::messages::common::HDNodeType* release_node();
  ::hw::trezor::messages::common::HDNodeType* mutable_node();
  void set_allocated_node(::hw::trezor::messages::common::HDNodeType* node);

  // @@protoc_insertion_point(class_scope:hw.trezor.messages.bitcoin.MultisigRedeemScriptType.HDNodePathType)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > address_n_;
  ::hw::trezor::messages::common::HDNodeType* node_;
  friend struct ::TableStruct_messages_2dbitcoin_2eproto;
};
// -------------------------------------------------------------------

class MultisigRedeemScriptType final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:hw.trezor.messages.bitcoin.MultisigRedeemScriptType) */ {
 public:
  MultisigRedeemScriptType();
  virtual ~MultisigRedeemScriptType();

  MultisigRedeemScriptType(const MultisigRedeemScriptType& from);

  inline MultisigRedeemScriptType& operator=(const MultisigRedeemScriptType& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  MultisigRedeemScriptType(MultisigRedeemScriptType&& from) noexcept
    : MultisigRedeemScriptType() {
    *this = ::std::move(from);
  }

  inline MultisigRedeemScriptType& operator=(MultisigRedeemScriptType&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const MultisigRedeemScriptType& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const MultisigRedeemScriptType* internal_default_instance() {
    return reinterpret_cast<const MultisigRedeemScriptType*>(
               &_MultisigRedeemScriptType_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  void Swap(MultisigRedeemScriptType* other);
  friend void swap(MultisigRedeemScriptType& a, MultisigRedeemScriptType& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline MultisigRedeemScriptType* New() const final {
    return CreateMaybeMessage<MultisigRedeemScriptType>(nullptr);
  }

  MultisigRedeemScriptType* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<MultisigRedeemScriptType>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const MultisigRedeemScriptType& from);
  void MergeFrom(const MultisigRedeemScriptType& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MultisigRedeemScriptType* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef MultisigRedeemScriptType_HDNodePathType HDNodePathType;

  // accessors -------------------------------------------------------

  // repeated .hw.trezor.messages.bitcoin.MultisigRedeemScriptType.HDNodePathType pubkeys = 1;
  int pubkeys_size() const;
  void clear_pubkeys();
  static const int kPubkeysFieldNumber = 1;
  ::hw::trezor::messages::bitcoin::MultisigRedeemScriptType_HDNodePathType* mutable_pubkeys(int index);
  ::google::protobuf::RepeatedPtrField< ::hw::trezor::messages::bitcoin::MultisigRedeemScriptType_HDNodePathType >*
      mutable_pubkeys();
  const ::hw::trezor::messages::bitcoin::MultisigRedeemScriptType_HDNodePathType& pubkeys(int index) const;
  ::hw::trezor::messages::bitcoin::MultisigRedeemScriptType_HDNodePathType* add_pubkeys();
  const ::google::protobuf::RepeatedPtrField< ::hw::trezor::messages::bitcoin::MultisigRedeemScriptType_HDNodePathType >&
      pubkeys() const;

  // repeated bytes signatures = 2;
  int signatures_size() const;
  void clear_signatures();
  static const int kSignaturesFieldNumber = 2;
  const ::std::string& signatures(int index) const;
  ::std::string* mutable_signatures(int index);
  void set_signatures(int index, const ::std::string& value);
  #if LANG_CXX11
  void set_signatures(int index, ::std::string&& value);
  #endif
  void set_signatures(int index, const char* value);
  void set_signatures(int index, const void* value, size_t size);
  ::std::string* add_signatures();
  void add_signatures(const ::std::string& value);
  #if LANG_CXX11
  void add_signatures(::std::string&& value);
  #endif
  void add_signatures(const char* value);
  void add_signatures(const void* value, size_t size);
  const ::google::protobuf::RepeatedPtrField<::std::string>& signatures() const;
  ::google::protobuf::RepeatedPtrField<::std::string>* mutable_signatures();

  // optional uint32 m = 3;
  bool has_m() const;
  void clear_m();
  static const int kMFieldNumber = 3;
  ::google::protobuf::uint32 m() const;
  void set_m(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:hw.trezor.messages.bitcoin.MultisigRedeemScriptType)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::hw::trezor::messages::bitcoin::MultisigRedeemScriptType_HDNodePathType > pubkeys_;
  ::google::protobuf::RepeatedPtrField<::std::string> signatures_;
  ::google::protobuf::uint32 m_;
  friend struct ::TableStruct_messages_2dbitcoin_2eproto;
};
// -------------------------------------------------------------------

class GetPublicKey final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:hw.trezor.messages.bitcoin.GetPublicKey) */ {
 public:
  GetPublicKey();
  virtual ~GetPublicKey();

  GetPublicKey(const GetPublicKey& from);

  inline GetPublicKey& operator=(const GetPublicKey& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  GetPublicKey(GetPublicKey&& from) noexcept
    : GetPublicKey() {
    *this = ::std::move(from);
  }

  inline GetPublicKey& operator=(GetPublicKey&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const GetPublicKey& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const GetPublicKey* internal_default_instance() {
    return reinterpret_cast<const GetPublicKey*>(
               &_GetPublicKey_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  void Swap(GetPublicKey* other);
  friend void swap(GetPublicKey& a, GetPublicKey& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline GetPublicKey* New() const final {
    return CreateMaybeMessage<GetPublicKey>(nullptr);
  }

  GetPublicKey* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<GetPublicKey>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const GetPublicKey& from);
  void MergeFrom(const GetPublicKey& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetPublicKey* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated uint32 address_n = 1;
  int address_n_size() const;
  void clear_address_n();
  static const int kAddressNFieldNumber = 1;
  ::google::protobuf::uint32 address_n(int index) const;
  void set_address_n(int index, ::google::protobuf::uint32 value);
  void add_address_n(::google::protobuf::uint32 value);
  const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      address_n() const;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable_address_n();

  // optional string ecdsa_curve_name = 2;
  bool has_ecdsa_curve_name() const;
  void clear_ecdsa_curve_name();
  static const int kEcdsaCurveNameFieldNumber = 2;
  const ::std::string& ecdsa_curve_name() const;
  void set_ecdsa_curve_name(const ::std::string& value);
  #if LANG_CXX11
  void set_ecdsa_curve_name(::std::string&& value);
  #endif
  void set_ecdsa_curve_name(const char* value);
  void set_ecdsa_curve_name(const char* value, size_t size);
  ::std::string* mutable_ecdsa_curve_name();
  ::std::string* release_ecdsa_curve_name();
  void set_allocated_ecdsa_curve_name(::std::string* ecdsa_curve_name);

  // optional string coin_name = 4 [default = "Bitcoin"];
  bool has_coin_name() const;
  void clear_coin_name();
  static const int kCoinNameFieldNumber = 4;
  const ::std::string& coin_name() const;
  void set_coin_name(const ::std::string& value);
  #if LANG_CXX11
  void set_coin_name(::std::string&& value);
  #endif
  void set_coin_name(const char* value);
  void set_coin_name(const char* value, size_t size);
  ::std::string* mutable_coin_name();
  ::std::string* release_coin_name();
  void set_allocated_coin_name(::std::string* coin_name);

  // optional bool show_display = 3;
  bool has_show_display() const;
  void clear_show_display();
  static const int kShowDisplayFieldNumber = 3;
  bool show_display() const;
  void set_show_display(bool value);

  // optional .hw.trezor.messages.bitcoin.InputScriptType script_type = 5 [default = SPENDADDRESS];
  bool has_script_type() const;
  void clear_script_type();
  static const int kScriptTypeFieldNumber = 5;
  ::hw::trezor::messages::bitcoin::InputScriptType script_type() const;
  void set_script_type(::hw::trezor::messages::bitcoin::InputScriptType value);

  // @@protoc_insertion_point(class_scope:hw.trezor.messages.bitcoin.GetPublicKey)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > address_n_;
  ::google::protobuf::internal::ArenaStringPtr ecdsa_curve_name_;
  public:
  static ::google::protobuf::internal::ExplicitlyConstructed<::std::string> _i_give_permission_to_break_this_code_default_coin_name_;
  private:
  ::google::protobuf::internal::ArenaStringPtr coin_name_;
  bool show_display_;
  int script_type_;
  friend struct ::TableStruct_messages_2dbitcoin_2eproto;
};
// -------------------------------------------------------------------

class PublicKey final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:hw.trezor.messages.bitcoin.PublicKey) */ {
 public:
  PublicKey();
  virtual ~PublicKey();

  PublicKey(const PublicKey& from);

  inline PublicKey& operator=(const PublicKey& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  PublicKey(PublicKey&& from) noexcept
    : PublicKey() {
    *this = ::std::move(from);
  }

  inline PublicKey& operator=(PublicKey&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const PublicKey& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const PublicKey* internal_default_instance() {
    return reinterpret_cast<const PublicKey*>(
               &_PublicKey_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  void Swap(PublicKey* other);
  friend void swap(PublicKey& a, PublicKey& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline PublicKey* New() const final {
    return CreateMaybeMessage<PublicKey>(nullptr);
  }

  PublicKey* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<PublicKey>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const PublicKey& from);
  void MergeFrom(const PublicKey& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PublicKey* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string xpub = 2;
  bool has_xpub() const;
  void clear_xpub();
  static const int kXpubFieldNumber = 2;
  const ::std::string& xpub() const;
  void set_xpub(const ::std::string& value);
  #if LANG_CXX11
  void set_xpub(::std::string&& value);
  #endif
  void set_xpub(const char* value);
  void set_xpub(const char* value, size_t size);
  ::std::string* mutable_xpub();
  ::std::string* release_xpub();
  void set_allocated_xpub(::std::string* xpub);

  // required .hw.trezor.messages.common.HDNodeType node = 1;
  bool has_node() const;
  void clear_node();
  static const int kNodeFieldNumber = 1;
  const ::hw::trezor::messages::common::HDNodeType& node() const;
  ::hw::trezor::messages::common::HDNodeType* release_node();
  ::hw::trezor::messages::common::HDNodeType* mutable_node();
  void set_allocated_node(::hw::trezor::messages::common::HDNodeType* node);

  // @@protoc_insertion_point(class_scope:hw.trezor.messages.bitcoin.PublicKey)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr xpub_;
  ::hw::trezor::messages::common::HDNodeType* node_;
  friend struct ::TableStruct_messages_2dbitcoin_2eproto;
};
// -------------------------------------------------------------------

class GetAddress final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:hw.trezor.messages.bitcoin.GetAddress) */ {
 public:
  GetAddress();
  virtual ~GetAddress();

  GetAddress(const GetAddress& from);

  inline GetAddress& operator=(const GetAddress& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  GetAddress(GetAddress&& from) noexcept
    : GetAddress() {
    *this = ::std::move(from);
  }

  inline GetAddress& operator=(GetAddress&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const GetAddress& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const GetAddress* internal_default_instance() {
    return reinterpret_cast<const GetAddress*>(
               &_GetAddress_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  void Swap(GetAddress* other);
  friend void swap(GetAddress& a, GetAddress& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline GetAddress* New() const final {
    return CreateMaybeMessage<GetAddress>(nullptr);
  }

  GetAddress* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<GetAddress>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const GetAddress& from);
  void MergeFrom(const GetAddress& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetAddress* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated uint32 address_n = 1;
  int address_n_size() const;
  void clear_address_n();
  static const int kAddressNFieldNumber = 1;
  ::google::protobuf::uint32 address_n(int index) const;
  void set_address_n(int index, ::google::protobuf::uint32 value);
  void add_address_n(::google::protobuf::uint32 value);
  const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      address_n() const;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable_address_n();

  // optional string coin_name = 2 [default = "Bitcoin"];
  bool has_coin_name() const;
  void clear_coin_name();
  static const int kCoinNameFieldNumber = 2;
  const ::std::string& coin_name() const;
  void set_coin_name(const ::std::string& value);
  #if LANG_CXX11
  void set_coin_name(::std::string&& value);
  #endif
  void set_coin_name(const char* value);
  void set_coin_name(const char* value, size_t size);
  ::std::string* mutable_coin_name();
  ::std::string* release_coin_name();
  void set_allocated_coin_name(::std::string* coin_name);

  // optional .hw.trezor.messages.bitcoin.MultisigRedeemScriptType multisig = 4;
  bool has_multisig() const;
  void clear_multisig();
  static const int kMultisigFieldNumber = 4;
  const ::hw::trezor::messages::bitcoin::MultisigRedeemScriptType& multisig() const;
  ::hw::trezor::messages::bitcoin::MultisigRedeemScriptType* release_multisig();
  ::hw::trezor::messages::bitcoin::MultisigRedeemScriptType* mutable_multisig();
  void set_allocated_multisig(::hw::trezor::messages::bitcoin::MultisigRedeemScriptType* multisig);

  // optional bool show_display = 3;
  bool has_show_display() const;
  void clear_show_display();
  static const int kShowDisplayFieldNumber = 3;
  bool show_display() const;
  void set_show_display(bool value);

  // optional .hw.trezor.messages.bitcoin.InputScriptType script_type = 5 [default = SPENDADDRESS];
  bool has_script_type() const;
  void clear_script_type();
  static const int kScriptTypeFieldNumber = 5;
  ::hw::trezor::messages::bitcoin::InputScriptType script_type() const;
  void set_script_type(::hw::trezor::messages::bitcoin::InputScriptType value);

  // @@protoc_insertion_point(class_scope:hw.trezor.messages.bitcoin.GetAddress)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > address_n_;
  public:
  static ::google::protobuf::internal::ExplicitlyConstructed<::std::string> _i_give_permission_to_break_this_code_default_coin_name_;
  private:
  ::google::protobuf::internal::ArenaStringPtr coin_name_;
  ::hw::trezor::messages::bitcoin::MultisigRedeemScriptType* multisig_;
  bool show_display_;
  int script_type_;
  friend struct ::TableStruct_messages_2dbitcoin_2eproto;
};
// -------------------------------------------------------------------

class Address final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:hw.trezor.messages.bitcoin.Address) */ {
 public:
  Address();
  virtual ~Address();

  Address(const Address& from);

  inline Address& operator=(const Address& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Address(Address&& from) noexcept
    : Address() {
    *this = ::std::move(from);
  }

  inline Address& operator=(Address&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const Address& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Address* internal_default_instance() {
    return reinterpret_cast<const Address*>(
               &_Address_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  void Swap(Address* other);
  friend void swap(Address& a, Address& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Address* New() const final {
    return CreateMaybeMessage<Address>(nullptr);
  }

  Address* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Address>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Address& from);
  void MergeFrom(const Address& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Address* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string address = 1;
  bool has_address() const;
  void clear_address();
  static const int kAddressFieldNumber = 1;
  const ::std::string& address() const;
  void set_address(const ::std::string& value);
  #if LANG_CXX11
  void set_address(::std::string&& value);
  #endif
  void set_address(const char* value);
  void set_address(const char* value, size_t size);
  ::std::string* mutable_address();
  ::std::string* release_address();
  void set_allocated_address(::std::string* address);

  // @@protoc_insertion_point(class_scope:hw.trezor.messages.bitcoin.Address)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr address_;
  friend struct ::TableStruct_messages_2dbitcoin_2eproto;
};
// -------------------------------------------------------------------

class SignMessage final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:hw.trezor.messages.bitcoin.SignMessage) */ {
 public:
  SignMessage();
  virtual ~SignMessage();

  SignMessage(const SignMessage& from);

  inline SignMessage& operator=(const SignMessage& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  SignMessage(SignMessage&& from) noexcept
    : SignMessage() {
    *this = ::std::move(from);
  }

  inline SignMessage& operator=(SignMessage&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const SignMessage& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SignMessage* internal_default_instance() {
    return reinterpret_cast<const SignMessage*>(
               &_SignMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  void Swap(SignMessage* other);
  friend void swap(SignMessage& a, SignMessage& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline SignMessage* New() const final {
    return CreateMaybeMessage<SignMessage>(nullptr);
  }

  SignMessage* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<SignMessage>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const SignMessage& from);
  void MergeFrom(const SignMessage& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SignMessage* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated uint32 address_n = 1;
  int address_n_size() const;
  void clear_address_n();
  static const int kAddressNFieldNumber = 1;
  ::google::protobuf::uint32 address_n(int index) const;
  void set_address_n(int index, ::google::protobuf::uint32 value);
  void add_address_n(::google::protobuf::uint32 value);
  const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      address_n() const;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable_address_n();

  // required bytes message = 2;
  bool has_message() const;
  void clear_message();
  static const int kMessageFieldNumber = 2;
  const ::std::string& message() const;
  void set_message(const ::std::string& value);
  #if LANG_CXX11
  void set_message(::std::string&& value);
  #endif
  void set_message(const char* value);
  void set_message(const void* value, size_t size);
  ::std::string* mutable_message();
  ::std::string* release_message();
  void set_allocated_message(::std::string* message);

  // optional string coin_name = 3 [default = "Bitcoin"];
  bool has_coin_name() const;
  void clear_coin_name();
  static const int kCoinNameFieldNumber = 3;
  const ::std::string& coin_name() const;
  void set_coin_name(const ::std::string& value);
  #if LANG_CXX11
  void set_coin_name(::std::string&& value);
  #endif
  void set_coin_name(const char* value);
  void set_coin_name(const char* value, size_t size);
  ::std::string* mutable_coin_name();
  ::std::string* release_coin_name();
  void set_allocated_coin_name(::std::string* coin_name);

  // optional .hw.trezor.messages.bitcoin.InputScriptType script_type = 4 [default = SPENDADDRESS];
  bool has_script_type() const;
  void clear_script_type();
  static const int kScriptTypeFieldNumber = 4;
  ::hw::trezor::messages::bitcoin::InputScriptType script_type() const;
  void set_script_type(::hw::trezor::messages::bitcoin::InputScriptType value);

  // @@protoc_insertion_point(class_scope:hw.trezor.messages.bitcoin.SignMessage)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > address_n_;
  ::google::protobuf::internal::ArenaStringPtr message_;
  public:
  static ::google::protobuf::internal::ExplicitlyConstructed<::std::string> _i_give_permission_to_break_this_code_default_coin_name_;
  private:
  ::google::protobuf::internal::ArenaStringPtr coin_name_;
  int script_type_;
  friend struct ::TableStruct_messages_2dbitcoin_2eproto;
};
// -------------------------------------------------------------------

class MessageSignature final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:hw.trezor.messages.bitcoin.MessageSignature) */ {
 public:
  MessageSignature();
  virtual ~MessageSignature();

  MessageSignature(const MessageSignature& from);

  inline MessageSignature& operator=(const MessageSignature& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  MessageSignature(MessageSignature&& from) noexcept
    : MessageSignature() {
    *this = ::std::move(from);
  }

  inline MessageSignature& operator=(MessageSignature&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const MessageSignature& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const MessageSignature* internal_default_instance() {
    return reinterpret_cast<const MessageSignature*>(
               &_MessageSignature_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  void Swap(MessageSignature* other);
  friend void swap(MessageSignature& a, MessageSignature& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline MessageSignature* New() const final {
    return CreateMaybeMessage<MessageSignature>(nullptr);
  }

  MessageSignature* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<MessageSignature>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const MessageSignature& from);
  void MergeFrom(const MessageSignature& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MessageSignature* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string address = 1;
  bool has_address() const;
  void clear_address();
  static const int kAddressFieldNumber = 1;
  const ::std::string& address() const;
  void set_address(const ::std::string& value);
  #if LANG_CXX11
  void set_address(::std::string&& value);
  #endif
  void set_address(const char* value);
  void set_address(const char* value, size_t size);
  ::std::string* mutable_address();
  ::std::string* release_address();
  void set_allocated_address(::std::string* address);

  // optional bytes signature = 2;
  bool has_signature() const;
  void clear_signature();
  static const int kSignatureFieldNumber = 2;
  const ::std::string& signature() const;
  void set_signature(const ::std::string& value);
  #if LANG_CXX11
  void set_signature(::std::string&& value);
  #endif
  void set_signature(const char* value);
  void set_signature(const void* value, size_t size);
  ::std::string* mutable_signature();
  ::std::string* release_signature();
  void set_allocated_signature(::std::string* signature);

  // @@protoc_insertion_point(class_scope:hw.trezor.messages.bitcoin.MessageSignature)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr address_;
  ::google::protobuf::internal::ArenaStringPtr signature_;
  friend struct ::TableStruct_messages_2dbitcoin_2eproto;
};
// -------------------------------------------------------------------

class VerifyMessage final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:hw.trezor.messages.bitcoin.VerifyMessage) */ {
 public:
  VerifyMessage();
  virtual ~VerifyMessage();

  VerifyMessage(const VerifyMessage& from);

  inline VerifyMessage& operator=(const VerifyMessage& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  VerifyMessage(VerifyMessage&& from) noexcept
    : VerifyMessage() {
    *this = ::std::move(from);
  }

  inline VerifyMessage& operator=(VerifyMessage&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const VerifyMessage& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const VerifyMessage* internal_default_instance() {
    return reinterpret_cast<const VerifyMessage*>(
               &_VerifyMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  void Swap(VerifyMessage* other);
  friend void swap(VerifyMessage& a, VerifyMessage& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline VerifyMessage* New() const final {
    return CreateMaybeMessage<VerifyMessage>(nullptr);
  }

  VerifyMessage* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<VerifyMessage>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const VerifyMessage& from);
  void MergeFrom(const VerifyMessage& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(VerifyMessage* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string address = 1;
  bool has_address() const;
  void clear_address();
  static const int kAddressFieldNumber = 1;
  const ::std::string& address() const;
  void set_address(const ::std::string& value);
  #if LANG_CXX11
  void set_address(::std::string&& value);
  #endif
  void set_address(const char* value);
  void set_address(const char* value, size_t size);
  ::std::string* mutable_address();
  ::std::string* release_address();
  void set_allocated_address(::std::string* address);

  // optional bytes signature = 2;
  bool has_signature() const;
  void clear_signature();
  static const int kSignatureFieldNumber = 2;
  const ::std::string& signature() const;
  void set_signature(const ::std::string& value);
  #if LANG_CXX11
  void set_signature(::std::string&& value);
  #endif
  void set_signature(const char* value);
  void set_signature(const void* value, size_t size);
  ::std::string* mutable_signature();
  ::std::string* release_signature();
  void set_allocated_signature(::std::string* signature);

  // optional bytes message = 3;
  bool has_message() const;
  void clear_message();
  static const int kMessageFieldNumber = 3;
  const ::std::string& message() const;
  void set_message(const ::std::string& value);
  #if LANG_CXX11
  void set_message(::std::string&& value);
  #endif
  void set_message(const char* value);
  void set_message(const void* value, size_t size);
  ::std::string* mutable_message();
  ::std::string* release_message();
  void set_allocated_message(::std::string* message);

  // optional string coin_name = 4 [default = "Bitcoin"];
  bool has_coin_name() const;
  void clear_coin_name();
  static const int kCoinNameFieldNumber = 4;
  const ::std::string& coin_name() const;
  void set_coin_name(const ::std::string& value);
  #if LANG_CXX11
  void set_coin_name(::std::string&& value);
  #endif
  void set_coin_name(const char* value);
  void set_coin_name(const char* value, size_t size);
  ::std::string* mutable_coin_name();
  ::std::string* release_coin_name();
  void set_allocated_coin_name(::std::string* coin_name);

  // @@protoc_insertion_point(class_scope:hw.trezor.messages.bitcoin.VerifyMessage)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr address_;
  ::google::protobuf::internal::ArenaStringPtr signature_;
  ::google::protobuf::internal::ArenaStringPtr message_;
  public:
  static ::google::protobuf::internal::ExplicitlyConstructed<::std::string> _i_give_permission_to_break_this_code_default_coin_name_;
  private:
  ::google::protobuf::internal::ArenaStringPtr coin_name_;
  friend struct ::TableStruct_messages_2dbitcoin_2eproto;
};
// -------------------------------------------------------------------

class SignTx final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:hw.trezor.messages.bitcoin.SignTx) */ {
 public:
  SignTx();
  virtual ~SignTx();

  SignTx(const SignTx& from);

  inline SignTx& operator=(const SignTx& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  SignTx(SignTx&& from) noexcept
    : SignTx() {
    *this = ::std::move(from);
  }

  inline SignTx& operator=(SignTx&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const SignTx& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SignTx* internal_default_instance() {
    return reinterpret_cast<const SignTx*>(
               &_SignTx_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  void Swap(SignTx* other);
  friend void swap(SignTx& a, SignTx& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline SignTx* New() const final {
    return CreateMaybeMessage<SignTx>(nullptr);
  }

  SignTx* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<SignTx>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const SignTx& from);
  void MergeFrom(const SignTx& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SignTx* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string coin_name = 3 [default = "Bitcoin"];
  bool has_coin_name() const;
  void clear_coin_name();
  static const int kCoinNameFieldNumber = 3;
  const ::std::string& coin_name() const;
  void set_coin_name(const ::std::string& value);
  #if LANG_CXX11
  void set_coin_name(::std::string&& value);
  #endif
  void set_coin_name(const char* value);
  void set_coin_name(const char* value, size_t size);
  ::std::string* mutable_coin_name();
  ::std::string* release_coin_name();
  void set_allocated_coin_name(::std::string* coin_name);

  // required uint32 outputs_count = 1;
  bool has_outputs_count() const;
  void clear_outputs_count();
  static const int kOutputsCountFieldNumber = 1;
  ::google::protobuf::uint32 outputs_count() const;
  void set_outputs_count(::google::protobuf::uint32 value);

  // required uint32 inputs_count = 2;
  bool has_inputs_count() const;
  void clear_inputs_count();
  static const int kInputsCountFieldNumber = 2;
  ::google::protobuf::uint32 inputs_count() const;
  void set_inputs_count(::google::protobuf::uint32 value);

  // optional uint32 lock_time = 5 [default = 0];
  bool has_lock_time() const;
  void clear_lock_time();
  static const int kLockTimeFieldNumber = 5;
  ::google::protobuf::uint32 lock_time() const;
  void set_lock_time(::google::protobuf::uint32 value);

  // optional uint32 expiry = 6;
  bool has_expiry() const;
  void clear_expiry();
  static const int kExpiryFieldNumber = 6;
  ::google::protobuf::uint32 expiry() const;
  void set_expiry(::google::protobuf::uint32 value);

  // optional bool overwintered = 7;
  bool has_overwintered() const;
  void clear_overwintered();
  static const int kOverwinteredFieldNumber = 7;
  bool overwintered() const;
  void set_overwintered(bool value);

  // optional uint32 version_group_id = 8;
  bool has_version_group_id() const;
  void clear_version_group_id();
  static const int kVersionGroupIdFieldNumber = 8;
  ::google::protobuf::uint32 version_group_id() const;
  void set_version_group_id(::google::protobuf::uint32 value);

  // optional uint32 timestamp = 9;
  bool has_timestamp() const;
  void clear_timestamp();
  static const int kTimestampFieldNumber = 9;
  ::google::protobuf::uint32 timestamp() const;
  void set_timestamp(::google::protobuf::uint32 value);

  // optional uint32 version = 4 [default = 1];
  bool has_version() const;
  void clear_version();
  static const int kVersionFieldNumber = 4;
  ::google::protobuf::uint32 version() const;
  void set_version(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:hw.trezor.messages.bitcoin.SignTx)
 private:
  class HasBitSetters;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  public:
  static ::google::protobuf::internal::ExplicitlyConstructed<::std::string> _i_give_permission_to_break_this_code_default_coin_name_;
  private:
  ::google::protobuf::internal::ArenaStringPtr coin_name_;
  ::google::protobuf::uint32 outputs_count_;
  ::google::protobuf::uint32 inputs_count_;
  ::google::protobuf::uint32 lock_time_;
  ::google::protobuf::uint32 expiry_;
  bool overwintered_;
  ::google::protobuf::uint32 version_group_id_;
  ::google::protobuf::uint32 timestamp_;
  ::google::protobuf::uint32 version_;
  friend struct ::TableStruct_messages_2dbitcoin_2eproto;
};
// -------------------------------------------------------------------

class TxRequest_TxRequestDetailsType final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:hw.trezor.messages.bitcoin.TxRequest.TxRequestDetailsType) */ {
 public:
  TxRequest_TxRequestDetailsType();
  virtual ~TxRequest_TxRequestDetailsType();

  TxRequest_TxRequestDetailsType(const TxRequest_TxRequestDetailsType& from);

  inline TxRequest_TxRequestDetailsType& operator=(const TxRequest_TxRequestDetailsType& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  TxRequest_TxRequestDetailsType(TxRequest_TxRequestDetailsType&& from) noexcept
    : TxRequest_TxRequestDetailsType() {
    *this = ::std::move(from);
  }

  inline TxRequest_TxRequestDetailsType& operator=(TxRequest_TxRequestDetailsType&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const TxRequest_TxRequestDetailsType& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const TxRequest_TxRequestDetailsType* internal_default_instance() {
    return reinterpret_cast<const TxRequest_TxRequestDetailsType*>(
               &_TxRequest_TxRequestDetailsType_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  void Swap(TxRequest_TxRequestDetailsType* other);
  friend void swap(TxRequest_TxRequestDetailsType& a, TxRequest_TxRequestDetailsType& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline TxRequest_TxRequestDetailsType* New() const final {
    return CreateMaybeMessage<TxRequest_TxRequestDetailsType>(nullptr);
  }

  TxRequest_TxRequestDetailsType* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<TxRequest_TxRequestDetailsType>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const TxRequest_TxRequestDetailsType& from);
  void MergeFrom(const TxRequest_TxRequestDetailsType& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TxRequest_TxRequestDetailsType* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bytes tx_hash = 2;
  bool has_tx_hash() const;
  void clear_tx_hash();
  static const int kTxHashFieldNumber = 2;
  const ::std::string& tx_hash() const;
  void set_tx_hash(const ::std::string& value);
  #if LANG_CXX11
  void set_tx_hash(::std::string&& value);
  #endif
  void set_tx_hash(const char* value);
  void set_tx_hash(const void* value, size_t size);
  ::std::string* mutable_tx_hash();
  ::std::string* release_tx_hash();
  void set_allocated_tx_hash(::std::string* tx_hash);

  // optional uint32 request_index = 1;
  bool has_request_index() const;
  void clear_request_index();
  static const int kRequestIndexFieldNumber = 1;
  ::google::protobuf::uint32 request_index() const;
  void set_request_index(::google::protobuf::uint32 value);

  // optional uint32 extra_data_len = 3;
  bool has_extra_data_len() const;
  void clear_extra_data_len();
  static const int kExtraDataLenFieldNumber = 3;
  ::google::protobuf::uint32 extra_data_len() const;
  void set_extra_data_len(::google::protobuf::uint32 value);

  // optional uint32 extra_data_offset = 4;
  bool has_extra_data_offset() const;
  void clear_extra_data_offset();
  static const int kExtraDataOffsetFieldNumber = 4;
  ::google::protobuf::uint32 extra_data_offset() const;
  void set_extra_data_offset(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:hw.trezor.messages.bitcoin.TxRequest.TxRequestDetailsType)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr tx_hash_;
  ::google::protobuf::uint32 request_index_;
  ::google::protobuf::uint32 extra_data_len_;
  ::google::protobuf::uint32 extra_data_offset_;
  friend struct ::TableStruct_messages_2dbitcoin_2eproto;
};
// -------------------------------------------------------------------

class TxRequest_TxRequestSerializedType final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:hw.trezor.messages.bitcoin.TxRequest.TxRequestSerializedType) */ {
 public:
  TxRequest_TxRequestSerializedType();
  virtual ~TxRequest_TxRequestSerializedType();

  TxRequest_TxRequestSerializedType(const TxRequest_TxRequestSerializedType& from);

  inline TxRequest_TxRequestSerializedType& operator=(const TxRequest_TxRequestSerializedType& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  TxRequest_TxRequestSerializedType(TxRequest_TxRequestSerializedType&& from) noexcept
    : TxRequest_TxRequestSerializedType() {
    *this = ::std::move(from);
  }

  inline TxRequest_TxRequestSerializedType& operator=(TxRequest_TxRequestSerializedType&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const TxRequest_TxRequestSerializedType& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const TxRequest_TxRequestSerializedType* internal_default_instance() {
    return reinterpret_cast<const TxRequest_TxRequestSerializedType*>(
               &_TxRequest_TxRequestSerializedType_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  void Swap(TxRequest_TxRequestSerializedType* other);
  friend void swap(TxRequest_TxRequestSerializedType& a, TxRequest_TxRequestSerializedType& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline TxRequest_TxRequestSerializedType* New() const final {
    return CreateMaybeMessage<TxRequest_TxRequestSerializedType>(nullptr);
  }

  TxRequest_TxRequestSerializedType* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<TxRequest_TxRequestSerializedType>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const TxRequest_TxRequestSerializedType& from);
  void MergeFrom(const TxRequest_TxRequestSerializedType& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TxRequest_TxRequestSerializedType* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bytes signature = 2;
  bool has_signature() const;
  void clear_signature();
  static const int kSignatureFieldNumber = 2;
  const ::std::string& signature() const;
  void set_signature(const ::std::string& value);
  #if LANG_CXX11
  void set_signature(::std::string&& value);
  #endif
  void set_signature(const char* value);
  void set_signature(const void* value, size_t size);
  ::std::string* mutable_signature();
  ::std::string* release_signature();
  void set_allocated_signature(::std::string* signature);

  // optional bytes serialized_tx = 3;
  bool has_serialized_tx() const;
  void clear_serialized_tx();
  static const int kSerializedTxFieldNumber = 3;
  const ::std::string& serialized_tx() const;
  void set_serialized_tx(const ::std::string& value);
  #if LANG_CXX11
  void set_serialized_tx(::std::string&& value);
  #endif
  void set_serialized_tx(const char* value);
  void set_serialized_tx(const void* value, size_t size);
  ::std::string* mutable_serialized_tx();
  ::std::string* release_serialized_tx();
  void set_allocated_serialized_tx(::std::string* serialized_tx);

  // optional uint32 signature_index = 1;
  bool has_signature_index() const;
  void clear_signature_index();
  static const int kSignatureIndexFieldNumber = 1;
  ::google::protobuf::uint32 signature_index() const;
  void set_signature_index(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:hw.trezor.messages.bitcoin.TxRequest.TxRequestSerializedType)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr signature_;
  ::google::protobuf::internal::ArenaStringPtr serialized_tx_;
  ::google::protobuf::uint32 signature_index_;
  friend struct ::TableStruct_messages_2dbitcoin_2eproto;
};
// -------------------------------------------------------------------

class TxRequest final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:hw.trezor.messages.bitcoin.TxRequest) */ {
 public:
  TxRequest();
  virtual ~TxRequest();

  TxRequest(const TxRequest& from);

  inline TxRequest& operator=(const TxRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  TxRequest(TxRequest&& from) noexcept
    : TxRequest() {
    *this = ::std::move(from);
  }

  inline TxRequest& operator=(TxRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const TxRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const TxRequest* internal_default_instance() {
    return reinterpret_cast<const TxRequest*>(
               &_TxRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  void Swap(TxRequest* other);
  friend void swap(TxRequest& a, TxRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline TxRequest* New() const final {
    return CreateMaybeMessage<TxRequest>(nullptr);
  }

  TxRequest* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<TxRequest>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const TxRequest& from);
  void MergeFrom(const TxRequest& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TxRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef TxRequest_TxRequestDetailsType TxRequestDetailsType;
  typedef TxRequest_TxRequestSerializedType TxRequestSerializedType;

  typedef TxRequest_RequestType RequestType;
  static const RequestType TXINPUT =
    TxRequest_RequestType_TXINPUT;
  static const RequestType TXOUTPUT =
    TxRequest_RequestType_TXOUTPUT;
  static const RequestType TXMETA =
    TxRequest_RequestType_TXMETA;
  static const RequestType TXFINISHED =
    TxRequest_RequestType_TXFINISHED;
  static const RequestType TXEXTRADATA =
    TxRequest_RequestType_TXEXTRADATA;
  static inline bool RequestType_IsValid(int value) {
    return TxRequest_RequestType_IsValid(value);
  }
  static const RequestType RequestType_MIN =
    TxRequest_RequestType_RequestType_MIN;
  static const RequestType RequestType_MAX =
    TxRequest_RequestType_RequestType_MAX;
  static const int RequestType_ARRAYSIZE =
    TxRequest_RequestType_RequestType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  RequestType_descriptor() {
    return TxRequest_RequestType_descriptor();
  }
  static inline const ::std::string& RequestType_Name(RequestType value) {
    return TxRequest_RequestType_Name(value);
  }
  static inline bool RequestType_Parse(const ::std::string& name,
      RequestType* value) {
    return TxRequest_RequestType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // optional .hw.trezor.messages.bitcoin.TxRequest.TxRequestDetailsType details = 2;
  bool has_details() const;
  void clear_details();
  static const int kDetailsFieldNumber = 2;
  const ::hw::trezor::messages::bitcoin::TxRequest_TxRequestDetailsType& details() const;
  ::hw::trezor::messages::bitcoin::TxRequest_TxRequestDetailsType* release_details();
  ::hw::trezor::messages::bitcoin::TxRequest_TxRequestDetailsType* mutable_details();
  void set_allocated_details(::hw::trezor::messages::bitcoin::TxRequest_TxRequestDetailsType* details);

  // optional .hw.trezor.messages.bitcoin.TxRequest.TxRequestSerializedType serialized = 3;
  bool has_serialized() const;
  void clear_serialized();
  static const int kSerializedFieldNumber = 3;
  const ::hw::trezor::messages::bitcoin::TxRequest_TxRequestSerializedType& serialized() const;
  ::hw::trezor::messages::bitcoin::TxRequest_TxRequestSerializedType* release_serialized();
  ::hw::trezor::messages::bitcoin::TxRequest_TxRequestSerializedType* mutable_serialized();
  void set_allocated_serialized(::hw::trezor::messages::bitcoin::TxRequest_TxRequestSerializedType* serialized);

  // optional .hw.trezor.messages.bitcoin.TxRequest.RequestType request_type = 1;
  bool has_request_type() const;
  void clear_request_type();
  static const int kRequestTypeFieldNumber = 1;
  ::hw::trezor::messages::bitcoin::TxRequest_RequestType request_type() const;
  void set_request_type(::hw::trezor::messages::bitcoin::TxRequest_RequestType value);

  // @@protoc_insertion_point(class_scope:hw.trezor.messages.bitcoin.TxRequest)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::hw::trezor::messages::bitcoin::TxRequest_TxRequestDetailsType* details_;
  ::hw::trezor::messages::bitcoin::TxRequest_TxRequestSerializedType* serialized_;
  int request_type_;
  friend struct ::TableStruct_messages_2dbitcoin_2eproto;
};
// -------------------------------------------------------------------

class TxAck_TransactionType_TxInputType final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:hw.trezor.messages.bitcoin.TxAck.TransactionType.TxInputType) */ {
 public:
  TxAck_TransactionType_TxInputType();
  virtual ~TxAck_TransactionType_TxInputType();

  TxAck_TransactionType_TxInputType(const TxAck_TransactionType_TxInputType& from);

  inline TxAck_TransactionType_TxInputType& operator=(const TxAck_TransactionType_TxInputType& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  TxAck_TransactionType_TxInputType(TxAck_TransactionType_TxInputType&& from) noexcept
    : TxAck_TransactionType_TxInputType() {
    *this = ::std::move(from);
  }

  inline TxAck_TransactionType_TxInputType& operator=(TxAck_TransactionType_TxInputType&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const TxAck_TransactionType_TxInputType& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const TxAck_TransactionType_TxInputType* internal_default_instance() {
    return reinterpret_cast<const TxAck_TransactionType_TxInputType*>(
               &_TxAck_TransactionType_TxInputType_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  void Swap(TxAck_TransactionType_TxInputType* other);
  friend void swap(TxAck_TransactionType_TxInputType& a, TxAck_TransactionType_TxInputType& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline TxAck_TransactionType_TxInputType* New() const final {
    return CreateMaybeMessage<TxAck_TransactionType_TxInputType>(nullptr);
  }

  TxAck_TransactionType_TxInputType* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<TxAck_TransactionType_TxInputType>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const TxAck_TransactionType_TxInputType& from);
  void MergeFrom(const TxAck_TransactionType_TxInputType& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TxAck_TransactionType_TxInputType* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated uint32 address_n = 1;
  int address_n_size() const;
  void clear_address_n();
  static const int kAddressNFieldNumber = 1;
  ::google::protobuf::uint32 address_n(int index) const;
  void set_address_n(int index, ::google::protobuf::uint32 value);
  void add_address_n(::google::protobuf::uint32 value);
  const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      address_n() const;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable_address_n();

  // required bytes prev_hash = 2;
  bool has_prev_hash() const;
  void clear_prev_hash();
  static const int kPrevHashFieldNumber = 2;
  const ::std::string& prev_hash() const;
  void set_prev_hash(const ::std::string& value);
  #if LANG_CXX11
  void set_prev_hash(::std::string&& value);
  #endif
  void set_prev_hash(const char* value);
  void set_prev_hash(const void* value, size_t size);
  ::std::string* mutable_prev_hash();
  ::std::string* release_prev_hash();
  void set_allocated_prev_hash(::std::string* prev_hash);

  // optional bytes script_sig = 4;
  bool has_script_sig() const;
  void clear_script_sig();
  static const int kScriptSigFieldNumber = 4;
  const ::std::string& script_sig() const;
  void set_script_sig(const ::std::string& value);
  #if LANG_CXX11
  void set_script_sig(::std::string&& value);
  #endif
  void set_script_sig(const char* value);
  void set_script_sig(const void* value, size_t size);
  ::std::string* mutable_script_sig();
  ::std::string* release_script_sig();
  void set_allocated_script_sig(::std::string* script_sig);

  // optional bytes prev_block_hash_bip115 = 11;
  bool has_prev_block_hash_bip115() const;
  void clear_prev_block_hash_bip115();
  static const int kPrevBlockHashBip115FieldNumber = 11;
  const ::std::string& prev_block_hash_bip115() const;
  void set_prev_block_hash_bip115(const ::std::string& value);
  #if LANG_CXX11
  void set_prev_block_hash_bip115(::std::string&& value);
  #endif
  void set_prev_block_hash_bip115(const char* value);
  void set_prev_block_hash_bip115(const void* value, size_t size);
  ::std::string* mutable_prev_block_hash_bip115();
  ::std::string* release_prev_block_hash_bip115();
  void set_allocated_prev_block_hash_bip115(::std::string* prev_block_hash_bip115);

  // optional .hw.trezor.messages.bitcoin.MultisigRedeemScriptType multisig = 7;
  bool has_multisig() const;
  void clear_multisig();
  static const int kMultisigFieldNumber = 7;
  const ::hw::trezor::messages::bitcoin::MultisigRedeemScriptType& multisig() const;
  ::hw::trezor::messages::bitcoin::MultisigRedeemScriptType* release_multisig();
  ::hw::trezor::messages::bitcoin::MultisigRedeemScriptType* mutable_multisig();
  void set_allocated_multisig(::hw::trezor::messages::bitcoin::MultisigRedeemScriptType* multisig);

  // required uint32 prev_index = 3;
  bool has_prev_index() const;
  void clear_prev_index();
  static const int kPrevIndexFieldNumber = 3;
  ::google::protobuf::uint32 prev_index() const;
  void set_prev_index(::google::protobuf::uint32 value);

  // optional .hw.trezor.messages.bitcoin.InputScriptType script_type = 6 [default = SPENDADDRESS];
  bool has_script_type() const;
  void clear_script_type();
  static const int kScriptTypeFieldNumber = 6;
  ::hw::trezor::messages::bitcoin::InputScriptType script_type() const;
  void set_script_type(::hw::trezor::messages::bitcoin::InputScriptType value);

  // optional uint64 amount = 8;
  bool has_amount() const;
  void clear_amount();
  static const int kAmountFieldNumber = 8;
  ::google::protobuf::uint64 amount() const;
  void set_amount(::google::protobuf::uint64 value);

  // optional uint32 decred_tree = 9;
  bool has_decred_tree() const;
  void clear_decred_tree();
  static const int kDecredTreeFieldNumber = 9;
  ::google::protobuf::uint32 decred_tree() const;
  void set_decred_tree(::google::protobuf::uint32 value);

  // optional uint32 decred_script_version = 10;
  bool has_decred_script_version() const;
  void clear_decred_script_version();
  static const int kDecredScriptVersionFieldNumber = 10;
  ::google::protobuf::uint32 decred_script_version() const;
  void set_decred_script_version(::google::protobuf::uint32 value);

  // optional uint32 prev_block_height_bip115 = 12;
  bool has_prev_block_height_bip115() const;
  void clear_prev_block_height_bip115();
  static const int kPrevBlockHeightBip115FieldNumber = 12;
  ::google::protobuf::uint32 prev_block_height_bip115() const;
  void set_prev_block_height_bip115(::google::protobuf::uint32 value);

  // optional uint32 sequence = 5 [default = 4294967295];
  bool has_sequence() const;
  void clear_sequence();
  static const int kSequenceFieldNumber = 5;
  ::google::protobuf::uint32 sequence() const;
  void set_sequence(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:hw.trezor.messages.bitcoin.TxAck.TransactionType.TxInputType)
 private:
  class HasBitSetters;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > address_n_;
  ::google::protobuf::internal::ArenaStringPtr prev_hash_;
  ::google::protobuf::internal::ArenaStringPtr script_sig_;
  ::google::protobuf::internal::ArenaStringPtr prev_block_hash_bip115_;
  ::hw::trezor::messages::bitcoin::MultisigRedeemScriptType* multisig_;
  ::google::protobuf::uint32 prev_index_;
  int script_type_;
  ::google::protobuf::uint64 amount_;
  ::google::protobuf::uint32 decred_tree_;
  ::google::protobuf::uint32 decred_script_version_;
  ::google::protobuf::uint32 prev_block_height_bip115_;
  ::google::protobuf::uint32 sequence_;
  friend struct ::TableStruct_messages_2dbitcoin_2eproto;
};
// -------------------------------------------------------------------

class TxAck_TransactionType_TxOutputBinType final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:hw.trezor.messages.bitcoin.TxAck.TransactionType.TxOutputBinType) */ {
 public:
  TxAck_TransactionType_TxOutputBinType();
  virtual ~TxAck_TransactionType_TxOutputBinType();

  TxAck_TransactionType_TxOutputBinType(const TxAck_TransactionType_TxOutputBinType& from);

  inline TxAck_TransactionType_TxOutputBinType& operator=(const TxAck_TransactionType_TxOutputBinType& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  TxAck_TransactionType_TxOutputBinType(TxAck_TransactionType_TxOutputBinType&& from) noexcept
    : TxAck_TransactionType_TxOutputBinType() {
    *this = ::std::move(from);
  }

  inline TxAck_TransactionType_TxOutputBinType& operator=(TxAck_TransactionType_TxOutputBinType&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const TxAck_TransactionType_TxOutputBinType& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const TxAck_TransactionType_TxOutputBinType* internal_default_instance() {
    return reinterpret_cast<const TxAck_TransactionType_TxOutputBinType*>(
               &_TxAck_TransactionType_TxOutputBinType_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  void Swap(TxAck_TransactionType_TxOutputBinType* other);
  friend void swap(TxAck_TransactionType_TxOutputBinType& a, TxAck_TransactionType_TxOutputBinType& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline TxAck_TransactionType_TxOutputBinType* New() const final {
    return CreateMaybeMessage<TxAck_TransactionType_TxOutputBinType>(nullptr);
  }

  TxAck_TransactionType_TxOutputBinType* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<TxAck_TransactionType_TxOutputBinType>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const TxAck_TransactionType_TxOutputBinType& from);
  void MergeFrom(const TxAck_TransactionType_TxOutputBinType& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TxAck_TransactionType_TxOutputBinType* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required bytes script_pubkey = 2;
  bool has_script_pubkey() const;
  void clear_script_pubkey();
  static const int kScriptPubkeyFieldNumber = 2;
  const ::std::string& script_pubkey() const;
  void set_script_pubkey(const ::std::string& value);
  #if LANG_CXX11
  void set_script_pubkey(::std::string&& value);
  #endif
  void set_script_pubkey(const char* value);
  void set_script_pubkey(const void* value, size_t size);
  ::std::string* mutable_script_pubkey();
  ::std::string* release_script_pubkey();
  void set_allocated_script_pubkey(::std::string* script_pubkey);

  // required uint64 amount = 1;
  bool has_amount() const;
  void clear_amount();
  static const int kAmountFieldNumber = 1;
  ::google::protobuf::uint64 amount() const;
  void set_amount(::google::protobuf::uint64 value);

  // optional uint32 decred_script_version = 3;
  bool has_decred_script_version() const;
  void clear_decred_script_version();
  static const int kDecredScriptVersionFieldNumber = 3;
  ::google::protobuf::uint32 decred_script_version() const;
  void set_decred_script_version(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:hw.trezor.messages.bitcoin.TxAck.TransactionType.TxOutputBinType)
 private:
  class HasBitSetters;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr script_pubkey_;
  ::google::protobuf::uint64 amount_;
  ::google::protobuf::uint32 decred_script_version_;
  friend struct ::TableStruct_messages_2dbitcoin_2eproto;
};
// -------------------------------------------------------------------

class TxAck_TransactionType_TxOutputType final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:hw.trezor.messages.bitcoin.TxAck.TransactionType.TxOutputType) */ {
 public:
  TxAck_TransactionType_TxOutputType();
  virtual ~TxAck_TransactionType_TxOutputType();

  TxAck_TransactionType_TxOutputType(const TxAck_TransactionType_TxOutputType& from);

  inline TxAck_TransactionType_TxOutputType& operator=(const TxAck_TransactionType_TxOutputType& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  TxAck_TransactionType_TxOutputType(TxAck_TransactionType_TxOutputType&& from) noexcept
    : TxAck_TransactionType_TxOutputType() {
    *this = ::std::move(from);
  }

  inline TxAck_TransactionType_TxOutputType& operator=(TxAck_TransactionType_TxOutputType&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const TxAck_TransactionType_TxOutputType& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const TxAck_TransactionType_TxOutputType* internal_default_instance() {
    return reinterpret_cast<const TxAck_TransactionType_TxOutputType*>(
               &_TxAck_TransactionType_TxOutputType_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  void Swap(TxAck_TransactionType_TxOutputType* other);
  friend void swap(TxAck_TransactionType_TxOutputType& a, TxAck_TransactionType_TxOutputType& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline TxAck_TransactionType_TxOutputType* New() const final {
    return CreateMaybeMessage<TxAck_TransactionType_TxOutputType>(nullptr);
  }

  TxAck_TransactionType_TxOutputType* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<TxAck_TransactionType_TxOutputType>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const TxAck_TransactionType_TxOutputType& from);
  void MergeFrom(const TxAck_TransactionType_TxOutputType& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TxAck_TransactionType_TxOutputType* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef TxAck_TransactionType_TxOutputType_OutputScriptType OutputScriptType;
  static const OutputScriptType PAYTOADDRESS =
    TxAck_TransactionType_TxOutputType_OutputScriptType_PAYTOADDRESS;
  static const OutputScriptType PAYTOSCRIPTHASH =
    TxAck_TransactionType_TxOutputType_OutputScriptType_PAYTOSCRIPTHASH;
  static const OutputScriptType PAYTOMULTISIG =
    TxAck_TransactionType_TxOutputType_OutputScriptType_PAYTOMULTISIG;
  static const OutputScriptType PAYTOOPRETURN =
    TxAck_TransactionType_TxOutputType_OutputScriptType_PAYTOOPRETURN;
  static const OutputScriptType PAYTOWITNESS =
    TxAck_TransactionType_TxOutputType_OutputScriptType_PAYTOWITNESS;
  static const OutputScriptType PAYTOP2SHWITNESS =
    TxAck_TransactionType_TxOutputType_OutputScriptType_PAYTOP2SHWITNESS;
  static inline bool OutputScriptType_IsValid(int value) {
    return TxAck_TransactionType_TxOutputType_OutputScriptType_IsValid(value);
  }
  static const OutputScriptType OutputScriptType_MIN =
    TxAck_TransactionType_TxOutputType_OutputScriptType_OutputScriptType_MIN;
  static const OutputScriptType OutputScriptType_MAX =
    TxAck_TransactionType_TxOutputType_OutputScriptType_OutputScriptType_MAX;
  static const int OutputScriptType_ARRAYSIZE =
    TxAck_TransactionType_TxOutputType_OutputScriptType_OutputScriptType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  OutputScriptType_descriptor() {
    return TxAck_TransactionType_TxOutputType_OutputScriptType_descriptor();
  }
  static inline const ::std::string& OutputScriptType_Name(OutputScriptType value) {
    return TxAck_TransactionType_TxOutputType_OutputScriptType_Name(value);
  }
  static inline bool OutputScriptType_Parse(const ::std::string& name,
      OutputScriptType* value) {
    return TxAck_TransactionType_TxOutputType_OutputScriptType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // repeated uint32 address_n = 2;
  int address_n_size() const;
  void clear_address_n();
  static const int kAddressNFieldNumber = 2;
  ::google::protobuf::uint32 address_n(int index) const;
  void set_address_n(int index, ::google::protobuf::uint32 value);
  void add_address_n(::google::protobuf::uint32 value);
  const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      address_n() const;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable_address_n();

  // optional string address = 1;
  bool has_address() const;
  void clear_address();
  static const int kAddressFieldNumber = 1;
  const ::std::string& address() const;
  void set_address(const ::std::string& value);
  #if LANG_CXX11
  void set_address(::std::string&& value);
  #endif
  void set_address(const char* value);
  void set_address(const char* value, size_t size);
  ::std::string* mutable_address();
  ::std::string* release_address();
  void set_allocated_address(::std::string* address);

  // optional bytes op_return_data = 6;
  bool has_op_return_data() const;
  void clear_op_return_data();
  static const int kOpReturnDataFieldNumber = 6;
  const ::std::string& op_return_data() const;
  void set_op_return_data(const ::std::string& value);
  #if LANG_CXX11
  void set_op_return_data(::std::string&& value);
  #endif
  void set_op_return_data(const char* value);
  void set_op_return_data(const void* value, size_t size);
  ::std::string* mutable_op_return_data();
  ::std::string* release_op_return_data();
  void set_allocated_op_return_data(::std::string* op_return_data);

  // optional bytes block_hash_bip115 = 8;
  bool has_block_hash_bip115() const;
  void clear_block_hash_bip115();
  static const int kBlockHashBip115FieldNumber = 8;
  const ::std::string& block_hash_bip115() const;
  void set_block_hash_bip115(const ::std::string& value);
  #if LANG_CXX11
  void set_block_hash_bip115(::std::string&& value);
  #endif
  void set_block_hash_bip115(const char* value);
  void set_block_hash_bip115(const void* value, size_t size);
  ::std::string* mutable_block_hash_bip115();
  ::std::string* release_block_hash_bip115();
  void set_allocated_block_hash_bip115(::std::string* block_hash_bip115);

  // optional .hw.trezor.messages.bitcoin.MultisigRedeemScriptType multisig = 5;
  bool has_multisig() const;
  void clear_multisig();
  static const int kMultisigFieldNumber = 5;
  const ::hw::trezor::messages::bitcoin::MultisigRedeemScriptType& multisig() const;
  ::hw::trezor::messages::bitcoin::MultisigRedeemScriptType* release_multisig();
  ::hw::trezor::messages::bitcoin::MultisigRedeemScriptType* mutable_multisig();
  void set_allocated_multisig(::hw::trezor::messages::bitcoin::MultisigRedeemScriptType* multisig);

  // required uint64 amount = 3;
  bool has_amount() const;
  void clear_amount();
  static const int kAmountFieldNumber = 3;
  ::google::protobuf::uint64 amount() const;
  void set_amount(::google::protobuf::uint64 value);

  // required .hw.trezor.messages.bitcoin.TxAck.TransactionType.TxOutputType.OutputScriptType script_type = 4;
  bool has_script_type() const;
  void clear_script_type();
  static const int kScriptTypeFieldNumber = 4;
  ::hw::trezor::messages::bitcoin::TxAck_TransactionType_TxOutputType_OutputScriptType script_type() const;
  void set_script_type(::hw::trezor::messages::bitcoin::TxAck_TransactionType_TxOutputType_OutputScriptType value);

  // optional uint32 decred_script_version = 7;
  bool has_decred_script_version() const;
  void clear_decred_script_version();
  static const int kDecredScriptVersionFieldNumber = 7;
  ::google::protobuf::uint32 decred_script_version() const;
  void set_decred_script_version(::google::protobuf::uint32 value);

  // optional uint32 block_height_bip115 = 9;
  bool has_block_height_bip115() const;
  void clear_block_height_bip115();
  static const int kBlockHeightBip115FieldNumber = 9;
  ::google::protobuf::uint32 block_height_bip115() const;
  void set_block_height_bip115(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:hw.trezor.messages.bitcoin.TxAck.TransactionType.TxOutputType)
 private:
  class HasBitSetters;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > address_n_;
  ::google::protobuf::internal::ArenaStringPtr address_;
  ::google::protobuf::internal::ArenaStringPtr op_return_data_;
  ::google::protobuf::internal::ArenaStringPtr block_hash_bip115_;
  ::hw::trezor::messages::bitcoin::MultisigRedeemScriptType* multisig_;
  ::google::protobuf::uint64 amount_;
  int script_type_;
  ::google::protobuf::uint32 decred_script_version_;
  ::google::protobuf::uint32 block_height_bip115_;
  friend struct ::TableStruct_messages_2dbitcoin_2eproto;
};
// -------------------------------------------------------------------

class TxAck_TransactionType final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:hw.trezor.messages.bitcoin.TxAck.TransactionType) */ {
 public:
  TxAck_TransactionType();
  virtual ~TxAck_TransactionType();

  TxAck_TransactionType(const TxAck_TransactionType& from);

  inline TxAck_TransactionType& operator=(const TxAck_TransactionType& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  TxAck_TransactionType(TxAck_TransactionType&& from) noexcept
    : TxAck_TransactionType() {
    *this = ::std::move(from);
  }

  inline TxAck_TransactionType& operator=(TxAck_TransactionType&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const TxAck_TransactionType& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const TxAck_TransactionType* internal_default_instance() {
    return reinterpret_cast<const TxAck_TransactionType*>(
               &_TxAck_TransactionType_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    16;

  void Swap(TxAck_TransactionType* other);
  friend void swap(TxAck_TransactionType& a, TxAck_TransactionType& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline TxAck_TransactionType* New() const final {
    return CreateMaybeMessage<TxAck_TransactionType>(nullptr);
  }

  TxAck_TransactionType* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<TxAck_TransactionType>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const TxAck_TransactionType& from);
  void MergeFrom(const TxAck_TransactionType& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TxAck_TransactionType* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef TxAck_TransactionType_TxInputType TxInputType;
  typedef TxAck_TransactionType_TxOutputBinType TxOutputBinType;
  typedef TxAck_TransactionType_TxOutputType TxOutputType;

  // accessors -------------------------------------------------------

  // repeated .hw.trezor.messages.bitcoin.TxAck.TransactionType.TxInputType inputs = 2;
  int inputs_size() const;
  void clear_inputs();
  static const int kInputsFieldNumber = 2;
  ::hw::trezor::messages::bitcoin::TxAck_TransactionType_TxInputType* mutable_inputs(int index);
  ::google::protobuf::RepeatedPtrField< ::hw::trezor::messages::bitcoin::TxAck_TransactionType_TxInputType >*
      mutable_inputs();
  const ::hw::trezor::messages::bitcoin::TxAck_TransactionType_TxInputType& inputs(int index) const;
  ::hw::trezor::messages::bitcoin::TxAck_TransactionType_TxInputType* add_inputs();
  const ::google::protobuf::RepeatedPtrField< ::hw::trezor::messages::bitcoin::TxAck_TransactionType_TxInputType >&
      inputs() const;

  // repeated .hw.trezor.messages.bitcoin.TxAck.TransactionType.TxOutputBinType bin_outputs = 3;
  int bin_outputs_size() const;
  void clear_bin_outputs();
  static const int kBinOutputsFieldNumber = 3;
  ::hw::trezor::messages::bitcoin::TxAck_TransactionType_TxOutputBinType* mutable_bin_outputs(int index);
  ::google::protobuf::RepeatedPtrField< ::hw::trezor::messages::bitcoin::TxAck_TransactionType_TxOutputBinType >*
      mutable_bin_outputs();
  const ::hw::trezor::messages::bitcoin::TxAck_TransactionType_TxOutputBinType& bin_outputs(int index) const;
  ::hw::trezor::messages::bitcoin::TxAck_TransactionType_TxOutputBinType* add_bin_outputs();
  const ::google::protobuf::RepeatedPtrField< ::hw::trezor::messages::bitcoin::TxAck_TransactionType_TxOutputBinType >&
      bin_outputs() const;

  // repeated .hw.trezor.messages.bitcoin.TxAck.TransactionType.TxOutputType outputs = 5;
  int outputs_size() const;
  void clear_outputs();
  static const int kOutputsFieldNumber = 5;
  ::hw::trezor::messages::bitcoin::TxAck_TransactionType_TxOutputType* mutable_outputs(int index);
  ::google::protobuf::RepeatedPtrField< ::hw::trezor::messages::bitcoin::TxAck_TransactionType_TxOutputType >*
      mutable_outputs();
  const ::hw::trezor::messages::bitcoin::TxAck_TransactionType_TxOutputType& outputs(int index) const;
  ::hw::trezor::messages::bitcoin::TxAck_TransactionType_TxOutputType* add_outputs();
  const ::google::protobuf::RepeatedPtrField< ::hw::trezor::messages::bitcoin::TxAck_TransactionType_TxOutputType >&
      outputs() const;

  // optional bytes extra_data = 8;
  bool has_extra_data() const;
  void clear_extra_data();
  static const int kExtraDataFieldNumber = 8;
  const ::std::string& extra_data() const;
  void set_extra_data(const ::std::string& value);
  #if LANG_CXX11
  void set_extra_data(::std::string&& value);
  #endif
  void set_extra_data(const char* value);
  void set_extra_data(const void* value, size_t size);
  ::std::string* mutable_extra_data();
  ::std::string* release_extra_data();
  void set_allocated_extra_data(::std::string* extra_data);

  // optional uint32 version = 1;
  bool has_version() const;
  void clear_version();
  static const int kVersionFieldNumber = 1;
  ::google::protobuf::uint32 version() const;
  void set_version(::google::protobuf::uint32 value);

  // optional uint32 lock_time = 4;
  bool has_lock_time() const;
  void clear_lock_time();
  static const int kLockTimeFieldNumber = 4;
  ::google::protobuf::uint32 lock_time() const;
  void set_lock_time(::google::protobuf::uint32 value);

  // optional uint32 inputs_cnt = 6;
  bool has_inputs_cnt() const;
  void clear_inputs_cnt();
  static const int kInputsCntFieldNumber = 6;
  ::google::protobuf::uint32 inputs_cnt() const;
  void set_inputs_cnt(::google::protobuf::uint32 value);

  // optional uint32 outputs_cnt = 7;
  bool has_outputs_cnt() const;
  void clear_outputs_cnt();
  static const int kOutputsCntFieldNumber = 7;
  ::google::protobuf::uint32 outputs_cnt() const;
  void set_outputs_cnt(::google::protobuf::uint32 value);

  // optional uint32 extra_data_len = 9;
  bool has_extra_data_len() const;
  void clear_extra_data_len();
  static const int kExtraDataLenFieldNumber = 9;
  ::google::protobuf::uint32 extra_data_len() const;
  void set_extra_data_len(::google::protobuf::uint32 value);

  // optional uint32 expiry = 10;
  bool has_expiry() const;
  void clear_expiry();
  static const int kExpiryFieldNumber = 10;
  ::google::protobuf::uint32 expiry() const;
  void set_expiry(::google::protobuf::uint32 value);

  // optional bool overwintered = 11;
  bool has_overwintered() const;
  void clear_overwintered();
  static const int kOverwinteredFieldNumber = 11;
  bool overwintered() const;
  void set_overwintered(bool value);

  // optional uint32 version_group_id = 12;
  bool has_version_group_id() const;
  void clear_version_group_id();
  static const int kVersionGroupIdFieldNumber = 12;
  ::google::protobuf::uint32 version_group_id() const;
  void set_version_group_id(::google::protobuf::uint32 value);

  // optional uint32 timestamp = 13;
  bool has_timestamp() const;
  void clear_timestamp();
  static const int kTimestampFieldNumber = 13;
  ::google::protobuf::uint32 timestamp() const;
  void set_timestamp(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:hw.trezor.messages.bitcoin.TxAck.TransactionType)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::hw::trezor::messages::bitcoin::TxAck_TransactionType_TxInputType > inputs_;
  ::google::protobuf::RepeatedPtrField< ::hw::trezor::messages::bitcoin::TxAck_TransactionType_TxOutputBinType > bin_outputs_;
  ::google::protobuf::RepeatedPtrField< ::hw::trezor::messages::bitcoin::TxAck_TransactionType_TxOutputType > outputs_;
  ::google::protobuf::internal::ArenaStringPtr extra_data_;
  ::google::protobuf::uint32 version_;
  ::google::protobuf::uint32 lock_time_;
  ::google::protobuf::uint32 inputs_cnt_;
  ::google::protobuf::uint32 outputs_cnt_;
  ::google::protobuf::uint32 extra_data_len_;
  ::google::protobuf::uint32 expiry_;
  bool overwintered_;
  ::google::protobuf::uint32 version_group_id_;
  ::google::protobuf::uint32 timestamp_;
  friend struct ::TableStruct_messages_2dbitcoin_2eproto;
};
// -------------------------------------------------------------------

class TxAck final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:hw.trezor.messages.bitcoin.TxAck) */ {
 public:
  TxAck();
  virtual ~TxAck();

  TxAck(const TxAck& from);

  inline TxAck& operator=(const TxAck& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  TxAck(TxAck&& from) noexcept
    : TxAck() {
    *this = ::std::move(from);
  }

  inline TxAck& operator=(TxAck&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const TxAck& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const TxAck* internal_default_instance() {
    return reinterpret_cast<const TxAck*>(
               &_TxAck_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    17;

  void Swap(TxAck* other);
  friend void swap(TxAck& a, TxAck& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline TxAck* New() const final {
    return CreateMaybeMessage<TxAck>(nullptr);
  }

  TxAck* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<TxAck>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const TxAck& from);
  void MergeFrom(const TxAck& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TxAck* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef TxAck_TransactionType TransactionType;

  // accessors -------------------------------------------------------

  // optional .hw.trezor.messages.bitcoin.TxAck.TransactionType tx = 1;
  bool has_tx() const;
  void clear_tx();
  static const int kTxFieldNumber = 1;
  const ::hw::trezor::messages::bitcoin::TxAck_TransactionType& tx() const;
  ::hw::trezor::messages::bitcoin::TxAck_TransactionType* release_tx();
  ::hw::trezor::messages::bitcoin::TxAck_TransactionType* mutable_tx();
  void set_allocated_tx(::hw::trezor::messages::bitcoin::TxAck_TransactionType* tx);

  // @@protoc_insertion_point(class_scope:hw.trezor.messages.bitcoin.TxAck)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::hw::trezor::messages::bitcoin::TxAck_TransactionType* tx_;
  friend struct ::TableStruct_messages_2dbitcoin_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// MultisigRedeemScriptType_HDNodePathType

// required .hw.trezor.messages.common.HDNodeType node = 1;
inline bool MultisigRedeemScriptType_HDNodePathType::has_node() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline const ::hw::trezor::messages::common::HDNodeType& MultisigRedeemScriptType_HDNodePathType::node() const {
  const ::hw::trezor::messages::common::HDNodeType* p = node_;
  // @@protoc_insertion_point(field_get:hw.trezor.messages.bitcoin.MultisigRedeemScriptType.HDNodePathType.node)
  return p != nullptr ? *p : *reinterpret_cast<const ::hw::trezor::messages::common::HDNodeType*>(
      &::hw::trezor::messages::common::_HDNodeType_default_instance_);
}
inline ::hw::trezor::messages::common::HDNodeType* MultisigRedeemScriptType_HDNodePathType::release_node() {
  // @@protoc_insertion_point(field_release:hw.trezor.messages.bitcoin.MultisigRedeemScriptType.HDNodePathType.node)
  _has_bits_[0] &= ~0x00000001u;
  ::hw::trezor::messages::common::HDNodeType* temp = node_;
  node_ = nullptr;
  return temp;
}
inline ::hw::trezor::messages::common::HDNodeType* MultisigRedeemScriptType_HDNodePathType::mutable_node() {
  _has_bits_[0] |= 0x00000001u;
  if (node_ == nullptr) {
    auto* p = CreateMaybeMessage<::hw::trezor::messages::common::HDNodeType>(GetArenaNoVirtual());
    node_ = p;
  }
  // @@protoc_insertion_point(field_mutable:hw.trezor.messages.bitcoin.MultisigRedeemScriptType.HDNodePathType.node)
  return node_;
}
inline void MultisigRedeemScriptType_HDNodePathType::set_allocated_node(::hw::trezor::messages::common::HDNodeType* node) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(node_);
  }
  if (node) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      node = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, node, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  node_ = node;
  // @@protoc_insertion_point(field_set_allocated:hw.trezor.messages.bitcoin.MultisigRedeemScriptType.HDNodePathType.node)
}

// repeated uint32 address_n = 2;
inline int MultisigRedeemScriptType_HDNodePathType::address_n_size() const {
  return address_n_.size();
}
inline void MultisigRedeemScriptType_HDNodePathType::clear_address_n() {
  address_n_.Clear();
}
inline ::google::protobuf::uint32 MultisigRedeemScriptType_HDNodePathType::address_n(int index) const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.bitcoin.MultisigRedeemScriptType.HDNodePathType.address_n)
  return address_n_.Get(index);
}
inline void MultisigRedeemScriptType_HDNodePathType::set_address_n(int index, ::google::protobuf::uint32 value) {
  address_n_.Set(index, value);
  // @@protoc_insertion_point(field_set:hw.trezor.messages.bitcoin.MultisigRedeemScriptType.HDNodePathType.address_n)
}
inline void MultisigRedeemScriptType_HDNodePathType::add_address_n(::google::protobuf::uint32 value) {
  address_n_.Add(value);
  // @@protoc_insertion_point(field_add:hw.trezor.messages.bitcoin.MultisigRedeemScriptType.HDNodePathType.address_n)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
MultisigRedeemScriptType_HDNodePathType::address_n() const {
  // @@protoc_insertion_point(field_list:hw.trezor.messages.bitcoin.MultisigRedeemScriptType.HDNodePathType.address_n)
  return address_n_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
MultisigRedeemScriptType_HDNodePathType::mutable_address_n() {
  // @@protoc_insertion_point(field_mutable_list:hw.trezor.messages.bitcoin.MultisigRedeemScriptType.HDNodePathType.address_n)
  return &address_n_;
}

// -------------------------------------------------------------------

// MultisigRedeemScriptType

// repeated .hw.trezor.messages.bitcoin.MultisigRedeemScriptType.HDNodePathType pubkeys = 1;
inline int MultisigRedeemScriptType::pubkeys_size() const {
  return pubkeys_.size();
}
inline void MultisigRedeemScriptType::clear_pubkeys() {
  pubkeys_.Clear();
}
inline ::hw::trezor::messages::bitcoin::MultisigRedeemScriptType_HDNodePathType* MultisigRedeemScriptType::mutable_pubkeys(int index) {
  // @@protoc_insertion_point(field_mutable:hw.trezor.messages.bitcoin.MultisigRedeemScriptType.pubkeys)
  return pubkeys_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::hw::trezor::messages::bitcoin::MultisigRedeemScriptType_HDNodePathType >*
MultisigRedeemScriptType::mutable_pubkeys() {
  // @@protoc_insertion_point(field_mutable_list:hw.trezor.messages.bitcoin.MultisigRedeemScriptType.pubkeys)
  return &pubkeys_;
}
inline const ::hw::trezor::messages::bitcoin::MultisigRedeemScriptType_HDNodePathType& MultisigRedeemScriptType::pubkeys(int index) const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.bitcoin.MultisigRedeemScriptType.pubkeys)
  return pubkeys_.Get(index);
}
inline ::hw::trezor::messages::bitcoin::MultisigRedeemScriptType_HDNodePathType* MultisigRedeemScriptType::add_pubkeys() {
  // @@protoc_insertion_point(field_add:hw.trezor.messages.bitcoin.MultisigRedeemScriptType.pubkeys)
  return pubkeys_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::hw::trezor::messages::bitcoin::MultisigRedeemScriptType_HDNodePathType >&
MultisigRedeemScriptType::pubkeys() const {
  // @@protoc_insertion_point(field_list:hw.trezor.messages.bitcoin.MultisigRedeemScriptType.pubkeys)
  return pubkeys_;
}

// repeated bytes signatures = 2;
inline int MultisigRedeemScriptType::signatures_size() const {
  return signatures_.size();
}
inline void MultisigRedeemScriptType::clear_signatures() {
  signatures_.Clear();
}
inline const ::std::string& MultisigRedeemScriptType::signatures(int index) const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.bitcoin.MultisigRedeemScriptType.signatures)
  return signatures_.Get(index);
}
inline ::std::string* MultisigRedeemScriptType::mutable_signatures(int index) {
  // @@protoc_insertion_point(field_mutable:hw.trezor.messages.bitcoin.MultisigRedeemScriptType.signatures)
  return signatures_.Mutable(index);
}
inline void MultisigRedeemScriptType::set_signatures(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:hw.trezor.messages.bitcoin.MultisigRedeemScriptType.signatures)
  signatures_.Mutable(index)->assign(value);
}
#if LANG_CXX11
inline void MultisigRedeemScriptType::set_signatures(int index, ::std::string&& value) {
  // @@protoc_insertion_point(field_set:hw.trezor.messages.bitcoin.MultisigRedeemScriptType.signatures)
  signatures_.Mutable(index)->assign(std::move(value));
}
#endif
inline void MultisigRedeemScriptType::set_signatures(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  signatures_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:hw.trezor.messages.bitcoin.MultisigRedeemScriptType.signatures)
}
inline void MultisigRedeemScriptType::set_signatures(int index, const void* value, size_t size) {
  signatures_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:hw.trezor.messages.bitcoin.MultisigRedeemScriptType.signatures)
}
inline ::std::string* MultisigRedeemScriptType::add_signatures() {
  // @@protoc_insertion_point(field_add_mutable:hw.trezor.messages.bitcoin.MultisigRedeemScriptType.signatures)
  return signatures_.Add();
}
inline void MultisigRedeemScriptType::add_signatures(const ::std::string& value) {
  signatures_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:hw.trezor.messages.bitcoin.MultisigRedeemScriptType.signatures)
}
#if LANG_CXX11
inline void MultisigRedeemScriptType::add_signatures(::std::string&& value) {
  signatures_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:hw.trezor.messages.bitcoin.MultisigRedeemScriptType.signatures)
}
#endif
inline void MultisigRedeemScriptType::add_signatures(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  signatures_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:hw.trezor.messages.bitcoin.MultisigRedeemScriptType.signatures)
}
inline void MultisigRedeemScriptType::add_signatures(const void* value, size_t size) {
  signatures_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:hw.trezor.messages.bitcoin.MultisigRedeemScriptType.signatures)
}
inline const ::google::protobuf::RepeatedPtrField<::std::string>&
MultisigRedeemScriptType::signatures() const {
  // @@protoc_insertion_point(field_list:hw.trezor.messages.bitcoin.MultisigRedeemScriptType.signatures)
  return signatures_;
}
inline ::google::protobuf::RepeatedPtrField<::std::string>*
MultisigRedeemScriptType::mutable_signatures() {
  // @@protoc_insertion_point(field_mutable_list:hw.trezor.messages.bitcoin.MultisigRedeemScriptType.signatures)
  return &signatures_;
}

// optional uint32 m = 3;
inline bool MultisigRedeemScriptType::has_m() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MultisigRedeemScriptType::clear_m() {
  m_ = 0u;
  _has_bits_[0] &= ~0x00000001u;
}
inline ::google::protobuf::uint32 MultisigRedeemScriptType::m() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.bitcoin.MultisigRedeemScriptType.m)
  return m_;
}
inline void MultisigRedeemScriptType::set_m(::google::protobuf::uint32 value) {
  _has_bits_[0] |= 0x00000001u;
  m_ = value;
  // @@protoc_insertion_point(field_set:hw.trezor.messages.bitcoin.MultisigRedeemScriptType.m)
}

// -------------------------------------------------------------------

// GetPublicKey

// repeated uint32 address_n = 1;
inline int GetPublicKey::address_n_size() const {
  return address_n_.size();
}
inline void GetPublicKey::clear_address_n() {
  address_n_.Clear();
}
inline ::google::protobuf::uint32 GetPublicKey::address_n(int index) const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.bitcoin.GetPublicKey.address_n)
  return address_n_.Get(index);
}
inline void GetPublicKey::set_address_n(int index, ::google::protobuf::uint32 value) {
  address_n_.Set(index, value);
  // @@protoc_insertion_point(field_set:hw.trezor.messages.bitcoin.GetPublicKey.address_n)
}
inline void GetPublicKey::add_address_n(::google::protobuf::uint32 value) {
  address_n_.Add(value);
  // @@protoc_insertion_point(field_add:hw.trezor.messages.bitcoin.GetPublicKey.address_n)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
GetPublicKey::address_n() const {
  // @@protoc_insertion_point(field_list:hw.trezor.messages.bitcoin.GetPublicKey.address_n)
  return address_n_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
GetPublicKey::mutable_address_n() {
  // @@protoc_insertion_point(field_mutable_list:hw.trezor.messages.bitcoin.GetPublicKey.address_n)
  return &address_n_;
}

// optional string ecdsa_curve_name = 2;
inline bool GetPublicKey::has_ecdsa_curve_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GetPublicKey::clear_ecdsa_curve_name() {
  ecdsa_curve_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::std::string& GetPublicKey::ecdsa_curve_name() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.bitcoin.GetPublicKey.ecdsa_curve_name)
  return ecdsa_curve_name_.GetNoArena();
}
inline void GetPublicKey::set_ecdsa_curve_name(const ::std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  ecdsa_curve_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:hw.trezor.messages.bitcoin.GetPublicKey.ecdsa_curve_name)
}
#if LANG_CXX11
inline void GetPublicKey::set_ecdsa_curve_name(::std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  ecdsa_curve_name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:hw.trezor.messages.bitcoin.GetPublicKey.ecdsa_curve_name)
}
#endif
inline void GetPublicKey::set_ecdsa_curve_name(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  ecdsa_curve_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:hw.trezor.messages.bitcoin.GetPublicKey.ecdsa_curve_name)
}
inline void GetPublicKey::set_ecdsa_curve_name(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000001u;
  ecdsa_curve_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:hw.trezor.messages.bitcoin.GetPublicKey.ecdsa_curve_name)
}
inline ::std::string* GetPublicKey::mutable_ecdsa_curve_name() {
  _has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_mutable:hw.trezor.messages.bitcoin.GetPublicKey.ecdsa_curve_name)
  return ecdsa_curve_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* GetPublicKey::release_ecdsa_curve_name() {
  // @@protoc_insertion_point(field_release:hw.trezor.messages.bitcoin.GetPublicKey.ecdsa_curve_name)
  if (!has_ecdsa_curve_name()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return ecdsa_curve_name_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void GetPublicKey::set_allocated_ecdsa_curve_name(::std::string* ecdsa_curve_name) {
  if (ecdsa_curve_name != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  ecdsa_curve_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ecdsa_curve_name);
  // @@protoc_insertion_point(field_set_allocated:hw.trezor.messages.bitcoin.GetPublicKey.ecdsa_curve_name)
}

// optional bool show_display = 3;
inline bool GetPublicKey::has_show_display() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void GetPublicKey::clear_show_display() {
  show_display_ = false;
  _has_bits_[0] &= ~0x00000004u;
}
inline bool GetPublicKey::show_display() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.bitcoin.GetPublicKey.show_display)
  return show_display_;
}
inline void GetPublicKey::set_show_display(bool value) {
  _has_bits_[0] |= 0x00000004u;
  show_display_ = value;
  // @@protoc_insertion_point(field_set:hw.trezor.messages.bitcoin.GetPublicKey.show_display)
}

// optional string coin_name = 4 [default = "Bitcoin"];
inline bool GetPublicKey::has_coin_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GetPublicKey::clear_coin_name() {
  coin_name_.ClearToDefaultNoArena(&::hw::trezor::messages::bitcoin::GetPublicKey::_i_give_permission_to_break_this_code_default_coin_name_.get());
  _has_bits_[0] &= ~0x00000002u;
}
inline const ::std::string& GetPublicKey::coin_name() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.bitcoin.GetPublicKey.coin_name)
  return coin_name_.GetNoArena();
}
inline void GetPublicKey::set_coin_name(const ::std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  coin_name_.SetNoArena(&::hw::trezor::messages::bitcoin::GetPublicKey::_i_give_permission_to_break_this_code_default_coin_name_.get(), value);
  // @@protoc_insertion_point(field_set:hw.trezor.messages.bitcoin.GetPublicKey.coin_name)
}
#if LANG_CXX11
inline void GetPublicKey::set_coin_name(::std::string&& value) {
  _has_bits_[0] |= 0x00000002u;
  coin_name_.SetNoArena(
    &::hw::trezor::messages::bitcoin::GetPublicKey::_i_give_permission_to_break_this_code_default_coin_name_.get(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:hw.trezor.messages.bitcoin.GetPublicKey.coin_name)
}
#endif
inline void GetPublicKey::set_coin_name(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000002u;
  coin_name_.SetNoArena(&::hw::trezor::messages::bitcoin::GetPublicKey::_i_give_permission_to_break_this_code_default_coin_name_.get(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:hw.trezor.messages.bitcoin.GetPublicKey.coin_name)
}
inline void GetPublicKey::set_coin_name(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000002u;
  coin_name_.SetNoArena(&::hw::trezor::messages::bitcoin::GetPublicKey::_i_give_permission_to_break_this_code_default_coin_name_.get(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:hw.trezor.messages.bitcoin.GetPublicKey.coin_name)
}
inline ::std::string* GetPublicKey::mutable_coin_name() {
  _has_bits_[0] |= 0x00000002u;
  // @@protoc_insertion_point(field_mutable:hw.trezor.messages.bitcoin.GetPublicKey.coin_name)
  return coin_name_.MutableNoArena(&::hw::trezor::messages::bitcoin::GetPublicKey::_i_give_permission_to_break_this_code_default_coin_name_.get());
}
inline ::std::string* GetPublicKey::release_coin_name() {
  // @@protoc_insertion_point(field_release:hw.trezor.messages.bitcoin.GetPublicKey.coin_name)
  if (!has_coin_name()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  return coin_name_.ReleaseNonDefaultNoArena(&::hw::trezor::messages::bitcoin::GetPublicKey::_i_give_permission_to_break_this_code_default_coin_name_.get());
}
inline void GetPublicKey::set_allocated_coin_name(::std::string* coin_name) {
  if (coin_name != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  coin_name_.SetAllocatedNoArena(&::hw::trezor::messages::bitcoin::GetPublicKey::_i_give_permission_to_break_this_code_default_coin_name_.get(), coin_name);
  // @@protoc_insertion_point(field_set_allocated:hw.trezor.messages.bitcoin.GetPublicKey.coin_name)
}

// optional .hw.trezor.messages.bitcoin.InputScriptType script_type = 5 [default = SPENDADDRESS];
inline bool GetPublicKey::has_script_type() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void GetPublicKey::clear_script_type() {
  script_type_ = 0;
  _has_bits_[0] &= ~0x00000008u;
}
inline ::hw::trezor::messages::bitcoin::InputScriptType GetPublicKey::script_type() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.bitcoin.GetPublicKey.script_type)
  return static_cast< ::hw::trezor::messages::bitcoin::InputScriptType >(script_type_);
}
inline void GetPublicKey::set_script_type(::hw::trezor::messages::bitcoin::InputScriptType value) {
  assert(::hw::trezor::messages::bitcoin::InputScriptType_IsValid(value));
  _has_bits_[0] |= 0x00000008u;
  script_type_ = value;
  // @@protoc_insertion_point(field_set:hw.trezor.messages.bitcoin.GetPublicKey.script_type)
}

// -------------------------------------------------------------------

// PublicKey

// required .hw.trezor.messages.common.HDNodeType node = 1;
inline bool PublicKey::has_node() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline const ::hw::trezor::messages::common::HDNodeType& PublicKey::node() const {
  const ::hw::trezor::messages::common::HDNodeType* p = node_;
  // @@protoc_insertion_point(field_get:hw.trezor.messages.bitcoin.PublicKey.node)
  return p != nullptr ? *p : *reinterpret_cast<const ::hw::trezor::messages::common::HDNodeType*>(
      &::hw::trezor::messages::common::_HDNodeType_default_instance_);
}
inline ::hw::trezor::messages::common::HDNodeType* PublicKey::release_node() {
  // @@protoc_insertion_point(field_release:hw.trezor.messages.bitcoin.PublicKey.node)
  _has_bits_[0] &= ~0x00000002u;
  ::hw::trezor::messages::common::HDNodeType* temp = node_;
  node_ = nullptr;
  return temp;
}
inline ::hw::trezor::messages::common::HDNodeType* PublicKey::mutable_node() {
  _has_bits_[0] |= 0x00000002u;
  if (node_ == nullptr) {
    auto* p = CreateMaybeMessage<::hw::trezor::messages::common::HDNodeType>(GetArenaNoVirtual());
    node_ = p;
  }
  // @@protoc_insertion_point(field_mutable:hw.trezor.messages.bitcoin.PublicKey.node)
  return node_;
}
inline void PublicKey::set_allocated_node(::hw::trezor::messages::common::HDNodeType* node) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(node_);
  }
  if (node) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      node = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, node, submessage_arena);
    }
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  node_ = node;
  // @@protoc_insertion_point(field_set_allocated:hw.trezor.messages.bitcoin.PublicKey.node)
}

// optional string xpub = 2;
inline bool PublicKey::has_xpub() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PublicKey::clear_xpub() {
  xpub_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::std::string& PublicKey::xpub() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.bitcoin.PublicKey.xpub)
  return xpub_.GetNoArena();
}
inline void PublicKey::set_xpub(const ::std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  xpub_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:hw.trezor.messages.bitcoin.PublicKey.xpub)
}
#if LANG_CXX11
inline void PublicKey::set_xpub(::std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  xpub_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:hw.trezor.messages.bitcoin.PublicKey.xpub)
}
#endif
inline void PublicKey::set_xpub(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  xpub_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:hw.trezor.messages.bitcoin.PublicKey.xpub)
}
inline void PublicKey::set_xpub(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000001u;
  xpub_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:hw.trezor.messages.bitcoin.PublicKey.xpub)
}
inline ::std::string* PublicKey::mutable_xpub() {
  _has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_mutable:hw.trezor.messages.bitcoin.PublicKey.xpub)
  return xpub_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* PublicKey::release_xpub() {
  // @@protoc_insertion_point(field_release:hw.trezor.messages.bitcoin.PublicKey.xpub)
  if (!has_xpub()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return xpub_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void PublicKey::set_allocated_xpub(::std::string* xpub) {
  if (xpub != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  xpub_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), xpub);
  // @@protoc_insertion_point(field_set_allocated:hw.trezor.messages.bitcoin.PublicKey.xpub)
}

// -------------------------------------------------------------------

// GetAddress

// repeated uint32 address_n = 1;
inline int GetAddress::address_n_size() const {
  return address_n_.size();
}
inline void GetAddress::clear_address_n() {
  address_n_.Clear();
}
inline ::google::protobuf::uint32 GetAddress::address_n(int index) const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.bitcoin.GetAddress.address_n)
  return address_n_.Get(index);
}
inline void GetAddress::set_address_n(int index, ::google::protobuf::uint32 value) {
  address_n_.Set(index, value);
  // @@protoc_insertion_point(field_set:hw.trezor.messages.bitcoin.GetAddress.address_n)
}
inline void GetAddress::add_address_n(::google::protobuf::uint32 value) {
  address_n_.Add(value);
  // @@protoc_insertion_point(field_add:hw.trezor.messages.bitcoin.GetAddress.address_n)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
GetAddress::address_n() const {
  // @@protoc_insertion_point(field_list:hw.trezor.messages.bitcoin.GetAddress.address_n)
  return address_n_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
GetAddress::mutable_address_n() {
  // @@protoc_insertion_point(field_mutable_list:hw.trezor.messages.bitcoin.GetAddress.address_n)
  return &address_n_;
}

// optional string coin_name = 2 [default = "Bitcoin"];
inline bool GetAddress::has_coin_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GetAddress::clear_coin_name() {
  coin_name_.ClearToDefaultNoArena(&::hw::trezor::messages::bitcoin::GetAddress::_i_give_permission_to_break_this_code_default_coin_name_.get());
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::std::string& GetAddress::coin_name() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.bitcoin.GetAddress.coin_name)
  return coin_name_.GetNoArena();
}
inline void GetAddress::set_coin_name(const ::std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  coin_name_.SetNoArena(&::hw::trezor::messages::bitcoin::GetAddress::_i_give_permission_to_break_this_code_default_coin_name_.get(), value);
  // @@protoc_insertion_point(field_set:hw.trezor.messages.bitcoin.GetAddress.coin_name)
}
#if LANG_CXX11
inline void GetAddress::set_coin_name(::std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  coin_name_.SetNoArena(
    &::hw::trezor::messages::bitcoin::GetAddress::_i_give_permission_to_break_this_code_default_coin_name_.get(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:hw.trezor.messages.bitcoin.GetAddress.coin_name)
}
#endif
inline void GetAddress::set_coin_name(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  coin_name_.SetNoArena(&::hw::trezor::messages::bitcoin::GetAddress::_i_give_permission_to_break_this_code_default_coin_name_.get(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:hw.trezor.messages.bitcoin.GetAddress.coin_name)
}
inline void GetAddress::set_coin_name(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000001u;
  coin_name_.SetNoArena(&::hw::trezor::messages::bitcoin::GetAddress::_i_give_permission_to_break_this_code_default_coin_name_.get(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:hw.trezor.messages.bitcoin.GetAddress.coin_name)
}
inline ::std::string* GetAddress::mutable_coin_name() {
  _has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_mutable:hw.trezor.messages.bitcoin.GetAddress.coin_name)
  return coin_name_.MutableNoArena(&::hw::trezor::messages::bitcoin::GetAddress::_i_give_permission_to_break_this_code_default_coin_name_.get());
}
inline ::std::string* GetAddress::release_coin_name() {
  // @@protoc_insertion_point(field_release:hw.trezor.messages.bitcoin.GetAddress.coin_name)
  if (!has_coin_name()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return coin_name_.ReleaseNonDefaultNoArena(&::hw::trezor::messages::bitcoin::GetAddress::_i_give_permission_to_break_this_code_default_coin_name_.get());
}
inline void GetAddress::set_allocated_coin_name(::std::string* coin_name) {
  if (coin_name != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  coin_name_.SetAllocatedNoArena(&::hw::trezor::messages::bitcoin::GetAddress::_i_give_permission_to_break_this_code_default_coin_name_.get(), coin_name);
  // @@protoc_insertion_point(field_set_allocated:hw.trezor.messages.bitcoin.GetAddress.coin_name)
}

// optional bool show_display = 3;
inline bool GetAddress::has_show_display() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void GetAddress::clear_show_display() {
  show_display_ = false;
  _has_bits_[0] &= ~0x00000004u;
}
inline bool GetAddress::show_display() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.bitcoin.GetAddress.show_display)
  return show_display_;
}
inline void GetAddress::set_show_display(bool value) {
  _has_bits_[0] |= 0x00000004u;
  show_display_ = value;
  // @@protoc_insertion_point(field_set:hw.trezor.messages.bitcoin.GetAddress.show_display)
}

// optional .hw.trezor.messages.bitcoin.MultisigRedeemScriptType multisig = 4;
inline bool GetAddress::has_multisig() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GetAddress::clear_multisig() {
  if (multisig_ != nullptr) multisig_->Clear();
  _has_bits_[0] &= ~0x00000002u;
}
inline const ::hw::trezor::messages::bitcoin::MultisigRedeemScriptType& GetAddress::multisig() const {
  const ::hw::trezor::messages::bitcoin::MultisigRedeemScriptType* p = multisig_;
  // @@protoc_insertion_point(field_get:hw.trezor.messages.bitcoin.GetAddress.multisig)
  return p != nullptr ? *p : *reinterpret_cast<const ::hw::trezor::messages::bitcoin::MultisigRedeemScriptType*>(
      &::hw::trezor::messages::bitcoin::_MultisigRedeemScriptType_default_instance_);
}
inline ::hw::trezor::messages::bitcoin::MultisigRedeemScriptType* GetAddress::release_multisig() {
  // @@protoc_insertion_point(field_release:hw.trezor.messages.bitcoin.GetAddress.multisig)
  _has_bits_[0] &= ~0x00000002u;
  ::hw::trezor::messages::bitcoin::MultisigRedeemScriptType* temp = multisig_;
  multisig_ = nullptr;
  return temp;
}
inline ::hw::trezor::messages::bitcoin::MultisigRedeemScriptType* GetAddress::mutable_multisig() {
  _has_bits_[0] |= 0x00000002u;
  if (multisig_ == nullptr) {
    auto* p = CreateMaybeMessage<::hw::trezor::messages::bitcoin::MultisigRedeemScriptType>(GetArenaNoVirtual());
    multisig_ = p;
  }
  // @@protoc_insertion_point(field_mutable:hw.trezor.messages.bitcoin.GetAddress.multisig)
  return multisig_;
}
inline void GetAddress::set_allocated_multisig(::hw::trezor::messages::bitcoin::MultisigRedeemScriptType* multisig) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete multisig_;
  }
  if (multisig) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      multisig = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, multisig, submessage_arena);
    }
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  multisig_ = multisig;
  // @@protoc_insertion_point(field_set_allocated:hw.trezor.messages.bitcoin.GetAddress.multisig)
}

// optional .hw.trezor.messages.bitcoin.InputScriptType script_type = 5 [default = SPENDADDRESS];
inline bool GetAddress::has_script_type() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void GetAddress::clear_script_type() {
  script_type_ = 0;
  _has_bits_[0] &= ~0x00000008u;
}
inline ::hw::trezor::messages::bitcoin::InputScriptType GetAddress::script_type() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.bitcoin.GetAddress.script_type)
  return static_cast< ::hw::trezor::messages::bitcoin::InputScriptType >(script_type_);
}
inline void GetAddress::set_script_type(::hw::trezor::messages::bitcoin::InputScriptType value) {
  assert(::hw::trezor::messages::bitcoin::InputScriptType_IsValid(value));
  _has_bits_[0] |= 0x00000008u;
  script_type_ = value;
  // @@protoc_insertion_point(field_set:hw.trezor.messages.bitcoin.GetAddress.script_type)
}

// -------------------------------------------------------------------

// Address

// required string address = 1;
inline bool Address::has_address() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Address::clear_address() {
  address_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::std::string& Address::address() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.bitcoin.Address.address)
  return address_.GetNoArena();
}
inline void Address::set_address(const ::std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  address_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:hw.trezor.messages.bitcoin.Address.address)
}
#if LANG_CXX11
inline void Address::set_address(::std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  address_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:hw.trezor.messages.bitcoin.Address.address)
}
#endif
inline void Address::set_address(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  address_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:hw.trezor.messages.bitcoin.Address.address)
}
inline void Address::set_address(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000001u;
  address_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:hw.trezor.messages.bitcoin.Address.address)
}
inline ::std::string* Address::mutable_address() {
  _has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_mutable:hw.trezor.messages.bitcoin.Address.address)
  return address_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Address::release_address() {
  // @@protoc_insertion_point(field_release:hw.trezor.messages.bitcoin.Address.address)
  if (!has_address()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return address_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Address::set_allocated_address(::std::string* address) {
  if (address != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  address_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), address);
  // @@protoc_insertion_point(field_set_allocated:hw.trezor.messages.bitcoin.Address.address)
}

// -------------------------------------------------------------------

// SignMessage

// repeated uint32 address_n = 1;
inline int SignMessage::address_n_size() const {
  return address_n_.size();
}
inline void SignMessage::clear_address_n() {
  address_n_.Clear();
}
inline ::google::protobuf::uint32 SignMessage::address_n(int index) const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.bitcoin.SignMessage.address_n)
  return address_n_.Get(index);
}
inline void SignMessage::set_address_n(int index, ::google::protobuf::uint32 value) {
  address_n_.Set(index, value);
  // @@protoc_insertion_point(field_set:hw.trezor.messages.bitcoin.SignMessage.address_n)
}
inline void SignMessage::add_address_n(::google::protobuf::uint32 value) {
  address_n_.Add(value);
  // @@protoc_insertion_point(field_add:hw.trezor.messages.bitcoin.SignMessage.address_n)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
SignMessage::address_n() const {
  // @@protoc_insertion_point(field_list:hw.trezor.messages.bitcoin.SignMessage.address_n)
  return address_n_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
SignMessage::mutable_address_n() {
  // @@protoc_insertion_point(field_mutable_list:hw.trezor.messages.bitcoin.SignMessage.address_n)
  return &address_n_;
}

// required bytes message = 2;
inline bool SignMessage::has_message() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SignMessage::clear_message() {
  message_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::std::string& SignMessage::message() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.bitcoin.SignMessage.message)
  return message_.GetNoArena();
}
inline void SignMessage::set_message(const ::std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  message_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:hw.trezor.messages.bitcoin.SignMessage.message)
}
#if LANG_CXX11
inline void SignMessage::set_message(::std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  message_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:hw.trezor.messages.bitcoin.SignMessage.message)
}
#endif
inline void SignMessage::set_message(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  message_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:hw.trezor.messages.bitcoin.SignMessage.message)
}
inline void SignMessage::set_message(const void* value, size_t size) {
  _has_bits_[0] |= 0x00000001u;
  message_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:hw.trezor.messages.bitcoin.SignMessage.message)
}
inline ::std::string* SignMessage::mutable_message() {
  _has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_mutable:hw.trezor.messages.bitcoin.SignMessage.message)
  return message_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* SignMessage::release_message() {
  // @@protoc_insertion_point(field_release:hw.trezor.messages.bitcoin.SignMessage.message)
  if (!has_message()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return message_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void SignMessage::set_allocated_message(::std::string* message) {
  if (message != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  message_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), message);
  // @@protoc_insertion_point(field_set_allocated:hw.trezor.messages.bitcoin.SignMessage.message)
}

// optional string coin_name = 3 [default = "Bitcoin"];
inline bool SignMessage::has_coin_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SignMessage::clear_coin_name() {
  coin_name_.ClearToDefaultNoArena(&::hw::trezor::messages::bitcoin::SignMessage::_i_give_permission_to_break_this_code_default_coin_name_.get());
  _has_bits_[0] &= ~0x00000002u;
}
inline const ::std::string& SignMessage::coin_name() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.bitcoin.SignMessage.coin_name)
  return coin_name_.GetNoArena();
}
inline void SignMessage::set_coin_name(const ::std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  coin_name_.SetNoArena(&::hw::trezor::messages::bitcoin::SignMessage::_i_give_permission_to_break_this_code_default_coin_name_.get(), value);
  // @@protoc_insertion_point(field_set:hw.trezor.messages.bitcoin.SignMessage.coin_name)
}
#if LANG_CXX11
inline void SignMessage::set_coin_name(::std::string&& value) {
  _has_bits_[0] |= 0x00000002u;
  coin_name_.SetNoArena(
    &::hw::trezor::messages::bitcoin::SignMessage::_i_give_permission_to_break_this_code_default_coin_name_.get(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:hw.trezor.messages.bitcoin.SignMessage.coin_name)
}
#endif
inline void SignMessage::set_coin_name(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000002u;
  coin_name_.SetNoArena(&::hw::trezor::messages::bitcoin::SignMessage::_i_give_permission_to_break_this_code_default_coin_name_.get(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:hw.trezor.messages.bitcoin.SignMessage.coin_name)
}
inline void SignMessage::set_coin_name(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000002u;
  coin_name_.SetNoArena(&::hw::trezor::messages::bitcoin::SignMessage::_i_give_permission_to_break_this_code_default_coin_name_.get(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:hw.trezor.messages.bitcoin.SignMessage.coin_name)
}
inline ::std::string* SignMessage::mutable_coin_name() {
  _has_bits_[0] |= 0x00000002u;
  // @@protoc_insertion_point(field_mutable:hw.trezor.messages.bitcoin.SignMessage.coin_name)
  return coin_name_.MutableNoArena(&::hw::trezor::messages::bitcoin::SignMessage::_i_give_permission_to_break_this_code_default_coin_name_.get());
}
inline ::std::string* SignMessage::release_coin_name() {
  // @@protoc_insertion_point(field_release:hw.trezor.messages.bitcoin.SignMessage.coin_name)
  if (!has_coin_name()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  return coin_name_.ReleaseNonDefaultNoArena(&::hw::trezor::messages::bitcoin::SignMessage::_i_give_permission_to_break_this_code_default_coin_name_.get());
}
inline void SignMessage::set_allocated_coin_name(::std::string* coin_name) {
  if (coin_name != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  coin_name_.SetAllocatedNoArena(&::hw::trezor::messages::bitcoin::SignMessage::_i_give_permission_to_break_this_code_default_coin_name_.get(), coin_name);
  // @@protoc_insertion_point(field_set_allocated:hw.trezor.messages.bitcoin.SignMessage.coin_name)
}

// optional .hw.trezor.messages.bitcoin.InputScriptType script_type = 4 [default = SPENDADDRESS];
inline bool SignMessage::has_script_type() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void SignMessage::clear_script_type() {
  script_type_ = 0;
  _has_bits_[0] &= ~0x00000004u;
}
inline ::hw::trezor::messages::bitcoin::InputScriptType SignMessage::script_type() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.bitcoin.SignMessage.script_type)
  return static_cast< ::hw::trezor::messages::bitcoin::InputScriptType >(script_type_);
}
inline void SignMessage::set_script_type(::hw::trezor::messages::bitcoin::InputScriptType value) {
  assert(::hw::trezor::messages::bitcoin::InputScriptType_IsValid(value));
  _has_bits_[0] |= 0x00000004u;
  script_type_ = value;
  // @@protoc_insertion_point(field_set:hw.trezor.messages.bitcoin.SignMessage.script_type)
}

// -------------------------------------------------------------------

// MessageSignature

// optional string address = 1;
inline bool MessageSignature::has_address() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MessageSignature::clear_address() {
  address_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::std::string& MessageSignature::address() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.bitcoin.MessageSignature.address)
  return address_.GetNoArena();
}
inline void MessageSignature::set_address(const ::std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  address_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:hw.trezor.messages.bitcoin.MessageSignature.address)
}
#if LANG_CXX11
inline void MessageSignature::set_address(::std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  address_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:hw.trezor.messages.bitcoin.MessageSignature.address)
}
#endif
inline void MessageSignature::set_address(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  address_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:hw.trezor.messages.bitcoin.MessageSignature.address)
}
inline void MessageSignature::set_address(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000001u;
  address_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:hw.trezor.messages.bitcoin.MessageSignature.address)
}
inline ::std::string* MessageSignature::mutable_address() {
  _has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_mutable:hw.trezor.messages.bitcoin.MessageSignature.address)
  return address_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* MessageSignature::release_address() {
  // @@protoc_insertion_point(field_release:hw.trezor.messages.bitcoin.MessageSignature.address)
  if (!has_address()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return address_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void MessageSignature::set_allocated_address(::std::string* address) {
  if (address != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  address_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), address);
  // @@protoc_insertion_point(field_set_allocated:hw.trezor.messages.bitcoin.MessageSignature.address)
}

// optional bytes signature = 2;
inline bool MessageSignature::has_signature() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void MessageSignature::clear_signature() {
  signature_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000002u;
}
inline const ::std::string& MessageSignature::signature() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.bitcoin.MessageSignature.signature)
  return signature_.GetNoArena();
}
inline void MessageSignature::set_signature(const ::std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  signature_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:hw.trezor.messages.bitcoin.MessageSignature.signature)
}
#if LANG_CXX11
inline void MessageSignature::set_signature(::std::string&& value) {
  _has_bits_[0] |= 0x00000002u;
  signature_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:hw.trezor.messages.bitcoin.MessageSignature.signature)
}
#endif
inline void MessageSignature::set_signature(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000002u;
  signature_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:hw.trezor.messages.bitcoin.MessageSignature.signature)
}
inline void MessageSignature::set_signature(const void* value, size_t size) {
  _has_bits_[0] |= 0x00000002u;
  signature_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:hw.trezor.messages.bitcoin.MessageSignature.signature)
}
inline ::std::string* MessageSignature::mutable_signature() {
  _has_bits_[0] |= 0x00000002u;
  // @@protoc_insertion_point(field_mutable:hw.trezor.messages.bitcoin.MessageSignature.signature)
  return signature_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* MessageSignature::release_signature() {
  // @@protoc_insertion_point(field_release:hw.trezor.messages.bitcoin.MessageSignature.signature)
  if (!has_signature()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  return signature_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void MessageSignature::set_allocated_signature(::std::string* signature) {
  if (signature != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  signature_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), signature);
  // @@protoc_insertion_point(field_set_allocated:hw.trezor.messages.bitcoin.MessageSignature.signature)
}

// -------------------------------------------------------------------

// VerifyMessage

// optional string address = 1;
inline bool VerifyMessage::has_address() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void VerifyMessage::clear_address() {
  address_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::std::string& VerifyMessage::address() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.bitcoin.VerifyMessage.address)
  return address_.GetNoArena();
}
inline void VerifyMessage::set_address(const ::std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  address_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:hw.trezor.messages.bitcoin.VerifyMessage.address)
}
#if LANG_CXX11
inline void VerifyMessage::set_address(::std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  address_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:hw.trezor.messages.bitcoin.VerifyMessage.address)
}
#endif
inline void VerifyMessage::set_address(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  address_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:hw.trezor.messages.bitcoin.VerifyMessage.address)
}
inline void VerifyMessage::set_address(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000001u;
  address_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:hw.trezor.messages.bitcoin.VerifyMessage.address)
}
inline ::std::string* VerifyMessage::mutable_address() {
  _has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_mutable:hw.trezor.messages.bitcoin.VerifyMessage.address)
  return address_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* VerifyMessage::release_address() {
  // @@protoc_insertion_point(field_release:hw.trezor.messages.bitcoin.VerifyMessage.address)
  if (!has_address()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return address_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void VerifyMessage::set_allocated_address(::std::string* address) {
  if (address != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  address_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), address);
  // @@protoc_insertion_point(field_set_allocated:hw.trezor.messages.bitcoin.VerifyMessage.address)
}

// optional bytes signature = 2;
inline bool VerifyMessage::has_signature() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void VerifyMessage::clear_signature() {
  signature_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000002u;
}
inline const ::std::string& VerifyMessage::signature() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.bitcoin.VerifyMessage.signature)
  return signature_.GetNoArena();
}
inline void VerifyMessage::set_signature(const ::std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  signature_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:hw.trezor.messages.bitcoin.VerifyMessage.signature)
}
#if LANG_CXX11
inline void VerifyMessage::set_signature(::std::string&& value) {
  _has_bits_[0] |= 0x00000002u;
  signature_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:hw.trezor.messages.bitcoin.VerifyMessage.signature)
}
#endif
inline void VerifyMessage::set_signature(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000002u;
  signature_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:hw.trezor.messages.bitcoin.VerifyMessage.signature)
}
inline void VerifyMessage::set_signature(const void* value, size_t size) {
  _has_bits_[0] |= 0x00000002u;
  signature_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:hw.trezor.messages.bitcoin.VerifyMessage.signature)
}
inline ::std::string* VerifyMessage::mutable_signature() {
  _has_bits_[0] |= 0x00000002u;
  // @@protoc_insertion_point(field_mutable:hw.trezor.messages.bitcoin.VerifyMessage.signature)
  return signature_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* VerifyMessage::release_signature() {
  // @@protoc_insertion_point(field_release:hw.trezor.messages.bitcoin.VerifyMessage.signature)
  if (!has_signature()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  return signature_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void VerifyMessage::set_allocated_signature(::std::string* signature) {
  if (signature != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  signature_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), signature);
  // @@protoc_insertion_point(field_set_allocated:hw.trezor.messages.bitcoin.VerifyMessage.signature)
}

// optional bytes message = 3;
inline bool VerifyMessage::has_message() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void VerifyMessage::clear_message() {
  message_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000004u;
}
inline const ::std::string& VerifyMessage::message() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.bitcoin.VerifyMessage.message)
  return message_.GetNoArena();
}
inline void VerifyMessage::set_message(const ::std::string& value) {
  _has_bits_[0] |= 0x00000004u;
  message_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:hw.trezor.messages.bitcoin.VerifyMessage.message)
}
#if LANG_CXX11
inline void VerifyMessage::set_message(::std::string&& value) {
  _has_bits_[0] |= 0x00000004u;
  message_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:hw.trezor.messages.bitcoin.VerifyMessage.message)
}
#endif
inline void VerifyMessage::set_message(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000004u;
  message_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:hw.trezor.messages.bitcoin.VerifyMessage.message)
}
inline void VerifyMessage::set_message(const void* value, size_t size) {
  _has_bits_[0] |= 0x00000004u;
  message_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:hw.trezor.messages.bitcoin.VerifyMessage.message)
}
inline ::std::string* VerifyMessage::mutable_message() {
  _has_bits_[0] |= 0x00000004u;
  // @@protoc_insertion_point(field_mutable:hw.trezor.messages.bitcoin.VerifyMessage.message)
  return message_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* VerifyMessage::release_message() {
  // @@protoc_insertion_point(field_release:hw.trezor.messages.bitcoin.VerifyMessage.message)
  if (!has_message()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000004u;
  return message_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void VerifyMessage::set_allocated_message(::std::string* message) {
  if (message != nullptr) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  message_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), message);
  // @@protoc_insertion_point(field_set_allocated:hw.trezor.messages.bitcoin.VerifyMessage.message)
}

// optional string coin_name = 4 [default = "Bitcoin"];
inline bool VerifyMessage::has_coin_name() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void VerifyMessage::clear_coin_name() {
  coin_name_.ClearToDefaultNoArena(&::hw::trezor::messages::bitcoin::VerifyMessage::_i_give_permission_to_break_this_code_default_coin_name_.get());
  _has_bits_[0] &= ~0x00000008u;
}
inline const ::std::string& VerifyMessage::coin_name() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.bitcoin.VerifyMessage.coin_name)
  return coin_name_.GetNoArena();
}
inline void VerifyMessage::set_coin_name(const ::std::string& value) {
  _has_bits_[0] |= 0x00000008u;
  coin_name_.SetNoArena(&::hw::trezor::messages::bitcoin::VerifyMessage::_i_give_permission_to_break_this_code_default_coin_name_.get(), value);
  // @@protoc_insertion_point(field_set:hw.trezor.messages.bitcoin.VerifyMessage.coin_name)
}
#if LANG_CXX11
inline void VerifyMessage::set_coin_name(::std::string&& value) {
  _has_bits_[0] |= 0x00000008u;
  coin_name_.SetNoArena(
    &::hw::trezor::messages::bitcoin::VerifyMessage::_i_give_permission_to_break_this_code_default_coin_name_.get(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:hw.trezor.messages.bitcoin.VerifyMessage.coin_name)
}
#endif
inline void VerifyMessage::set_coin_name(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000008u;
  coin_name_.SetNoArena(&::hw::trezor::messages::bitcoin::VerifyMessage::_i_give_permission_to_break_this_code_default_coin_name_.get(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:hw.trezor.messages.bitcoin.VerifyMessage.coin_name)
}
inline void VerifyMessage::set_coin_name(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000008u;
  coin_name_.SetNoArena(&::hw::trezor::messages::bitcoin::VerifyMessage::_i_give_permission_to_break_this_code_default_coin_name_.get(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:hw.trezor.messages.bitcoin.VerifyMessage.coin_name)
}
inline ::std::string* VerifyMessage::mutable_coin_name() {
  _has_bits_[0] |= 0x00000008u;
  // @@protoc_insertion_point(field_mutable:hw.trezor.messages.bitcoin.VerifyMessage.coin_name)
  return coin_name_.MutableNoArena(&::hw::trezor::messages::bitcoin::VerifyMessage::_i_give_permission_to_break_this_code_default_coin_name_.get());
}
inline ::std::string* VerifyMessage::release_coin_name() {
  // @@protoc_insertion_point(field_release:hw.trezor.messages.bitcoin.VerifyMessage.coin_name)
  if (!has_coin_name()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000008u;
  return coin_name_.ReleaseNonDefaultNoArena(&::hw::trezor::messages::bitcoin::VerifyMessage::_i_give_permission_to_break_this_code_default_coin_name_.get());
}
inline void VerifyMessage::set_allocated_coin_name(::std::string* coin_name) {
  if (coin_name != nullptr) {
    _has_bits_[0] |= 0x00000008u;
  } else {
    _has_bits_[0] &= ~0x00000008u;
  }
  coin_name_.SetAllocatedNoArena(&::hw::trezor::messages::bitcoin::VerifyMessage::_i_give_permission_to_break_this_code_default_coin_name_.get(), coin_name);
  // @@protoc_insertion_point(field_set_allocated:hw.trezor.messages.bitcoin.VerifyMessage.coin_name)
}

// -------------------------------------------------------------------

// SignTx

// required uint32 outputs_count = 1;
inline bool SignTx::has_outputs_count() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SignTx::clear_outputs_count() {
  outputs_count_ = 0u;
  _has_bits_[0] &= ~0x00000002u;
}
inline ::google::protobuf::uint32 SignTx::outputs_count() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.bitcoin.SignTx.outputs_count)
  return outputs_count_;
}
inline void SignTx::set_outputs_count(::google::protobuf::uint32 value) {
  _has_bits_[0] |= 0x00000002u;
  outputs_count_ = value;
  // @@protoc_insertion_point(field_set:hw.trezor.messages.bitcoin.SignTx.outputs_count)
}

// required uint32 inputs_count = 2;
inline bool SignTx::has_inputs_count() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void SignTx::clear_inputs_count() {
  inputs_count_ = 0u;
  _has_bits_[0] &= ~0x00000004u;
}
inline ::google::protobuf::uint32 SignTx::inputs_count() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.bitcoin.SignTx.inputs_count)
  return inputs_count_;
}
inline void SignTx::set_inputs_count(::google::protobuf::uint32 value) {
  _has_bits_[0] |= 0x00000004u;
  inputs_count_ = value;
  // @@protoc_insertion_point(field_set:hw.trezor.messages.bitcoin.SignTx.inputs_count)
}

// optional string coin_name = 3 [default = "Bitcoin"];
inline bool SignTx::has_coin_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SignTx::clear_coin_name() {
  coin_name_.ClearToDefaultNoArena(&::hw::trezor::messages::bitcoin::SignTx::_i_give_permission_to_break_this_code_default_coin_name_.get());
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::std::string& SignTx::coin_name() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.bitcoin.SignTx.coin_name)
  return coin_name_.GetNoArena();
}
inline void SignTx::set_coin_name(const ::std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  coin_name_.SetNoArena(&::hw::trezor::messages::bitcoin::SignTx::_i_give_permission_to_break_this_code_default_coin_name_.get(), value);
  // @@protoc_insertion_point(field_set:hw.trezor.messages.bitcoin.SignTx.coin_name)
}
#if LANG_CXX11
inline void SignTx::set_coin_name(::std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  coin_name_.SetNoArena(
    &::hw::trezor::messages::bitcoin::SignTx::_i_give_permission_to_break_this_code_default_coin_name_.get(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:hw.trezor.messages.bitcoin.SignTx.coin_name)
}
#endif
inline void SignTx::set_coin_name(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  coin_name_.SetNoArena(&::hw::trezor::messages::bitcoin::SignTx::_i_give_permission_to_break_this_code_default_coin_name_.get(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:hw.trezor.messages.bitcoin.SignTx.coin_name)
}
inline void SignTx::set_coin_name(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000001u;
  coin_name_.SetNoArena(&::hw::trezor::messages::bitcoin::SignTx::_i_give_permission_to_break_this_code_default_coin_name_.get(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:hw.trezor.messages.bitcoin.SignTx.coin_name)
}
inline ::std::string* SignTx::mutable_coin_name() {
  _has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_mutable:hw.trezor.messages.bitcoin.SignTx.coin_name)
  return coin_name_.MutableNoArena(&::hw::trezor::messages::bitcoin::SignTx::_i_give_permission_to_break_this_code_default_coin_name_.get());
}
inline ::std::string* SignTx::release_coin_name() {
  // @@protoc_insertion_point(field_release:hw.trezor.messages.bitcoin.SignTx.coin_name)
  if (!has_coin_name()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return coin_name_.ReleaseNonDefaultNoArena(&::hw::trezor::messages::bitcoin::SignTx::_i_give_permission_to_break_this_code_default_coin_name_.get());
}
inline void SignTx::set_allocated_coin_name(::std::string* coin_name) {
  if (coin_name != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  coin_name_.SetAllocatedNoArena(&::hw::trezor::messages::bitcoin::SignTx::_i_give_permission_to_break_this_code_default_coin_name_.get(), coin_name);
  // @@protoc_insertion_point(field_set_allocated:hw.trezor.messages.bitcoin.SignTx.coin_name)
}

// optional uint32 version = 4 [default = 1];
inline bool SignTx::has_version() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void SignTx::clear_version() {
  version_ = 1u;
  _has_bits_[0] &= ~0x00000100u;
}
inline ::google::protobuf::uint32 SignTx::version() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.bitcoin.SignTx.version)
  return version_;
}
inline void SignTx::set_version(::google::protobuf::uint32 value) {
  _has_bits_[0] |= 0x00000100u;
  version_ = value;
  // @@protoc_insertion_point(field_set:hw.trezor.messages.bitcoin.SignTx.version)
}

// optional uint32 lock_time = 5 [default = 0];
inline bool SignTx::has_lock_time() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void SignTx::clear_lock_time() {
  lock_time_ = 0u;
  _has_bits_[0] &= ~0x00000008u;
}
inline ::google::protobuf::uint32 SignTx::lock_time() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.bitcoin.SignTx.lock_time)
  return lock_time_;
}
inline void SignTx::set_lock_time(::google::protobuf::uint32 value) {
  _has_bits_[0] |= 0x00000008u;
  lock_time_ = value;
  // @@protoc_insertion_point(field_set:hw.trezor.messages.bitcoin.SignTx.lock_time)
}

// optional uint32 expiry = 6;
inline bool SignTx::has_expiry() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void SignTx::clear_expiry() {
  expiry_ = 0u;
  _has_bits_[0] &= ~0x00000010u;
}
inline ::google::protobuf::uint32 SignTx::expiry() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.bitcoin.SignTx.expiry)
  return expiry_;
}
inline void SignTx::set_expiry(::google::protobuf::uint32 value) {
  _has_bits_[0] |= 0x00000010u;
  expiry_ = value;
  // @@protoc_insertion_point(field_set:hw.trezor.messages.bitcoin.SignTx.expiry)
}

// optional bool overwintered = 7;
inline bool SignTx::has_overwintered() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void SignTx::clear_overwintered() {
  overwintered_ = false;
  _has_bits_[0] &= ~0x00000020u;
}
inline bool SignTx::overwintered() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.bitcoin.SignTx.overwintered)
  return overwintered_;
}
inline void SignTx::set_overwintered(bool value) {
  _has_bits_[0] |= 0x00000020u;
  overwintered_ = value;
  // @@protoc_insertion_point(field_set:hw.trezor.messages.bitcoin.SignTx.overwintered)
}

// optional uint32 version_group_id = 8;
inline bool SignTx::has_version_group_id() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void SignTx::clear_version_group_id() {
  version_group_id_ = 0u;
  _has_bits_[0] &= ~0x00000040u;
}
inline ::google::protobuf::uint32 SignTx::version_group_id() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.bitcoin.SignTx.version_group_id)
  return version_group_id_;
}
inline void SignTx::set_version_group_id(::google::protobuf::uint32 value) {
  _has_bits_[0] |= 0x00000040u;
  version_group_id_ = value;
  // @@protoc_insertion_point(field_set:hw.trezor.messages.bitcoin.SignTx.version_group_id)
}

// optional uint32 timestamp = 9;
inline bool SignTx::has_timestamp() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void SignTx::clear_timestamp() {
  timestamp_ = 0u;
  _has_bits_[0] &= ~0x00000080u;
}
inline ::google::protobuf::uint32 SignTx::timestamp() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.bitcoin.SignTx.timestamp)
  return timestamp_;
}
inline void SignTx::set_timestamp(::google::protobuf::uint32 value) {
  _has_bits_[0] |= 0x00000080u;
  timestamp_ = value;
  // @@protoc_insertion_point(field_set:hw.trezor.messages.bitcoin.SignTx.timestamp)
}

// -------------------------------------------------------------------

// TxRequest_TxRequestDetailsType

// optional uint32 request_index = 1;
inline bool TxRequest_TxRequestDetailsType::has_request_index() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TxRequest_TxRequestDetailsType::clear_request_index() {
  request_index_ = 0u;
  _has_bits_[0] &= ~0x00000002u;
}
inline ::google::protobuf::uint32 TxRequest_TxRequestDetailsType::request_index() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.bitcoin.TxRequest.TxRequestDetailsType.request_index)
  return request_index_;
}
inline void TxRequest_TxRequestDetailsType::set_request_index(::google::protobuf::uint32 value) {
  _has_bits_[0] |= 0x00000002u;
  request_index_ = value;
  // @@protoc_insertion_point(field_set:hw.trezor.messages.bitcoin.TxRequest.TxRequestDetailsType.request_index)
}

// optional bytes tx_hash = 2;
inline bool TxRequest_TxRequestDetailsType::has_tx_hash() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TxRequest_TxRequestDetailsType::clear_tx_hash() {
  tx_hash_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::std::string& TxRequest_TxRequestDetailsType::tx_hash() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.bitcoin.TxRequest.TxRequestDetailsType.tx_hash)
  return tx_hash_.GetNoArena();
}
inline void TxRequest_TxRequestDetailsType::set_tx_hash(const ::std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  tx_hash_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:hw.trezor.messages.bitcoin.TxRequest.TxRequestDetailsType.tx_hash)
}
#if LANG_CXX11
inline void TxRequest_TxRequestDetailsType::set_tx_hash(::std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  tx_hash_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:hw.trezor.messages.bitcoin.TxRequest.TxRequestDetailsType.tx_hash)
}
#endif
inline void TxRequest_TxRequestDetailsType::set_tx_hash(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  tx_hash_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:hw.trezor.messages.bitcoin.TxRequest.TxRequestDetailsType.tx_hash)
}
inline void TxRequest_TxRequestDetailsType::set_tx_hash(const void* value, size_t size) {
  _has_bits_[0] |= 0x00000001u;
  tx_hash_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:hw.trezor.messages.bitcoin.TxRequest.TxRequestDetailsType.tx_hash)
}
inline ::std::string* TxRequest_TxRequestDetailsType::mutable_tx_hash() {
  _has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_mutable:hw.trezor.messages.bitcoin.TxRequest.TxRequestDetailsType.tx_hash)
  return tx_hash_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* TxRequest_TxRequestDetailsType::release_tx_hash() {
  // @@protoc_insertion_point(field_release:hw.trezor.messages.bitcoin.TxRequest.TxRequestDetailsType.tx_hash)
  if (!has_tx_hash()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return tx_hash_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void TxRequest_TxRequestDetailsType::set_allocated_tx_hash(::std::string* tx_hash) {
  if (tx_hash != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  tx_hash_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), tx_hash);
  // @@protoc_insertion_point(field_set_allocated:hw.trezor.messages.bitcoin.TxRequest.TxRequestDetailsType.tx_hash)
}

// optional uint32 extra_data_len = 3;
inline bool TxRequest_TxRequestDetailsType::has_extra_data_len() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TxRequest_TxRequestDetailsType::clear_extra_data_len() {
  extra_data_len_ = 0u;
  _has_bits_[0] &= ~0x00000004u;
}
inline ::google::protobuf::uint32 TxRequest_TxRequestDetailsType::extra_data_len() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.bitcoin.TxRequest.TxRequestDetailsType.extra_data_len)
  return extra_data_len_;
}
inline void TxRequest_TxRequestDetailsType::set_extra_data_len(::google::protobuf::uint32 value) {
  _has_bits_[0] |= 0x00000004u;
  extra_data_len_ = value;
  // @@protoc_insertion_point(field_set:hw.trezor.messages.bitcoin.TxRequest.TxRequestDetailsType.extra_data_len)
}

// optional uint32 extra_data_offset = 4;
inline bool TxRequest_TxRequestDetailsType::has_extra_data_offset() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void TxRequest_TxRequestDetailsType::clear_extra_data_offset() {
  extra_data_offset_ = 0u;
  _has_bits_[0] &= ~0x00000008u;
}
inline ::google::protobuf::uint32 TxRequest_TxRequestDetailsType::extra_data_offset() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.bitcoin.TxRequest.TxRequestDetailsType.extra_data_offset)
  return extra_data_offset_;
}
inline void TxRequest_TxRequestDetailsType::set_extra_data_offset(::google::protobuf::uint32 value) {
  _has_bits_[0] |= 0x00000008u;
  extra_data_offset_ = value;
  // @@protoc_insertion_point(field_set:hw.trezor.messages.bitcoin.TxRequest.TxRequestDetailsType.extra_data_offset)
}

// -------------------------------------------------------------------

// TxRequest_TxRequestSerializedType

// optional uint32 signature_index = 1;
inline bool TxRequest_TxRequestSerializedType::has_signature_index() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TxRequest_TxRequestSerializedType::clear_signature_index() {
  signature_index_ = 0u;
  _has_bits_[0] &= ~0x00000004u;
}
inline ::google::protobuf::uint32 TxRequest_TxRequestSerializedType::signature_index() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.bitcoin.TxRequest.TxRequestSerializedType.signature_index)
  return signature_index_;
}
inline void TxRequest_TxRequestSerializedType::set_signature_index(::google::protobuf::uint32 value) {
  _has_bits_[0] |= 0x00000004u;
  signature_index_ = value;
  // @@protoc_insertion_point(field_set:hw.trezor.messages.bitcoin.TxRequest.TxRequestSerializedType.signature_index)
}

// optional bytes signature = 2;
inline bool TxRequest_TxRequestSerializedType::has_signature() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TxRequest_TxRequestSerializedType::clear_signature() {
  signature_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::std::string& TxRequest_TxRequestSerializedType::signature() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.bitcoin.TxRequest.TxRequestSerializedType.signature)
  return signature_.GetNoArena();
}
inline void TxRequest_TxRequestSerializedType::set_signature(const ::std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  signature_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:hw.trezor.messages.bitcoin.TxRequest.TxRequestSerializedType.signature)
}
#if LANG_CXX11
inline void TxRequest_TxRequestSerializedType::set_signature(::std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  signature_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:hw.trezor.messages.bitcoin.TxRequest.TxRequestSerializedType.signature)
}
#endif
inline void TxRequest_TxRequestSerializedType::set_signature(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  signature_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:hw.trezor.messages.bitcoin.TxRequest.TxRequestSerializedType.signature)
}
inline void TxRequest_TxRequestSerializedType::set_signature(const void* value, size_t size) {
  _has_bits_[0] |= 0x00000001u;
  signature_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:hw.trezor.messages.bitcoin.TxRequest.TxRequestSerializedType.signature)
}
inline ::std::string* TxRequest_TxRequestSerializedType::mutable_signature() {
  _has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_mutable:hw.trezor.messages.bitcoin.TxRequest.TxRequestSerializedType.signature)
  return signature_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* TxRequest_TxRequestSerializedType::release_signature() {
  // @@protoc_insertion_point(field_release:hw.trezor.messages.bitcoin.TxRequest.TxRequestSerializedType.signature)
  if (!has_signature()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return signature_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void TxRequest_TxRequestSerializedType::set_allocated_signature(::std::string* signature) {
  if (signature != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  signature_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), signature);
  // @@protoc_insertion_point(field_set_allocated:hw.trezor.messages.bitcoin.TxRequest.TxRequestSerializedType.signature)
}

// optional bytes serialized_tx = 3;
inline bool TxRequest_TxRequestSerializedType::has_serialized_tx() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TxRequest_TxRequestSerializedType::clear_serialized_tx() {
  serialized_tx_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000002u;
}
inline const ::std::string& TxRequest_TxRequestSerializedType::serialized_tx() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.bitcoin.TxRequest.TxRequestSerializedType.serialized_tx)
  return serialized_tx_.GetNoArena();
}
inline void TxRequest_TxRequestSerializedType::set_serialized_tx(const ::std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  serialized_tx_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:hw.trezor.messages.bitcoin.TxRequest.TxRequestSerializedType.serialized_tx)
}
#if LANG_CXX11
inline void TxRequest_TxRequestSerializedType::set_serialized_tx(::std::string&& value) {
  _has_bits_[0] |= 0x00000002u;
  serialized_tx_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:hw.trezor.messages.bitcoin.TxRequest.TxRequestSerializedType.serialized_tx)
}
#endif
inline void TxRequest_TxRequestSerializedType::set_serialized_tx(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000002u;
  serialized_tx_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:hw.trezor.messages.bitcoin.TxRequest.TxRequestSerializedType.serialized_tx)
}
inline void TxRequest_TxRequestSerializedType::set_serialized_tx(const void* value, size_t size) {
  _has_bits_[0] |= 0x00000002u;
  serialized_tx_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:hw.trezor.messages.bitcoin.TxRequest.TxRequestSerializedType.serialized_tx)
}
inline ::std::string* TxRequest_TxRequestSerializedType::mutable_serialized_tx() {
  _has_bits_[0] |= 0x00000002u;
  // @@protoc_insertion_point(field_mutable:hw.trezor.messages.bitcoin.TxRequest.TxRequestSerializedType.serialized_tx)
  return serialized_tx_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* TxRequest_TxRequestSerializedType::release_serialized_tx() {
  // @@protoc_insertion_point(field_release:hw.trezor.messages.bitcoin.TxRequest.TxRequestSerializedType.serialized_tx)
  if (!has_serialized_tx()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  return serialized_tx_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void TxRequest_TxRequestSerializedType::set_allocated_serialized_tx(::std::string* serialized_tx) {
  if (serialized_tx != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  serialized_tx_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), serialized_tx);
  // @@protoc_insertion_point(field_set_allocated:hw.trezor.messages.bitcoin.TxRequest.TxRequestSerializedType.serialized_tx)
}

// -------------------------------------------------------------------

// TxRequest

// optional .hw.trezor.messages.bitcoin.TxRequest.RequestType request_type = 1;
inline bool TxRequest::has_request_type() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TxRequest::clear_request_type() {
  request_type_ = 0;
  _has_bits_[0] &= ~0x00000004u;
}
inline ::hw::trezor::messages::bitcoin::TxRequest_RequestType TxRequest::request_type() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.bitcoin.TxRequest.request_type)
  return static_cast< ::hw::trezor::messages::bitcoin::TxRequest_RequestType >(request_type_);
}
inline void TxRequest::set_request_type(::hw::trezor::messages::bitcoin::TxRequest_RequestType value) {
  assert(::hw::trezor::messages::bitcoin::TxRequest_RequestType_IsValid(value));
  _has_bits_[0] |= 0x00000004u;
  request_type_ = value;
  // @@protoc_insertion_point(field_set:hw.trezor.messages.bitcoin.TxRequest.request_type)
}

// optional .hw.trezor.messages.bitcoin.TxRequest.TxRequestDetailsType details = 2;
inline bool TxRequest::has_details() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TxRequest::clear_details() {
  if (details_ != nullptr) details_->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::hw::trezor::messages::bitcoin::TxRequest_TxRequestDetailsType& TxRequest::details() const {
  const ::hw::trezor::messages::bitcoin::TxRequest_TxRequestDetailsType* p = details_;
  // @@protoc_insertion_point(field_get:hw.trezor.messages.bitcoin.TxRequest.details)
  return p != nullptr ? *p : *reinterpret_cast<const ::hw::trezor::messages::bitcoin::TxRequest_TxRequestDetailsType*>(
      &::hw::trezor::messages::bitcoin::_TxRequest_TxRequestDetailsType_default_instance_);
}
inline ::hw::trezor::messages::bitcoin::TxRequest_TxRequestDetailsType* TxRequest::release_details() {
  // @@protoc_insertion_point(field_release:hw.trezor.messages.bitcoin.TxRequest.details)
  _has_bits_[0] &= ~0x00000001u;
  ::hw::trezor::messages::bitcoin::TxRequest_TxRequestDetailsType* temp = details_;
  details_ = nullptr;
  return temp;
}
inline ::hw::trezor::messages::bitcoin::TxRequest_TxRequestDetailsType* TxRequest::mutable_details() {
  _has_bits_[0] |= 0x00000001u;
  if (details_ == nullptr) {
    auto* p = CreateMaybeMessage<::hw::trezor::messages::bitcoin::TxRequest_TxRequestDetailsType>(GetArenaNoVirtual());
    details_ = p;
  }
  // @@protoc_insertion_point(field_mutable:hw.trezor.messages.bitcoin.TxRequest.details)
  return details_;
}
inline void TxRequest::set_allocated_details(::hw::trezor::messages::bitcoin::TxRequest_TxRequestDetailsType* details) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete details_;
  }
  if (details) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      details = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, details, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  details_ = details;
  // @@protoc_insertion_point(field_set_allocated:hw.trezor.messages.bitcoin.TxRequest.details)
}

// optional .hw.trezor.messages.bitcoin.TxRequest.TxRequestSerializedType serialized = 3;
inline bool TxRequest::has_serialized() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TxRequest::clear_serialized() {
  if (serialized_ != nullptr) serialized_->Clear();
  _has_bits_[0] &= ~0x00000002u;
}
inline const ::hw::trezor::messages::bitcoin::TxRequest_TxRequestSerializedType& TxRequest::serialized() const {
  const ::hw::trezor::messages::bitcoin::TxRequest_TxRequestSerializedType* p = serialized_;
  // @@protoc_insertion_point(field_get:hw.trezor.messages.bitcoin.TxRequest.serialized)
  return p != nullptr ? *p : *reinterpret_cast<const ::hw::trezor::messages::bitcoin::TxRequest_TxRequestSerializedType*>(
      &::hw::trezor::messages::bitcoin::_TxRequest_TxRequestSerializedType_default_instance_);
}
inline ::hw::trezor::messages::bitcoin::TxRequest_TxRequestSerializedType* TxRequest::release_serialized() {
  // @@protoc_insertion_point(field_release:hw.trezor.messages.bitcoin.TxRequest.serialized)
  _has_bits_[0] &= ~0x00000002u;
  ::hw::trezor::messages::bitcoin::TxRequest_TxRequestSerializedType* temp = serialized_;
  serialized_ = nullptr;
  return temp;
}
inline ::hw::trezor::messages::bitcoin::TxRequest_TxRequestSerializedType* TxRequest::mutable_serialized() {
  _has_bits_[0] |= 0x00000002u;
  if (serialized_ == nullptr) {
    auto* p = CreateMaybeMessage<::hw::trezor::messages::bitcoin::TxRequest_TxRequestSerializedType>(GetArenaNoVirtual());
    serialized_ = p;
  }
  // @@protoc_insertion_point(field_mutable:hw.trezor.messages.bitcoin.TxRequest.serialized)
  return serialized_;
}
inline void TxRequest::set_allocated_serialized(::hw::trezor::messages::bitcoin::TxRequest_TxRequestSerializedType* serialized) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete serialized_;
  }
  if (serialized) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      serialized = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, serialized, submessage_arena);
    }
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  serialized_ = serialized;
  // @@protoc_insertion_point(field_set_allocated:hw.trezor.messages.bitcoin.TxRequest.serialized)
}

// -------------------------------------------------------------------

// TxAck_TransactionType_TxInputType

// repeated uint32 address_n = 1;
inline int TxAck_TransactionType_TxInputType::address_n_size() const {
  return address_n_.size();
}
inline void TxAck_TransactionType_TxInputType::clear_address_n() {
  address_n_.Clear();
}
inline ::google::protobuf::uint32 TxAck_TransactionType_TxInputType::address_n(int index) const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.bitcoin.TxAck.TransactionType.TxInputType.address_n)
  return address_n_.Get(index);
}
inline void TxAck_TransactionType_TxInputType::set_address_n(int index, ::google::protobuf::uint32 value) {
  address_n_.Set(index, value);
  // @@protoc_insertion_point(field_set:hw.trezor.messages.bitcoin.TxAck.TransactionType.TxInputType.address_n)
}
inline void TxAck_TransactionType_TxInputType::add_address_n(::google::protobuf::uint32 value) {
  address_n_.Add(value);
  // @@protoc_insertion_point(field_add:hw.trezor.messages.bitcoin.TxAck.TransactionType.TxInputType.address_n)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
TxAck_TransactionType_TxInputType::address_n() const {
  // @@protoc_insertion_point(field_list:hw.trezor.messages.bitcoin.TxAck.TransactionType.TxInputType.address_n)
  return address_n_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
TxAck_TransactionType_TxInputType::mutable_address_n() {
  // @@protoc_insertion_point(field_mutable_list:hw.trezor.messages.bitcoin.TxAck.TransactionType.TxInputType.address_n)
  return &address_n_;
}

// required bytes prev_hash = 2;
inline bool TxAck_TransactionType_TxInputType::has_prev_hash() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TxAck_TransactionType_TxInputType::clear_prev_hash() {
  prev_hash_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::std::string& TxAck_TransactionType_TxInputType::prev_hash() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.bitcoin.TxAck.TransactionType.TxInputType.prev_hash)
  return prev_hash_.GetNoArena();
}
inline void TxAck_TransactionType_TxInputType::set_prev_hash(const ::std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  prev_hash_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:hw.trezor.messages.bitcoin.TxAck.TransactionType.TxInputType.prev_hash)
}
#if LANG_CXX11
inline void TxAck_TransactionType_TxInputType::set_prev_hash(::std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  prev_hash_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:hw.trezor.messages.bitcoin.TxAck.TransactionType.TxInputType.prev_hash)
}
#endif
inline void TxAck_TransactionType_TxInputType::set_prev_hash(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  prev_hash_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:hw.trezor.messages.bitcoin.TxAck.TransactionType.TxInputType.prev_hash)
}
inline void TxAck_TransactionType_TxInputType::set_prev_hash(const void* value, size_t size) {
  _has_bits_[0] |= 0x00000001u;
  prev_hash_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:hw.trezor.messages.bitcoin.TxAck.TransactionType.TxInputType.prev_hash)
}
inline ::std::string* TxAck_TransactionType_TxInputType::mutable_prev_hash() {
  _has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_mutable:hw.trezor.messages.bitcoin.TxAck.TransactionType.TxInputType.prev_hash)
  return prev_hash_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* TxAck_TransactionType_TxInputType::release_prev_hash() {
  // @@protoc_insertion_point(field_release:hw.trezor.messages.bitcoin.TxAck.TransactionType.TxInputType.prev_hash)
  if (!has_prev_hash()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return prev_hash_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void TxAck_TransactionType_TxInputType::set_allocated_prev_hash(::std::string* prev_hash) {
  if (prev_hash != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  prev_hash_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), prev_hash);
  // @@protoc_insertion_point(field_set_allocated:hw.trezor.messages.bitcoin.TxAck.TransactionType.TxInputType.prev_hash)
}

// required uint32 prev_index = 3;
inline bool TxAck_TransactionType_TxInputType::has_prev_index() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void TxAck_TransactionType_TxInputType::clear_prev_index() {
  prev_index_ = 0u;
  _has_bits_[0] &= ~0x00000010u;
}
inline ::google::protobuf::uint32 TxAck_TransactionType_TxInputType::prev_index() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.bitcoin.TxAck.TransactionType.TxInputType.prev_index)
  return prev_index_;
}
inline void TxAck_TransactionType_TxInputType::set_prev_index(::google::protobuf::uint32 value) {
  _has_bits_[0] |= 0x00000010u;
  prev_index_ = value;
  // @@protoc_insertion_point(field_set:hw.trezor.messages.bitcoin.TxAck.TransactionType.TxInputType.prev_index)
}

// optional bytes script_sig = 4;
inline bool TxAck_TransactionType_TxInputType::has_script_sig() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TxAck_TransactionType_TxInputType::clear_script_sig() {
  script_sig_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000002u;
}
inline const ::std::string& TxAck_TransactionType_TxInputType::script_sig() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.bitcoin.TxAck.TransactionType.TxInputType.script_sig)
  return script_sig_.GetNoArena();
}
inline void TxAck_TransactionType_TxInputType::set_script_sig(const ::std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  script_sig_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:hw.trezor.messages.bitcoin.TxAck.TransactionType.TxInputType.script_sig)
}
#if LANG_CXX11
inline void TxAck_TransactionType_TxInputType::set_script_sig(::std::string&& value) {
  _has_bits_[0] |= 0x00000002u;
  script_sig_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:hw.trezor.messages.bitcoin.TxAck.TransactionType.TxInputType.script_sig)
}
#endif
inline void TxAck_TransactionType_TxInputType::set_script_sig(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000002u;
  script_sig_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:hw.trezor.messages.bitcoin.TxAck.TransactionType.TxInputType.script_sig)
}
inline void TxAck_TransactionType_TxInputType::set_script_sig(const void* value, size_t size) {
  _has_bits_[0] |= 0x00000002u;
  script_sig_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:hw.trezor.messages.bitcoin.TxAck.TransactionType.TxInputType.script_sig)
}
inline ::std::string* TxAck_TransactionType_TxInputType::mutable_script_sig() {
  _has_bits_[0] |= 0x00000002u;
  // @@protoc_insertion_point(field_mutable:hw.trezor.messages.bitcoin.TxAck.TransactionType.TxInputType.script_sig)
  return script_sig_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* TxAck_TransactionType_TxInputType::release_script_sig() {
  // @@protoc_insertion_point(field_release:hw.trezor.messages.bitcoin.TxAck.TransactionType.TxInputType.script_sig)
  if (!has_script_sig()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  return script_sig_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void TxAck_TransactionType_TxInputType::set_allocated_script_sig(::std::string* script_sig) {
  if (script_sig != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  script_sig_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), script_sig);
  // @@protoc_insertion_point(field_set_allocated:hw.trezor.messages.bitcoin.TxAck.TransactionType.TxInputType.script_sig)
}

// optional uint32 sequence = 5 [default = 4294967295];
inline bool TxAck_TransactionType_TxInputType::has_sequence() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void TxAck_TransactionType_TxInputType::clear_sequence() {
  sequence_ = 4294967295u;
  _has_bits_[0] &= ~0x00000400u;
}
inline ::google::protobuf::uint32 TxAck_TransactionType_TxInputType::sequence() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.bitcoin.TxAck.TransactionType.TxInputType.sequence)
  return sequence_;
}
inline void TxAck_TransactionType_TxInputType::set_sequence(::google::protobuf::uint32 value) {
  _has_bits_[0] |= 0x00000400u;
  sequence_ = value;
  // @@protoc_insertion_point(field_set:hw.trezor.messages.bitcoin.TxAck.TransactionType.TxInputType.sequence)
}

// optional .hw.trezor.messages.bitcoin.InputScriptType script_type = 6 [default = SPENDADDRESS];
inline bool TxAck_TransactionType_TxInputType::has_script_type() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void TxAck_TransactionType_TxInputType::clear_script_type() {
  script_type_ = 0;
  _has_bits_[0] &= ~0x00000020u;
}
inline ::hw::trezor::messages::bitcoin::InputScriptType TxAck_TransactionType_TxInputType::script_type() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.bitcoin.TxAck.TransactionType.TxInputType.script_type)
  return static_cast< ::hw::trezor::messages::bitcoin::InputScriptType >(script_type_);
}
inline void TxAck_TransactionType_TxInputType::set_script_type(::hw::trezor::messages::bitcoin::InputScriptType value) {
  assert(::hw::trezor::messages::bitcoin::InputScriptType_IsValid(value));
  _has_bits_[0] |= 0x00000020u;
  script_type_ = value;
  // @@protoc_insertion_point(field_set:hw.trezor.messages.bitcoin.TxAck.TransactionType.TxInputType.script_type)
}

// optional .hw.trezor.messages.bitcoin.MultisigRedeemScriptType multisig = 7;
inline bool TxAck_TransactionType_TxInputType::has_multisig() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void TxAck_TransactionType_TxInputType::clear_multisig() {
  if (multisig_ != nullptr) multisig_->Clear();
  _has_bits_[0] &= ~0x00000008u;
}
inline const ::hw::trezor::messages::bitcoin::MultisigRedeemScriptType& TxAck_TransactionType_TxInputType::multisig() const {
  const ::hw::trezor::messages::bitcoin::MultisigRedeemScriptType* p = multisig_;
  // @@protoc_insertion_point(field_get:hw.trezor.messages.bitcoin.TxAck.TransactionType.TxInputType.multisig)
  return p != nullptr ? *p : *reinterpret_cast<const ::hw::trezor::messages::bitcoin::MultisigRedeemScriptType*>(
      &::hw::trezor::messages::bitcoin::_MultisigRedeemScriptType_default_instance_);
}
inline ::hw::trezor::messages::bitcoin::MultisigRedeemScriptType* TxAck_TransactionType_TxInputType::release_multisig() {
  // @@protoc_insertion_point(field_release:hw.trezor.messages.bitcoin.TxAck.TransactionType.TxInputType.multisig)
  _has_bits_[0] &= ~0x00000008u;
  ::hw::trezor::messages::bitcoin::MultisigRedeemScriptType* temp = multisig_;
  multisig_ = nullptr;
  return temp;
}
inline ::hw::trezor::messages::bitcoin::MultisigRedeemScriptType* TxAck_TransactionType_TxInputType::mutable_multisig() {
  _has_bits_[0] |= 0x00000008u;
  if (multisig_ == nullptr) {
    auto* p = CreateMaybeMessage<::hw::trezor::messages::bitcoin::MultisigRedeemScriptType>(GetArenaNoVirtual());
    multisig_ = p;
  }
  // @@protoc_insertion_point(field_mutable:hw.trezor.messages.bitcoin.TxAck.TransactionType.TxInputType.multisig)
  return multisig_;
}
inline void TxAck_TransactionType_TxInputType::set_allocated_multisig(::hw::trezor::messages::bitcoin::MultisigRedeemScriptType* multisig) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete multisig_;
  }
  if (multisig) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      multisig = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, multisig, submessage_arena);
    }
    _has_bits_[0] |= 0x00000008u;
  } else {
    _has_bits_[0] &= ~0x00000008u;
  }
  multisig_ = multisig;
  // @@protoc_insertion_point(field_set_allocated:hw.trezor.messages.bitcoin.TxAck.TransactionType.TxInputType.multisig)
}

// optional uint64 amount = 8;
inline bool TxAck_TransactionType_TxInputType::has_amount() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void TxAck_TransactionType_TxInputType::clear_amount() {
  amount_ = PROTOBUF_ULONGLONG(0);
  _has_bits_[0] &= ~0x00000040u;
}
inline ::google::protobuf::uint64 TxAck_TransactionType_TxInputType::amount() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.bitcoin.TxAck.TransactionType.TxInputType.amount)
  return amount_;
}
inline void TxAck_TransactionType_TxInputType::set_amount(::google::protobuf::uint64 value) {
  _has_bits_[0] |= 0x00000040u;
  amount_ = value;
  // @@protoc_insertion_point(field_set:hw.trezor.messages.bitcoin.TxAck.TransactionType.TxInputType.amount)
}

// optional uint32 decred_tree = 9;
inline bool TxAck_TransactionType_TxInputType::has_decred_tree() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void TxAck_TransactionType_TxInputType::clear_decred_tree() {
  decred_tree_ = 0u;
  _has_bits_[0] &= ~0x00000080u;
}
inline ::google::protobuf::uint32 TxAck_TransactionType_TxInputType::decred_tree() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.bitcoin.TxAck.TransactionType.TxInputType.decred_tree)
  return decred_tree_;
}
inline void TxAck_TransactionType_TxInputType::set_decred_tree(::google::protobuf::uint32 value) {
  _has_bits_[0] |= 0x00000080u;
  decred_tree_ = value;
  // @@protoc_insertion_point(field_set:hw.trezor.messages.bitcoin.TxAck.TransactionType.TxInputType.decred_tree)
}

// optional uint32 decred_script_version = 10;
inline bool TxAck_TransactionType_TxInputType::has_decred_script_version() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void TxAck_TransactionType_TxInputType::clear_decred_script_version() {
  decred_script_version_ = 0u;
  _has_bits_[0] &= ~0x00000100u;
}
inline ::google::protobuf::uint32 TxAck_TransactionType_TxInputType::decred_script_version() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.bitcoin.TxAck.TransactionType.TxInputType.decred_script_version)
  return decred_script_version_;
}
inline void TxAck_TransactionType_TxInputType::set_decred_script_version(::google::protobuf::uint32 value) {
  _has_bits_[0] |= 0x00000100u;
  decred_script_version_ = value;
  // @@protoc_insertion_point(field_set:hw.trezor.messages.bitcoin.TxAck.TransactionType.TxInputType.decred_script_version)
}

// optional bytes prev_block_hash_bip115 = 11;
inline bool TxAck_TransactionType_TxInputType::has_prev_block_hash_bip115() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TxAck_TransactionType_TxInputType::clear_prev_block_hash_bip115() {
  prev_block_hash_bip115_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000004u;
}
inline const ::std::string& TxAck_TransactionType_TxInputType::prev_block_hash_bip115() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.bitcoin.TxAck.TransactionType.TxInputType.prev_block_hash_bip115)
  return prev_block_hash_bip115_.GetNoArena();
}
inline void TxAck_TransactionType_TxInputType::set_prev_block_hash_bip115(const ::std::string& value) {
  _has_bits_[0] |= 0x00000004u;
  prev_block_hash_bip115_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:hw.trezor.messages.bitcoin.TxAck.TransactionType.TxInputType.prev_block_hash_bip115)
}
#if LANG_CXX11
inline void TxAck_TransactionType_TxInputType::set_prev_block_hash_bip115(::std::string&& value) {
  _has_bits_[0] |= 0x00000004u;
  prev_block_hash_bip115_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:hw.trezor.messages.bitcoin.TxAck.TransactionType.TxInputType.prev_block_hash_bip115)
}
#endif
inline void TxAck_TransactionType_TxInputType::set_prev_block_hash_bip115(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000004u;
  prev_block_hash_bip115_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:hw.trezor.messages.bitcoin.TxAck.TransactionType.TxInputType.prev_block_hash_bip115)
}
inline void TxAck_TransactionType_TxInputType::set_prev_block_hash_bip115(const void* value, size_t size) {
  _has_bits_[0] |= 0x00000004u;
  prev_block_hash_bip115_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:hw.trezor.messages.bitcoin.TxAck.TransactionType.TxInputType.prev_block_hash_bip115)
}
inline ::std::string* TxAck_TransactionType_TxInputType::mutable_prev_block_hash_bip115() {
  _has_bits_[0] |= 0x00000004u;
  // @@protoc_insertion_point(field_mutable:hw.trezor.messages.bitcoin.TxAck.TransactionType.TxInputType.prev_block_hash_bip115)
  return prev_block_hash_bip115_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* TxAck_TransactionType_TxInputType::release_prev_block_hash_bip115() {
  // @@protoc_insertion_point(field_release:hw.trezor.messages.bitcoin.TxAck.TransactionType.TxInputType.prev_block_hash_bip115)
  if (!has_prev_block_hash_bip115()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000004u;
  return prev_block_hash_bip115_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void TxAck_TransactionType_TxInputType::set_allocated_prev_block_hash_bip115(::std::string* prev_block_hash_bip115) {
  if (prev_block_hash_bip115 != nullptr) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  prev_block_hash_bip115_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), prev_block_hash_bip115);
  // @@protoc_insertion_point(field_set_allocated:hw.trezor.messages.bitcoin.TxAck.TransactionType.TxInputType.prev_block_hash_bip115)
}

// optional uint32 prev_block_height_bip115 = 12;
inline bool TxAck_TransactionType_TxInputType::has_prev_block_height_bip115() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void TxAck_TransactionType_TxInputType::clear_prev_block_height_bip115() {
  prev_block_height_bip115_ = 0u;
  _has_bits_[0] &= ~0x00000200u;
}
inline ::google::protobuf::uint32 TxAck_TransactionType_TxInputType::prev_block_height_bip115() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.bitcoin.TxAck.TransactionType.TxInputType.prev_block_height_bip115)
  return prev_block_height_bip115_;
}
inline void TxAck_TransactionType_TxInputType::set_prev_block_height_bip115(::google::protobuf::uint32 value) {
  _has_bits_[0] |= 0x00000200u;
  prev_block_height_bip115_ = value;
  // @@protoc_insertion_point(field_set:hw.trezor.messages.bitcoin.TxAck.TransactionType.TxInputType.prev_block_height_bip115)
}

// -------------------------------------------------------------------

// TxAck_TransactionType_TxOutputBinType

// required uint64 amount = 1;
inline bool TxAck_TransactionType_TxOutputBinType::has_amount() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TxAck_TransactionType_TxOutputBinType::clear_amount() {
  amount_ = PROTOBUF_ULONGLONG(0);
  _has_bits_[0] &= ~0x00000002u;
}
inline ::google::protobuf::uint64 TxAck_TransactionType_TxOutputBinType::amount() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.bitcoin.TxAck.TransactionType.TxOutputBinType.amount)
  return amount_;
}
inline void TxAck_TransactionType_TxOutputBinType::set_amount(::google::protobuf::uint64 value) {
  _has_bits_[0] |= 0x00000002u;
  amount_ = value;
  // @@protoc_insertion_point(field_set:hw.trezor.messages.bitcoin.TxAck.TransactionType.TxOutputBinType.amount)
}

// required bytes script_pubkey = 2;
inline bool TxAck_TransactionType_TxOutputBinType::has_script_pubkey() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TxAck_TransactionType_TxOutputBinType::clear_script_pubkey() {
  script_pubkey_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::std::string& TxAck_TransactionType_TxOutputBinType::script_pubkey() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.bitcoin.TxAck.TransactionType.TxOutputBinType.script_pubkey)
  return script_pubkey_.GetNoArena();
}
inline void TxAck_TransactionType_TxOutputBinType::set_script_pubkey(const ::std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  script_pubkey_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:hw.trezor.messages.bitcoin.TxAck.TransactionType.TxOutputBinType.script_pubkey)
}
#if LANG_CXX11
inline void TxAck_TransactionType_TxOutputBinType::set_script_pubkey(::std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  script_pubkey_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:hw.trezor.messages.bitcoin.TxAck.TransactionType.TxOutputBinType.script_pubkey)
}
#endif
inline void TxAck_TransactionType_TxOutputBinType::set_script_pubkey(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  script_pubkey_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:hw.trezor.messages.bitcoin.TxAck.TransactionType.TxOutputBinType.script_pubkey)
}
inline void TxAck_TransactionType_TxOutputBinType::set_script_pubkey(const void* value, size_t size) {
  _has_bits_[0] |= 0x00000001u;
  script_pubkey_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:hw.trezor.messages.bitcoin.TxAck.TransactionType.TxOutputBinType.script_pubkey)
}
inline ::std::string* TxAck_TransactionType_TxOutputBinType::mutable_script_pubkey() {
  _has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_mutable:hw.trezor.messages.bitcoin.TxAck.TransactionType.TxOutputBinType.script_pubkey)
  return script_pubkey_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* TxAck_TransactionType_TxOutputBinType::release_script_pubkey() {
  // @@protoc_insertion_point(field_release:hw.trezor.messages.bitcoin.TxAck.TransactionType.TxOutputBinType.script_pubkey)
  if (!has_script_pubkey()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return script_pubkey_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void TxAck_TransactionType_TxOutputBinType::set_allocated_script_pubkey(::std::string* script_pubkey) {
  if (script_pubkey != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  script_pubkey_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), script_pubkey);
  // @@protoc_insertion_point(field_set_allocated:hw.trezor.messages.bitcoin.TxAck.TransactionType.TxOutputBinType.script_pubkey)
}

// optional uint32 decred_script_version = 3;
inline bool TxAck_TransactionType_TxOutputBinType::has_decred_script_version() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TxAck_TransactionType_TxOutputBinType::clear_decred_script_version() {
  decred_script_version_ = 0u;
  _has_bits_[0] &= ~0x00000004u;
}
inline ::google::protobuf::uint32 TxAck_TransactionType_TxOutputBinType::decred_script_version() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.bitcoin.TxAck.TransactionType.TxOutputBinType.decred_script_version)
  return decred_script_version_;
}
inline void TxAck_TransactionType_TxOutputBinType::set_decred_script_version(::google::protobuf::uint32 value) {
  _has_bits_[0] |= 0x00000004u;
  decred_script_version_ = value;
  // @@protoc_insertion_point(field_set:hw.trezor.messages.bitcoin.TxAck.TransactionType.TxOutputBinType.decred_script_version)
}

// -------------------------------------------------------------------

// TxAck_TransactionType_TxOutputType

// optional string address = 1;
inline bool TxAck_TransactionType_TxOutputType::has_address() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TxAck_TransactionType_TxOutputType::clear_address() {
  address_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::std::string& TxAck_TransactionType_TxOutputType::address() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.bitcoin.TxAck.TransactionType.TxOutputType.address)
  return address_.GetNoArena();
}
inline void TxAck_TransactionType_TxOutputType::set_address(const ::std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  address_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:hw.trezor.messages.bitcoin.TxAck.TransactionType.TxOutputType.address)
}
#if LANG_CXX11
inline void TxAck_TransactionType_TxOutputType::set_address(::std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  address_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:hw.trezor.messages.bitcoin.TxAck.TransactionType.TxOutputType.address)
}
#endif
inline void TxAck_TransactionType_TxOutputType::set_address(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  address_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:hw.trezor.messages.bitcoin.TxAck.TransactionType.TxOutputType.address)
}
inline void TxAck_TransactionType_TxOutputType::set_address(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000001u;
  address_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:hw.trezor.messages.bitcoin.TxAck.TransactionType.TxOutputType.address)
}
inline ::std::string* TxAck_TransactionType_TxOutputType::mutable_address() {
  _has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_mutable:hw.trezor.messages.bitcoin.TxAck.TransactionType.TxOutputType.address)
  return address_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* TxAck_TransactionType_TxOutputType::release_address() {
  // @@protoc_insertion_point(field_release:hw.trezor.messages.bitcoin.TxAck.TransactionType.TxOutputType.address)
  if (!has_address()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return address_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void TxAck_TransactionType_TxOutputType::set_allocated_address(::std::string* address) {
  if (address != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  address_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), address);
  // @@protoc_insertion_point(field_set_allocated:hw.trezor.messages.bitcoin.TxAck.TransactionType.TxOutputType.address)
}

// repeated uint32 address_n = 2;
inline int TxAck_TransactionType_TxOutputType::address_n_size() const {
  return address_n_.size();
}
inline void TxAck_TransactionType_TxOutputType::clear_address_n() {
  address_n_.Clear();
}
inline ::google::protobuf::uint32 TxAck_TransactionType_TxOutputType::address_n(int index) const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.bitcoin.TxAck.TransactionType.TxOutputType.address_n)
  return address_n_.Get(index);
}
inline void TxAck_TransactionType_TxOutputType::set_address_n(int index, ::google::protobuf::uint32 value) {
  address_n_.Set(index, value);
  // @@protoc_insertion_point(field_set:hw.trezor.messages.bitcoin.TxAck.TransactionType.TxOutputType.address_n)
}
inline void TxAck_TransactionType_TxOutputType::add_address_n(::google::protobuf::uint32 value) {
  address_n_.Add(value);
  // @@protoc_insertion_point(field_add:hw.trezor.messages.bitcoin.TxAck.TransactionType.TxOutputType.address_n)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
TxAck_TransactionType_TxOutputType::address_n() const {
  // @@protoc_insertion_point(field_list:hw.trezor.messages.bitcoin.TxAck.TransactionType.TxOutputType.address_n)
  return address_n_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
TxAck_TransactionType_TxOutputType::mutable_address_n() {
  // @@protoc_insertion_point(field_mutable_list:hw.trezor.messages.bitcoin.TxAck.TransactionType.TxOutputType.address_n)
  return &address_n_;
}

// required uint64 amount = 3;
inline bool TxAck_TransactionType_TxOutputType::has_amount() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void TxAck_TransactionType_TxOutputType::clear_amount() {
  amount_ = PROTOBUF_ULONGLONG(0);
  _has_bits_[0] &= ~0x00000010u;
}
inline ::google::protobuf::uint64 TxAck_TransactionType_TxOutputType::amount() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.bitcoin.TxAck.TransactionType.TxOutputType.amount)
  return amount_;
}
inline void TxAck_TransactionType_TxOutputType::set_amount(::google::protobuf::uint64 value) {
  _has_bits_[0] |= 0x00000010u;
  amount_ = value;
  // @@protoc_insertion_point(field_set:hw.trezor.messages.bitcoin.TxAck.TransactionType.TxOutputType.amount)
}

// required .hw.trezor.messages.bitcoin.TxAck.TransactionType.TxOutputType.OutputScriptType script_type = 4;
inline bool TxAck_TransactionType_TxOutputType::has_script_type() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void TxAck_TransactionType_TxOutputType::clear_script_type() {
  script_type_ = 0;
  _has_bits_[0] &= ~0x00000020u;
}
inline ::hw::trezor::messages::bitcoin::TxAck_TransactionType_TxOutputType_OutputScriptType TxAck_TransactionType_TxOutputType::script_type() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.bitcoin.TxAck.TransactionType.TxOutputType.script_type)
  return static_cast< ::hw::trezor::messages::bitcoin::TxAck_TransactionType_TxOutputType_OutputScriptType >(script_type_);
}
inline void TxAck_TransactionType_TxOutputType::set_script_type(::hw::trezor::messages::bitcoin::TxAck_TransactionType_TxOutputType_OutputScriptType value) {
  assert(::hw::trezor::messages::bitcoin::TxAck_TransactionType_TxOutputType_OutputScriptType_IsValid(value));
  _has_bits_[0] |= 0x00000020u;
  script_type_ = value;
  // @@protoc_insertion_point(field_set:hw.trezor.messages.bitcoin.TxAck.TransactionType.TxOutputType.script_type)
}

// optional .hw.trezor.messages.bitcoin.MultisigRedeemScriptType multisig = 5;
inline bool TxAck_TransactionType_TxOutputType::has_multisig() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void TxAck_TransactionType_TxOutputType::clear_multisig() {
  if (multisig_ != nullptr) multisig_->Clear();
  _has_bits_[0] &= ~0x00000008u;
}
inline const ::hw::trezor::messages::bitcoin::MultisigRedeemScriptType& TxAck_TransactionType_TxOutputType::multisig() const {
  const ::hw::trezor::messages::bitcoin::MultisigRedeemScriptType* p = multisig_;
  // @@protoc_insertion_point(field_get:hw.trezor.messages.bitcoin.TxAck.TransactionType.TxOutputType.multisig)
  return p != nullptr ? *p : *reinterpret_cast<const ::hw::trezor::messages::bitcoin::MultisigRedeemScriptType*>(
      &::hw::trezor::messages::bitcoin::_MultisigRedeemScriptType_default_instance_);
}
inline ::hw::trezor::messages::bitcoin::MultisigRedeemScriptType* TxAck_TransactionType_TxOutputType::release_multisig() {
  // @@protoc_insertion_point(field_release:hw.trezor.messages.bitcoin.TxAck.TransactionType.TxOutputType.multisig)
  _has_bits_[0] &= ~0x00000008u;
  ::hw::trezor::messages::bitcoin::MultisigRedeemScriptType* temp = multisig_;
  multisig_ = nullptr;
  return temp;
}
inline ::hw::trezor::messages::bitcoin::MultisigRedeemScriptType* TxAck_TransactionType_TxOutputType::mutable_multisig() {
  _has_bits_[0] |= 0x00000008u;
  if (multisig_ == nullptr) {
    auto* p = CreateMaybeMessage<::hw::trezor::messages::bitcoin::MultisigRedeemScriptType>(GetArenaNoVirtual());
    multisig_ = p;
  }
  // @@protoc_insertion_point(field_mutable:hw.trezor.messages.bitcoin.TxAck.TransactionType.TxOutputType.multisig)
  return multisig_;
}
inline void TxAck_TransactionType_TxOutputType::set_allocated_multisig(::hw::trezor::messages::bitcoin::MultisigRedeemScriptType* multisig) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete multisig_;
  }
  if (multisig) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      multisig = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, multisig, submessage_arena);
    }
    _has_bits_[0] |= 0x00000008u;
  } else {
    _has_bits_[0] &= ~0x00000008u;
  }
  multisig_ = multisig;
  // @@protoc_insertion_point(field_set_allocated:hw.trezor.messages.bitcoin.TxAck.TransactionType.TxOutputType.multisig)
}

// optional bytes op_return_data = 6;
inline bool TxAck_TransactionType_TxOutputType::has_op_return_data() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TxAck_TransactionType_TxOutputType::clear_op_return_data() {
  op_return_data_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000002u;
}
inline const ::std::string& TxAck_TransactionType_TxOutputType::op_return_data() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.bitcoin.TxAck.TransactionType.TxOutputType.op_return_data)
  return op_return_data_.GetNoArena();
}
inline void TxAck_TransactionType_TxOutputType::set_op_return_data(const ::std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  op_return_data_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:hw.trezor.messages.bitcoin.TxAck.TransactionType.TxOutputType.op_return_data)
}
#if LANG_CXX11
inline void TxAck_TransactionType_TxOutputType::set_op_return_data(::std::string&& value) {
  _has_bits_[0] |= 0x00000002u;
  op_return_data_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:hw.trezor.messages.bitcoin.TxAck.TransactionType.TxOutputType.op_return_data)
}
#endif
inline void TxAck_TransactionType_TxOutputType::set_op_return_data(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000002u;
  op_return_data_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:hw.trezor.messages.bitcoin.TxAck.TransactionType.TxOutputType.op_return_data)
}
inline void TxAck_TransactionType_TxOutputType::set_op_return_data(const void* value, size_t size) {
  _has_bits_[0] |= 0x00000002u;
  op_return_data_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:hw.trezor.messages.bitcoin.TxAck.TransactionType.TxOutputType.op_return_data)
}
inline ::std::string* TxAck_TransactionType_TxOutputType::mutable_op_return_data() {
  _has_bits_[0] |= 0x00000002u;
  // @@protoc_insertion_point(field_mutable:hw.trezor.messages.bitcoin.TxAck.TransactionType.TxOutputType.op_return_data)
  return op_return_data_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* TxAck_TransactionType_TxOutputType::release_op_return_data() {
  // @@protoc_insertion_point(field_release:hw.trezor.messages.bitcoin.TxAck.TransactionType.TxOutputType.op_return_data)
  if (!has_op_return_data()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  return op_return_data_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void TxAck_TransactionType_TxOutputType::set_allocated_op_return_data(::std::string* op_return_data) {
  if (op_return_data != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  op_return_data_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), op_return_data);
  // @@protoc_insertion_point(field_set_allocated:hw.trezor.messages.bitcoin.TxAck.TransactionType.TxOutputType.op_return_data)
}

// optional uint32 decred_script_version = 7;
inline bool TxAck_TransactionType_TxOutputType::has_decred_script_version() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void TxAck_TransactionType_TxOutputType::clear_decred_script_version() {
  decred_script_version_ = 0u;
  _has_bits_[0] &= ~0x00000040u;
}
inline ::google::protobuf::uint32 TxAck_TransactionType_TxOutputType::decred_script_version() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.bitcoin.TxAck.TransactionType.TxOutputType.decred_script_version)
  return decred_script_version_;
}
inline void TxAck_TransactionType_TxOutputType::set_decred_script_version(::google::protobuf::uint32 value) {
  _has_bits_[0] |= 0x00000040u;
  decred_script_version_ = value;
  // @@protoc_insertion_point(field_set:hw.trezor.messages.bitcoin.TxAck.TransactionType.TxOutputType.decred_script_version)
}

// optional bytes block_hash_bip115 = 8;
inline bool TxAck_TransactionType_TxOutputType::has_block_hash_bip115() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TxAck_TransactionType_TxOutputType::clear_block_hash_bip115() {
  block_hash_bip115_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000004u;
}
inline const ::std::string& TxAck_TransactionType_TxOutputType::block_hash_bip115() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.bitcoin.TxAck.TransactionType.TxOutputType.block_hash_bip115)
  return block_hash_bip115_.GetNoArena();
}
inline void TxAck_TransactionType_TxOutputType::set_block_hash_bip115(const ::std::string& value) {
  _has_bits_[0] |= 0x00000004u;
  block_hash_bip115_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:hw.trezor.messages.bitcoin.TxAck.TransactionType.TxOutputType.block_hash_bip115)
}
#if LANG_CXX11
inline void TxAck_TransactionType_TxOutputType::set_block_hash_bip115(::std::string&& value) {
  _has_bits_[0] |= 0x00000004u;
  block_hash_bip115_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:hw.trezor.messages.bitcoin.TxAck.TransactionType.TxOutputType.block_hash_bip115)
}
#endif
inline void TxAck_TransactionType_TxOutputType::set_block_hash_bip115(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000004u;
  block_hash_bip115_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:hw.trezor.messages.bitcoin.TxAck.TransactionType.TxOutputType.block_hash_bip115)
}
inline void TxAck_TransactionType_TxOutputType::set_block_hash_bip115(const void* value, size_t size) {
  _has_bits_[0] |= 0x00000004u;
  block_hash_bip115_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:hw.trezor.messages.bitcoin.TxAck.TransactionType.TxOutputType.block_hash_bip115)
}
inline ::std::string* TxAck_TransactionType_TxOutputType::mutable_block_hash_bip115() {
  _has_bits_[0] |= 0x00000004u;
  // @@protoc_insertion_point(field_mutable:hw.trezor.messages.bitcoin.TxAck.TransactionType.TxOutputType.block_hash_bip115)
  return block_hash_bip115_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* TxAck_TransactionType_TxOutputType::release_block_hash_bip115() {
  // @@protoc_insertion_point(field_release:hw.trezor.messages.bitcoin.TxAck.TransactionType.TxOutputType.block_hash_bip115)
  if (!has_block_hash_bip115()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000004u;
  return block_hash_bip115_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void TxAck_TransactionType_TxOutputType::set_allocated_block_hash_bip115(::std::string* block_hash_bip115) {
  if (block_hash_bip115 != nullptr) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  block_hash_bip115_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), block_hash_bip115);
  // @@protoc_insertion_point(field_set_allocated:hw.trezor.messages.bitcoin.TxAck.TransactionType.TxOutputType.block_hash_bip115)
}

// optional uint32 block_height_bip115 = 9;
inline bool TxAck_TransactionType_TxOutputType::has_block_height_bip115() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void TxAck_TransactionType_TxOutputType::clear_block_height_bip115() {
  block_height_bip115_ = 0u;
  _has_bits_[0] &= ~0x00000080u;
}
inline ::google::protobuf::uint32 TxAck_TransactionType_TxOutputType::block_height_bip115() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.bitcoin.TxAck.TransactionType.TxOutputType.block_height_bip115)
  return block_height_bip115_;
}
inline void TxAck_TransactionType_TxOutputType::set_block_height_bip115(::google::protobuf::uint32 value) {
  _has_bits_[0] |= 0x00000080u;
  block_height_bip115_ = value;
  // @@protoc_insertion_point(field_set:hw.trezor.messages.bitcoin.TxAck.TransactionType.TxOutputType.block_height_bip115)
}

// -------------------------------------------------------------------

// TxAck_TransactionType

// optional uint32 version = 1;
inline bool TxAck_TransactionType::has_version() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TxAck_TransactionType::clear_version() {
  version_ = 0u;
  _has_bits_[0] &= ~0x00000002u;
}
inline ::google::protobuf::uint32 TxAck_TransactionType::version() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.bitcoin.TxAck.TransactionType.version)
  return version_;
}
inline void TxAck_TransactionType::set_version(::google::protobuf::uint32 value) {
  _has_bits_[0] |= 0x00000002u;
  version_ = value;
  // @@protoc_insertion_point(field_set:hw.trezor.messages.bitcoin.TxAck.TransactionType.version)
}

// repeated .hw.trezor.messages.bitcoin.TxAck.TransactionType.TxInputType inputs = 2;
inline int TxAck_TransactionType::inputs_size() const {
  return inputs_.size();
}
inline void TxAck_TransactionType::clear_inputs() {
  inputs_.Clear();
}
inline ::hw::trezor::messages::bitcoin::TxAck_TransactionType_TxInputType* TxAck_TransactionType::mutable_inputs(int index) {
  // @@protoc_insertion_point(field_mutable:hw.trezor.messages.bitcoin.TxAck.TransactionType.inputs)
  return inputs_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::hw::trezor::messages::bitcoin::TxAck_TransactionType_TxInputType >*
TxAck_TransactionType::mutable_inputs() {
  // @@protoc_insertion_point(field_mutable_list:hw.trezor.messages.bitcoin.TxAck.TransactionType.inputs)
  return &inputs_;
}
inline const ::hw::trezor::messages::bitcoin::TxAck_TransactionType_TxInputType& TxAck_TransactionType::inputs(int index) const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.bitcoin.TxAck.TransactionType.inputs)
  return inputs_.Get(index);
}
inline ::hw::trezor::messages::bitcoin::TxAck_TransactionType_TxInputType* TxAck_TransactionType::add_inputs() {
  // @@protoc_insertion_point(field_add:hw.trezor.messages.bitcoin.TxAck.TransactionType.inputs)
  return inputs_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::hw::trezor::messages::bitcoin::TxAck_TransactionType_TxInputType >&
TxAck_TransactionType::inputs() const {
  // @@protoc_insertion_point(field_list:hw.trezor.messages.bitcoin.TxAck.TransactionType.inputs)
  return inputs_;
}

// repeated .hw.trezor.messages.bitcoin.TxAck.TransactionType.TxOutputBinType bin_outputs = 3;
inline int TxAck_TransactionType::bin_outputs_size() const {
  return bin_outputs_.size();
}
inline void TxAck_TransactionType::clear_bin_outputs() {
  bin_outputs_.Clear();
}
inline ::hw::trezor::messages::bitcoin::TxAck_TransactionType_TxOutputBinType* TxAck_TransactionType::mutable_bin_outputs(int index) {
  // @@protoc_insertion_point(field_mutable:hw.trezor.messages.bitcoin.TxAck.TransactionType.bin_outputs)
  return bin_outputs_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::hw::trezor::messages::bitcoin::TxAck_TransactionType_TxOutputBinType >*
TxAck_TransactionType::mutable_bin_outputs() {
  // @@protoc_insertion_point(field_mutable_list:hw.trezor.messages.bitcoin.TxAck.TransactionType.bin_outputs)
  return &bin_outputs_;
}
inline const ::hw::trezor::messages::bitcoin::TxAck_TransactionType_TxOutputBinType& TxAck_TransactionType::bin_outputs(int index) const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.bitcoin.TxAck.TransactionType.bin_outputs)
  return bin_outputs_.Get(index);
}
inline ::hw::trezor::messages::bitcoin::TxAck_TransactionType_TxOutputBinType* TxAck_TransactionType::add_bin_outputs() {
  // @@protoc_insertion_point(field_add:hw.trezor.messages.bitcoin.TxAck.TransactionType.bin_outputs)
  return bin_outputs_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::hw::trezor::messages::bitcoin::TxAck_TransactionType_TxOutputBinType >&
TxAck_TransactionType::bin_outputs() const {
  // @@protoc_insertion_point(field_list:hw.trezor.messages.bitcoin.TxAck.TransactionType.bin_outputs)
  return bin_outputs_;
}

// optional uint32 lock_time = 4;
inline bool TxAck_TransactionType::has_lock_time() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TxAck_TransactionType::clear_lock_time() {
  lock_time_ = 0u;
  _has_bits_[0] &= ~0x00000004u;
}
inline ::google::protobuf::uint32 TxAck_TransactionType::lock_time() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.bitcoin.TxAck.TransactionType.lock_time)
  return lock_time_;
}
inline void TxAck_TransactionType::set_lock_time(::google::protobuf::uint32 value) {
  _has_bits_[0] |= 0x00000004u;
  lock_time_ = value;
  // @@protoc_insertion_point(field_set:hw.trezor.messages.bitcoin.TxAck.TransactionType.lock_time)
}

// repeated .hw.trezor.messages.bitcoin.TxAck.TransactionType.TxOutputType outputs = 5;
inline int TxAck_TransactionType::outputs_size() const {
  return outputs_.size();
}
inline void TxAck_TransactionType::clear_outputs() {
  outputs_.Clear();
}
inline ::hw::trezor::messages::bitcoin::TxAck_TransactionType_TxOutputType* TxAck_TransactionType::mutable_outputs(int index) {
  // @@protoc_insertion_point(field_mutable:hw.trezor.messages.bitcoin.TxAck.TransactionType.outputs)
  return outputs_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::hw::trezor::messages::bitcoin::TxAck_TransactionType_TxOutputType >*
TxAck_TransactionType::mutable_outputs() {
  // @@protoc_insertion_point(field_mutable_list:hw.trezor.messages.bitcoin.TxAck.TransactionType.outputs)
  return &outputs_;
}
inline const ::hw::trezor::messages::bitcoin::TxAck_TransactionType_TxOutputType& TxAck_TransactionType::outputs(int index) const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.bitcoin.TxAck.TransactionType.outputs)
  return outputs_.Get(index);
}
inline ::hw::trezor::messages::bitcoin::TxAck_TransactionType_TxOutputType* TxAck_TransactionType::add_outputs() {
  // @@protoc_insertion_point(field_add:hw.trezor.messages.bitcoin.TxAck.TransactionType.outputs)
  return outputs_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::hw::trezor::messages::bitcoin::TxAck_TransactionType_TxOutputType >&
TxAck_TransactionType::outputs() const {
  // @@protoc_insertion_point(field_list:hw.trezor.messages.bitcoin.TxAck.TransactionType.outputs)
  return outputs_;
}

// optional uint32 inputs_cnt = 6;
inline bool TxAck_TransactionType::has_inputs_cnt() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void TxAck_TransactionType::clear_inputs_cnt() {
  inputs_cnt_ = 0u;
  _has_bits_[0] &= ~0x00000008u;
}
inline ::google::protobuf::uint32 TxAck_TransactionType::inputs_cnt() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.bitcoin.TxAck.TransactionType.inputs_cnt)
  return inputs_cnt_;
}
inline void TxAck_TransactionType::set_inputs_cnt(::google::protobuf::uint32 value) {
  _has_bits_[0] |= 0x00000008u;
  inputs_cnt_ = value;
  // @@protoc_insertion_point(field_set:hw.trezor.messages.bitcoin.TxAck.TransactionType.inputs_cnt)
}

// optional uint32 outputs_cnt = 7;
inline bool TxAck_TransactionType::has_outputs_cnt() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void TxAck_TransactionType::clear_outputs_cnt() {
  outputs_cnt_ = 0u;
  _has_bits_[0] &= ~0x00000010u;
}
inline ::google::protobuf::uint32 TxAck_TransactionType::outputs_cnt() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.bitcoin.TxAck.TransactionType.outputs_cnt)
  return outputs_cnt_;
}
inline void TxAck_TransactionType::set_outputs_cnt(::google::protobuf::uint32 value) {
  _has_bits_[0] |= 0x00000010u;
  outputs_cnt_ = value;
  // @@protoc_insertion_point(field_set:hw.trezor.messages.bitcoin.TxAck.TransactionType.outputs_cnt)
}

// optional bytes extra_data = 8;
inline bool TxAck_TransactionType::has_extra_data() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TxAck_TransactionType::clear_extra_data() {
  extra_data_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::std::string& TxAck_TransactionType::extra_data() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.bitcoin.TxAck.TransactionType.extra_data)
  return extra_data_.GetNoArena();
}
inline void TxAck_TransactionType::set_extra_data(const ::std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  extra_data_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:hw.trezor.messages.bitcoin.TxAck.TransactionType.extra_data)
}
#if LANG_CXX11
inline void TxAck_TransactionType::set_extra_data(::std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  extra_data_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:hw.trezor.messages.bitcoin.TxAck.TransactionType.extra_data)
}
#endif
inline void TxAck_TransactionType::set_extra_data(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  extra_data_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:hw.trezor.messages.bitcoin.TxAck.TransactionType.extra_data)
}
inline void TxAck_TransactionType::set_extra_data(const void* value, size_t size) {
  _has_bits_[0] |= 0x00000001u;
  extra_data_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:hw.trezor.messages.bitcoin.TxAck.TransactionType.extra_data)
}
inline ::std::string* TxAck_TransactionType::mutable_extra_data() {
  _has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_mutable:hw.trezor.messages.bitcoin.TxAck.TransactionType.extra_data)
  return extra_data_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* TxAck_TransactionType::release_extra_data() {
  // @@protoc_insertion_point(field_release:hw.trezor.messages.bitcoin.TxAck.TransactionType.extra_data)
  if (!has_extra_data()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return extra_data_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void TxAck_TransactionType::set_allocated_extra_data(::std::string* extra_data) {
  if (extra_data != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  extra_data_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), extra_data);
  // @@protoc_insertion_point(field_set_allocated:hw.trezor.messages.bitcoin.TxAck.TransactionType.extra_data)
}

// optional uint32 extra_data_len = 9;
inline bool TxAck_TransactionType::has_extra_data_len() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void TxAck_TransactionType::clear_extra_data_len() {
  extra_data_len_ = 0u;
  _has_bits_[0] &= ~0x00000020u;
}
inline ::google::protobuf::uint32 TxAck_TransactionType::extra_data_len() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.bitcoin.TxAck.TransactionType.extra_data_len)
  return extra_data_len_;
}
inline void TxAck_TransactionType::set_extra_data_len(::google::protobuf::uint32 value) {
  _has_bits_[0] |= 0x00000020u;
  extra_data_len_ = value;
  // @@protoc_insertion_point(field_set:hw.trezor.messages.bitcoin.TxAck.TransactionType.extra_data_len)
}

// optional uint32 expiry = 10;
inline bool TxAck_TransactionType::has_expiry() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void TxAck_TransactionType::clear_expiry() {
  expiry_ = 0u;
  _has_bits_[0] &= ~0x00000040u;
}
inline ::google::protobuf::uint32 TxAck_TransactionType::expiry() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.bitcoin.TxAck.TransactionType.expiry)
  return expiry_;
}
inline void TxAck_TransactionType::set_expiry(::google::protobuf::uint32 value) {
  _has_bits_[0] |= 0x00000040u;
  expiry_ = value;
  // @@protoc_insertion_point(field_set:hw.trezor.messages.bitcoin.TxAck.TransactionType.expiry)
}

// optional bool overwintered = 11;
inline bool TxAck_TransactionType::has_overwintered() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void TxAck_TransactionType::clear_overwintered() {
  overwintered_ = false;
  _has_bits_[0] &= ~0x00000080u;
}
inline bool TxAck_TransactionType::overwintered() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.bitcoin.TxAck.TransactionType.overwintered)
  return overwintered_;
}
inline void TxAck_TransactionType::set_overwintered(bool value) {
  _has_bits_[0] |= 0x00000080u;
  overwintered_ = value;
  // @@protoc_insertion_point(field_set:hw.trezor.messages.bitcoin.TxAck.TransactionType.overwintered)
}

// optional uint32 version_group_id = 12;
inline bool TxAck_TransactionType::has_version_group_id() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void TxAck_TransactionType::clear_version_group_id() {
  version_group_id_ = 0u;
  _has_bits_[0] &= ~0x00000100u;
}
inline ::google::protobuf::uint32 TxAck_TransactionType::version_group_id() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.bitcoin.TxAck.TransactionType.version_group_id)
  return version_group_id_;
}
inline void TxAck_TransactionType::set_version_group_id(::google::protobuf::uint32 value) {
  _has_bits_[0] |= 0x00000100u;
  version_group_id_ = value;
  // @@protoc_insertion_point(field_set:hw.trezor.messages.bitcoin.TxAck.TransactionType.version_group_id)
}

// optional uint32 timestamp = 13;
inline bool TxAck_TransactionType::has_timestamp() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void TxAck_TransactionType::clear_timestamp() {
  timestamp_ = 0u;
  _has_bits_[0] &= ~0x00000200u;
}
inline ::google::protobuf::uint32 TxAck_TransactionType::timestamp() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.bitcoin.TxAck.TransactionType.timestamp)
  return timestamp_;
}
inline void TxAck_TransactionType::set_timestamp(::google::protobuf::uint32 value) {
  _has_bits_[0] |= 0x00000200u;
  timestamp_ = value;
  // @@protoc_insertion_point(field_set:hw.trezor.messages.bitcoin.TxAck.TransactionType.timestamp)
}

// -------------------------------------------------------------------

// TxAck

// optional .hw.trezor.messages.bitcoin.TxAck.TransactionType tx = 1;
inline bool TxAck::has_tx() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TxAck::clear_tx() {
  if (tx_ != nullptr) tx_->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::hw::trezor::messages::bitcoin::TxAck_TransactionType& TxAck::tx() const {
  const ::hw::trezor::messages::bitcoin::TxAck_TransactionType* p = tx_;
  // @@protoc_insertion_point(field_get:hw.trezor.messages.bitcoin.TxAck.tx)
  return p != nullptr ? *p : *reinterpret_cast<const ::hw::trezor::messages::bitcoin::TxAck_TransactionType*>(
      &::hw::trezor::messages::bitcoin::_TxAck_TransactionType_default_instance_);
}
inline ::hw::trezor::messages::bitcoin::TxAck_TransactionType* TxAck::release_tx() {
  // @@protoc_insertion_point(field_release:hw.trezor.messages.bitcoin.TxAck.tx)
  _has_bits_[0] &= ~0x00000001u;
  ::hw::trezor::messages::bitcoin::TxAck_TransactionType* temp = tx_;
  tx_ = nullptr;
  return temp;
}
inline ::hw::trezor::messages::bitcoin::TxAck_TransactionType* TxAck::mutable_tx() {
  _has_bits_[0] |= 0x00000001u;
  if (tx_ == nullptr) {
    auto* p = CreateMaybeMessage<::hw::trezor::messages::bitcoin::TxAck_TransactionType>(GetArenaNoVirtual());
    tx_ = p;
  }
  // @@protoc_insertion_point(field_mutable:hw.trezor.messages.bitcoin.TxAck.tx)
  return tx_;
}
inline void TxAck::set_allocated_tx(::hw::trezor::messages::bitcoin::TxAck_TransactionType* tx) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete tx_;
  }
  if (tx) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      tx = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, tx, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  tx_ = tx;
  // @@protoc_insertion_point(field_set_allocated:hw.trezor.messages.bitcoin.TxAck.tx)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace bitcoin
}  // namespace messages
}  // namespace trezor
}  // namespace hw

namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::hw::trezor::messages::bitcoin::TxRequest_RequestType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::hw::trezor::messages::bitcoin::TxRequest_RequestType>() {
  return ::hw::trezor::messages::bitcoin::TxRequest_RequestType_descriptor();
}
template <> struct is_proto_enum< ::hw::trezor::messages::bitcoin::TxAck_TransactionType_TxOutputType_OutputScriptType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::hw::trezor::messages::bitcoin::TxAck_TransactionType_TxOutputType_OutputScriptType>() {
  return ::hw::trezor::messages::bitcoin::TxAck_TransactionType_TxOutputType_OutputScriptType_descriptor();
}
template <> struct is_proto_enum< ::hw::trezor::messages::bitcoin::InputScriptType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::hw::trezor::messages::bitcoin::InputScriptType>() {
  return ::hw::trezor::messages::bitcoin::InputScriptType_descriptor();
}

}  // namespace protobuf
}  // namespace google

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // PROTOBUF_INCLUDED_messages_2dbitcoin_2eproto
