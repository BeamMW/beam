// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: messages-eos.proto

#ifndef PROTOBUF_INCLUDED_messages_2deos_2eproto
#define PROTOBUF_INCLUDED_messages_2deos_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3007000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3007000 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_messages_2deos_2eproto

// Internal implementation detail -- do not use these members.
struct TableStruct_messages_2deos_2eproto {
  static const ::google::protobuf::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::google::protobuf::internal::ParseTable schema[28]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::google::protobuf::internal::FieldMetadata field_metadata[];
  static const ::google::protobuf::internal::SerializationTable serialization_table[];
  static const ::google::protobuf::uint32 offsets[];
};
void AddDescriptors_messages_2deos_2eproto();
namespace hw {
namespace trezor {
namespace messages {
namespace eos {
class EosGetPublicKey;
class EosGetPublicKeyDefaultTypeInternal;
extern EosGetPublicKeyDefaultTypeInternal _EosGetPublicKey_default_instance_;
class EosPublicKey;
class EosPublicKeyDefaultTypeInternal;
extern EosPublicKeyDefaultTypeInternal _EosPublicKey_default_instance_;
class EosSignTx;
class EosSignTxDefaultTypeInternal;
extern EosSignTxDefaultTypeInternal _EosSignTx_default_instance_;
class EosSignTx_EosTxHeader;
class EosSignTx_EosTxHeaderDefaultTypeInternal;
extern EosSignTx_EosTxHeaderDefaultTypeInternal _EosSignTx_EosTxHeader_default_instance_;
class EosSignedTx;
class EosSignedTxDefaultTypeInternal;
extern EosSignedTxDefaultTypeInternal _EosSignedTx_default_instance_;
class EosTxActionAck;
class EosTxActionAckDefaultTypeInternal;
extern EosTxActionAckDefaultTypeInternal _EosTxActionAck_default_instance_;
class EosTxActionAck_EosActionBuyRam;
class EosTxActionAck_EosActionBuyRamDefaultTypeInternal;
extern EosTxActionAck_EosActionBuyRamDefaultTypeInternal _EosTxActionAck_EosActionBuyRam_default_instance_;
class EosTxActionAck_EosActionBuyRamBytes;
class EosTxActionAck_EosActionBuyRamBytesDefaultTypeInternal;
extern EosTxActionAck_EosActionBuyRamBytesDefaultTypeInternal _EosTxActionAck_EosActionBuyRamBytes_default_instance_;
class EosTxActionAck_EosActionCommon;
class EosTxActionAck_EosActionCommonDefaultTypeInternal;
extern EosTxActionAck_EosActionCommonDefaultTypeInternal _EosTxActionAck_EosActionCommon_default_instance_;
class EosTxActionAck_EosActionDelegate;
class EosTxActionAck_EosActionDelegateDefaultTypeInternal;
extern EosTxActionAck_EosActionDelegateDefaultTypeInternal _EosTxActionAck_EosActionDelegate_default_instance_;
class EosTxActionAck_EosActionDeleteAuth;
class EosTxActionAck_EosActionDeleteAuthDefaultTypeInternal;
extern EosTxActionAck_EosActionDeleteAuthDefaultTypeInternal _EosTxActionAck_EosActionDeleteAuth_default_instance_;
class EosTxActionAck_EosActionLinkAuth;
class EosTxActionAck_EosActionLinkAuthDefaultTypeInternal;
extern EosTxActionAck_EosActionLinkAuthDefaultTypeInternal _EosTxActionAck_EosActionLinkAuth_default_instance_;
class EosTxActionAck_EosActionNewAccount;
class EosTxActionAck_EosActionNewAccountDefaultTypeInternal;
extern EosTxActionAck_EosActionNewAccountDefaultTypeInternal _EosTxActionAck_EosActionNewAccount_default_instance_;
class EosTxActionAck_EosActionRefund;
class EosTxActionAck_EosActionRefundDefaultTypeInternal;
extern EosTxActionAck_EosActionRefundDefaultTypeInternal _EosTxActionAck_EosActionRefund_default_instance_;
class EosTxActionAck_EosActionSellRam;
class EosTxActionAck_EosActionSellRamDefaultTypeInternal;
extern EosTxActionAck_EosActionSellRamDefaultTypeInternal _EosTxActionAck_EosActionSellRam_default_instance_;
class EosTxActionAck_EosActionTransfer;
class EosTxActionAck_EosActionTransferDefaultTypeInternal;
extern EosTxActionAck_EosActionTransferDefaultTypeInternal _EosTxActionAck_EosActionTransfer_default_instance_;
class EosTxActionAck_EosActionUndelegate;
class EosTxActionAck_EosActionUndelegateDefaultTypeInternal;
extern EosTxActionAck_EosActionUndelegateDefaultTypeInternal _EosTxActionAck_EosActionUndelegate_default_instance_;
class EosTxActionAck_EosActionUnknown;
class EosTxActionAck_EosActionUnknownDefaultTypeInternal;
extern EosTxActionAck_EosActionUnknownDefaultTypeInternal _EosTxActionAck_EosActionUnknown_default_instance_;
class EosTxActionAck_EosActionUnlinkAuth;
class EosTxActionAck_EosActionUnlinkAuthDefaultTypeInternal;
extern EosTxActionAck_EosActionUnlinkAuthDefaultTypeInternal _EosTxActionAck_EosActionUnlinkAuth_default_instance_;
class EosTxActionAck_EosActionUpdateAuth;
class EosTxActionAck_EosActionUpdateAuthDefaultTypeInternal;
extern EosTxActionAck_EosActionUpdateAuthDefaultTypeInternal _EosTxActionAck_EosActionUpdateAuth_default_instance_;
class EosTxActionAck_EosActionVoteProducer;
class EosTxActionAck_EosActionVoteProducerDefaultTypeInternal;
extern EosTxActionAck_EosActionVoteProducerDefaultTypeInternal _EosTxActionAck_EosActionVoteProducer_default_instance_;
class EosTxActionAck_EosAsset;
class EosTxActionAck_EosAssetDefaultTypeInternal;
extern EosTxActionAck_EosAssetDefaultTypeInternal _EosTxActionAck_EosAsset_default_instance_;
class EosTxActionAck_EosAuthorization;
class EosTxActionAck_EosAuthorizationDefaultTypeInternal;
extern EosTxActionAck_EosAuthorizationDefaultTypeInternal _EosTxActionAck_EosAuthorization_default_instance_;
class EosTxActionAck_EosAuthorizationAccount;
class EosTxActionAck_EosAuthorizationAccountDefaultTypeInternal;
extern EosTxActionAck_EosAuthorizationAccountDefaultTypeInternal _EosTxActionAck_EosAuthorizationAccount_default_instance_;
class EosTxActionAck_EosAuthorizationKey;
class EosTxActionAck_EosAuthorizationKeyDefaultTypeInternal;
extern EosTxActionAck_EosAuthorizationKeyDefaultTypeInternal _EosTxActionAck_EosAuthorizationKey_default_instance_;
class EosTxActionAck_EosAuthorizationWait;
class EosTxActionAck_EosAuthorizationWaitDefaultTypeInternal;
extern EosTxActionAck_EosAuthorizationWaitDefaultTypeInternal _EosTxActionAck_EosAuthorizationWait_default_instance_;
class EosTxActionAck_EosPermissionLevel;
class EosTxActionAck_EosPermissionLevelDefaultTypeInternal;
extern EosTxActionAck_EosPermissionLevelDefaultTypeInternal _EosTxActionAck_EosPermissionLevel_default_instance_;
class EosTxActionRequest;
class EosTxActionRequestDefaultTypeInternal;
extern EosTxActionRequestDefaultTypeInternal _EosTxActionRequest_default_instance_;
}  // namespace eos
}  // namespace messages
}  // namespace trezor
}  // namespace hw
namespace google {
namespace protobuf {
template<> ::hw::trezor::messages::eos::EosGetPublicKey* Arena::CreateMaybeMessage<::hw::trezor::messages::eos::EosGetPublicKey>(Arena*);
template<> ::hw::trezor::messages::eos::EosPublicKey* Arena::CreateMaybeMessage<::hw::trezor::messages::eos::EosPublicKey>(Arena*);
template<> ::hw::trezor::messages::eos::EosSignTx* Arena::CreateMaybeMessage<::hw::trezor::messages::eos::EosSignTx>(Arena*);
template<> ::hw::trezor::messages::eos::EosSignTx_EosTxHeader* Arena::CreateMaybeMessage<::hw::trezor::messages::eos::EosSignTx_EosTxHeader>(Arena*);
template<> ::hw::trezor::messages::eos::EosSignedTx* Arena::CreateMaybeMessage<::hw::trezor::messages::eos::EosSignedTx>(Arena*);
template<> ::hw::trezor::messages::eos::EosTxActionAck* Arena::CreateMaybeMessage<::hw::trezor::messages::eos::EosTxActionAck>(Arena*);
template<> ::hw::trezor::messages::eos::EosTxActionAck_EosActionBuyRam* Arena::CreateMaybeMessage<::hw::trezor::messages::eos::EosTxActionAck_EosActionBuyRam>(Arena*);
template<> ::hw::trezor::messages::eos::EosTxActionAck_EosActionBuyRamBytes* Arena::CreateMaybeMessage<::hw::trezor::messages::eos::EosTxActionAck_EosActionBuyRamBytes>(Arena*);
template<> ::hw::trezor::messages::eos::EosTxActionAck_EosActionCommon* Arena::CreateMaybeMessage<::hw::trezor::messages::eos::EosTxActionAck_EosActionCommon>(Arena*);
template<> ::hw::trezor::messages::eos::EosTxActionAck_EosActionDelegate* Arena::CreateMaybeMessage<::hw::trezor::messages::eos::EosTxActionAck_EosActionDelegate>(Arena*);
template<> ::hw::trezor::messages::eos::EosTxActionAck_EosActionDeleteAuth* Arena::CreateMaybeMessage<::hw::trezor::messages::eos::EosTxActionAck_EosActionDeleteAuth>(Arena*);
template<> ::hw::trezor::messages::eos::EosTxActionAck_EosActionLinkAuth* Arena::CreateMaybeMessage<::hw::trezor::messages::eos::EosTxActionAck_EosActionLinkAuth>(Arena*);
template<> ::hw::trezor::messages::eos::EosTxActionAck_EosActionNewAccount* Arena::CreateMaybeMessage<::hw::trezor::messages::eos::EosTxActionAck_EosActionNewAccount>(Arena*);
template<> ::hw::trezor::messages::eos::EosTxActionAck_EosActionRefund* Arena::CreateMaybeMessage<::hw::trezor::messages::eos::EosTxActionAck_EosActionRefund>(Arena*);
template<> ::hw::trezor::messages::eos::EosTxActionAck_EosActionSellRam* Arena::CreateMaybeMessage<::hw::trezor::messages::eos::EosTxActionAck_EosActionSellRam>(Arena*);
template<> ::hw::trezor::messages::eos::EosTxActionAck_EosActionTransfer* Arena::CreateMaybeMessage<::hw::trezor::messages::eos::EosTxActionAck_EosActionTransfer>(Arena*);
template<> ::hw::trezor::messages::eos::EosTxActionAck_EosActionUndelegate* Arena::CreateMaybeMessage<::hw::trezor::messages::eos::EosTxActionAck_EosActionUndelegate>(Arena*);
template<> ::hw::trezor::messages::eos::EosTxActionAck_EosActionUnknown* Arena::CreateMaybeMessage<::hw::trezor::messages::eos::EosTxActionAck_EosActionUnknown>(Arena*);
template<> ::hw::trezor::messages::eos::EosTxActionAck_EosActionUnlinkAuth* Arena::CreateMaybeMessage<::hw::trezor::messages::eos::EosTxActionAck_EosActionUnlinkAuth>(Arena*);
template<> ::hw::trezor::messages::eos::EosTxActionAck_EosActionUpdateAuth* Arena::CreateMaybeMessage<::hw::trezor::messages::eos::EosTxActionAck_EosActionUpdateAuth>(Arena*);
template<> ::hw::trezor::messages::eos::EosTxActionAck_EosActionVoteProducer* Arena::CreateMaybeMessage<::hw::trezor::messages::eos::EosTxActionAck_EosActionVoteProducer>(Arena*);
template<> ::hw::trezor::messages::eos::EosTxActionAck_EosAsset* Arena::CreateMaybeMessage<::hw::trezor::messages::eos::EosTxActionAck_EosAsset>(Arena*);
template<> ::hw::trezor::messages::eos::EosTxActionAck_EosAuthorization* Arena::CreateMaybeMessage<::hw::trezor::messages::eos::EosTxActionAck_EosAuthorization>(Arena*);
template<> ::hw::trezor::messages::eos::EosTxActionAck_EosAuthorizationAccount* Arena::CreateMaybeMessage<::hw::trezor::messages::eos::EosTxActionAck_EosAuthorizationAccount>(Arena*);
template<> ::hw::trezor::messages::eos::EosTxActionAck_EosAuthorizationKey* Arena::CreateMaybeMessage<::hw::trezor::messages::eos::EosTxActionAck_EosAuthorizationKey>(Arena*);
template<> ::hw::trezor::messages::eos::EosTxActionAck_EosAuthorizationWait* Arena::CreateMaybeMessage<::hw::trezor::messages::eos::EosTxActionAck_EosAuthorizationWait>(Arena*);
template<> ::hw::trezor::messages::eos::EosTxActionAck_EosPermissionLevel* Arena::CreateMaybeMessage<::hw::trezor::messages::eos::EosTxActionAck_EosPermissionLevel>(Arena*);
template<> ::hw::trezor::messages::eos::EosTxActionRequest* Arena::CreateMaybeMessage<::hw::trezor::messages::eos::EosTxActionRequest>(Arena*);
}  // namespace protobuf
}  // namespace google
namespace hw {
namespace trezor {
namespace messages {
namespace eos {

// ===================================================================

class EosGetPublicKey final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:hw.trezor.messages.eos.EosGetPublicKey) */ {
 public:
  EosGetPublicKey();
  virtual ~EosGetPublicKey();

  EosGetPublicKey(const EosGetPublicKey& from);

  inline EosGetPublicKey& operator=(const EosGetPublicKey& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  EosGetPublicKey(EosGetPublicKey&& from) noexcept
    : EosGetPublicKey() {
    *this = ::std::move(from);
  }

  inline EosGetPublicKey& operator=(EosGetPublicKey&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const EosGetPublicKey& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const EosGetPublicKey* internal_default_instance() {
    return reinterpret_cast<const EosGetPublicKey*>(
               &_EosGetPublicKey_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  void Swap(EosGetPublicKey* other);
  friend void swap(EosGetPublicKey& a, EosGetPublicKey& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline EosGetPublicKey* New() const final {
    return CreateMaybeMessage<EosGetPublicKey>(nullptr);
  }

  EosGetPublicKey* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<EosGetPublicKey>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const EosGetPublicKey& from);
  void MergeFrom(const EosGetPublicKey& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(EosGetPublicKey* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated uint32 address_n = 1;
  int address_n_size() const;
  void clear_address_n();
  static const int kAddressNFieldNumber = 1;
  ::google::protobuf::uint32 address_n(int index) const;
  void set_address_n(int index, ::google::protobuf::uint32 value);
  void add_address_n(::google::protobuf::uint32 value);
  const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      address_n() const;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable_address_n();

  // optional bool show_display = 2;
  bool has_show_display() const;
  void clear_show_display();
  static const int kShowDisplayFieldNumber = 2;
  bool show_display() const;
  void set_show_display(bool value);

  // @@protoc_insertion_point(class_scope:hw.trezor.messages.eos.EosGetPublicKey)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > address_n_;
  bool show_display_;
  friend struct ::TableStruct_messages_2deos_2eproto;
};
// -------------------------------------------------------------------

class EosPublicKey final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:hw.trezor.messages.eos.EosPublicKey) */ {
 public:
  EosPublicKey();
  virtual ~EosPublicKey();

  EosPublicKey(const EosPublicKey& from);

  inline EosPublicKey& operator=(const EosPublicKey& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  EosPublicKey(EosPublicKey&& from) noexcept
    : EosPublicKey() {
    *this = ::std::move(from);
  }

  inline EosPublicKey& operator=(EosPublicKey&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const EosPublicKey& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const EosPublicKey* internal_default_instance() {
    return reinterpret_cast<const EosPublicKey*>(
               &_EosPublicKey_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  void Swap(EosPublicKey* other);
  friend void swap(EosPublicKey& a, EosPublicKey& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline EosPublicKey* New() const final {
    return CreateMaybeMessage<EosPublicKey>(nullptr);
  }

  EosPublicKey* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<EosPublicKey>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const EosPublicKey& from);
  void MergeFrom(const EosPublicKey& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(EosPublicKey* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string wif_public_key = 1;
  bool has_wif_public_key() const;
  void clear_wif_public_key();
  static const int kWifPublicKeyFieldNumber = 1;
  const ::std::string& wif_public_key() const;
  void set_wif_public_key(const ::std::string& value);
  #if LANG_CXX11
  void set_wif_public_key(::std::string&& value);
  #endif
  void set_wif_public_key(const char* value);
  void set_wif_public_key(const char* value, size_t size);
  ::std::string* mutable_wif_public_key();
  ::std::string* release_wif_public_key();
  void set_allocated_wif_public_key(::std::string* wif_public_key);

  // optional bytes raw_public_key = 2;
  bool has_raw_public_key() const;
  void clear_raw_public_key();
  static const int kRawPublicKeyFieldNumber = 2;
  const ::std::string& raw_public_key() const;
  void set_raw_public_key(const ::std::string& value);
  #if LANG_CXX11
  void set_raw_public_key(::std::string&& value);
  #endif
  void set_raw_public_key(const char* value);
  void set_raw_public_key(const void* value, size_t size);
  ::std::string* mutable_raw_public_key();
  ::std::string* release_raw_public_key();
  void set_allocated_raw_public_key(::std::string* raw_public_key);

  // @@protoc_insertion_point(class_scope:hw.trezor.messages.eos.EosPublicKey)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr wif_public_key_;
  ::google::protobuf::internal::ArenaStringPtr raw_public_key_;
  friend struct ::TableStruct_messages_2deos_2eproto;
};
// -------------------------------------------------------------------

class EosSignTx_EosTxHeader final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:hw.trezor.messages.eos.EosSignTx.EosTxHeader) */ {
 public:
  EosSignTx_EosTxHeader();
  virtual ~EosSignTx_EosTxHeader();

  EosSignTx_EosTxHeader(const EosSignTx_EosTxHeader& from);

  inline EosSignTx_EosTxHeader& operator=(const EosSignTx_EosTxHeader& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  EosSignTx_EosTxHeader(EosSignTx_EosTxHeader&& from) noexcept
    : EosSignTx_EosTxHeader() {
    *this = ::std::move(from);
  }

  inline EosSignTx_EosTxHeader& operator=(EosSignTx_EosTxHeader&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const EosSignTx_EosTxHeader& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const EosSignTx_EosTxHeader* internal_default_instance() {
    return reinterpret_cast<const EosSignTx_EosTxHeader*>(
               &_EosSignTx_EosTxHeader_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  void Swap(EosSignTx_EosTxHeader* other);
  friend void swap(EosSignTx_EosTxHeader& a, EosSignTx_EosTxHeader& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline EosSignTx_EosTxHeader* New() const final {
    return CreateMaybeMessage<EosSignTx_EosTxHeader>(nullptr);
  }

  EosSignTx_EosTxHeader* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<EosSignTx_EosTxHeader>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const EosSignTx_EosTxHeader& from);
  void MergeFrom(const EosSignTx_EosTxHeader& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(EosSignTx_EosTxHeader* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 expiration = 1;
  bool has_expiration() const;
  void clear_expiration();
  static const int kExpirationFieldNumber = 1;
  ::google::protobuf::uint32 expiration() const;
  void set_expiration(::google::protobuf::uint32 value);

  // required uint32 ref_block_num = 2;
  bool has_ref_block_num() const;
  void clear_ref_block_num();
  static const int kRefBlockNumFieldNumber = 2;
  ::google::protobuf::uint32 ref_block_num() const;
  void set_ref_block_num(::google::protobuf::uint32 value);

  // required uint32 ref_block_prefix = 3;
  bool has_ref_block_prefix() const;
  void clear_ref_block_prefix();
  static const int kRefBlockPrefixFieldNumber = 3;
  ::google::protobuf::uint32 ref_block_prefix() const;
  void set_ref_block_prefix(::google::protobuf::uint32 value);

  // required uint32 max_net_usage_words = 4;
  bool has_max_net_usage_words() const;
  void clear_max_net_usage_words();
  static const int kMaxNetUsageWordsFieldNumber = 4;
  ::google::protobuf::uint32 max_net_usage_words() const;
  void set_max_net_usage_words(::google::protobuf::uint32 value);

  // required uint32 max_cpu_usage_ms = 5;
  bool has_max_cpu_usage_ms() const;
  void clear_max_cpu_usage_ms();
  static const int kMaxCpuUsageMsFieldNumber = 5;
  ::google::protobuf::uint32 max_cpu_usage_ms() const;
  void set_max_cpu_usage_ms(::google::protobuf::uint32 value);

  // required uint32 delay_sec = 6;
  bool has_delay_sec() const;
  void clear_delay_sec();
  static const int kDelaySecFieldNumber = 6;
  ::google::protobuf::uint32 delay_sec() const;
  void set_delay_sec(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:hw.trezor.messages.eos.EosSignTx.EosTxHeader)
 private:
  class HasBitSetters;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::uint32 expiration_;
  ::google::protobuf::uint32 ref_block_num_;
  ::google::protobuf::uint32 ref_block_prefix_;
  ::google::protobuf::uint32 max_net_usage_words_;
  ::google::protobuf::uint32 max_cpu_usage_ms_;
  ::google::protobuf::uint32 delay_sec_;
  friend struct ::TableStruct_messages_2deos_2eproto;
};
// -------------------------------------------------------------------

class EosSignTx final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:hw.trezor.messages.eos.EosSignTx) */ {
 public:
  EosSignTx();
  virtual ~EosSignTx();

  EosSignTx(const EosSignTx& from);

  inline EosSignTx& operator=(const EosSignTx& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  EosSignTx(EosSignTx&& from) noexcept
    : EosSignTx() {
    *this = ::std::move(from);
  }

  inline EosSignTx& operator=(EosSignTx&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const EosSignTx& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const EosSignTx* internal_default_instance() {
    return reinterpret_cast<const EosSignTx*>(
               &_EosSignTx_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  void Swap(EosSignTx* other);
  friend void swap(EosSignTx& a, EosSignTx& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline EosSignTx* New() const final {
    return CreateMaybeMessage<EosSignTx>(nullptr);
  }

  EosSignTx* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<EosSignTx>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const EosSignTx& from);
  void MergeFrom(const EosSignTx& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(EosSignTx* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef EosSignTx_EosTxHeader EosTxHeader;

  // accessors -------------------------------------------------------

  // repeated uint32 address_n = 1;
  int address_n_size() const;
  void clear_address_n();
  static const int kAddressNFieldNumber = 1;
  ::google::protobuf::uint32 address_n(int index) const;
  void set_address_n(int index, ::google::protobuf::uint32 value);
  void add_address_n(::google::protobuf::uint32 value);
  const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      address_n() const;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable_address_n();

  // optional bytes chain_id = 2;
  bool has_chain_id() const;
  void clear_chain_id();
  static const int kChainIdFieldNumber = 2;
  const ::std::string& chain_id() const;
  void set_chain_id(const ::std::string& value);
  #if LANG_CXX11
  void set_chain_id(::std::string&& value);
  #endif
  void set_chain_id(const char* value);
  void set_chain_id(const void* value, size_t size);
  ::std::string* mutable_chain_id();
  ::std::string* release_chain_id();
  void set_allocated_chain_id(::std::string* chain_id);

  // optional .hw.trezor.messages.eos.EosSignTx.EosTxHeader header = 3;
  bool has_header() const;
  void clear_header();
  static const int kHeaderFieldNumber = 3;
  const ::hw::trezor::messages::eos::EosSignTx_EosTxHeader& header() const;
  ::hw::trezor::messages::eos::EosSignTx_EosTxHeader* release_header();
  ::hw::trezor::messages::eos::EosSignTx_EosTxHeader* mutable_header();
  void set_allocated_header(::hw::trezor::messages::eos::EosSignTx_EosTxHeader* header);

  // optional uint32 num_actions = 4;
  bool has_num_actions() const;
  void clear_num_actions();
  static const int kNumActionsFieldNumber = 4;
  ::google::protobuf::uint32 num_actions() const;
  void set_num_actions(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:hw.trezor.messages.eos.EosSignTx)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > address_n_;
  ::google::protobuf::internal::ArenaStringPtr chain_id_;
  ::hw::trezor::messages::eos::EosSignTx_EosTxHeader* header_;
  ::google::protobuf::uint32 num_actions_;
  friend struct ::TableStruct_messages_2deos_2eproto;
};
// -------------------------------------------------------------------

class EosTxActionRequest final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:hw.trezor.messages.eos.EosTxActionRequest) */ {
 public:
  EosTxActionRequest();
  virtual ~EosTxActionRequest();

  EosTxActionRequest(const EosTxActionRequest& from);

  inline EosTxActionRequest& operator=(const EosTxActionRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  EosTxActionRequest(EosTxActionRequest&& from) noexcept
    : EosTxActionRequest() {
    *this = ::std::move(from);
  }

  inline EosTxActionRequest& operator=(EosTxActionRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const EosTxActionRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const EosTxActionRequest* internal_default_instance() {
    return reinterpret_cast<const EosTxActionRequest*>(
               &_EosTxActionRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  void Swap(EosTxActionRequest* other);
  friend void swap(EosTxActionRequest& a, EosTxActionRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline EosTxActionRequest* New() const final {
    return CreateMaybeMessage<EosTxActionRequest>(nullptr);
  }

  EosTxActionRequest* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<EosTxActionRequest>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const EosTxActionRequest& from);
  void MergeFrom(const EosTxActionRequest& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(EosTxActionRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 data_size = 1;
  bool has_data_size() const;
  void clear_data_size();
  static const int kDataSizeFieldNumber = 1;
  ::google::protobuf::uint32 data_size() const;
  void set_data_size(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:hw.trezor.messages.eos.EosTxActionRequest)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::uint32 data_size_;
  friend struct ::TableStruct_messages_2deos_2eproto;
};
// -------------------------------------------------------------------

class EosTxActionAck_EosAsset final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:hw.trezor.messages.eos.EosTxActionAck.EosAsset) */ {
 public:
  EosTxActionAck_EosAsset();
  virtual ~EosTxActionAck_EosAsset();

  EosTxActionAck_EosAsset(const EosTxActionAck_EosAsset& from);

  inline EosTxActionAck_EosAsset& operator=(const EosTxActionAck_EosAsset& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  EosTxActionAck_EosAsset(EosTxActionAck_EosAsset&& from) noexcept
    : EosTxActionAck_EosAsset() {
    *this = ::std::move(from);
  }

  inline EosTxActionAck_EosAsset& operator=(EosTxActionAck_EosAsset&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const EosTxActionAck_EosAsset& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const EosTxActionAck_EosAsset* internal_default_instance() {
    return reinterpret_cast<const EosTxActionAck_EosAsset*>(
               &_EosTxActionAck_EosAsset_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  void Swap(EosTxActionAck_EosAsset* other);
  friend void swap(EosTxActionAck_EosAsset& a, EosTxActionAck_EosAsset& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline EosTxActionAck_EosAsset* New() const final {
    return CreateMaybeMessage<EosTxActionAck_EosAsset>(nullptr);
  }

  EosTxActionAck_EosAsset* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<EosTxActionAck_EosAsset>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const EosTxActionAck_EosAsset& from);
  void MergeFrom(const EosTxActionAck_EosAsset& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(EosTxActionAck_EosAsset* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional sint64 amount = 1;
  bool has_amount() const;
  void clear_amount();
  static const int kAmountFieldNumber = 1;
  ::google::protobuf::int64 amount() const;
  void set_amount(::google::protobuf::int64 value);

  // optional uint64 symbol = 2;
  bool has_symbol() const;
  void clear_symbol();
  static const int kSymbolFieldNumber = 2;
  ::google::protobuf::uint64 symbol() const;
  void set_symbol(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:hw.trezor.messages.eos.EosTxActionAck.EosAsset)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::int64 amount_;
  ::google::protobuf::uint64 symbol_;
  friend struct ::TableStruct_messages_2deos_2eproto;
};
// -------------------------------------------------------------------

class EosTxActionAck_EosPermissionLevel final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:hw.trezor.messages.eos.EosTxActionAck.EosPermissionLevel) */ {
 public:
  EosTxActionAck_EosPermissionLevel();
  virtual ~EosTxActionAck_EosPermissionLevel();

  EosTxActionAck_EosPermissionLevel(const EosTxActionAck_EosPermissionLevel& from);

  inline EosTxActionAck_EosPermissionLevel& operator=(const EosTxActionAck_EosPermissionLevel& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  EosTxActionAck_EosPermissionLevel(EosTxActionAck_EosPermissionLevel&& from) noexcept
    : EosTxActionAck_EosPermissionLevel() {
    *this = ::std::move(from);
  }

  inline EosTxActionAck_EosPermissionLevel& operator=(EosTxActionAck_EosPermissionLevel&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const EosTxActionAck_EosPermissionLevel& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const EosTxActionAck_EosPermissionLevel* internal_default_instance() {
    return reinterpret_cast<const EosTxActionAck_EosPermissionLevel*>(
               &_EosTxActionAck_EosPermissionLevel_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  void Swap(EosTxActionAck_EosPermissionLevel* other);
  friend void swap(EosTxActionAck_EosPermissionLevel& a, EosTxActionAck_EosPermissionLevel& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline EosTxActionAck_EosPermissionLevel* New() const final {
    return CreateMaybeMessage<EosTxActionAck_EosPermissionLevel>(nullptr);
  }

  EosTxActionAck_EosPermissionLevel* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<EosTxActionAck_EosPermissionLevel>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const EosTxActionAck_EosPermissionLevel& from);
  void MergeFrom(const EosTxActionAck_EosPermissionLevel& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(EosTxActionAck_EosPermissionLevel* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint64 actor = 1;
  bool has_actor() const;
  void clear_actor();
  static const int kActorFieldNumber = 1;
  ::google::protobuf::uint64 actor() const;
  void set_actor(::google::protobuf::uint64 value);

  // optional uint64 permission = 2;
  bool has_permission() const;
  void clear_permission();
  static const int kPermissionFieldNumber = 2;
  ::google::protobuf::uint64 permission() const;
  void set_permission(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:hw.trezor.messages.eos.EosTxActionAck.EosPermissionLevel)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::uint64 actor_;
  ::google::protobuf::uint64 permission_;
  friend struct ::TableStruct_messages_2deos_2eproto;
};
// -------------------------------------------------------------------

class EosTxActionAck_EosAuthorizationKey final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:hw.trezor.messages.eos.EosTxActionAck.EosAuthorizationKey) */ {
 public:
  EosTxActionAck_EosAuthorizationKey();
  virtual ~EosTxActionAck_EosAuthorizationKey();

  EosTxActionAck_EosAuthorizationKey(const EosTxActionAck_EosAuthorizationKey& from);

  inline EosTxActionAck_EosAuthorizationKey& operator=(const EosTxActionAck_EosAuthorizationKey& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  EosTxActionAck_EosAuthorizationKey(EosTxActionAck_EosAuthorizationKey&& from) noexcept
    : EosTxActionAck_EosAuthorizationKey() {
    *this = ::std::move(from);
  }

  inline EosTxActionAck_EosAuthorizationKey& operator=(EosTxActionAck_EosAuthorizationKey&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const EosTxActionAck_EosAuthorizationKey& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const EosTxActionAck_EosAuthorizationKey* internal_default_instance() {
    return reinterpret_cast<const EosTxActionAck_EosAuthorizationKey*>(
               &_EosTxActionAck_EosAuthorizationKey_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  void Swap(EosTxActionAck_EosAuthorizationKey* other);
  friend void swap(EosTxActionAck_EosAuthorizationKey& a, EosTxActionAck_EosAuthorizationKey& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline EosTxActionAck_EosAuthorizationKey* New() const final {
    return CreateMaybeMessage<EosTxActionAck_EosAuthorizationKey>(nullptr);
  }

  EosTxActionAck_EosAuthorizationKey* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<EosTxActionAck_EosAuthorizationKey>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const EosTxActionAck_EosAuthorizationKey& from);
  void MergeFrom(const EosTxActionAck_EosAuthorizationKey& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(EosTxActionAck_EosAuthorizationKey* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated uint32 address_n = 3;
  int address_n_size() const;
  void clear_address_n();
  static const int kAddressNFieldNumber = 3;
  ::google::protobuf::uint32 address_n(int index) const;
  void set_address_n(int index, ::google::protobuf::uint32 value);
  void add_address_n(::google::protobuf::uint32 value);
  const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      address_n() const;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable_address_n();

  // optional bytes key = 2;
  bool has_key() const;
  void clear_key();
  static const int kKeyFieldNumber = 2;
  const ::std::string& key() const;
  void set_key(const ::std::string& value);
  #if LANG_CXX11
  void set_key(::std::string&& value);
  #endif
  void set_key(const char* value);
  void set_key(const void* value, size_t size);
  ::std::string* mutable_key();
  ::std::string* release_key();
  void set_allocated_key(::std::string* key);

  // optional uint32 type = 1;
  bool has_type() const;
  void clear_type();
  static const int kTypeFieldNumber = 1;
  ::google::protobuf::uint32 type() const;
  void set_type(::google::protobuf::uint32 value);

  // optional uint32 weight = 4;
  bool has_weight() const;
  void clear_weight();
  static const int kWeightFieldNumber = 4;
  ::google::protobuf::uint32 weight() const;
  void set_weight(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:hw.trezor.messages.eos.EosTxActionAck.EosAuthorizationKey)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > address_n_;
  ::google::protobuf::internal::ArenaStringPtr key_;
  ::google::protobuf::uint32 type_;
  ::google::protobuf::uint32 weight_;
  friend struct ::TableStruct_messages_2deos_2eproto;
};
// -------------------------------------------------------------------

class EosTxActionAck_EosAuthorizationAccount final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:hw.trezor.messages.eos.EosTxActionAck.EosAuthorizationAccount) */ {
 public:
  EosTxActionAck_EosAuthorizationAccount();
  virtual ~EosTxActionAck_EosAuthorizationAccount();

  EosTxActionAck_EosAuthorizationAccount(const EosTxActionAck_EosAuthorizationAccount& from);

  inline EosTxActionAck_EosAuthorizationAccount& operator=(const EosTxActionAck_EosAuthorizationAccount& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  EosTxActionAck_EosAuthorizationAccount(EosTxActionAck_EosAuthorizationAccount&& from) noexcept
    : EosTxActionAck_EosAuthorizationAccount() {
    *this = ::std::move(from);
  }

  inline EosTxActionAck_EosAuthorizationAccount& operator=(EosTxActionAck_EosAuthorizationAccount&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const EosTxActionAck_EosAuthorizationAccount& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const EosTxActionAck_EosAuthorizationAccount* internal_default_instance() {
    return reinterpret_cast<const EosTxActionAck_EosAuthorizationAccount*>(
               &_EosTxActionAck_EosAuthorizationAccount_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  void Swap(EosTxActionAck_EosAuthorizationAccount* other);
  friend void swap(EosTxActionAck_EosAuthorizationAccount& a, EosTxActionAck_EosAuthorizationAccount& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline EosTxActionAck_EosAuthorizationAccount* New() const final {
    return CreateMaybeMessage<EosTxActionAck_EosAuthorizationAccount>(nullptr);
  }

  EosTxActionAck_EosAuthorizationAccount* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<EosTxActionAck_EosAuthorizationAccount>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const EosTxActionAck_EosAuthorizationAccount& from);
  void MergeFrom(const EosTxActionAck_EosAuthorizationAccount& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(EosTxActionAck_EosAuthorizationAccount* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .hw.trezor.messages.eos.EosTxActionAck.EosPermissionLevel account = 1;
  bool has_account() const;
  void clear_account();
  static const int kAccountFieldNumber = 1;
  const ::hw::trezor::messages::eos::EosTxActionAck_EosPermissionLevel& account() const;
  ::hw::trezor::messages::eos::EosTxActionAck_EosPermissionLevel* release_account();
  ::hw::trezor::messages::eos::EosTxActionAck_EosPermissionLevel* mutable_account();
  void set_allocated_account(::hw::trezor::messages::eos::EosTxActionAck_EosPermissionLevel* account);

  // optional uint32 weight = 2;
  bool has_weight() const;
  void clear_weight();
  static const int kWeightFieldNumber = 2;
  ::google::protobuf::uint32 weight() const;
  void set_weight(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:hw.trezor.messages.eos.EosTxActionAck.EosAuthorizationAccount)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::hw::trezor::messages::eos::EosTxActionAck_EosPermissionLevel* account_;
  ::google::protobuf::uint32 weight_;
  friend struct ::TableStruct_messages_2deos_2eproto;
};
// -------------------------------------------------------------------

class EosTxActionAck_EosAuthorizationWait final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:hw.trezor.messages.eos.EosTxActionAck.EosAuthorizationWait) */ {
 public:
  EosTxActionAck_EosAuthorizationWait();
  virtual ~EosTxActionAck_EosAuthorizationWait();

  EosTxActionAck_EosAuthorizationWait(const EosTxActionAck_EosAuthorizationWait& from);

  inline EosTxActionAck_EosAuthorizationWait& operator=(const EosTxActionAck_EosAuthorizationWait& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  EosTxActionAck_EosAuthorizationWait(EosTxActionAck_EosAuthorizationWait&& from) noexcept
    : EosTxActionAck_EosAuthorizationWait() {
    *this = ::std::move(from);
  }

  inline EosTxActionAck_EosAuthorizationWait& operator=(EosTxActionAck_EosAuthorizationWait&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const EosTxActionAck_EosAuthorizationWait& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const EosTxActionAck_EosAuthorizationWait* internal_default_instance() {
    return reinterpret_cast<const EosTxActionAck_EosAuthorizationWait*>(
               &_EosTxActionAck_EosAuthorizationWait_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  void Swap(EosTxActionAck_EosAuthorizationWait* other);
  friend void swap(EosTxActionAck_EosAuthorizationWait& a, EosTxActionAck_EosAuthorizationWait& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline EosTxActionAck_EosAuthorizationWait* New() const final {
    return CreateMaybeMessage<EosTxActionAck_EosAuthorizationWait>(nullptr);
  }

  EosTxActionAck_EosAuthorizationWait* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<EosTxActionAck_EosAuthorizationWait>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const EosTxActionAck_EosAuthorizationWait& from);
  void MergeFrom(const EosTxActionAck_EosAuthorizationWait& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(EosTxActionAck_EosAuthorizationWait* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 wait_sec = 1;
  bool has_wait_sec() const;
  void clear_wait_sec();
  static const int kWaitSecFieldNumber = 1;
  ::google::protobuf::uint32 wait_sec() const;
  void set_wait_sec(::google::protobuf::uint32 value);

  // optional uint32 weight = 2;
  bool has_weight() const;
  void clear_weight();
  static const int kWeightFieldNumber = 2;
  ::google::protobuf::uint32 weight() const;
  void set_weight(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:hw.trezor.messages.eos.EosTxActionAck.EosAuthorizationWait)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::uint32 wait_sec_;
  ::google::protobuf::uint32 weight_;
  friend struct ::TableStruct_messages_2deos_2eproto;
};
// -------------------------------------------------------------------

class EosTxActionAck_EosAuthorization final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:hw.trezor.messages.eos.EosTxActionAck.EosAuthorization) */ {
 public:
  EosTxActionAck_EosAuthorization();
  virtual ~EosTxActionAck_EosAuthorization();

  EosTxActionAck_EosAuthorization(const EosTxActionAck_EosAuthorization& from);

  inline EosTxActionAck_EosAuthorization& operator=(const EosTxActionAck_EosAuthorization& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  EosTxActionAck_EosAuthorization(EosTxActionAck_EosAuthorization&& from) noexcept
    : EosTxActionAck_EosAuthorization() {
    *this = ::std::move(from);
  }

  inline EosTxActionAck_EosAuthorization& operator=(EosTxActionAck_EosAuthorization&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const EosTxActionAck_EosAuthorization& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const EosTxActionAck_EosAuthorization* internal_default_instance() {
    return reinterpret_cast<const EosTxActionAck_EosAuthorization*>(
               &_EosTxActionAck_EosAuthorization_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  void Swap(EosTxActionAck_EosAuthorization* other);
  friend void swap(EosTxActionAck_EosAuthorization& a, EosTxActionAck_EosAuthorization& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline EosTxActionAck_EosAuthorization* New() const final {
    return CreateMaybeMessage<EosTxActionAck_EosAuthorization>(nullptr);
  }

  EosTxActionAck_EosAuthorization* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<EosTxActionAck_EosAuthorization>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const EosTxActionAck_EosAuthorization& from);
  void MergeFrom(const EosTxActionAck_EosAuthorization& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(EosTxActionAck_EosAuthorization* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .hw.trezor.messages.eos.EosTxActionAck.EosAuthorizationKey keys = 2;
  int keys_size() const;
  void clear_keys();
  static const int kKeysFieldNumber = 2;
  ::hw::trezor::messages::eos::EosTxActionAck_EosAuthorizationKey* mutable_keys(int index);
  ::google::protobuf::RepeatedPtrField< ::hw::trezor::messages::eos::EosTxActionAck_EosAuthorizationKey >*
      mutable_keys();
  const ::hw::trezor::messages::eos::EosTxActionAck_EosAuthorizationKey& keys(int index) const;
  ::hw::trezor::messages::eos::EosTxActionAck_EosAuthorizationKey* add_keys();
  const ::google::protobuf::RepeatedPtrField< ::hw::trezor::messages::eos::EosTxActionAck_EosAuthorizationKey >&
      keys() const;

  // repeated .hw.trezor.messages.eos.EosTxActionAck.EosAuthorizationAccount accounts = 3;
  int accounts_size() const;
  void clear_accounts();
  static const int kAccountsFieldNumber = 3;
  ::hw::trezor::messages::eos::EosTxActionAck_EosAuthorizationAccount* mutable_accounts(int index);
  ::google::protobuf::RepeatedPtrField< ::hw::trezor::messages::eos::EosTxActionAck_EosAuthorizationAccount >*
      mutable_accounts();
  const ::hw::trezor::messages::eos::EosTxActionAck_EosAuthorizationAccount& accounts(int index) const;
  ::hw::trezor::messages::eos::EosTxActionAck_EosAuthorizationAccount* add_accounts();
  const ::google::protobuf::RepeatedPtrField< ::hw::trezor::messages::eos::EosTxActionAck_EosAuthorizationAccount >&
      accounts() const;

  // repeated .hw.trezor.messages.eos.EosTxActionAck.EosAuthorizationWait waits = 4;
  int waits_size() const;
  void clear_waits();
  static const int kWaitsFieldNumber = 4;
  ::hw::trezor::messages::eos::EosTxActionAck_EosAuthorizationWait* mutable_waits(int index);
  ::google::protobuf::RepeatedPtrField< ::hw::trezor::messages::eos::EosTxActionAck_EosAuthorizationWait >*
      mutable_waits();
  const ::hw::trezor::messages::eos::EosTxActionAck_EosAuthorizationWait& waits(int index) const;
  ::hw::trezor::messages::eos::EosTxActionAck_EosAuthorizationWait* add_waits();
  const ::google::protobuf::RepeatedPtrField< ::hw::trezor::messages::eos::EosTxActionAck_EosAuthorizationWait >&
      waits() const;

  // optional uint32 threshold = 1;
  bool has_threshold() const;
  void clear_threshold();
  static const int kThresholdFieldNumber = 1;
  ::google::protobuf::uint32 threshold() const;
  void set_threshold(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:hw.trezor.messages.eos.EosTxActionAck.EosAuthorization)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::hw::trezor::messages::eos::EosTxActionAck_EosAuthorizationKey > keys_;
  ::google::protobuf::RepeatedPtrField< ::hw::trezor::messages::eos::EosTxActionAck_EosAuthorizationAccount > accounts_;
  ::google::protobuf::RepeatedPtrField< ::hw::trezor::messages::eos::EosTxActionAck_EosAuthorizationWait > waits_;
  ::google::protobuf::uint32 threshold_;
  friend struct ::TableStruct_messages_2deos_2eproto;
};
// -------------------------------------------------------------------

class EosTxActionAck_EosActionCommon final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:hw.trezor.messages.eos.EosTxActionAck.EosActionCommon) */ {
 public:
  EosTxActionAck_EosActionCommon();
  virtual ~EosTxActionAck_EosActionCommon();

  EosTxActionAck_EosActionCommon(const EosTxActionAck_EosActionCommon& from);

  inline EosTxActionAck_EosActionCommon& operator=(const EosTxActionAck_EosActionCommon& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  EosTxActionAck_EosActionCommon(EosTxActionAck_EosActionCommon&& from) noexcept
    : EosTxActionAck_EosActionCommon() {
    *this = ::std::move(from);
  }

  inline EosTxActionAck_EosActionCommon& operator=(EosTxActionAck_EosActionCommon&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const EosTxActionAck_EosActionCommon& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const EosTxActionAck_EosActionCommon* internal_default_instance() {
    return reinterpret_cast<const EosTxActionAck_EosActionCommon*>(
               &_EosTxActionAck_EosActionCommon_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  void Swap(EosTxActionAck_EosActionCommon* other);
  friend void swap(EosTxActionAck_EosActionCommon& a, EosTxActionAck_EosActionCommon& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline EosTxActionAck_EosActionCommon* New() const final {
    return CreateMaybeMessage<EosTxActionAck_EosActionCommon>(nullptr);
  }

  EosTxActionAck_EosActionCommon* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<EosTxActionAck_EosActionCommon>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const EosTxActionAck_EosActionCommon& from);
  void MergeFrom(const EosTxActionAck_EosActionCommon& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(EosTxActionAck_EosActionCommon* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .hw.trezor.messages.eos.EosTxActionAck.EosPermissionLevel authorization = 3;
  int authorization_size() const;
  void clear_authorization();
  static const int kAuthorizationFieldNumber = 3;
  ::hw::trezor::messages::eos::EosTxActionAck_EosPermissionLevel* mutable_authorization(int index);
  ::google::protobuf::RepeatedPtrField< ::hw::trezor::messages::eos::EosTxActionAck_EosPermissionLevel >*
      mutable_authorization();
  const ::hw::trezor::messages::eos::EosTxActionAck_EosPermissionLevel& authorization(int index) const;
  ::hw::trezor::messages::eos::EosTxActionAck_EosPermissionLevel* add_authorization();
  const ::google::protobuf::RepeatedPtrField< ::hw::trezor::messages::eos::EosTxActionAck_EosPermissionLevel >&
      authorization() const;

  // optional uint64 account = 1;
  bool has_account() const;
  void clear_account();
  static const int kAccountFieldNumber = 1;
  ::google::protobuf::uint64 account() const;
  void set_account(::google::protobuf::uint64 value);

  // optional uint64 name = 2;
  bool has_name() const;
  void clear_name();
  static const int kNameFieldNumber = 2;
  ::google::protobuf::uint64 name() const;
  void set_name(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:hw.trezor.messages.eos.EosTxActionAck.EosActionCommon)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::hw::trezor::messages::eos::EosTxActionAck_EosPermissionLevel > authorization_;
  ::google::protobuf::uint64 account_;
  ::google::protobuf::uint64 name_;
  friend struct ::TableStruct_messages_2deos_2eproto;
};
// -------------------------------------------------------------------

class EosTxActionAck_EosActionTransfer final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:hw.trezor.messages.eos.EosTxActionAck.EosActionTransfer) */ {
 public:
  EosTxActionAck_EosActionTransfer();
  virtual ~EosTxActionAck_EosActionTransfer();

  EosTxActionAck_EosActionTransfer(const EosTxActionAck_EosActionTransfer& from);

  inline EosTxActionAck_EosActionTransfer& operator=(const EosTxActionAck_EosActionTransfer& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  EosTxActionAck_EosActionTransfer(EosTxActionAck_EosActionTransfer&& from) noexcept
    : EosTxActionAck_EosActionTransfer() {
    *this = ::std::move(from);
  }

  inline EosTxActionAck_EosActionTransfer& operator=(EosTxActionAck_EosActionTransfer&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const EosTxActionAck_EosActionTransfer& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const EosTxActionAck_EosActionTransfer* internal_default_instance() {
    return reinterpret_cast<const EosTxActionAck_EosActionTransfer*>(
               &_EosTxActionAck_EosActionTransfer_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  void Swap(EosTxActionAck_EosActionTransfer* other);
  friend void swap(EosTxActionAck_EosActionTransfer& a, EosTxActionAck_EosActionTransfer& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline EosTxActionAck_EosActionTransfer* New() const final {
    return CreateMaybeMessage<EosTxActionAck_EosActionTransfer>(nullptr);
  }

  EosTxActionAck_EosActionTransfer* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<EosTxActionAck_EosActionTransfer>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const EosTxActionAck_EosActionTransfer& from);
  void MergeFrom(const EosTxActionAck_EosActionTransfer& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(EosTxActionAck_EosActionTransfer* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string memo = 4;
  bool has_memo() const;
  void clear_memo();
  static const int kMemoFieldNumber = 4;
  const ::std::string& memo() const;
  void set_memo(const ::std::string& value);
  #if LANG_CXX11
  void set_memo(::std::string&& value);
  #endif
  void set_memo(const char* value);
  void set_memo(const char* value, size_t size);
  ::std::string* mutable_memo();
  ::std::string* release_memo();
  void set_allocated_memo(::std::string* memo);

  // optional .hw.trezor.messages.eos.EosTxActionAck.EosAsset quantity = 3;
  bool has_quantity() const;
  void clear_quantity();
  static const int kQuantityFieldNumber = 3;
  const ::hw::trezor::messages::eos::EosTxActionAck_EosAsset& quantity() const;
  ::hw::trezor::messages::eos::EosTxActionAck_EosAsset* release_quantity();
  ::hw::trezor::messages::eos::EosTxActionAck_EosAsset* mutable_quantity();
  void set_allocated_quantity(::hw::trezor::messages::eos::EosTxActionAck_EosAsset* quantity);

  // optional uint64 sender = 1;
  bool has_sender() const;
  void clear_sender();
  static const int kSenderFieldNumber = 1;
  ::google::protobuf::uint64 sender() const;
  void set_sender(::google::protobuf::uint64 value);

  // optional uint64 receiver = 2;
  bool has_receiver() const;
  void clear_receiver();
  static const int kReceiverFieldNumber = 2;
  ::google::protobuf::uint64 receiver() const;
  void set_receiver(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:hw.trezor.messages.eos.EosTxActionAck.EosActionTransfer)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr memo_;
  ::hw::trezor::messages::eos::EosTxActionAck_EosAsset* quantity_;
  ::google::protobuf::uint64 sender_;
  ::google::protobuf::uint64 receiver_;
  friend struct ::TableStruct_messages_2deos_2eproto;
};
// -------------------------------------------------------------------

class EosTxActionAck_EosActionDelegate final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:hw.trezor.messages.eos.EosTxActionAck.EosActionDelegate) */ {
 public:
  EosTxActionAck_EosActionDelegate();
  virtual ~EosTxActionAck_EosActionDelegate();

  EosTxActionAck_EosActionDelegate(const EosTxActionAck_EosActionDelegate& from);

  inline EosTxActionAck_EosActionDelegate& operator=(const EosTxActionAck_EosActionDelegate& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  EosTxActionAck_EosActionDelegate(EosTxActionAck_EosActionDelegate&& from) noexcept
    : EosTxActionAck_EosActionDelegate() {
    *this = ::std::move(from);
  }

  inline EosTxActionAck_EosActionDelegate& operator=(EosTxActionAck_EosActionDelegate&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const EosTxActionAck_EosActionDelegate& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const EosTxActionAck_EosActionDelegate* internal_default_instance() {
    return reinterpret_cast<const EosTxActionAck_EosActionDelegate*>(
               &_EosTxActionAck_EosActionDelegate_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  void Swap(EosTxActionAck_EosActionDelegate* other);
  friend void swap(EosTxActionAck_EosActionDelegate& a, EosTxActionAck_EosActionDelegate& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline EosTxActionAck_EosActionDelegate* New() const final {
    return CreateMaybeMessage<EosTxActionAck_EosActionDelegate>(nullptr);
  }

  EosTxActionAck_EosActionDelegate* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<EosTxActionAck_EosActionDelegate>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const EosTxActionAck_EosActionDelegate& from);
  void MergeFrom(const EosTxActionAck_EosActionDelegate& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(EosTxActionAck_EosActionDelegate* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .hw.trezor.messages.eos.EosTxActionAck.EosAsset net_quantity = 3;
  bool has_net_quantity() const;
  void clear_net_quantity();
  static const int kNetQuantityFieldNumber = 3;
  const ::hw::trezor::messages::eos::EosTxActionAck_EosAsset& net_quantity() const;
  ::hw::trezor::messages::eos::EosTxActionAck_EosAsset* release_net_quantity();
  ::hw::trezor::messages::eos::EosTxActionAck_EosAsset* mutable_net_quantity();
  void set_allocated_net_quantity(::hw::trezor::messages::eos::EosTxActionAck_EosAsset* net_quantity);

  // optional .hw.trezor.messages.eos.EosTxActionAck.EosAsset cpu_quantity = 4;
  bool has_cpu_quantity() const;
  void clear_cpu_quantity();
  static const int kCpuQuantityFieldNumber = 4;
  const ::hw::trezor::messages::eos::EosTxActionAck_EosAsset& cpu_quantity() const;
  ::hw::trezor::messages::eos::EosTxActionAck_EosAsset* release_cpu_quantity();
  ::hw::trezor::messages::eos::EosTxActionAck_EosAsset* mutable_cpu_quantity();
  void set_allocated_cpu_quantity(::hw::trezor::messages::eos::EosTxActionAck_EosAsset* cpu_quantity);

  // optional uint64 sender = 1;
  bool has_sender() const;
  void clear_sender();
  static const int kSenderFieldNumber = 1;
  ::google::protobuf::uint64 sender() const;
  void set_sender(::google::protobuf::uint64 value);

  // optional uint64 receiver = 2;
  bool has_receiver() const;
  void clear_receiver();
  static const int kReceiverFieldNumber = 2;
  ::google::protobuf::uint64 receiver() const;
  void set_receiver(::google::protobuf::uint64 value);

  // optional bool transfer = 5;
  bool has_transfer() const;
  void clear_transfer();
  static const int kTransferFieldNumber = 5;
  bool transfer() const;
  void set_transfer(bool value);

  // @@protoc_insertion_point(class_scope:hw.trezor.messages.eos.EosTxActionAck.EosActionDelegate)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::hw::trezor::messages::eos::EosTxActionAck_EosAsset* net_quantity_;
  ::hw::trezor::messages::eos::EosTxActionAck_EosAsset* cpu_quantity_;
  ::google::protobuf::uint64 sender_;
  ::google::protobuf::uint64 receiver_;
  bool transfer_;
  friend struct ::TableStruct_messages_2deos_2eproto;
};
// -------------------------------------------------------------------

class EosTxActionAck_EosActionUndelegate final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:hw.trezor.messages.eos.EosTxActionAck.EosActionUndelegate) */ {
 public:
  EosTxActionAck_EosActionUndelegate();
  virtual ~EosTxActionAck_EosActionUndelegate();

  EosTxActionAck_EosActionUndelegate(const EosTxActionAck_EosActionUndelegate& from);

  inline EosTxActionAck_EosActionUndelegate& operator=(const EosTxActionAck_EosActionUndelegate& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  EosTxActionAck_EosActionUndelegate(EosTxActionAck_EosActionUndelegate&& from) noexcept
    : EosTxActionAck_EosActionUndelegate() {
    *this = ::std::move(from);
  }

  inline EosTxActionAck_EosActionUndelegate& operator=(EosTxActionAck_EosActionUndelegate&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const EosTxActionAck_EosActionUndelegate& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const EosTxActionAck_EosActionUndelegate* internal_default_instance() {
    return reinterpret_cast<const EosTxActionAck_EosActionUndelegate*>(
               &_EosTxActionAck_EosActionUndelegate_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  void Swap(EosTxActionAck_EosActionUndelegate* other);
  friend void swap(EosTxActionAck_EosActionUndelegate& a, EosTxActionAck_EosActionUndelegate& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline EosTxActionAck_EosActionUndelegate* New() const final {
    return CreateMaybeMessage<EosTxActionAck_EosActionUndelegate>(nullptr);
  }

  EosTxActionAck_EosActionUndelegate* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<EosTxActionAck_EosActionUndelegate>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const EosTxActionAck_EosActionUndelegate& from);
  void MergeFrom(const EosTxActionAck_EosActionUndelegate& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(EosTxActionAck_EosActionUndelegate* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .hw.trezor.messages.eos.EosTxActionAck.EosAsset net_quantity = 3;
  bool has_net_quantity() const;
  void clear_net_quantity();
  static const int kNetQuantityFieldNumber = 3;
  const ::hw::trezor::messages::eos::EosTxActionAck_EosAsset& net_quantity() const;
  ::hw::trezor::messages::eos::EosTxActionAck_EosAsset* release_net_quantity();
  ::hw::trezor::messages::eos::EosTxActionAck_EosAsset* mutable_net_quantity();
  void set_allocated_net_quantity(::hw::trezor::messages::eos::EosTxActionAck_EosAsset* net_quantity);

  // optional .hw.trezor.messages.eos.EosTxActionAck.EosAsset cpu_quantity = 4;
  bool has_cpu_quantity() const;
  void clear_cpu_quantity();
  static const int kCpuQuantityFieldNumber = 4;
  const ::hw::trezor::messages::eos::EosTxActionAck_EosAsset& cpu_quantity() const;
  ::hw::trezor::messages::eos::EosTxActionAck_EosAsset* release_cpu_quantity();
  ::hw::trezor::messages::eos::EosTxActionAck_EosAsset* mutable_cpu_quantity();
  void set_allocated_cpu_quantity(::hw::trezor::messages::eos::EosTxActionAck_EosAsset* cpu_quantity);

  // optional uint64 sender = 1;
  bool has_sender() const;
  void clear_sender();
  static const int kSenderFieldNumber = 1;
  ::google::protobuf::uint64 sender() const;
  void set_sender(::google::protobuf::uint64 value);

  // optional uint64 receiver = 2;
  bool has_receiver() const;
  void clear_receiver();
  static const int kReceiverFieldNumber = 2;
  ::google::protobuf::uint64 receiver() const;
  void set_receiver(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:hw.trezor.messages.eos.EosTxActionAck.EosActionUndelegate)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::hw::trezor::messages::eos::EosTxActionAck_EosAsset* net_quantity_;
  ::hw::trezor::messages::eos::EosTxActionAck_EosAsset* cpu_quantity_;
  ::google::protobuf::uint64 sender_;
  ::google::protobuf::uint64 receiver_;
  friend struct ::TableStruct_messages_2deos_2eproto;
};
// -------------------------------------------------------------------

class EosTxActionAck_EosActionRefund final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:hw.trezor.messages.eos.EosTxActionAck.EosActionRefund) */ {
 public:
  EosTxActionAck_EosActionRefund();
  virtual ~EosTxActionAck_EosActionRefund();

  EosTxActionAck_EosActionRefund(const EosTxActionAck_EosActionRefund& from);

  inline EosTxActionAck_EosActionRefund& operator=(const EosTxActionAck_EosActionRefund& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  EosTxActionAck_EosActionRefund(EosTxActionAck_EosActionRefund&& from) noexcept
    : EosTxActionAck_EosActionRefund() {
    *this = ::std::move(from);
  }

  inline EosTxActionAck_EosActionRefund& operator=(EosTxActionAck_EosActionRefund&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const EosTxActionAck_EosActionRefund& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const EosTxActionAck_EosActionRefund* internal_default_instance() {
    return reinterpret_cast<const EosTxActionAck_EosActionRefund*>(
               &_EosTxActionAck_EosActionRefund_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  void Swap(EosTxActionAck_EosActionRefund* other);
  friend void swap(EosTxActionAck_EosActionRefund& a, EosTxActionAck_EosActionRefund& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline EosTxActionAck_EosActionRefund* New() const final {
    return CreateMaybeMessage<EosTxActionAck_EosActionRefund>(nullptr);
  }

  EosTxActionAck_EosActionRefund* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<EosTxActionAck_EosActionRefund>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const EosTxActionAck_EosActionRefund& from);
  void MergeFrom(const EosTxActionAck_EosActionRefund& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(EosTxActionAck_EosActionRefund* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint64 owner = 1;
  bool has_owner() const;
  void clear_owner();
  static const int kOwnerFieldNumber = 1;
  ::google::protobuf::uint64 owner() const;
  void set_owner(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:hw.trezor.messages.eos.EosTxActionAck.EosActionRefund)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::uint64 owner_;
  friend struct ::TableStruct_messages_2deos_2eproto;
};
// -------------------------------------------------------------------

class EosTxActionAck_EosActionBuyRam final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:hw.trezor.messages.eos.EosTxActionAck.EosActionBuyRam) */ {
 public:
  EosTxActionAck_EosActionBuyRam();
  virtual ~EosTxActionAck_EosActionBuyRam();

  EosTxActionAck_EosActionBuyRam(const EosTxActionAck_EosActionBuyRam& from);

  inline EosTxActionAck_EosActionBuyRam& operator=(const EosTxActionAck_EosActionBuyRam& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  EosTxActionAck_EosActionBuyRam(EosTxActionAck_EosActionBuyRam&& from) noexcept
    : EosTxActionAck_EosActionBuyRam() {
    *this = ::std::move(from);
  }

  inline EosTxActionAck_EosActionBuyRam& operator=(EosTxActionAck_EosActionBuyRam&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const EosTxActionAck_EosActionBuyRam& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const EosTxActionAck_EosActionBuyRam* internal_default_instance() {
    return reinterpret_cast<const EosTxActionAck_EosActionBuyRam*>(
               &_EosTxActionAck_EosActionBuyRam_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    16;

  void Swap(EosTxActionAck_EosActionBuyRam* other);
  friend void swap(EosTxActionAck_EosActionBuyRam& a, EosTxActionAck_EosActionBuyRam& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline EosTxActionAck_EosActionBuyRam* New() const final {
    return CreateMaybeMessage<EosTxActionAck_EosActionBuyRam>(nullptr);
  }

  EosTxActionAck_EosActionBuyRam* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<EosTxActionAck_EosActionBuyRam>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const EosTxActionAck_EosActionBuyRam& from);
  void MergeFrom(const EosTxActionAck_EosActionBuyRam& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(EosTxActionAck_EosActionBuyRam* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .hw.trezor.messages.eos.EosTxActionAck.EosAsset quantity = 3;
  bool has_quantity() const;
  void clear_quantity();
  static const int kQuantityFieldNumber = 3;
  const ::hw::trezor::messages::eos::EosTxActionAck_EosAsset& quantity() const;
  ::hw::trezor::messages::eos::EosTxActionAck_EosAsset* release_quantity();
  ::hw::trezor::messages::eos::EosTxActionAck_EosAsset* mutable_quantity();
  void set_allocated_quantity(::hw::trezor::messages::eos::EosTxActionAck_EosAsset* quantity);

  // optional uint64 payer = 1;
  bool has_payer() const;
  void clear_payer();
  static const int kPayerFieldNumber = 1;
  ::google::protobuf::uint64 payer() const;
  void set_payer(::google::protobuf::uint64 value);

  // optional uint64 receiver = 2;
  bool has_receiver() const;
  void clear_receiver();
  static const int kReceiverFieldNumber = 2;
  ::google::protobuf::uint64 receiver() const;
  void set_receiver(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:hw.trezor.messages.eos.EosTxActionAck.EosActionBuyRam)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::hw::trezor::messages::eos::EosTxActionAck_EosAsset* quantity_;
  ::google::protobuf::uint64 payer_;
  ::google::protobuf::uint64 receiver_;
  friend struct ::TableStruct_messages_2deos_2eproto;
};
// -------------------------------------------------------------------

class EosTxActionAck_EosActionBuyRamBytes final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:hw.trezor.messages.eos.EosTxActionAck.EosActionBuyRamBytes) */ {
 public:
  EosTxActionAck_EosActionBuyRamBytes();
  virtual ~EosTxActionAck_EosActionBuyRamBytes();

  EosTxActionAck_EosActionBuyRamBytes(const EosTxActionAck_EosActionBuyRamBytes& from);

  inline EosTxActionAck_EosActionBuyRamBytes& operator=(const EosTxActionAck_EosActionBuyRamBytes& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  EosTxActionAck_EosActionBuyRamBytes(EosTxActionAck_EosActionBuyRamBytes&& from) noexcept
    : EosTxActionAck_EosActionBuyRamBytes() {
    *this = ::std::move(from);
  }

  inline EosTxActionAck_EosActionBuyRamBytes& operator=(EosTxActionAck_EosActionBuyRamBytes&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const EosTxActionAck_EosActionBuyRamBytes& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const EosTxActionAck_EosActionBuyRamBytes* internal_default_instance() {
    return reinterpret_cast<const EosTxActionAck_EosActionBuyRamBytes*>(
               &_EosTxActionAck_EosActionBuyRamBytes_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    17;

  void Swap(EosTxActionAck_EosActionBuyRamBytes* other);
  friend void swap(EosTxActionAck_EosActionBuyRamBytes& a, EosTxActionAck_EosActionBuyRamBytes& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline EosTxActionAck_EosActionBuyRamBytes* New() const final {
    return CreateMaybeMessage<EosTxActionAck_EosActionBuyRamBytes>(nullptr);
  }

  EosTxActionAck_EosActionBuyRamBytes* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<EosTxActionAck_EosActionBuyRamBytes>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const EosTxActionAck_EosActionBuyRamBytes& from);
  void MergeFrom(const EosTxActionAck_EosActionBuyRamBytes& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(EosTxActionAck_EosActionBuyRamBytes* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint64 payer = 1;
  bool has_payer() const;
  void clear_payer();
  static const int kPayerFieldNumber = 1;
  ::google::protobuf::uint64 payer() const;
  void set_payer(::google::protobuf::uint64 value);

  // optional uint64 receiver = 2;
  bool has_receiver() const;
  void clear_receiver();
  static const int kReceiverFieldNumber = 2;
  ::google::protobuf::uint64 receiver() const;
  void set_receiver(::google::protobuf::uint64 value);

  // optional uint32 bytes = 3;
  bool has_bytes() const;
  void clear_bytes();
  static const int kBytesFieldNumber = 3;
  ::google::protobuf::uint32 bytes() const;
  void set_bytes(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:hw.trezor.messages.eos.EosTxActionAck.EosActionBuyRamBytes)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::uint64 payer_;
  ::google::protobuf::uint64 receiver_;
  ::google::protobuf::uint32 bytes_;
  friend struct ::TableStruct_messages_2deos_2eproto;
};
// -------------------------------------------------------------------

class EosTxActionAck_EosActionSellRam final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:hw.trezor.messages.eos.EosTxActionAck.EosActionSellRam) */ {
 public:
  EosTxActionAck_EosActionSellRam();
  virtual ~EosTxActionAck_EosActionSellRam();

  EosTxActionAck_EosActionSellRam(const EosTxActionAck_EosActionSellRam& from);

  inline EosTxActionAck_EosActionSellRam& operator=(const EosTxActionAck_EosActionSellRam& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  EosTxActionAck_EosActionSellRam(EosTxActionAck_EosActionSellRam&& from) noexcept
    : EosTxActionAck_EosActionSellRam() {
    *this = ::std::move(from);
  }

  inline EosTxActionAck_EosActionSellRam& operator=(EosTxActionAck_EosActionSellRam&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const EosTxActionAck_EosActionSellRam& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const EosTxActionAck_EosActionSellRam* internal_default_instance() {
    return reinterpret_cast<const EosTxActionAck_EosActionSellRam*>(
               &_EosTxActionAck_EosActionSellRam_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    18;

  void Swap(EosTxActionAck_EosActionSellRam* other);
  friend void swap(EosTxActionAck_EosActionSellRam& a, EosTxActionAck_EosActionSellRam& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline EosTxActionAck_EosActionSellRam* New() const final {
    return CreateMaybeMessage<EosTxActionAck_EosActionSellRam>(nullptr);
  }

  EosTxActionAck_EosActionSellRam* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<EosTxActionAck_EosActionSellRam>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const EosTxActionAck_EosActionSellRam& from);
  void MergeFrom(const EosTxActionAck_EosActionSellRam& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(EosTxActionAck_EosActionSellRam* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint64 account = 1;
  bool has_account() const;
  void clear_account();
  static const int kAccountFieldNumber = 1;
  ::google::protobuf::uint64 account() const;
  void set_account(::google::protobuf::uint64 value);

  // optional uint64 bytes = 2;
  bool has_bytes() const;
  void clear_bytes();
  static const int kBytesFieldNumber = 2;
  ::google::protobuf::uint64 bytes() const;
  void set_bytes(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:hw.trezor.messages.eos.EosTxActionAck.EosActionSellRam)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::uint64 account_;
  ::google::protobuf::uint64 bytes_;
  friend struct ::TableStruct_messages_2deos_2eproto;
};
// -------------------------------------------------------------------

class EosTxActionAck_EosActionVoteProducer final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:hw.trezor.messages.eos.EosTxActionAck.EosActionVoteProducer) */ {
 public:
  EosTxActionAck_EosActionVoteProducer();
  virtual ~EosTxActionAck_EosActionVoteProducer();

  EosTxActionAck_EosActionVoteProducer(const EosTxActionAck_EosActionVoteProducer& from);

  inline EosTxActionAck_EosActionVoteProducer& operator=(const EosTxActionAck_EosActionVoteProducer& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  EosTxActionAck_EosActionVoteProducer(EosTxActionAck_EosActionVoteProducer&& from) noexcept
    : EosTxActionAck_EosActionVoteProducer() {
    *this = ::std::move(from);
  }

  inline EosTxActionAck_EosActionVoteProducer& operator=(EosTxActionAck_EosActionVoteProducer&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const EosTxActionAck_EosActionVoteProducer& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const EosTxActionAck_EosActionVoteProducer* internal_default_instance() {
    return reinterpret_cast<const EosTxActionAck_EosActionVoteProducer*>(
               &_EosTxActionAck_EosActionVoteProducer_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    19;

  void Swap(EosTxActionAck_EosActionVoteProducer* other);
  friend void swap(EosTxActionAck_EosActionVoteProducer& a, EosTxActionAck_EosActionVoteProducer& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline EosTxActionAck_EosActionVoteProducer* New() const final {
    return CreateMaybeMessage<EosTxActionAck_EosActionVoteProducer>(nullptr);
  }

  EosTxActionAck_EosActionVoteProducer* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<EosTxActionAck_EosActionVoteProducer>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const EosTxActionAck_EosActionVoteProducer& from);
  void MergeFrom(const EosTxActionAck_EosActionVoteProducer& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(EosTxActionAck_EosActionVoteProducer* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated uint64 producers = 3;
  int producers_size() const;
  void clear_producers();
  static const int kProducersFieldNumber = 3;
  ::google::protobuf::uint64 producers(int index) const;
  void set_producers(int index, ::google::protobuf::uint64 value);
  void add_producers(::google::protobuf::uint64 value);
  const ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >&
      producers() const;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >*
      mutable_producers();

  // optional uint64 voter = 1;
  bool has_voter() const;
  void clear_voter();
  static const int kVoterFieldNumber = 1;
  ::google::protobuf::uint64 voter() const;
  void set_voter(::google::protobuf::uint64 value);

  // optional uint64 proxy = 2;
  bool has_proxy() const;
  void clear_proxy();
  static const int kProxyFieldNumber = 2;
  ::google::protobuf::uint64 proxy() const;
  void set_proxy(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:hw.trezor.messages.eos.EosTxActionAck.EosActionVoteProducer)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint64 > producers_;
  ::google::protobuf::uint64 voter_;
  ::google::protobuf::uint64 proxy_;
  friend struct ::TableStruct_messages_2deos_2eproto;
};
// -------------------------------------------------------------------

class EosTxActionAck_EosActionUpdateAuth final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:hw.trezor.messages.eos.EosTxActionAck.EosActionUpdateAuth) */ {
 public:
  EosTxActionAck_EosActionUpdateAuth();
  virtual ~EosTxActionAck_EosActionUpdateAuth();

  EosTxActionAck_EosActionUpdateAuth(const EosTxActionAck_EosActionUpdateAuth& from);

  inline EosTxActionAck_EosActionUpdateAuth& operator=(const EosTxActionAck_EosActionUpdateAuth& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  EosTxActionAck_EosActionUpdateAuth(EosTxActionAck_EosActionUpdateAuth&& from) noexcept
    : EosTxActionAck_EosActionUpdateAuth() {
    *this = ::std::move(from);
  }

  inline EosTxActionAck_EosActionUpdateAuth& operator=(EosTxActionAck_EosActionUpdateAuth&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const EosTxActionAck_EosActionUpdateAuth& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const EosTxActionAck_EosActionUpdateAuth* internal_default_instance() {
    return reinterpret_cast<const EosTxActionAck_EosActionUpdateAuth*>(
               &_EosTxActionAck_EosActionUpdateAuth_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    20;

  void Swap(EosTxActionAck_EosActionUpdateAuth* other);
  friend void swap(EosTxActionAck_EosActionUpdateAuth& a, EosTxActionAck_EosActionUpdateAuth& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline EosTxActionAck_EosActionUpdateAuth* New() const final {
    return CreateMaybeMessage<EosTxActionAck_EosActionUpdateAuth>(nullptr);
  }

  EosTxActionAck_EosActionUpdateAuth* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<EosTxActionAck_EosActionUpdateAuth>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const EosTxActionAck_EosActionUpdateAuth& from);
  void MergeFrom(const EosTxActionAck_EosActionUpdateAuth& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(EosTxActionAck_EosActionUpdateAuth* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .hw.trezor.messages.eos.EosTxActionAck.EosAuthorization auth = 4;
  bool has_auth() const;
  void clear_auth();
  static const int kAuthFieldNumber = 4;
  const ::hw::trezor::messages::eos::EosTxActionAck_EosAuthorization& auth() const;
  ::hw::trezor::messages::eos::EosTxActionAck_EosAuthorization* release_auth();
  ::hw::trezor::messages::eos::EosTxActionAck_EosAuthorization* mutable_auth();
  void set_allocated_auth(::hw::trezor::messages::eos::EosTxActionAck_EosAuthorization* auth);

  // optional uint64 account = 1;
  bool has_account() const;
  void clear_account();
  static const int kAccountFieldNumber = 1;
  ::google::protobuf::uint64 account() const;
  void set_account(::google::protobuf::uint64 value);

  // optional uint64 permission = 2;
  bool has_permission() const;
  void clear_permission();
  static const int kPermissionFieldNumber = 2;
  ::google::protobuf::uint64 permission() const;
  void set_permission(::google::protobuf::uint64 value);

  // optional uint64 parent = 3;
  bool has_parent() const;
  void clear_parent();
  static const int kParentFieldNumber = 3;
  ::google::protobuf::uint64 parent() const;
  void set_parent(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:hw.trezor.messages.eos.EosTxActionAck.EosActionUpdateAuth)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::hw::trezor::messages::eos::EosTxActionAck_EosAuthorization* auth_;
  ::google::protobuf::uint64 account_;
  ::google::protobuf::uint64 permission_;
  ::google::protobuf::uint64 parent_;
  friend struct ::TableStruct_messages_2deos_2eproto;
};
// -------------------------------------------------------------------

class EosTxActionAck_EosActionDeleteAuth final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:hw.trezor.messages.eos.EosTxActionAck.EosActionDeleteAuth) */ {
 public:
  EosTxActionAck_EosActionDeleteAuth();
  virtual ~EosTxActionAck_EosActionDeleteAuth();

  EosTxActionAck_EosActionDeleteAuth(const EosTxActionAck_EosActionDeleteAuth& from);

  inline EosTxActionAck_EosActionDeleteAuth& operator=(const EosTxActionAck_EosActionDeleteAuth& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  EosTxActionAck_EosActionDeleteAuth(EosTxActionAck_EosActionDeleteAuth&& from) noexcept
    : EosTxActionAck_EosActionDeleteAuth() {
    *this = ::std::move(from);
  }

  inline EosTxActionAck_EosActionDeleteAuth& operator=(EosTxActionAck_EosActionDeleteAuth&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const EosTxActionAck_EosActionDeleteAuth& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const EosTxActionAck_EosActionDeleteAuth* internal_default_instance() {
    return reinterpret_cast<const EosTxActionAck_EosActionDeleteAuth*>(
               &_EosTxActionAck_EosActionDeleteAuth_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    21;

  void Swap(EosTxActionAck_EosActionDeleteAuth* other);
  friend void swap(EosTxActionAck_EosActionDeleteAuth& a, EosTxActionAck_EosActionDeleteAuth& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline EosTxActionAck_EosActionDeleteAuth* New() const final {
    return CreateMaybeMessage<EosTxActionAck_EosActionDeleteAuth>(nullptr);
  }

  EosTxActionAck_EosActionDeleteAuth* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<EosTxActionAck_EosActionDeleteAuth>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const EosTxActionAck_EosActionDeleteAuth& from);
  void MergeFrom(const EosTxActionAck_EosActionDeleteAuth& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(EosTxActionAck_EosActionDeleteAuth* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint64 account = 1;
  bool has_account() const;
  void clear_account();
  static const int kAccountFieldNumber = 1;
  ::google::protobuf::uint64 account() const;
  void set_account(::google::protobuf::uint64 value);

  // optional uint64 permission = 2;
  bool has_permission() const;
  void clear_permission();
  static const int kPermissionFieldNumber = 2;
  ::google::protobuf::uint64 permission() const;
  void set_permission(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:hw.trezor.messages.eos.EosTxActionAck.EosActionDeleteAuth)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::uint64 account_;
  ::google::protobuf::uint64 permission_;
  friend struct ::TableStruct_messages_2deos_2eproto;
};
// -------------------------------------------------------------------

class EosTxActionAck_EosActionLinkAuth final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:hw.trezor.messages.eos.EosTxActionAck.EosActionLinkAuth) */ {
 public:
  EosTxActionAck_EosActionLinkAuth();
  virtual ~EosTxActionAck_EosActionLinkAuth();

  EosTxActionAck_EosActionLinkAuth(const EosTxActionAck_EosActionLinkAuth& from);

  inline EosTxActionAck_EosActionLinkAuth& operator=(const EosTxActionAck_EosActionLinkAuth& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  EosTxActionAck_EosActionLinkAuth(EosTxActionAck_EosActionLinkAuth&& from) noexcept
    : EosTxActionAck_EosActionLinkAuth() {
    *this = ::std::move(from);
  }

  inline EosTxActionAck_EosActionLinkAuth& operator=(EosTxActionAck_EosActionLinkAuth&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const EosTxActionAck_EosActionLinkAuth& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const EosTxActionAck_EosActionLinkAuth* internal_default_instance() {
    return reinterpret_cast<const EosTxActionAck_EosActionLinkAuth*>(
               &_EosTxActionAck_EosActionLinkAuth_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    22;

  void Swap(EosTxActionAck_EosActionLinkAuth* other);
  friend void swap(EosTxActionAck_EosActionLinkAuth& a, EosTxActionAck_EosActionLinkAuth& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline EosTxActionAck_EosActionLinkAuth* New() const final {
    return CreateMaybeMessage<EosTxActionAck_EosActionLinkAuth>(nullptr);
  }

  EosTxActionAck_EosActionLinkAuth* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<EosTxActionAck_EosActionLinkAuth>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const EosTxActionAck_EosActionLinkAuth& from);
  void MergeFrom(const EosTxActionAck_EosActionLinkAuth& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(EosTxActionAck_EosActionLinkAuth* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint64 account = 1;
  bool has_account() const;
  void clear_account();
  static const int kAccountFieldNumber = 1;
  ::google::protobuf::uint64 account() const;
  void set_account(::google::protobuf::uint64 value);

  // optional uint64 code = 2;
  bool has_code() const;
  void clear_code();
  static const int kCodeFieldNumber = 2;
  ::google::protobuf::uint64 code() const;
  void set_code(::google::protobuf::uint64 value);

  // optional uint64 type = 3;
  bool has_type() const;
  void clear_type();
  static const int kTypeFieldNumber = 3;
  ::google::protobuf::uint64 type() const;
  void set_type(::google::protobuf::uint64 value);

  // optional uint64 requirement = 4;
  bool has_requirement() const;
  void clear_requirement();
  static const int kRequirementFieldNumber = 4;
  ::google::protobuf::uint64 requirement() const;
  void set_requirement(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:hw.trezor.messages.eos.EosTxActionAck.EosActionLinkAuth)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::uint64 account_;
  ::google::protobuf::uint64 code_;
  ::google::protobuf::uint64 type_;
  ::google::protobuf::uint64 requirement_;
  friend struct ::TableStruct_messages_2deos_2eproto;
};
// -------------------------------------------------------------------

class EosTxActionAck_EosActionUnlinkAuth final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:hw.trezor.messages.eos.EosTxActionAck.EosActionUnlinkAuth) */ {
 public:
  EosTxActionAck_EosActionUnlinkAuth();
  virtual ~EosTxActionAck_EosActionUnlinkAuth();

  EosTxActionAck_EosActionUnlinkAuth(const EosTxActionAck_EosActionUnlinkAuth& from);

  inline EosTxActionAck_EosActionUnlinkAuth& operator=(const EosTxActionAck_EosActionUnlinkAuth& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  EosTxActionAck_EosActionUnlinkAuth(EosTxActionAck_EosActionUnlinkAuth&& from) noexcept
    : EosTxActionAck_EosActionUnlinkAuth() {
    *this = ::std::move(from);
  }

  inline EosTxActionAck_EosActionUnlinkAuth& operator=(EosTxActionAck_EosActionUnlinkAuth&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const EosTxActionAck_EosActionUnlinkAuth& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const EosTxActionAck_EosActionUnlinkAuth* internal_default_instance() {
    return reinterpret_cast<const EosTxActionAck_EosActionUnlinkAuth*>(
               &_EosTxActionAck_EosActionUnlinkAuth_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    23;

  void Swap(EosTxActionAck_EosActionUnlinkAuth* other);
  friend void swap(EosTxActionAck_EosActionUnlinkAuth& a, EosTxActionAck_EosActionUnlinkAuth& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline EosTxActionAck_EosActionUnlinkAuth* New() const final {
    return CreateMaybeMessage<EosTxActionAck_EosActionUnlinkAuth>(nullptr);
  }

  EosTxActionAck_EosActionUnlinkAuth* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<EosTxActionAck_EosActionUnlinkAuth>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const EosTxActionAck_EosActionUnlinkAuth& from);
  void MergeFrom(const EosTxActionAck_EosActionUnlinkAuth& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(EosTxActionAck_EosActionUnlinkAuth* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint64 account = 1;
  bool has_account() const;
  void clear_account();
  static const int kAccountFieldNumber = 1;
  ::google::protobuf::uint64 account() const;
  void set_account(::google::protobuf::uint64 value);

  // optional uint64 code = 2;
  bool has_code() const;
  void clear_code();
  static const int kCodeFieldNumber = 2;
  ::google::protobuf::uint64 code() const;
  void set_code(::google::protobuf::uint64 value);

  // optional uint64 type = 3;
  bool has_type() const;
  void clear_type();
  static const int kTypeFieldNumber = 3;
  ::google::protobuf::uint64 type() const;
  void set_type(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:hw.trezor.messages.eos.EosTxActionAck.EosActionUnlinkAuth)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::uint64 account_;
  ::google::protobuf::uint64 code_;
  ::google::protobuf::uint64 type_;
  friend struct ::TableStruct_messages_2deos_2eproto;
};
// -------------------------------------------------------------------

class EosTxActionAck_EosActionNewAccount final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:hw.trezor.messages.eos.EosTxActionAck.EosActionNewAccount) */ {
 public:
  EosTxActionAck_EosActionNewAccount();
  virtual ~EosTxActionAck_EosActionNewAccount();

  EosTxActionAck_EosActionNewAccount(const EosTxActionAck_EosActionNewAccount& from);

  inline EosTxActionAck_EosActionNewAccount& operator=(const EosTxActionAck_EosActionNewAccount& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  EosTxActionAck_EosActionNewAccount(EosTxActionAck_EosActionNewAccount&& from) noexcept
    : EosTxActionAck_EosActionNewAccount() {
    *this = ::std::move(from);
  }

  inline EosTxActionAck_EosActionNewAccount& operator=(EosTxActionAck_EosActionNewAccount&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const EosTxActionAck_EosActionNewAccount& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const EosTxActionAck_EosActionNewAccount* internal_default_instance() {
    return reinterpret_cast<const EosTxActionAck_EosActionNewAccount*>(
               &_EosTxActionAck_EosActionNewAccount_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    24;

  void Swap(EosTxActionAck_EosActionNewAccount* other);
  friend void swap(EosTxActionAck_EosActionNewAccount& a, EosTxActionAck_EosActionNewAccount& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline EosTxActionAck_EosActionNewAccount* New() const final {
    return CreateMaybeMessage<EosTxActionAck_EosActionNewAccount>(nullptr);
  }

  EosTxActionAck_EosActionNewAccount* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<EosTxActionAck_EosActionNewAccount>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const EosTxActionAck_EosActionNewAccount& from);
  void MergeFrom(const EosTxActionAck_EosActionNewAccount& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(EosTxActionAck_EosActionNewAccount* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .hw.trezor.messages.eos.EosTxActionAck.EosAuthorization owner = 3;
  bool has_owner() const;
  void clear_owner();
  static const int kOwnerFieldNumber = 3;
  const ::hw::trezor::messages::eos::EosTxActionAck_EosAuthorization& owner() const;
  ::hw::trezor::messages::eos::EosTxActionAck_EosAuthorization* release_owner();
  ::hw::trezor::messages::eos::EosTxActionAck_EosAuthorization* mutable_owner();
  void set_allocated_owner(::hw::trezor::messages::eos::EosTxActionAck_EosAuthorization* owner);

  // optional .hw.trezor.messages.eos.EosTxActionAck.EosAuthorization active = 4;
  bool has_active() const;
  void clear_active();
  static const int kActiveFieldNumber = 4;
  const ::hw::trezor::messages::eos::EosTxActionAck_EosAuthorization& active() const;
  ::hw::trezor::messages::eos::EosTxActionAck_EosAuthorization* release_active();
  ::hw::trezor::messages::eos::EosTxActionAck_EosAuthorization* mutable_active();
  void set_allocated_active(::hw::trezor::messages::eos::EosTxActionAck_EosAuthorization* active);

  // optional uint64 creator = 1;
  bool has_creator() const;
  void clear_creator();
  static const int kCreatorFieldNumber = 1;
  ::google::protobuf::uint64 creator() const;
  void set_creator(::google::protobuf::uint64 value);

  // optional uint64 name = 2;
  bool has_name() const;
  void clear_name();
  static const int kNameFieldNumber = 2;
  ::google::protobuf::uint64 name() const;
  void set_name(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:hw.trezor.messages.eos.EosTxActionAck.EosActionNewAccount)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::hw::trezor::messages::eos::EosTxActionAck_EosAuthorization* owner_;
  ::hw::trezor::messages::eos::EosTxActionAck_EosAuthorization* active_;
  ::google::protobuf::uint64 creator_;
  ::google::protobuf::uint64 name_;
  friend struct ::TableStruct_messages_2deos_2eproto;
};
// -------------------------------------------------------------------

class EosTxActionAck_EosActionUnknown final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:hw.trezor.messages.eos.EosTxActionAck.EosActionUnknown) */ {
 public:
  EosTxActionAck_EosActionUnknown();
  virtual ~EosTxActionAck_EosActionUnknown();

  EosTxActionAck_EosActionUnknown(const EosTxActionAck_EosActionUnknown& from);

  inline EosTxActionAck_EosActionUnknown& operator=(const EosTxActionAck_EosActionUnknown& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  EosTxActionAck_EosActionUnknown(EosTxActionAck_EosActionUnknown&& from) noexcept
    : EosTxActionAck_EosActionUnknown() {
    *this = ::std::move(from);
  }

  inline EosTxActionAck_EosActionUnknown& operator=(EosTxActionAck_EosActionUnknown&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const EosTxActionAck_EosActionUnknown& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const EosTxActionAck_EosActionUnknown* internal_default_instance() {
    return reinterpret_cast<const EosTxActionAck_EosActionUnknown*>(
               &_EosTxActionAck_EosActionUnknown_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    25;

  void Swap(EosTxActionAck_EosActionUnknown* other);
  friend void swap(EosTxActionAck_EosActionUnknown& a, EosTxActionAck_EosActionUnknown& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline EosTxActionAck_EosActionUnknown* New() const final {
    return CreateMaybeMessage<EosTxActionAck_EosActionUnknown>(nullptr);
  }

  EosTxActionAck_EosActionUnknown* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<EosTxActionAck_EosActionUnknown>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const EosTxActionAck_EosActionUnknown& from);
  void MergeFrom(const EosTxActionAck_EosActionUnknown& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(EosTxActionAck_EosActionUnknown* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bytes data_chunk = 2;
  bool has_data_chunk() const;
  void clear_data_chunk();
  static const int kDataChunkFieldNumber = 2;
  const ::std::string& data_chunk() const;
  void set_data_chunk(const ::std::string& value);
  #if LANG_CXX11
  void set_data_chunk(::std::string&& value);
  #endif
  void set_data_chunk(const char* value);
  void set_data_chunk(const void* value, size_t size);
  ::std::string* mutable_data_chunk();
  ::std::string* release_data_chunk();
  void set_allocated_data_chunk(::std::string* data_chunk);

  // optional uint32 data_size = 1;
  bool has_data_size() const;
  void clear_data_size();
  static const int kDataSizeFieldNumber = 1;
  ::google::protobuf::uint32 data_size() const;
  void set_data_size(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:hw.trezor.messages.eos.EosTxActionAck.EosActionUnknown)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr data_chunk_;
  ::google::protobuf::uint32 data_size_;
  friend struct ::TableStruct_messages_2deos_2eproto;
};
// -------------------------------------------------------------------

class EosTxActionAck final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:hw.trezor.messages.eos.EosTxActionAck) */ {
 public:
  EosTxActionAck();
  virtual ~EosTxActionAck();

  EosTxActionAck(const EosTxActionAck& from);

  inline EosTxActionAck& operator=(const EosTxActionAck& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  EosTxActionAck(EosTxActionAck&& from) noexcept
    : EosTxActionAck() {
    *this = ::std::move(from);
  }

  inline EosTxActionAck& operator=(EosTxActionAck&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const EosTxActionAck& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const EosTxActionAck* internal_default_instance() {
    return reinterpret_cast<const EosTxActionAck*>(
               &_EosTxActionAck_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    26;

  void Swap(EosTxActionAck* other);
  friend void swap(EosTxActionAck& a, EosTxActionAck& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline EosTxActionAck* New() const final {
    return CreateMaybeMessage<EosTxActionAck>(nullptr);
  }

  EosTxActionAck* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<EosTxActionAck>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const EosTxActionAck& from);
  void MergeFrom(const EosTxActionAck& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(EosTxActionAck* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef EosTxActionAck_EosAsset EosAsset;
  typedef EosTxActionAck_EosPermissionLevel EosPermissionLevel;
  typedef EosTxActionAck_EosAuthorizationKey EosAuthorizationKey;
  typedef EosTxActionAck_EosAuthorizationAccount EosAuthorizationAccount;
  typedef EosTxActionAck_EosAuthorizationWait EosAuthorizationWait;
  typedef EosTxActionAck_EosAuthorization EosAuthorization;
  typedef EosTxActionAck_EosActionCommon EosActionCommon;
  typedef EosTxActionAck_EosActionTransfer EosActionTransfer;
  typedef EosTxActionAck_EosActionDelegate EosActionDelegate;
  typedef EosTxActionAck_EosActionUndelegate EosActionUndelegate;
  typedef EosTxActionAck_EosActionRefund EosActionRefund;
  typedef EosTxActionAck_EosActionBuyRam EosActionBuyRam;
  typedef EosTxActionAck_EosActionBuyRamBytes EosActionBuyRamBytes;
  typedef EosTxActionAck_EosActionSellRam EosActionSellRam;
  typedef EosTxActionAck_EosActionVoteProducer EosActionVoteProducer;
  typedef EosTxActionAck_EosActionUpdateAuth EosActionUpdateAuth;
  typedef EosTxActionAck_EosActionDeleteAuth EosActionDeleteAuth;
  typedef EosTxActionAck_EosActionLinkAuth EosActionLinkAuth;
  typedef EosTxActionAck_EosActionUnlinkAuth EosActionUnlinkAuth;
  typedef EosTxActionAck_EosActionNewAccount EosActionNewAccount;
  typedef EosTxActionAck_EosActionUnknown EosActionUnknown;

  // accessors -------------------------------------------------------

  // optional .hw.trezor.messages.eos.EosTxActionAck.EosActionCommon common = 1;
  bool has_common() const;
  void clear_common();
  static const int kCommonFieldNumber = 1;
  const ::hw::trezor::messages::eos::EosTxActionAck_EosActionCommon& common() const;
  ::hw::trezor::messages::eos::EosTxActionAck_EosActionCommon* release_common();
  ::hw::trezor::messages::eos::EosTxActionAck_EosActionCommon* mutable_common();
  void set_allocated_common(::hw::trezor::messages::eos::EosTxActionAck_EosActionCommon* common);

  // optional .hw.trezor.messages.eos.EosTxActionAck.EosActionTransfer transfer = 2;
  bool has_transfer() const;
  void clear_transfer();
  static const int kTransferFieldNumber = 2;
  const ::hw::trezor::messages::eos::EosTxActionAck_EosActionTransfer& transfer() const;
  ::hw::trezor::messages::eos::EosTxActionAck_EosActionTransfer* release_transfer();
  ::hw::trezor::messages::eos::EosTxActionAck_EosActionTransfer* mutable_transfer();
  void set_allocated_transfer(::hw::trezor::messages::eos::EosTxActionAck_EosActionTransfer* transfer);

  // optional .hw.trezor.messages.eos.EosTxActionAck.EosActionDelegate delegate = 3;
  bool has_delegate() const;
  void clear_delegate();
  static const int kDelegateFieldNumber = 3;
  const ::hw::trezor::messages::eos::EosTxActionAck_EosActionDelegate& delegate() const;
  ::hw::trezor::messages::eos::EosTxActionAck_EosActionDelegate* release_delegate();
  ::hw::trezor::messages::eos::EosTxActionAck_EosActionDelegate* mutable_delegate();
  void set_allocated_delegate(::hw::trezor::messages::eos::EosTxActionAck_EosActionDelegate* delegate);

  // optional .hw.trezor.messages.eos.EosTxActionAck.EosActionUndelegate undelegate = 4;
  bool has_undelegate() const;
  void clear_undelegate();
  static const int kUndelegateFieldNumber = 4;
  const ::hw::trezor::messages::eos::EosTxActionAck_EosActionUndelegate& undelegate() const;
  ::hw::trezor::messages::eos::EosTxActionAck_EosActionUndelegate* release_undelegate();
  ::hw::trezor::messages::eos::EosTxActionAck_EosActionUndelegate* mutable_undelegate();
  void set_allocated_undelegate(::hw::trezor::messages::eos::EosTxActionAck_EosActionUndelegate* undelegate);

  // optional .hw.trezor.messages.eos.EosTxActionAck.EosActionRefund refund = 5;
  bool has_refund() const;
  void clear_refund();
  static const int kRefundFieldNumber = 5;
  const ::hw::trezor::messages::eos::EosTxActionAck_EosActionRefund& refund() const;
  ::hw::trezor::messages::eos::EosTxActionAck_EosActionRefund* release_refund();
  ::hw::trezor::messages::eos::EosTxActionAck_EosActionRefund* mutable_refund();
  void set_allocated_refund(::hw::trezor::messages::eos::EosTxActionAck_EosActionRefund* refund);

  // optional .hw.trezor.messages.eos.EosTxActionAck.EosActionBuyRam buy_ram = 6;
  bool has_buy_ram() const;
  void clear_buy_ram();
  static const int kBuyRamFieldNumber = 6;
  const ::hw::trezor::messages::eos::EosTxActionAck_EosActionBuyRam& buy_ram() const;
  ::hw::trezor::messages::eos::EosTxActionAck_EosActionBuyRam* release_buy_ram();
  ::hw::trezor::messages::eos::EosTxActionAck_EosActionBuyRam* mutable_buy_ram();
  void set_allocated_buy_ram(::hw::trezor::messages::eos::EosTxActionAck_EosActionBuyRam* buy_ram);

  // optional .hw.trezor.messages.eos.EosTxActionAck.EosActionBuyRamBytes buy_ram_bytes = 7;
  bool has_buy_ram_bytes() const;
  void clear_buy_ram_bytes();
  static const int kBuyRamBytesFieldNumber = 7;
  const ::hw::trezor::messages::eos::EosTxActionAck_EosActionBuyRamBytes& buy_ram_bytes() const;
  ::hw::trezor::messages::eos::EosTxActionAck_EosActionBuyRamBytes* release_buy_ram_bytes();
  ::hw::trezor::messages::eos::EosTxActionAck_EosActionBuyRamBytes* mutable_buy_ram_bytes();
  void set_allocated_buy_ram_bytes(::hw::trezor::messages::eos::EosTxActionAck_EosActionBuyRamBytes* buy_ram_bytes);

  // optional .hw.trezor.messages.eos.EosTxActionAck.EosActionSellRam sell_ram = 8;
  bool has_sell_ram() const;
  void clear_sell_ram();
  static const int kSellRamFieldNumber = 8;
  const ::hw::trezor::messages::eos::EosTxActionAck_EosActionSellRam& sell_ram() const;
  ::hw::trezor::messages::eos::EosTxActionAck_EosActionSellRam* release_sell_ram();
  ::hw::trezor::messages::eos::EosTxActionAck_EosActionSellRam* mutable_sell_ram();
  void set_allocated_sell_ram(::hw::trezor::messages::eos::EosTxActionAck_EosActionSellRam* sell_ram);

  // optional .hw.trezor.messages.eos.EosTxActionAck.EosActionVoteProducer vote_producer = 9;
  bool has_vote_producer() const;
  void clear_vote_producer();
  static const int kVoteProducerFieldNumber = 9;
  const ::hw::trezor::messages::eos::EosTxActionAck_EosActionVoteProducer& vote_producer() const;
  ::hw::trezor::messages::eos::EosTxActionAck_EosActionVoteProducer* release_vote_producer();
  ::hw::trezor::messages::eos::EosTxActionAck_EosActionVoteProducer* mutable_vote_producer();
  void set_allocated_vote_producer(::hw::trezor::messages::eos::EosTxActionAck_EosActionVoteProducer* vote_producer);

  // optional .hw.trezor.messages.eos.EosTxActionAck.EosActionUpdateAuth update_auth = 10;
  bool has_update_auth() const;
  void clear_update_auth();
  static const int kUpdateAuthFieldNumber = 10;
  const ::hw::trezor::messages::eos::EosTxActionAck_EosActionUpdateAuth& update_auth() const;
  ::hw::trezor::messages::eos::EosTxActionAck_EosActionUpdateAuth* release_update_auth();
  ::hw::trezor::messages::eos::EosTxActionAck_EosActionUpdateAuth* mutable_update_auth();
  void set_allocated_update_auth(::hw::trezor::messages::eos::EosTxActionAck_EosActionUpdateAuth* update_auth);

  // optional .hw.trezor.messages.eos.EosTxActionAck.EosActionDeleteAuth delete_auth = 11;
  bool has_delete_auth() const;
  void clear_delete_auth();
  static const int kDeleteAuthFieldNumber = 11;
  const ::hw::trezor::messages::eos::EosTxActionAck_EosActionDeleteAuth& delete_auth() const;
  ::hw::trezor::messages::eos::EosTxActionAck_EosActionDeleteAuth* release_delete_auth();
  ::hw::trezor::messages::eos::EosTxActionAck_EosActionDeleteAuth* mutable_delete_auth();
  void set_allocated_delete_auth(::hw::trezor::messages::eos::EosTxActionAck_EosActionDeleteAuth* delete_auth);

  // optional .hw.trezor.messages.eos.EosTxActionAck.EosActionLinkAuth link_auth = 12;
  bool has_link_auth() const;
  void clear_link_auth();
  static const int kLinkAuthFieldNumber = 12;
  const ::hw::trezor::messages::eos::EosTxActionAck_EosActionLinkAuth& link_auth() const;
  ::hw::trezor::messages::eos::EosTxActionAck_EosActionLinkAuth* release_link_auth();
  ::hw::trezor::messages::eos::EosTxActionAck_EosActionLinkAuth* mutable_link_auth();
  void set_allocated_link_auth(::hw::trezor::messages::eos::EosTxActionAck_EosActionLinkAuth* link_auth);

  // optional .hw.trezor.messages.eos.EosTxActionAck.EosActionUnlinkAuth unlink_auth = 13;
  bool has_unlink_auth() const;
  void clear_unlink_auth();
  static const int kUnlinkAuthFieldNumber = 13;
  const ::hw::trezor::messages::eos::EosTxActionAck_EosActionUnlinkAuth& unlink_auth() const;
  ::hw::trezor::messages::eos::EosTxActionAck_EosActionUnlinkAuth* release_unlink_auth();
  ::hw::trezor::messages::eos::EosTxActionAck_EosActionUnlinkAuth* mutable_unlink_auth();
  void set_allocated_unlink_auth(::hw::trezor::messages::eos::EosTxActionAck_EosActionUnlinkAuth* unlink_auth);

  // optional .hw.trezor.messages.eos.EosTxActionAck.EosActionNewAccount new_account = 14;
  bool has_new_account() const;
  void clear_new_account();
  static const int kNewAccountFieldNumber = 14;
  const ::hw::trezor::messages::eos::EosTxActionAck_EosActionNewAccount& new_account() const;
  ::hw::trezor::messages::eos::EosTxActionAck_EosActionNewAccount* release_new_account();
  ::hw::trezor::messages::eos::EosTxActionAck_EosActionNewAccount* mutable_new_account();
  void set_allocated_new_account(::hw::trezor::messages::eos::EosTxActionAck_EosActionNewAccount* new_account);

  // optional .hw.trezor.messages.eos.EosTxActionAck.EosActionUnknown unknown = 15;
  bool has_unknown() const;
  void clear_unknown();
  static const int kUnknownFieldNumber = 15;
  const ::hw::trezor::messages::eos::EosTxActionAck_EosActionUnknown& unknown() const;
  ::hw::trezor::messages::eos::EosTxActionAck_EosActionUnknown* release_unknown();
  ::hw::trezor::messages::eos::EosTxActionAck_EosActionUnknown* mutable_unknown();
  void set_allocated_unknown(::hw::trezor::messages::eos::EosTxActionAck_EosActionUnknown* unknown);

  // @@protoc_insertion_point(class_scope:hw.trezor.messages.eos.EosTxActionAck)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::hw::trezor::messages::eos::EosTxActionAck_EosActionCommon* common_;
  ::hw::trezor::messages::eos::EosTxActionAck_EosActionTransfer* transfer_;
  ::hw::trezor::messages::eos::EosTxActionAck_EosActionDelegate* delegate_;
  ::hw::trezor::messages::eos::EosTxActionAck_EosActionUndelegate* undelegate_;
  ::hw::trezor::messages::eos::EosTxActionAck_EosActionRefund* refund_;
  ::hw::trezor::messages::eos::EosTxActionAck_EosActionBuyRam* buy_ram_;
  ::hw::trezor::messages::eos::EosTxActionAck_EosActionBuyRamBytes* buy_ram_bytes_;
  ::hw::trezor::messages::eos::EosTxActionAck_EosActionSellRam* sell_ram_;
  ::hw::trezor::messages::eos::EosTxActionAck_EosActionVoteProducer* vote_producer_;
  ::hw::trezor::messages::eos::EosTxActionAck_EosActionUpdateAuth* update_auth_;
  ::hw::trezor::messages::eos::EosTxActionAck_EosActionDeleteAuth* delete_auth_;
  ::hw::trezor::messages::eos::EosTxActionAck_EosActionLinkAuth* link_auth_;
  ::hw::trezor::messages::eos::EosTxActionAck_EosActionUnlinkAuth* unlink_auth_;
  ::hw::trezor::messages::eos::EosTxActionAck_EosActionNewAccount* new_account_;
  ::hw::trezor::messages::eos::EosTxActionAck_EosActionUnknown* unknown_;
  friend struct ::TableStruct_messages_2deos_2eproto;
};
// -------------------------------------------------------------------

class EosSignedTx final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:hw.trezor.messages.eos.EosSignedTx) */ {
 public:
  EosSignedTx();
  virtual ~EosSignedTx();

  EosSignedTx(const EosSignedTx& from);

  inline EosSignedTx& operator=(const EosSignedTx& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  EosSignedTx(EosSignedTx&& from) noexcept
    : EosSignedTx() {
    *this = ::std::move(from);
  }

  inline EosSignedTx& operator=(EosSignedTx&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const EosSignedTx& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const EosSignedTx* internal_default_instance() {
    return reinterpret_cast<const EosSignedTx*>(
               &_EosSignedTx_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    27;

  void Swap(EosSignedTx* other);
  friend void swap(EosSignedTx& a, EosSignedTx& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline EosSignedTx* New() const final {
    return CreateMaybeMessage<EosSignedTx>(nullptr);
  }

  EosSignedTx* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<EosSignedTx>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const EosSignedTx& from);
  void MergeFrom(const EosSignedTx& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(EosSignedTx* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bytes signature_r = 2;
  bool has_signature_r() const;
  void clear_signature_r();
  static const int kSignatureRFieldNumber = 2;
  const ::std::string& signature_r() const;
  void set_signature_r(const ::std::string& value);
  #if LANG_CXX11
  void set_signature_r(::std::string&& value);
  #endif
  void set_signature_r(const char* value);
  void set_signature_r(const void* value, size_t size);
  ::std::string* mutable_signature_r();
  ::std::string* release_signature_r();
  void set_allocated_signature_r(::std::string* signature_r);

  // optional bytes signature_s = 3;
  bool has_signature_s() const;
  void clear_signature_s();
  static const int kSignatureSFieldNumber = 3;
  const ::std::string& signature_s() const;
  void set_signature_s(const ::std::string& value);
  #if LANG_CXX11
  void set_signature_s(::std::string&& value);
  #endif
  void set_signature_s(const char* value);
  void set_signature_s(const void* value, size_t size);
  ::std::string* mutable_signature_s();
  ::std::string* release_signature_s();
  void set_allocated_signature_s(::std::string* signature_s);

  // optional uint32 signature_v = 1;
  bool has_signature_v() const;
  void clear_signature_v();
  static const int kSignatureVFieldNumber = 1;
  ::google::protobuf::uint32 signature_v() const;
  void set_signature_v(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:hw.trezor.messages.eos.EosSignedTx)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr signature_r_;
  ::google::protobuf::internal::ArenaStringPtr signature_s_;
  ::google::protobuf::uint32 signature_v_;
  friend struct ::TableStruct_messages_2deos_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// EosGetPublicKey

// repeated uint32 address_n = 1;
inline int EosGetPublicKey::address_n_size() const {
  return address_n_.size();
}
inline void EosGetPublicKey::clear_address_n() {
  address_n_.Clear();
}
inline ::google::protobuf::uint32 EosGetPublicKey::address_n(int index) const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.eos.EosGetPublicKey.address_n)
  return address_n_.Get(index);
}
inline void EosGetPublicKey::set_address_n(int index, ::google::protobuf::uint32 value) {
  address_n_.Set(index, value);
  // @@protoc_insertion_point(field_set:hw.trezor.messages.eos.EosGetPublicKey.address_n)
}
inline void EosGetPublicKey::add_address_n(::google::protobuf::uint32 value) {
  address_n_.Add(value);
  // @@protoc_insertion_point(field_add:hw.trezor.messages.eos.EosGetPublicKey.address_n)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
EosGetPublicKey::address_n() const {
  // @@protoc_insertion_point(field_list:hw.trezor.messages.eos.EosGetPublicKey.address_n)
  return address_n_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
EosGetPublicKey::mutable_address_n() {
  // @@protoc_insertion_point(field_mutable_list:hw.trezor.messages.eos.EosGetPublicKey.address_n)
  return &address_n_;
}

// optional bool show_display = 2;
inline bool EosGetPublicKey::has_show_display() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void EosGetPublicKey::clear_show_display() {
  show_display_ = false;
  _has_bits_[0] &= ~0x00000001u;
}
inline bool EosGetPublicKey::show_display() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.eos.EosGetPublicKey.show_display)
  return show_display_;
}
inline void EosGetPublicKey::set_show_display(bool value) {
  _has_bits_[0] |= 0x00000001u;
  show_display_ = value;
  // @@protoc_insertion_point(field_set:hw.trezor.messages.eos.EosGetPublicKey.show_display)
}

// -------------------------------------------------------------------

// EosPublicKey

// optional string wif_public_key = 1;
inline bool EosPublicKey::has_wif_public_key() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void EosPublicKey::clear_wif_public_key() {
  wif_public_key_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::std::string& EosPublicKey::wif_public_key() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.eos.EosPublicKey.wif_public_key)
  return wif_public_key_.GetNoArena();
}
inline void EosPublicKey::set_wif_public_key(const ::std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  wif_public_key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:hw.trezor.messages.eos.EosPublicKey.wif_public_key)
}
#if LANG_CXX11
inline void EosPublicKey::set_wif_public_key(::std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  wif_public_key_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:hw.trezor.messages.eos.EosPublicKey.wif_public_key)
}
#endif
inline void EosPublicKey::set_wif_public_key(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  wif_public_key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:hw.trezor.messages.eos.EosPublicKey.wif_public_key)
}
inline void EosPublicKey::set_wif_public_key(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000001u;
  wif_public_key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:hw.trezor.messages.eos.EosPublicKey.wif_public_key)
}
inline ::std::string* EosPublicKey::mutable_wif_public_key() {
  _has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_mutable:hw.trezor.messages.eos.EosPublicKey.wif_public_key)
  return wif_public_key_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* EosPublicKey::release_wif_public_key() {
  // @@protoc_insertion_point(field_release:hw.trezor.messages.eos.EosPublicKey.wif_public_key)
  if (!has_wif_public_key()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return wif_public_key_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void EosPublicKey::set_allocated_wif_public_key(::std::string* wif_public_key) {
  if (wif_public_key != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  wif_public_key_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), wif_public_key);
  // @@protoc_insertion_point(field_set_allocated:hw.trezor.messages.eos.EosPublicKey.wif_public_key)
}

// optional bytes raw_public_key = 2;
inline bool EosPublicKey::has_raw_public_key() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void EosPublicKey::clear_raw_public_key() {
  raw_public_key_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000002u;
}
inline const ::std::string& EosPublicKey::raw_public_key() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.eos.EosPublicKey.raw_public_key)
  return raw_public_key_.GetNoArena();
}
inline void EosPublicKey::set_raw_public_key(const ::std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  raw_public_key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:hw.trezor.messages.eos.EosPublicKey.raw_public_key)
}
#if LANG_CXX11
inline void EosPublicKey::set_raw_public_key(::std::string&& value) {
  _has_bits_[0] |= 0x00000002u;
  raw_public_key_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:hw.trezor.messages.eos.EosPublicKey.raw_public_key)
}
#endif
inline void EosPublicKey::set_raw_public_key(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000002u;
  raw_public_key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:hw.trezor.messages.eos.EosPublicKey.raw_public_key)
}
inline void EosPublicKey::set_raw_public_key(const void* value, size_t size) {
  _has_bits_[0] |= 0x00000002u;
  raw_public_key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:hw.trezor.messages.eos.EosPublicKey.raw_public_key)
}
inline ::std::string* EosPublicKey::mutable_raw_public_key() {
  _has_bits_[0] |= 0x00000002u;
  // @@protoc_insertion_point(field_mutable:hw.trezor.messages.eos.EosPublicKey.raw_public_key)
  return raw_public_key_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* EosPublicKey::release_raw_public_key() {
  // @@protoc_insertion_point(field_release:hw.trezor.messages.eos.EosPublicKey.raw_public_key)
  if (!has_raw_public_key()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  return raw_public_key_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void EosPublicKey::set_allocated_raw_public_key(::std::string* raw_public_key) {
  if (raw_public_key != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  raw_public_key_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), raw_public_key);
  // @@protoc_insertion_point(field_set_allocated:hw.trezor.messages.eos.EosPublicKey.raw_public_key)
}

// -------------------------------------------------------------------

// EosSignTx_EosTxHeader

// required uint32 expiration = 1;
inline bool EosSignTx_EosTxHeader::has_expiration() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void EosSignTx_EosTxHeader::clear_expiration() {
  expiration_ = 0u;
  _has_bits_[0] &= ~0x00000001u;
}
inline ::google::protobuf::uint32 EosSignTx_EosTxHeader::expiration() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.eos.EosSignTx.EosTxHeader.expiration)
  return expiration_;
}
inline void EosSignTx_EosTxHeader::set_expiration(::google::protobuf::uint32 value) {
  _has_bits_[0] |= 0x00000001u;
  expiration_ = value;
  // @@protoc_insertion_point(field_set:hw.trezor.messages.eos.EosSignTx.EosTxHeader.expiration)
}

// required uint32 ref_block_num = 2;
inline bool EosSignTx_EosTxHeader::has_ref_block_num() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void EosSignTx_EosTxHeader::clear_ref_block_num() {
  ref_block_num_ = 0u;
  _has_bits_[0] &= ~0x00000002u;
}
inline ::google::protobuf::uint32 EosSignTx_EosTxHeader::ref_block_num() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.eos.EosSignTx.EosTxHeader.ref_block_num)
  return ref_block_num_;
}
inline void EosSignTx_EosTxHeader::set_ref_block_num(::google::protobuf::uint32 value) {
  _has_bits_[0] |= 0x00000002u;
  ref_block_num_ = value;
  // @@protoc_insertion_point(field_set:hw.trezor.messages.eos.EosSignTx.EosTxHeader.ref_block_num)
}

// required uint32 ref_block_prefix = 3;
inline bool EosSignTx_EosTxHeader::has_ref_block_prefix() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void EosSignTx_EosTxHeader::clear_ref_block_prefix() {
  ref_block_prefix_ = 0u;
  _has_bits_[0] &= ~0x00000004u;
}
inline ::google::protobuf::uint32 EosSignTx_EosTxHeader::ref_block_prefix() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.eos.EosSignTx.EosTxHeader.ref_block_prefix)
  return ref_block_prefix_;
}
inline void EosSignTx_EosTxHeader::set_ref_block_prefix(::google::protobuf::uint32 value) {
  _has_bits_[0] |= 0x00000004u;
  ref_block_prefix_ = value;
  // @@protoc_insertion_point(field_set:hw.trezor.messages.eos.EosSignTx.EosTxHeader.ref_block_prefix)
}

// required uint32 max_net_usage_words = 4;
inline bool EosSignTx_EosTxHeader::has_max_net_usage_words() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void EosSignTx_EosTxHeader::clear_max_net_usage_words() {
  max_net_usage_words_ = 0u;
  _has_bits_[0] &= ~0x00000008u;
}
inline ::google::protobuf::uint32 EosSignTx_EosTxHeader::max_net_usage_words() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.eos.EosSignTx.EosTxHeader.max_net_usage_words)
  return max_net_usage_words_;
}
inline void EosSignTx_EosTxHeader::set_max_net_usage_words(::google::protobuf::uint32 value) {
  _has_bits_[0] |= 0x00000008u;
  max_net_usage_words_ = value;
  // @@protoc_insertion_point(field_set:hw.trezor.messages.eos.EosSignTx.EosTxHeader.max_net_usage_words)
}

// required uint32 max_cpu_usage_ms = 5;
inline bool EosSignTx_EosTxHeader::has_max_cpu_usage_ms() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void EosSignTx_EosTxHeader::clear_max_cpu_usage_ms() {
  max_cpu_usage_ms_ = 0u;
  _has_bits_[0] &= ~0x00000010u;
}
inline ::google::protobuf::uint32 EosSignTx_EosTxHeader::max_cpu_usage_ms() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.eos.EosSignTx.EosTxHeader.max_cpu_usage_ms)
  return max_cpu_usage_ms_;
}
inline void EosSignTx_EosTxHeader::set_max_cpu_usage_ms(::google::protobuf::uint32 value) {
  _has_bits_[0] |= 0x00000010u;
  max_cpu_usage_ms_ = value;
  // @@protoc_insertion_point(field_set:hw.trezor.messages.eos.EosSignTx.EosTxHeader.max_cpu_usage_ms)
}

// required uint32 delay_sec = 6;
inline bool EosSignTx_EosTxHeader::has_delay_sec() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void EosSignTx_EosTxHeader::clear_delay_sec() {
  delay_sec_ = 0u;
  _has_bits_[0] &= ~0x00000020u;
}
inline ::google::protobuf::uint32 EosSignTx_EosTxHeader::delay_sec() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.eos.EosSignTx.EosTxHeader.delay_sec)
  return delay_sec_;
}
inline void EosSignTx_EosTxHeader::set_delay_sec(::google::protobuf::uint32 value) {
  _has_bits_[0] |= 0x00000020u;
  delay_sec_ = value;
  // @@protoc_insertion_point(field_set:hw.trezor.messages.eos.EosSignTx.EosTxHeader.delay_sec)
}

// -------------------------------------------------------------------

// EosSignTx

// repeated uint32 address_n = 1;
inline int EosSignTx::address_n_size() const {
  return address_n_.size();
}
inline void EosSignTx::clear_address_n() {
  address_n_.Clear();
}
inline ::google::protobuf::uint32 EosSignTx::address_n(int index) const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.eos.EosSignTx.address_n)
  return address_n_.Get(index);
}
inline void EosSignTx::set_address_n(int index, ::google::protobuf::uint32 value) {
  address_n_.Set(index, value);
  // @@protoc_insertion_point(field_set:hw.trezor.messages.eos.EosSignTx.address_n)
}
inline void EosSignTx::add_address_n(::google::protobuf::uint32 value) {
  address_n_.Add(value);
  // @@protoc_insertion_point(field_add:hw.trezor.messages.eos.EosSignTx.address_n)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
EosSignTx::address_n() const {
  // @@protoc_insertion_point(field_list:hw.trezor.messages.eos.EosSignTx.address_n)
  return address_n_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
EosSignTx::mutable_address_n() {
  // @@protoc_insertion_point(field_mutable_list:hw.trezor.messages.eos.EosSignTx.address_n)
  return &address_n_;
}

// optional bytes chain_id = 2;
inline bool EosSignTx::has_chain_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void EosSignTx::clear_chain_id() {
  chain_id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::std::string& EosSignTx::chain_id() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.eos.EosSignTx.chain_id)
  return chain_id_.GetNoArena();
}
inline void EosSignTx::set_chain_id(const ::std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  chain_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:hw.trezor.messages.eos.EosSignTx.chain_id)
}
#if LANG_CXX11
inline void EosSignTx::set_chain_id(::std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  chain_id_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:hw.trezor.messages.eos.EosSignTx.chain_id)
}
#endif
inline void EosSignTx::set_chain_id(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  chain_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:hw.trezor.messages.eos.EosSignTx.chain_id)
}
inline void EosSignTx::set_chain_id(const void* value, size_t size) {
  _has_bits_[0] |= 0x00000001u;
  chain_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:hw.trezor.messages.eos.EosSignTx.chain_id)
}
inline ::std::string* EosSignTx::mutable_chain_id() {
  _has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_mutable:hw.trezor.messages.eos.EosSignTx.chain_id)
  return chain_id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* EosSignTx::release_chain_id() {
  // @@protoc_insertion_point(field_release:hw.trezor.messages.eos.EosSignTx.chain_id)
  if (!has_chain_id()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return chain_id_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void EosSignTx::set_allocated_chain_id(::std::string* chain_id) {
  if (chain_id != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  chain_id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), chain_id);
  // @@protoc_insertion_point(field_set_allocated:hw.trezor.messages.eos.EosSignTx.chain_id)
}

// optional .hw.trezor.messages.eos.EosSignTx.EosTxHeader header = 3;
inline bool EosSignTx::has_header() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void EosSignTx::clear_header() {
  if (header_ != nullptr) header_->Clear();
  _has_bits_[0] &= ~0x00000002u;
}
inline const ::hw::trezor::messages::eos::EosSignTx_EosTxHeader& EosSignTx::header() const {
  const ::hw::trezor::messages::eos::EosSignTx_EosTxHeader* p = header_;
  // @@protoc_insertion_point(field_get:hw.trezor.messages.eos.EosSignTx.header)
  return p != nullptr ? *p : *reinterpret_cast<const ::hw::trezor::messages::eos::EosSignTx_EosTxHeader*>(
      &::hw::trezor::messages::eos::_EosSignTx_EosTxHeader_default_instance_);
}
inline ::hw::trezor::messages::eos::EosSignTx_EosTxHeader* EosSignTx::release_header() {
  // @@protoc_insertion_point(field_release:hw.trezor.messages.eos.EosSignTx.header)
  _has_bits_[0] &= ~0x00000002u;
  ::hw::trezor::messages::eos::EosSignTx_EosTxHeader* temp = header_;
  header_ = nullptr;
  return temp;
}
inline ::hw::trezor::messages::eos::EosSignTx_EosTxHeader* EosSignTx::mutable_header() {
  _has_bits_[0] |= 0x00000002u;
  if (header_ == nullptr) {
    auto* p = CreateMaybeMessage<::hw::trezor::messages::eos::EosSignTx_EosTxHeader>(GetArenaNoVirtual());
    header_ = p;
  }
  // @@protoc_insertion_point(field_mutable:hw.trezor.messages.eos.EosSignTx.header)
  return header_;
}
inline void EosSignTx::set_allocated_header(::hw::trezor::messages::eos::EosSignTx_EosTxHeader* header) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete header_;
  }
  if (header) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      header = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  header_ = header;
  // @@protoc_insertion_point(field_set_allocated:hw.trezor.messages.eos.EosSignTx.header)
}

// optional uint32 num_actions = 4;
inline bool EosSignTx::has_num_actions() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void EosSignTx::clear_num_actions() {
  num_actions_ = 0u;
  _has_bits_[0] &= ~0x00000004u;
}
inline ::google::protobuf::uint32 EosSignTx::num_actions() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.eos.EosSignTx.num_actions)
  return num_actions_;
}
inline void EosSignTx::set_num_actions(::google::protobuf::uint32 value) {
  _has_bits_[0] |= 0x00000004u;
  num_actions_ = value;
  // @@protoc_insertion_point(field_set:hw.trezor.messages.eos.EosSignTx.num_actions)
}

// -------------------------------------------------------------------

// EosTxActionRequest

// optional uint32 data_size = 1;
inline bool EosTxActionRequest::has_data_size() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void EosTxActionRequest::clear_data_size() {
  data_size_ = 0u;
  _has_bits_[0] &= ~0x00000001u;
}
inline ::google::protobuf::uint32 EosTxActionRequest::data_size() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.eos.EosTxActionRequest.data_size)
  return data_size_;
}
inline void EosTxActionRequest::set_data_size(::google::protobuf::uint32 value) {
  _has_bits_[0] |= 0x00000001u;
  data_size_ = value;
  // @@protoc_insertion_point(field_set:hw.trezor.messages.eos.EosTxActionRequest.data_size)
}

// -------------------------------------------------------------------

// EosTxActionAck_EosAsset

// optional sint64 amount = 1;
inline bool EosTxActionAck_EosAsset::has_amount() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void EosTxActionAck_EosAsset::clear_amount() {
  amount_ = PROTOBUF_LONGLONG(0);
  _has_bits_[0] &= ~0x00000001u;
}
inline ::google::protobuf::int64 EosTxActionAck_EosAsset::amount() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.eos.EosTxActionAck.EosAsset.amount)
  return amount_;
}
inline void EosTxActionAck_EosAsset::set_amount(::google::protobuf::int64 value) {
  _has_bits_[0] |= 0x00000001u;
  amount_ = value;
  // @@protoc_insertion_point(field_set:hw.trezor.messages.eos.EosTxActionAck.EosAsset.amount)
}

// optional uint64 symbol = 2;
inline bool EosTxActionAck_EosAsset::has_symbol() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void EosTxActionAck_EosAsset::clear_symbol() {
  symbol_ = PROTOBUF_ULONGLONG(0);
  _has_bits_[0] &= ~0x00000002u;
}
inline ::google::protobuf::uint64 EosTxActionAck_EosAsset::symbol() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.eos.EosTxActionAck.EosAsset.symbol)
  return symbol_;
}
inline void EosTxActionAck_EosAsset::set_symbol(::google::protobuf::uint64 value) {
  _has_bits_[0] |= 0x00000002u;
  symbol_ = value;
  // @@protoc_insertion_point(field_set:hw.trezor.messages.eos.EosTxActionAck.EosAsset.symbol)
}

// -------------------------------------------------------------------

// EosTxActionAck_EosPermissionLevel

// optional uint64 actor = 1;
inline bool EosTxActionAck_EosPermissionLevel::has_actor() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void EosTxActionAck_EosPermissionLevel::clear_actor() {
  actor_ = PROTOBUF_ULONGLONG(0);
  _has_bits_[0] &= ~0x00000001u;
}
inline ::google::protobuf::uint64 EosTxActionAck_EosPermissionLevel::actor() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.eos.EosTxActionAck.EosPermissionLevel.actor)
  return actor_;
}
inline void EosTxActionAck_EosPermissionLevel::set_actor(::google::protobuf::uint64 value) {
  _has_bits_[0] |= 0x00000001u;
  actor_ = value;
  // @@protoc_insertion_point(field_set:hw.trezor.messages.eos.EosTxActionAck.EosPermissionLevel.actor)
}

// optional uint64 permission = 2;
inline bool EosTxActionAck_EosPermissionLevel::has_permission() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void EosTxActionAck_EosPermissionLevel::clear_permission() {
  permission_ = PROTOBUF_ULONGLONG(0);
  _has_bits_[0] &= ~0x00000002u;
}
inline ::google::protobuf::uint64 EosTxActionAck_EosPermissionLevel::permission() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.eos.EosTxActionAck.EosPermissionLevel.permission)
  return permission_;
}
inline void EosTxActionAck_EosPermissionLevel::set_permission(::google::protobuf::uint64 value) {
  _has_bits_[0] |= 0x00000002u;
  permission_ = value;
  // @@protoc_insertion_point(field_set:hw.trezor.messages.eos.EosTxActionAck.EosPermissionLevel.permission)
}

// -------------------------------------------------------------------

// EosTxActionAck_EosAuthorizationKey

// optional uint32 type = 1;
inline bool EosTxActionAck_EosAuthorizationKey::has_type() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void EosTxActionAck_EosAuthorizationKey::clear_type() {
  type_ = 0u;
  _has_bits_[0] &= ~0x00000002u;
}
inline ::google::protobuf::uint32 EosTxActionAck_EosAuthorizationKey::type() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.eos.EosTxActionAck.EosAuthorizationKey.type)
  return type_;
}
inline void EosTxActionAck_EosAuthorizationKey::set_type(::google::protobuf::uint32 value) {
  _has_bits_[0] |= 0x00000002u;
  type_ = value;
  // @@protoc_insertion_point(field_set:hw.trezor.messages.eos.EosTxActionAck.EosAuthorizationKey.type)
}

// optional bytes key = 2;
inline bool EosTxActionAck_EosAuthorizationKey::has_key() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void EosTxActionAck_EosAuthorizationKey::clear_key() {
  key_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::std::string& EosTxActionAck_EosAuthorizationKey::key() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.eos.EosTxActionAck.EosAuthorizationKey.key)
  return key_.GetNoArena();
}
inline void EosTxActionAck_EosAuthorizationKey::set_key(const ::std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:hw.trezor.messages.eos.EosTxActionAck.EosAuthorizationKey.key)
}
#if LANG_CXX11
inline void EosTxActionAck_EosAuthorizationKey::set_key(::std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  key_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:hw.trezor.messages.eos.EosTxActionAck.EosAuthorizationKey.key)
}
#endif
inline void EosTxActionAck_EosAuthorizationKey::set_key(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:hw.trezor.messages.eos.EosTxActionAck.EosAuthorizationKey.key)
}
inline void EosTxActionAck_EosAuthorizationKey::set_key(const void* value, size_t size) {
  _has_bits_[0] |= 0x00000001u;
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:hw.trezor.messages.eos.EosTxActionAck.EosAuthorizationKey.key)
}
inline ::std::string* EosTxActionAck_EosAuthorizationKey::mutable_key() {
  _has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_mutable:hw.trezor.messages.eos.EosTxActionAck.EosAuthorizationKey.key)
  return key_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* EosTxActionAck_EosAuthorizationKey::release_key() {
  // @@protoc_insertion_point(field_release:hw.trezor.messages.eos.EosTxActionAck.EosAuthorizationKey.key)
  if (!has_key()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return key_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void EosTxActionAck_EosAuthorizationKey::set_allocated_key(::std::string* key) {
  if (key != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  key_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), key);
  // @@protoc_insertion_point(field_set_allocated:hw.trezor.messages.eos.EosTxActionAck.EosAuthorizationKey.key)
}

// repeated uint32 address_n = 3;
inline int EosTxActionAck_EosAuthorizationKey::address_n_size() const {
  return address_n_.size();
}
inline void EosTxActionAck_EosAuthorizationKey::clear_address_n() {
  address_n_.Clear();
}
inline ::google::protobuf::uint32 EosTxActionAck_EosAuthorizationKey::address_n(int index) const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.eos.EosTxActionAck.EosAuthorizationKey.address_n)
  return address_n_.Get(index);
}
inline void EosTxActionAck_EosAuthorizationKey::set_address_n(int index, ::google::protobuf::uint32 value) {
  address_n_.Set(index, value);
  // @@protoc_insertion_point(field_set:hw.trezor.messages.eos.EosTxActionAck.EosAuthorizationKey.address_n)
}
inline void EosTxActionAck_EosAuthorizationKey::add_address_n(::google::protobuf::uint32 value) {
  address_n_.Add(value);
  // @@protoc_insertion_point(field_add:hw.trezor.messages.eos.EosTxActionAck.EosAuthorizationKey.address_n)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
EosTxActionAck_EosAuthorizationKey::address_n() const {
  // @@protoc_insertion_point(field_list:hw.trezor.messages.eos.EosTxActionAck.EosAuthorizationKey.address_n)
  return address_n_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
EosTxActionAck_EosAuthorizationKey::mutable_address_n() {
  // @@protoc_insertion_point(field_mutable_list:hw.trezor.messages.eos.EosTxActionAck.EosAuthorizationKey.address_n)
  return &address_n_;
}

// optional uint32 weight = 4;
inline bool EosTxActionAck_EosAuthorizationKey::has_weight() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void EosTxActionAck_EosAuthorizationKey::clear_weight() {
  weight_ = 0u;
  _has_bits_[0] &= ~0x00000004u;
}
inline ::google::protobuf::uint32 EosTxActionAck_EosAuthorizationKey::weight() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.eos.EosTxActionAck.EosAuthorizationKey.weight)
  return weight_;
}
inline void EosTxActionAck_EosAuthorizationKey::set_weight(::google::protobuf::uint32 value) {
  _has_bits_[0] |= 0x00000004u;
  weight_ = value;
  // @@protoc_insertion_point(field_set:hw.trezor.messages.eos.EosTxActionAck.EosAuthorizationKey.weight)
}

// -------------------------------------------------------------------

// EosTxActionAck_EosAuthorizationAccount

// optional .hw.trezor.messages.eos.EosTxActionAck.EosPermissionLevel account = 1;
inline bool EosTxActionAck_EosAuthorizationAccount::has_account() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void EosTxActionAck_EosAuthorizationAccount::clear_account() {
  if (account_ != nullptr) account_->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::hw::trezor::messages::eos::EosTxActionAck_EosPermissionLevel& EosTxActionAck_EosAuthorizationAccount::account() const {
  const ::hw::trezor::messages::eos::EosTxActionAck_EosPermissionLevel* p = account_;
  // @@protoc_insertion_point(field_get:hw.trezor.messages.eos.EosTxActionAck.EosAuthorizationAccount.account)
  return p != nullptr ? *p : *reinterpret_cast<const ::hw::trezor::messages::eos::EosTxActionAck_EosPermissionLevel*>(
      &::hw::trezor::messages::eos::_EosTxActionAck_EosPermissionLevel_default_instance_);
}
inline ::hw::trezor::messages::eos::EosTxActionAck_EosPermissionLevel* EosTxActionAck_EosAuthorizationAccount::release_account() {
  // @@protoc_insertion_point(field_release:hw.trezor.messages.eos.EosTxActionAck.EosAuthorizationAccount.account)
  _has_bits_[0] &= ~0x00000001u;
  ::hw::trezor::messages::eos::EosTxActionAck_EosPermissionLevel* temp = account_;
  account_ = nullptr;
  return temp;
}
inline ::hw::trezor::messages::eos::EosTxActionAck_EosPermissionLevel* EosTxActionAck_EosAuthorizationAccount::mutable_account() {
  _has_bits_[0] |= 0x00000001u;
  if (account_ == nullptr) {
    auto* p = CreateMaybeMessage<::hw::trezor::messages::eos::EosTxActionAck_EosPermissionLevel>(GetArenaNoVirtual());
    account_ = p;
  }
  // @@protoc_insertion_point(field_mutable:hw.trezor.messages.eos.EosTxActionAck.EosAuthorizationAccount.account)
  return account_;
}
inline void EosTxActionAck_EosAuthorizationAccount::set_allocated_account(::hw::trezor::messages::eos::EosTxActionAck_EosPermissionLevel* account) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete account_;
  }
  if (account) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      account = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, account, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  account_ = account;
  // @@protoc_insertion_point(field_set_allocated:hw.trezor.messages.eos.EosTxActionAck.EosAuthorizationAccount.account)
}

// optional uint32 weight = 2;
inline bool EosTxActionAck_EosAuthorizationAccount::has_weight() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void EosTxActionAck_EosAuthorizationAccount::clear_weight() {
  weight_ = 0u;
  _has_bits_[0] &= ~0x00000002u;
}
inline ::google::protobuf::uint32 EosTxActionAck_EosAuthorizationAccount::weight() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.eos.EosTxActionAck.EosAuthorizationAccount.weight)
  return weight_;
}
inline void EosTxActionAck_EosAuthorizationAccount::set_weight(::google::protobuf::uint32 value) {
  _has_bits_[0] |= 0x00000002u;
  weight_ = value;
  // @@protoc_insertion_point(field_set:hw.trezor.messages.eos.EosTxActionAck.EosAuthorizationAccount.weight)
}

// -------------------------------------------------------------------

// EosTxActionAck_EosAuthorizationWait

// optional uint32 wait_sec = 1;
inline bool EosTxActionAck_EosAuthorizationWait::has_wait_sec() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void EosTxActionAck_EosAuthorizationWait::clear_wait_sec() {
  wait_sec_ = 0u;
  _has_bits_[0] &= ~0x00000001u;
}
inline ::google::protobuf::uint32 EosTxActionAck_EosAuthorizationWait::wait_sec() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.eos.EosTxActionAck.EosAuthorizationWait.wait_sec)
  return wait_sec_;
}
inline void EosTxActionAck_EosAuthorizationWait::set_wait_sec(::google::protobuf::uint32 value) {
  _has_bits_[0] |= 0x00000001u;
  wait_sec_ = value;
  // @@protoc_insertion_point(field_set:hw.trezor.messages.eos.EosTxActionAck.EosAuthorizationWait.wait_sec)
}

// optional uint32 weight = 2;
inline bool EosTxActionAck_EosAuthorizationWait::has_weight() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void EosTxActionAck_EosAuthorizationWait::clear_weight() {
  weight_ = 0u;
  _has_bits_[0] &= ~0x00000002u;
}
inline ::google::protobuf::uint32 EosTxActionAck_EosAuthorizationWait::weight() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.eos.EosTxActionAck.EosAuthorizationWait.weight)
  return weight_;
}
inline void EosTxActionAck_EosAuthorizationWait::set_weight(::google::protobuf::uint32 value) {
  _has_bits_[0] |= 0x00000002u;
  weight_ = value;
  // @@protoc_insertion_point(field_set:hw.trezor.messages.eos.EosTxActionAck.EosAuthorizationWait.weight)
}

// -------------------------------------------------------------------

// EosTxActionAck_EosAuthorization

// optional uint32 threshold = 1;
inline bool EosTxActionAck_EosAuthorization::has_threshold() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void EosTxActionAck_EosAuthorization::clear_threshold() {
  threshold_ = 0u;
  _has_bits_[0] &= ~0x00000001u;
}
inline ::google::protobuf::uint32 EosTxActionAck_EosAuthorization::threshold() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.eos.EosTxActionAck.EosAuthorization.threshold)
  return threshold_;
}
inline void EosTxActionAck_EosAuthorization::set_threshold(::google::protobuf::uint32 value) {
  _has_bits_[0] |= 0x00000001u;
  threshold_ = value;
  // @@protoc_insertion_point(field_set:hw.trezor.messages.eos.EosTxActionAck.EosAuthorization.threshold)
}

// repeated .hw.trezor.messages.eos.EosTxActionAck.EosAuthorizationKey keys = 2;
inline int EosTxActionAck_EosAuthorization::keys_size() const {
  return keys_.size();
}
inline void EosTxActionAck_EosAuthorization::clear_keys() {
  keys_.Clear();
}
inline ::hw::trezor::messages::eos::EosTxActionAck_EosAuthorizationKey* EosTxActionAck_EosAuthorization::mutable_keys(int index) {
  // @@protoc_insertion_point(field_mutable:hw.trezor.messages.eos.EosTxActionAck.EosAuthorization.keys)
  return keys_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::hw::trezor::messages::eos::EosTxActionAck_EosAuthorizationKey >*
EosTxActionAck_EosAuthorization::mutable_keys() {
  // @@protoc_insertion_point(field_mutable_list:hw.trezor.messages.eos.EosTxActionAck.EosAuthorization.keys)
  return &keys_;
}
inline const ::hw::trezor::messages::eos::EosTxActionAck_EosAuthorizationKey& EosTxActionAck_EosAuthorization::keys(int index) const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.eos.EosTxActionAck.EosAuthorization.keys)
  return keys_.Get(index);
}
inline ::hw::trezor::messages::eos::EosTxActionAck_EosAuthorizationKey* EosTxActionAck_EosAuthorization::add_keys() {
  // @@protoc_insertion_point(field_add:hw.trezor.messages.eos.EosTxActionAck.EosAuthorization.keys)
  return keys_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::hw::trezor::messages::eos::EosTxActionAck_EosAuthorizationKey >&
EosTxActionAck_EosAuthorization::keys() const {
  // @@protoc_insertion_point(field_list:hw.trezor.messages.eos.EosTxActionAck.EosAuthorization.keys)
  return keys_;
}

// repeated .hw.trezor.messages.eos.EosTxActionAck.EosAuthorizationAccount accounts = 3;
inline int EosTxActionAck_EosAuthorization::accounts_size() const {
  return accounts_.size();
}
inline void EosTxActionAck_EosAuthorization::clear_accounts() {
  accounts_.Clear();
}
inline ::hw::trezor::messages::eos::EosTxActionAck_EosAuthorizationAccount* EosTxActionAck_EosAuthorization::mutable_accounts(int index) {
  // @@protoc_insertion_point(field_mutable:hw.trezor.messages.eos.EosTxActionAck.EosAuthorization.accounts)
  return accounts_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::hw::trezor::messages::eos::EosTxActionAck_EosAuthorizationAccount >*
EosTxActionAck_EosAuthorization::mutable_accounts() {
  // @@protoc_insertion_point(field_mutable_list:hw.trezor.messages.eos.EosTxActionAck.EosAuthorization.accounts)
  return &accounts_;
}
inline const ::hw::trezor::messages::eos::EosTxActionAck_EosAuthorizationAccount& EosTxActionAck_EosAuthorization::accounts(int index) const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.eos.EosTxActionAck.EosAuthorization.accounts)
  return accounts_.Get(index);
}
inline ::hw::trezor::messages::eos::EosTxActionAck_EosAuthorizationAccount* EosTxActionAck_EosAuthorization::add_accounts() {
  // @@protoc_insertion_point(field_add:hw.trezor.messages.eos.EosTxActionAck.EosAuthorization.accounts)
  return accounts_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::hw::trezor::messages::eos::EosTxActionAck_EosAuthorizationAccount >&
EosTxActionAck_EosAuthorization::accounts() const {
  // @@protoc_insertion_point(field_list:hw.trezor.messages.eos.EosTxActionAck.EosAuthorization.accounts)
  return accounts_;
}

// repeated .hw.trezor.messages.eos.EosTxActionAck.EosAuthorizationWait waits = 4;
inline int EosTxActionAck_EosAuthorization::waits_size() const {
  return waits_.size();
}
inline void EosTxActionAck_EosAuthorization::clear_waits() {
  waits_.Clear();
}
inline ::hw::trezor::messages::eos::EosTxActionAck_EosAuthorizationWait* EosTxActionAck_EosAuthorization::mutable_waits(int index) {
  // @@protoc_insertion_point(field_mutable:hw.trezor.messages.eos.EosTxActionAck.EosAuthorization.waits)
  return waits_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::hw::trezor::messages::eos::EosTxActionAck_EosAuthorizationWait >*
EosTxActionAck_EosAuthorization::mutable_waits() {
  // @@protoc_insertion_point(field_mutable_list:hw.trezor.messages.eos.EosTxActionAck.EosAuthorization.waits)
  return &waits_;
}
inline const ::hw::trezor::messages::eos::EosTxActionAck_EosAuthorizationWait& EosTxActionAck_EosAuthorization::waits(int index) const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.eos.EosTxActionAck.EosAuthorization.waits)
  return waits_.Get(index);
}
inline ::hw::trezor::messages::eos::EosTxActionAck_EosAuthorizationWait* EosTxActionAck_EosAuthorization::add_waits() {
  // @@protoc_insertion_point(field_add:hw.trezor.messages.eos.EosTxActionAck.EosAuthorization.waits)
  return waits_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::hw::trezor::messages::eos::EosTxActionAck_EosAuthorizationWait >&
EosTxActionAck_EosAuthorization::waits() const {
  // @@protoc_insertion_point(field_list:hw.trezor.messages.eos.EosTxActionAck.EosAuthorization.waits)
  return waits_;
}

// -------------------------------------------------------------------

// EosTxActionAck_EosActionCommon

// optional uint64 account = 1;
inline bool EosTxActionAck_EosActionCommon::has_account() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void EosTxActionAck_EosActionCommon::clear_account() {
  account_ = PROTOBUF_ULONGLONG(0);
  _has_bits_[0] &= ~0x00000001u;
}
inline ::google::protobuf::uint64 EosTxActionAck_EosActionCommon::account() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.eos.EosTxActionAck.EosActionCommon.account)
  return account_;
}
inline void EosTxActionAck_EosActionCommon::set_account(::google::protobuf::uint64 value) {
  _has_bits_[0] |= 0x00000001u;
  account_ = value;
  // @@protoc_insertion_point(field_set:hw.trezor.messages.eos.EosTxActionAck.EosActionCommon.account)
}

// optional uint64 name = 2;
inline bool EosTxActionAck_EosActionCommon::has_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void EosTxActionAck_EosActionCommon::clear_name() {
  name_ = PROTOBUF_ULONGLONG(0);
  _has_bits_[0] &= ~0x00000002u;
}
inline ::google::protobuf::uint64 EosTxActionAck_EosActionCommon::name() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.eos.EosTxActionAck.EosActionCommon.name)
  return name_;
}
inline void EosTxActionAck_EosActionCommon::set_name(::google::protobuf::uint64 value) {
  _has_bits_[0] |= 0x00000002u;
  name_ = value;
  // @@protoc_insertion_point(field_set:hw.trezor.messages.eos.EosTxActionAck.EosActionCommon.name)
}

// repeated .hw.trezor.messages.eos.EosTxActionAck.EosPermissionLevel authorization = 3;
inline int EosTxActionAck_EosActionCommon::authorization_size() const {
  return authorization_.size();
}
inline void EosTxActionAck_EosActionCommon::clear_authorization() {
  authorization_.Clear();
}
inline ::hw::trezor::messages::eos::EosTxActionAck_EosPermissionLevel* EosTxActionAck_EosActionCommon::mutable_authorization(int index) {
  // @@protoc_insertion_point(field_mutable:hw.trezor.messages.eos.EosTxActionAck.EosActionCommon.authorization)
  return authorization_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::hw::trezor::messages::eos::EosTxActionAck_EosPermissionLevel >*
EosTxActionAck_EosActionCommon::mutable_authorization() {
  // @@protoc_insertion_point(field_mutable_list:hw.trezor.messages.eos.EosTxActionAck.EosActionCommon.authorization)
  return &authorization_;
}
inline const ::hw::trezor::messages::eos::EosTxActionAck_EosPermissionLevel& EosTxActionAck_EosActionCommon::authorization(int index) const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.eos.EosTxActionAck.EosActionCommon.authorization)
  return authorization_.Get(index);
}
inline ::hw::trezor::messages::eos::EosTxActionAck_EosPermissionLevel* EosTxActionAck_EosActionCommon::add_authorization() {
  // @@protoc_insertion_point(field_add:hw.trezor.messages.eos.EosTxActionAck.EosActionCommon.authorization)
  return authorization_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::hw::trezor::messages::eos::EosTxActionAck_EosPermissionLevel >&
EosTxActionAck_EosActionCommon::authorization() const {
  // @@protoc_insertion_point(field_list:hw.trezor.messages.eos.EosTxActionAck.EosActionCommon.authorization)
  return authorization_;
}

// -------------------------------------------------------------------

// EosTxActionAck_EosActionTransfer

// optional uint64 sender = 1;
inline bool EosTxActionAck_EosActionTransfer::has_sender() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void EosTxActionAck_EosActionTransfer::clear_sender() {
  sender_ = PROTOBUF_ULONGLONG(0);
  _has_bits_[0] &= ~0x00000004u;
}
inline ::google::protobuf::uint64 EosTxActionAck_EosActionTransfer::sender() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.eos.EosTxActionAck.EosActionTransfer.sender)
  return sender_;
}
inline void EosTxActionAck_EosActionTransfer::set_sender(::google::protobuf::uint64 value) {
  _has_bits_[0] |= 0x00000004u;
  sender_ = value;
  // @@protoc_insertion_point(field_set:hw.trezor.messages.eos.EosTxActionAck.EosActionTransfer.sender)
}

// optional uint64 receiver = 2;
inline bool EosTxActionAck_EosActionTransfer::has_receiver() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void EosTxActionAck_EosActionTransfer::clear_receiver() {
  receiver_ = PROTOBUF_ULONGLONG(0);
  _has_bits_[0] &= ~0x00000008u;
}
inline ::google::protobuf::uint64 EosTxActionAck_EosActionTransfer::receiver() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.eos.EosTxActionAck.EosActionTransfer.receiver)
  return receiver_;
}
inline void EosTxActionAck_EosActionTransfer::set_receiver(::google::protobuf::uint64 value) {
  _has_bits_[0] |= 0x00000008u;
  receiver_ = value;
  // @@protoc_insertion_point(field_set:hw.trezor.messages.eos.EosTxActionAck.EosActionTransfer.receiver)
}

// optional .hw.trezor.messages.eos.EosTxActionAck.EosAsset quantity = 3;
inline bool EosTxActionAck_EosActionTransfer::has_quantity() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void EosTxActionAck_EosActionTransfer::clear_quantity() {
  if (quantity_ != nullptr) quantity_->Clear();
  _has_bits_[0] &= ~0x00000002u;
}
inline const ::hw::trezor::messages::eos::EosTxActionAck_EosAsset& EosTxActionAck_EosActionTransfer::quantity() const {
  const ::hw::trezor::messages::eos::EosTxActionAck_EosAsset* p = quantity_;
  // @@protoc_insertion_point(field_get:hw.trezor.messages.eos.EosTxActionAck.EosActionTransfer.quantity)
  return p != nullptr ? *p : *reinterpret_cast<const ::hw::trezor::messages::eos::EosTxActionAck_EosAsset*>(
      &::hw::trezor::messages::eos::_EosTxActionAck_EosAsset_default_instance_);
}
inline ::hw::trezor::messages::eos::EosTxActionAck_EosAsset* EosTxActionAck_EosActionTransfer::release_quantity() {
  // @@protoc_insertion_point(field_release:hw.trezor.messages.eos.EosTxActionAck.EosActionTransfer.quantity)
  _has_bits_[0] &= ~0x00000002u;
  ::hw::trezor::messages::eos::EosTxActionAck_EosAsset* temp = quantity_;
  quantity_ = nullptr;
  return temp;
}
inline ::hw::trezor::messages::eos::EosTxActionAck_EosAsset* EosTxActionAck_EosActionTransfer::mutable_quantity() {
  _has_bits_[0] |= 0x00000002u;
  if (quantity_ == nullptr) {
    auto* p = CreateMaybeMessage<::hw::trezor::messages::eos::EosTxActionAck_EosAsset>(GetArenaNoVirtual());
    quantity_ = p;
  }
  // @@protoc_insertion_point(field_mutable:hw.trezor.messages.eos.EosTxActionAck.EosActionTransfer.quantity)
  return quantity_;
}
inline void EosTxActionAck_EosActionTransfer::set_allocated_quantity(::hw::trezor::messages::eos::EosTxActionAck_EosAsset* quantity) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete quantity_;
  }
  if (quantity) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      quantity = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, quantity, submessage_arena);
    }
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  quantity_ = quantity;
  // @@protoc_insertion_point(field_set_allocated:hw.trezor.messages.eos.EosTxActionAck.EosActionTransfer.quantity)
}

// optional string memo = 4;
inline bool EosTxActionAck_EosActionTransfer::has_memo() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void EosTxActionAck_EosActionTransfer::clear_memo() {
  memo_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::std::string& EosTxActionAck_EosActionTransfer::memo() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.eos.EosTxActionAck.EosActionTransfer.memo)
  return memo_.GetNoArena();
}
inline void EosTxActionAck_EosActionTransfer::set_memo(const ::std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  memo_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:hw.trezor.messages.eos.EosTxActionAck.EosActionTransfer.memo)
}
#if LANG_CXX11
inline void EosTxActionAck_EosActionTransfer::set_memo(::std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  memo_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:hw.trezor.messages.eos.EosTxActionAck.EosActionTransfer.memo)
}
#endif
inline void EosTxActionAck_EosActionTransfer::set_memo(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  memo_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:hw.trezor.messages.eos.EosTxActionAck.EosActionTransfer.memo)
}
inline void EosTxActionAck_EosActionTransfer::set_memo(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000001u;
  memo_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:hw.trezor.messages.eos.EosTxActionAck.EosActionTransfer.memo)
}
inline ::std::string* EosTxActionAck_EosActionTransfer::mutable_memo() {
  _has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_mutable:hw.trezor.messages.eos.EosTxActionAck.EosActionTransfer.memo)
  return memo_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* EosTxActionAck_EosActionTransfer::release_memo() {
  // @@protoc_insertion_point(field_release:hw.trezor.messages.eos.EosTxActionAck.EosActionTransfer.memo)
  if (!has_memo()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return memo_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void EosTxActionAck_EosActionTransfer::set_allocated_memo(::std::string* memo) {
  if (memo != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  memo_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), memo);
  // @@protoc_insertion_point(field_set_allocated:hw.trezor.messages.eos.EosTxActionAck.EosActionTransfer.memo)
}

// -------------------------------------------------------------------

// EosTxActionAck_EosActionDelegate

// optional uint64 sender = 1;
inline bool EosTxActionAck_EosActionDelegate::has_sender() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void EosTxActionAck_EosActionDelegate::clear_sender() {
  sender_ = PROTOBUF_ULONGLONG(0);
  _has_bits_[0] &= ~0x00000004u;
}
inline ::google::protobuf::uint64 EosTxActionAck_EosActionDelegate::sender() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.eos.EosTxActionAck.EosActionDelegate.sender)
  return sender_;
}
inline void EosTxActionAck_EosActionDelegate::set_sender(::google::protobuf::uint64 value) {
  _has_bits_[0] |= 0x00000004u;
  sender_ = value;
  // @@protoc_insertion_point(field_set:hw.trezor.messages.eos.EosTxActionAck.EosActionDelegate.sender)
}

// optional uint64 receiver = 2;
inline bool EosTxActionAck_EosActionDelegate::has_receiver() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void EosTxActionAck_EosActionDelegate::clear_receiver() {
  receiver_ = PROTOBUF_ULONGLONG(0);
  _has_bits_[0] &= ~0x00000008u;
}
inline ::google::protobuf::uint64 EosTxActionAck_EosActionDelegate::receiver() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.eos.EosTxActionAck.EosActionDelegate.receiver)
  return receiver_;
}
inline void EosTxActionAck_EosActionDelegate::set_receiver(::google::protobuf::uint64 value) {
  _has_bits_[0] |= 0x00000008u;
  receiver_ = value;
  // @@protoc_insertion_point(field_set:hw.trezor.messages.eos.EosTxActionAck.EosActionDelegate.receiver)
}

// optional .hw.trezor.messages.eos.EosTxActionAck.EosAsset net_quantity = 3;
inline bool EosTxActionAck_EosActionDelegate::has_net_quantity() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void EosTxActionAck_EosActionDelegate::clear_net_quantity() {
  if (net_quantity_ != nullptr) net_quantity_->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::hw::trezor::messages::eos::EosTxActionAck_EosAsset& EosTxActionAck_EosActionDelegate::net_quantity() const {
  const ::hw::trezor::messages::eos::EosTxActionAck_EosAsset* p = net_quantity_;
  // @@protoc_insertion_point(field_get:hw.trezor.messages.eos.EosTxActionAck.EosActionDelegate.net_quantity)
  return p != nullptr ? *p : *reinterpret_cast<const ::hw::trezor::messages::eos::EosTxActionAck_EosAsset*>(
      &::hw::trezor::messages::eos::_EosTxActionAck_EosAsset_default_instance_);
}
inline ::hw::trezor::messages::eos::EosTxActionAck_EosAsset* EosTxActionAck_EosActionDelegate::release_net_quantity() {
  // @@protoc_insertion_point(field_release:hw.trezor.messages.eos.EosTxActionAck.EosActionDelegate.net_quantity)
  _has_bits_[0] &= ~0x00000001u;
  ::hw::trezor::messages::eos::EosTxActionAck_EosAsset* temp = net_quantity_;
  net_quantity_ = nullptr;
  return temp;
}
inline ::hw::trezor::messages::eos::EosTxActionAck_EosAsset* EosTxActionAck_EosActionDelegate::mutable_net_quantity() {
  _has_bits_[0] |= 0x00000001u;
  if (net_quantity_ == nullptr) {
    auto* p = CreateMaybeMessage<::hw::trezor::messages::eos::EosTxActionAck_EosAsset>(GetArenaNoVirtual());
    net_quantity_ = p;
  }
  // @@protoc_insertion_point(field_mutable:hw.trezor.messages.eos.EosTxActionAck.EosActionDelegate.net_quantity)
  return net_quantity_;
}
inline void EosTxActionAck_EosActionDelegate::set_allocated_net_quantity(::hw::trezor::messages::eos::EosTxActionAck_EosAsset* net_quantity) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete net_quantity_;
  }
  if (net_quantity) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      net_quantity = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, net_quantity, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  net_quantity_ = net_quantity;
  // @@protoc_insertion_point(field_set_allocated:hw.trezor.messages.eos.EosTxActionAck.EosActionDelegate.net_quantity)
}

// optional .hw.trezor.messages.eos.EosTxActionAck.EosAsset cpu_quantity = 4;
inline bool EosTxActionAck_EosActionDelegate::has_cpu_quantity() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void EosTxActionAck_EosActionDelegate::clear_cpu_quantity() {
  if (cpu_quantity_ != nullptr) cpu_quantity_->Clear();
  _has_bits_[0] &= ~0x00000002u;
}
inline const ::hw::trezor::messages::eos::EosTxActionAck_EosAsset& EosTxActionAck_EosActionDelegate::cpu_quantity() const {
  const ::hw::trezor::messages::eos::EosTxActionAck_EosAsset* p = cpu_quantity_;
  // @@protoc_insertion_point(field_get:hw.trezor.messages.eos.EosTxActionAck.EosActionDelegate.cpu_quantity)
  return p != nullptr ? *p : *reinterpret_cast<const ::hw::trezor::messages::eos::EosTxActionAck_EosAsset*>(
      &::hw::trezor::messages::eos::_EosTxActionAck_EosAsset_default_instance_);
}
inline ::hw::trezor::messages::eos::EosTxActionAck_EosAsset* EosTxActionAck_EosActionDelegate::release_cpu_quantity() {
  // @@protoc_insertion_point(field_release:hw.trezor.messages.eos.EosTxActionAck.EosActionDelegate.cpu_quantity)
  _has_bits_[0] &= ~0x00000002u;
  ::hw::trezor::messages::eos::EosTxActionAck_EosAsset* temp = cpu_quantity_;
  cpu_quantity_ = nullptr;
  return temp;
}
inline ::hw::trezor::messages::eos::EosTxActionAck_EosAsset* EosTxActionAck_EosActionDelegate::mutable_cpu_quantity() {
  _has_bits_[0] |= 0x00000002u;
  if (cpu_quantity_ == nullptr) {
    auto* p = CreateMaybeMessage<::hw::trezor::messages::eos::EosTxActionAck_EosAsset>(GetArenaNoVirtual());
    cpu_quantity_ = p;
  }
  // @@protoc_insertion_point(field_mutable:hw.trezor.messages.eos.EosTxActionAck.EosActionDelegate.cpu_quantity)
  return cpu_quantity_;
}
inline void EosTxActionAck_EosActionDelegate::set_allocated_cpu_quantity(::hw::trezor::messages::eos::EosTxActionAck_EosAsset* cpu_quantity) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete cpu_quantity_;
  }
  if (cpu_quantity) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      cpu_quantity = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, cpu_quantity, submessage_arena);
    }
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  cpu_quantity_ = cpu_quantity;
  // @@protoc_insertion_point(field_set_allocated:hw.trezor.messages.eos.EosTxActionAck.EosActionDelegate.cpu_quantity)
}

// optional bool transfer = 5;
inline bool EosTxActionAck_EosActionDelegate::has_transfer() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void EosTxActionAck_EosActionDelegate::clear_transfer() {
  transfer_ = false;
  _has_bits_[0] &= ~0x00000010u;
}
inline bool EosTxActionAck_EosActionDelegate::transfer() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.eos.EosTxActionAck.EosActionDelegate.transfer)
  return transfer_;
}
inline void EosTxActionAck_EosActionDelegate::set_transfer(bool value) {
  _has_bits_[0] |= 0x00000010u;
  transfer_ = value;
  // @@protoc_insertion_point(field_set:hw.trezor.messages.eos.EosTxActionAck.EosActionDelegate.transfer)
}

// -------------------------------------------------------------------

// EosTxActionAck_EosActionUndelegate

// optional uint64 sender = 1;
inline bool EosTxActionAck_EosActionUndelegate::has_sender() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void EosTxActionAck_EosActionUndelegate::clear_sender() {
  sender_ = PROTOBUF_ULONGLONG(0);
  _has_bits_[0] &= ~0x00000004u;
}
inline ::google::protobuf::uint64 EosTxActionAck_EosActionUndelegate::sender() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.eos.EosTxActionAck.EosActionUndelegate.sender)
  return sender_;
}
inline void EosTxActionAck_EosActionUndelegate::set_sender(::google::protobuf::uint64 value) {
  _has_bits_[0] |= 0x00000004u;
  sender_ = value;
  // @@protoc_insertion_point(field_set:hw.trezor.messages.eos.EosTxActionAck.EosActionUndelegate.sender)
}

// optional uint64 receiver = 2;
inline bool EosTxActionAck_EosActionUndelegate::has_receiver() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void EosTxActionAck_EosActionUndelegate::clear_receiver() {
  receiver_ = PROTOBUF_ULONGLONG(0);
  _has_bits_[0] &= ~0x00000008u;
}
inline ::google::protobuf::uint64 EosTxActionAck_EosActionUndelegate::receiver() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.eos.EosTxActionAck.EosActionUndelegate.receiver)
  return receiver_;
}
inline void EosTxActionAck_EosActionUndelegate::set_receiver(::google::protobuf::uint64 value) {
  _has_bits_[0] |= 0x00000008u;
  receiver_ = value;
  // @@protoc_insertion_point(field_set:hw.trezor.messages.eos.EosTxActionAck.EosActionUndelegate.receiver)
}

// optional .hw.trezor.messages.eos.EosTxActionAck.EosAsset net_quantity = 3;
inline bool EosTxActionAck_EosActionUndelegate::has_net_quantity() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void EosTxActionAck_EosActionUndelegate::clear_net_quantity() {
  if (net_quantity_ != nullptr) net_quantity_->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::hw::trezor::messages::eos::EosTxActionAck_EosAsset& EosTxActionAck_EosActionUndelegate::net_quantity() const {
  const ::hw::trezor::messages::eos::EosTxActionAck_EosAsset* p = net_quantity_;
  // @@protoc_insertion_point(field_get:hw.trezor.messages.eos.EosTxActionAck.EosActionUndelegate.net_quantity)
  return p != nullptr ? *p : *reinterpret_cast<const ::hw::trezor::messages::eos::EosTxActionAck_EosAsset*>(
      &::hw::trezor::messages::eos::_EosTxActionAck_EosAsset_default_instance_);
}
inline ::hw::trezor::messages::eos::EosTxActionAck_EosAsset* EosTxActionAck_EosActionUndelegate::release_net_quantity() {
  // @@protoc_insertion_point(field_release:hw.trezor.messages.eos.EosTxActionAck.EosActionUndelegate.net_quantity)
  _has_bits_[0] &= ~0x00000001u;
  ::hw::trezor::messages::eos::EosTxActionAck_EosAsset* temp = net_quantity_;
  net_quantity_ = nullptr;
  return temp;
}
inline ::hw::trezor::messages::eos::EosTxActionAck_EosAsset* EosTxActionAck_EosActionUndelegate::mutable_net_quantity() {
  _has_bits_[0] |= 0x00000001u;
  if (net_quantity_ == nullptr) {
    auto* p = CreateMaybeMessage<::hw::trezor::messages::eos::EosTxActionAck_EosAsset>(GetArenaNoVirtual());
    net_quantity_ = p;
  }
  // @@protoc_insertion_point(field_mutable:hw.trezor.messages.eos.EosTxActionAck.EosActionUndelegate.net_quantity)
  return net_quantity_;
}
inline void EosTxActionAck_EosActionUndelegate::set_allocated_net_quantity(::hw::trezor::messages::eos::EosTxActionAck_EosAsset* net_quantity) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete net_quantity_;
  }
  if (net_quantity) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      net_quantity = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, net_quantity, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  net_quantity_ = net_quantity;
  // @@protoc_insertion_point(field_set_allocated:hw.trezor.messages.eos.EosTxActionAck.EosActionUndelegate.net_quantity)
}

// optional .hw.trezor.messages.eos.EosTxActionAck.EosAsset cpu_quantity = 4;
inline bool EosTxActionAck_EosActionUndelegate::has_cpu_quantity() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void EosTxActionAck_EosActionUndelegate::clear_cpu_quantity() {
  if (cpu_quantity_ != nullptr) cpu_quantity_->Clear();
  _has_bits_[0] &= ~0x00000002u;
}
inline const ::hw::trezor::messages::eos::EosTxActionAck_EosAsset& EosTxActionAck_EosActionUndelegate::cpu_quantity() const {
  const ::hw::trezor::messages::eos::EosTxActionAck_EosAsset* p = cpu_quantity_;
  // @@protoc_insertion_point(field_get:hw.trezor.messages.eos.EosTxActionAck.EosActionUndelegate.cpu_quantity)
  return p != nullptr ? *p : *reinterpret_cast<const ::hw::trezor::messages::eos::EosTxActionAck_EosAsset*>(
      &::hw::trezor::messages::eos::_EosTxActionAck_EosAsset_default_instance_);
}
inline ::hw::trezor::messages::eos::EosTxActionAck_EosAsset* EosTxActionAck_EosActionUndelegate::release_cpu_quantity() {
  // @@protoc_insertion_point(field_release:hw.trezor.messages.eos.EosTxActionAck.EosActionUndelegate.cpu_quantity)
  _has_bits_[0] &= ~0x00000002u;
  ::hw::trezor::messages::eos::EosTxActionAck_EosAsset* temp = cpu_quantity_;
  cpu_quantity_ = nullptr;
  return temp;
}
inline ::hw::trezor::messages::eos::EosTxActionAck_EosAsset* EosTxActionAck_EosActionUndelegate::mutable_cpu_quantity() {
  _has_bits_[0] |= 0x00000002u;
  if (cpu_quantity_ == nullptr) {
    auto* p = CreateMaybeMessage<::hw::trezor::messages::eos::EosTxActionAck_EosAsset>(GetArenaNoVirtual());
    cpu_quantity_ = p;
  }
  // @@protoc_insertion_point(field_mutable:hw.trezor.messages.eos.EosTxActionAck.EosActionUndelegate.cpu_quantity)
  return cpu_quantity_;
}
inline void EosTxActionAck_EosActionUndelegate::set_allocated_cpu_quantity(::hw::trezor::messages::eos::EosTxActionAck_EosAsset* cpu_quantity) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete cpu_quantity_;
  }
  if (cpu_quantity) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      cpu_quantity = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, cpu_quantity, submessage_arena);
    }
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  cpu_quantity_ = cpu_quantity;
  // @@protoc_insertion_point(field_set_allocated:hw.trezor.messages.eos.EosTxActionAck.EosActionUndelegate.cpu_quantity)
}

// -------------------------------------------------------------------

// EosTxActionAck_EosActionRefund

// optional uint64 owner = 1;
inline bool EosTxActionAck_EosActionRefund::has_owner() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void EosTxActionAck_EosActionRefund::clear_owner() {
  owner_ = PROTOBUF_ULONGLONG(0);
  _has_bits_[0] &= ~0x00000001u;
}
inline ::google::protobuf::uint64 EosTxActionAck_EosActionRefund::owner() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.eos.EosTxActionAck.EosActionRefund.owner)
  return owner_;
}
inline void EosTxActionAck_EosActionRefund::set_owner(::google::protobuf::uint64 value) {
  _has_bits_[0] |= 0x00000001u;
  owner_ = value;
  // @@protoc_insertion_point(field_set:hw.trezor.messages.eos.EosTxActionAck.EosActionRefund.owner)
}

// -------------------------------------------------------------------

// EosTxActionAck_EosActionBuyRam

// optional uint64 payer = 1;
inline bool EosTxActionAck_EosActionBuyRam::has_payer() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void EosTxActionAck_EosActionBuyRam::clear_payer() {
  payer_ = PROTOBUF_ULONGLONG(0);
  _has_bits_[0] &= ~0x00000002u;
}
inline ::google::protobuf::uint64 EosTxActionAck_EosActionBuyRam::payer() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.eos.EosTxActionAck.EosActionBuyRam.payer)
  return payer_;
}
inline void EosTxActionAck_EosActionBuyRam::set_payer(::google::protobuf::uint64 value) {
  _has_bits_[0] |= 0x00000002u;
  payer_ = value;
  // @@protoc_insertion_point(field_set:hw.trezor.messages.eos.EosTxActionAck.EosActionBuyRam.payer)
}

// optional uint64 receiver = 2;
inline bool EosTxActionAck_EosActionBuyRam::has_receiver() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void EosTxActionAck_EosActionBuyRam::clear_receiver() {
  receiver_ = PROTOBUF_ULONGLONG(0);
  _has_bits_[0] &= ~0x00000004u;
}
inline ::google::protobuf::uint64 EosTxActionAck_EosActionBuyRam::receiver() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.eos.EosTxActionAck.EosActionBuyRam.receiver)
  return receiver_;
}
inline void EosTxActionAck_EosActionBuyRam::set_receiver(::google::protobuf::uint64 value) {
  _has_bits_[0] |= 0x00000004u;
  receiver_ = value;
  // @@protoc_insertion_point(field_set:hw.trezor.messages.eos.EosTxActionAck.EosActionBuyRam.receiver)
}

// optional .hw.trezor.messages.eos.EosTxActionAck.EosAsset quantity = 3;
inline bool EosTxActionAck_EosActionBuyRam::has_quantity() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void EosTxActionAck_EosActionBuyRam::clear_quantity() {
  if (quantity_ != nullptr) quantity_->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::hw::trezor::messages::eos::EosTxActionAck_EosAsset& EosTxActionAck_EosActionBuyRam::quantity() const {
  const ::hw::trezor::messages::eos::EosTxActionAck_EosAsset* p = quantity_;
  // @@protoc_insertion_point(field_get:hw.trezor.messages.eos.EosTxActionAck.EosActionBuyRam.quantity)
  return p != nullptr ? *p : *reinterpret_cast<const ::hw::trezor::messages::eos::EosTxActionAck_EosAsset*>(
      &::hw::trezor::messages::eos::_EosTxActionAck_EosAsset_default_instance_);
}
inline ::hw::trezor::messages::eos::EosTxActionAck_EosAsset* EosTxActionAck_EosActionBuyRam::release_quantity() {
  // @@protoc_insertion_point(field_release:hw.trezor.messages.eos.EosTxActionAck.EosActionBuyRam.quantity)
  _has_bits_[0] &= ~0x00000001u;
  ::hw::trezor::messages::eos::EosTxActionAck_EosAsset* temp = quantity_;
  quantity_ = nullptr;
  return temp;
}
inline ::hw::trezor::messages::eos::EosTxActionAck_EosAsset* EosTxActionAck_EosActionBuyRam::mutable_quantity() {
  _has_bits_[0] |= 0x00000001u;
  if (quantity_ == nullptr) {
    auto* p = CreateMaybeMessage<::hw::trezor::messages::eos::EosTxActionAck_EosAsset>(GetArenaNoVirtual());
    quantity_ = p;
  }
  // @@protoc_insertion_point(field_mutable:hw.trezor.messages.eos.EosTxActionAck.EosActionBuyRam.quantity)
  return quantity_;
}
inline void EosTxActionAck_EosActionBuyRam::set_allocated_quantity(::hw::trezor::messages::eos::EosTxActionAck_EosAsset* quantity) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete quantity_;
  }
  if (quantity) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      quantity = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, quantity, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  quantity_ = quantity;
  // @@protoc_insertion_point(field_set_allocated:hw.trezor.messages.eos.EosTxActionAck.EosActionBuyRam.quantity)
}

// -------------------------------------------------------------------

// EosTxActionAck_EosActionBuyRamBytes

// optional uint64 payer = 1;
inline bool EosTxActionAck_EosActionBuyRamBytes::has_payer() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void EosTxActionAck_EosActionBuyRamBytes::clear_payer() {
  payer_ = PROTOBUF_ULONGLONG(0);
  _has_bits_[0] &= ~0x00000001u;
}
inline ::google::protobuf::uint64 EosTxActionAck_EosActionBuyRamBytes::payer() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.eos.EosTxActionAck.EosActionBuyRamBytes.payer)
  return payer_;
}
inline void EosTxActionAck_EosActionBuyRamBytes::set_payer(::google::protobuf::uint64 value) {
  _has_bits_[0] |= 0x00000001u;
  payer_ = value;
  // @@protoc_insertion_point(field_set:hw.trezor.messages.eos.EosTxActionAck.EosActionBuyRamBytes.payer)
}

// optional uint64 receiver = 2;
inline bool EosTxActionAck_EosActionBuyRamBytes::has_receiver() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void EosTxActionAck_EosActionBuyRamBytes::clear_receiver() {
  receiver_ = PROTOBUF_ULONGLONG(0);
  _has_bits_[0] &= ~0x00000002u;
}
inline ::google::protobuf::uint64 EosTxActionAck_EosActionBuyRamBytes::receiver() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.eos.EosTxActionAck.EosActionBuyRamBytes.receiver)
  return receiver_;
}
inline void EosTxActionAck_EosActionBuyRamBytes::set_receiver(::google::protobuf::uint64 value) {
  _has_bits_[0] |= 0x00000002u;
  receiver_ = value;
  // @@protoc_insertion_point(field_set:hw.trezor.messages.eos.EosTxActionAck.EosActionBuyRamBytes.receiver)
}

// optional uint32 bytes = 3;
inline bool EosTxActionAck_EosActionBuyRamBytes::has_bytes() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void EosTxActionAck_EosActionBuyRamBytes::clear_bytes() {
  bytes_ = 0u;
  _has_bits_[0] &= ~0x00000004u;
}
inline ::google::protobuf::uint32 EosTxActionAck_EosActionBuyRamBytes::bytes() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.eos.EosTxActionAck.EosActionBuyRamBytes.bytes)
  return bytes_;
}
inline void EosTxActionAck_EosActionBuyRamBytes::set_bytes(::google::protobuf::uint32 value) {
  _has_bits_[0] |= 0x00000004u;
  bytes_ = value;
  // @@protoc_insertion_point(field_set:hw.trezor.messages.eos.EosTxActionAck.EosActionBuyRamBytes.bytes)
}

// -------------------------------------------------------------------

// EosTxActionAck_EosActionSellRam

// optional uint64 account = 1;
inline bool EosTxActionAck_EosActionSellRam::has_account() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void EosTxActionAck_EosActionSellRam::clear_account() {
  account_ = PROTOBUF_ULONGLONG(0);
  _has_bits_[0] &= ~0x00000001u;
}
inline ::google::protobuf::uint64 EosTxActionAck_EosActionSellRam::account() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.eos.EosTxActionAck.EosActionSellRam.account)
  return account_;
}
inline void EosTxActionAck_EosActionSellRam::set_account(::google::protobuf::uint64 value) {
  _has_bits_[0] |= 0x00000001u;
  account_ = value;
  // @@protoc_insertion_point(field_set:hw.trezor.messages.eos.EosTxActionAck.EosActionSellRam.account)
}

// optional uint64 bytes = 2;
inline bool EosTxActionAck_EosActionSellRam::has_bytes() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void EosTxActionAck_EosActionSellRam::clear_bytes() {
  bytes_ = PROTOBUF_ULONGLONG(0);
  _has_bits_[0] &= ~0x00000002u;
}
inline ::google::protobuf::uint64 EosTxActionAck_EosActionSellRam::bytes() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.eos.EosTxActionAck.EosActionSellRam.bytes)
  return bytes_;
}
inline void EosTxActionAck_EosActionSellRam::set_bytes(::google::protobuf::uint64 value) {
  _has_bits_[0] |= 0x00000002u;
  bytes_ = value;
  // @@protoc_insertion_point(field_set:hw.trezor.messages.eos.EosTxActionAck.EosActionSellRam.bytes)
}

// -------------------------------------------------------------------

// EosTxActionAck_EosActionVoteProducer

// optional uint64 voter = 1;
inline bool EosTxActionAck_EosActionVoteProducer::has_voter() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void EosTxActionAck_EosActionVoteProducer::clear_voter() {
  voter_ = PROTOBUF_ULONGLONG(0);
  _has_bits_[0] &= ~0x00000001u;
}
inline ::google::protobuf::uint64 EosTxActionAck_EosActionVoteProducer::voter() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.eos.EosTxActionAck.EosActionVoteProducer.voter)
  return voter_;
}
inline void EosTxActionAck_EosActionVoteProducer::set_voter(::google::protobuf::uint64 value) {
  _has_bits_[0] |= 0x00000001u;
  voter_ = value;
  // @@protoc_insertion_point(field_set:hw.trezor.messages.eos.EosTxActionAck.EosActionVoteProducer.voter)
}

// optional uint64 proxy = 2;
inline bool EosTxActionAck_EosActionVoteProducer::has_proxy() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void EosTxActionAck_EosActionVoteProducer::clear_proxy() {
  proxy_ = PROTOBUF_ULONGLONG(0);
  _has_bits_[0] &= ~0x00000002u;
}
inline ::google::protobuf::uint64 EosTxActionAck_EosActionVoteProducer::proxy() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.eos.EosTxActionAck.EosActionVoteProducer.proxy)
  return proxy_;
}
inline void EosTxActionAck_EosActionVoteProducer::set_proxy(::google::protobuf::uint64 value) {
  _has_bits_[0] |= 0x00000002u;
  proxy_ = value;
  // @@protoc_insertion_point(field_set:hw.trezor.messages.eos.EosTxActionAck.EosActionVoteProducer.proxy)
}

// repeated uint64 producers = 3;
inline int EosTxActionAck_EosActionVoteProducer::producers_size() const {
  return producers_.size();
}
inline void EosTxActionAck_EosActionVoteProducer::clear_producers() {
  producers_.Clear();
}
inline ::google::protobuf::uint64 EosTxActionAck_EosActionVoteProducer::producers(int index) const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.eos.EosTxActionAck.EosActionVoteProducer.producers)
  return producers_.Get(index);
}
inline void EosTxActionAck_EosActionVoteProducer::set_producers(int index, ::google::protobuf::uint64 value) {
  producers_.Set(index, value);
  // @@protoc_insertion_point(field_set:hw.trezor.messages.eos.EosTxActionAck.EosActionVoteProducer.producers)
}
inline void EosTxActionAck_EosActionVoteProducer::add_producers(::google::protobuf::uint64 value) {
  producers_.Add(value);
  // @@protoc_insertion_point(field_add:hw.trezor.messages.eos.EosTxActionAck.EosActionVoteProducer.producers)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >&
EosTxActionAck_EosActionVoteProducer::producers() const {
  // @@protoc_insertion_point(field_list:hw.trezor.messages.eos.EosTxActionAck.EosActionVoteProducer.producers)
  return producers_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >*
EosTxActionAck_EosActionVoteProducer::mutable_producers() {
  // @@protoc_insertion_point(field_mutable_list:hw.trezor.messages.eos.EosTxActionAck.EosActionVoteProducer.producers)
  return &producers_;
}

// -------------------------------------------------------------------

// EosTxActionAck_EosActionUpdateAuth

// optional uint64 account = 1;
inline bool EosTxActionAck_EosActionUpdateAuth::has_account() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void EosTxActionAck_EosActionUpdateAuth::clear_account() {
  account_ = PROTOBUF_ULONGLONG(0);
  _has_bits_[0] &= ~0x00000002u;
}
inline ::google::protobuf::uint64 EosTxActionAck_EosActionUpdateAuth::account() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.eos.EosTxActionAck.EosActionUpdateAuth.account)
  return account_;
}
inline void EosTxActionAck_EosActionUpdateAuth::set_account(::google::protobuf::uint64 value) {
  _has_bits_[0] |= 0x00000002u;
  account_ = value;
  // @@protoc_insertion_point(field_set:hw.trezor.messages.eos.EosTxActionAck.EosActionUpdateAuth.account)
}

// optional uint64 permission = 2;
inline bool EosTxActionAck_EosActionUpdateAuth::has_permission() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void EosTxActionAck_EosActionUpdateAuth::clear_permission() {
  permission_ = PROTOBUF_ULONGLONG(0);
  _has_bits_[0] &= ~0x00000004u;
}
inline ::google::protobuf::uint64 EosTxActionAck_EosActionUpdateAuth::permission() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.eos.EosTxActionAck.EosActionUpdateAuth.permission)
  return permission_;
}
inline void EosTxActionAck_EosActionUpdateAuth::set_permission(::google::protobuf::uint64 value) {
  _has_bits_[0] |= 0x00000004u;
  permission_ = value;
  // @@protoc_insertion_point(field_set:hw.trezor.messages.eos.EosTxActionAck.EosActionUpdateAuth.permission)
}

// optional uint64 parent = 3;
inline bool EosTxActionAck_EosActionUpdateAuth::has_parent() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void EosTxActionAck_EosActionUpdateAuth::clear_parent() {
  parent_ = PROTOBUF_ULONGLONG(0);
  _has_bits_[0] &= ~0x00000008u;
}
inline ::google::protobuf::uint64 EosTxActionAck_EosActionUpdateAuth::parent() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.eos.EosTxActionAck.EosActionUpdateAuth.parent)
  return parent_;
}
inline void EosTxActionAck_EosActionUpdateAuth::set_parent(::google::protobuf::uint64 value) {
  _has_bits_[0] |= 0x00000008u;
  parent_ = value;
  // @@protoc_insertion_point(field_set:hw.trezor.messages.eos.EosTxActionAck.EosActionUpdateAuth.parent)
}

// optional .hw.trezor.messages.eos.EosTxActionAck.EosAuthorization auth = 4;
inline bool EosTxActionAck_EosActionUpdateAuth::has_auth() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void EosTxActionAck_EosActionUpdateAuth::clear_auth() {
  if (auth_ != nullptr) auth_->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::hw::trezor::messages::eos::EosTxActionAck_EosAuthorization& EosTxActionAck_EosActionUpdateAuth::auth() const {
  const ::hw::trezor::messages::eos::EosTxActionAck_EosAuthorization* p = auth_;
  // @@protoc_insertion_point(field_get:hw.trezor.messages.eos.EosTxActionAck.EosActionUpdateAuth.auth)
  return p != nullptr ? *p : *reinterpret_cast<const ::hw::trezor::messages::eos::EosTxActionAck_EosAuthorization*>(
      &::hw::trezor::messages::eos::_EosTxActionAck_EosAuthorization_default_instance_);
}
inline ::hw::trezor::messages::eos::EosTxActionAck_EosAuthorization* EosTxActionAck_EosActionUpdateAuth::release_auth() {
  // @@protoc_insertion_point(field_release:hw.trezor.messages.eos.EosTxActionAck.EosActionUpdateAuth.auth)
  _has_bits_[0] &= ~0x00000001u;
  ::hw::trezor::messages::eos::EosTxActionAck_EosAuthorization* temp = auth_;
  auth_ = nullptr;
  return temp;
}
inline ::hw::trezor::messages::eos::EosTxActionAck_EosAuthorization* EosTxActionAck_EosActionUpdateAuth::mutable_auth() {
  _has_bits_[0] |= 0x00000001u;
  if (auth_ == nullptr) {
    auto* p = CreateMaybeMessage<::hw::trezor::messages::eos::EosTxActionAck_EosAuthorization>(GetArenaNoVirtual());
    auth_ = p;
  }
  // @@protoc_insertion_point(field_mutable:hw.trezor.messages.eos.EosTxActionAck.EosActionUpdateAuth.auth)
  return auth_;
}
inline void EosTxActionAck_EosActionUpdateAuth::set_allocated_auth(::hw::trezor::messages::eos::EosTxActionAck_EosAuthorization* auth) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete auth_;
  }
  if (auth) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      auth = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, auth, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  auth_ = auth;
  // @@protoc_insertion_point(field_set_allocated:hw.trezor.messages.eos.EosTxActionAck.EosActionUpdateAuth.auth)
}

// -------------------------------------------------------------------

// EosTxActionAck_EosActionDeleteAuth

// optional uint64 account = 1;
inline bool EosTxActionAck_EosActionDeleteAuth::has_account() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void EosTxActionAck_EosActionDeleteAuth::clear_account() {
  account_ = PROTOBUF_ULONGLONG(0);
  _has_bits_[0] &= ~0x00000001u;
}
inline ::google::protobuf::uint64 EosTxActionAck_EosActionDeleteAuth::account() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.eos.EosTxActionAck.EosActionDeleteAuth.account)
  return account_;
}
inline void EosTxActionAck_EosActionDeleteAuth::set_account(::google::protobuf::uint64 value) {
  _has_bits_[0] |= 0x00000001u;
  account_ = value;
  // @@protoc_insertion_point(field_set:hw.trezor.messages.eos.EosTxActionAck.EosActionDeleteAuth.account)
}

// optional uint64 permission = 2;
inline bool EosTxActionAck_EosActionDeleteAuth::has_permission() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void EosTxActionAck_EosActionDeleteAuth::clear_permission() {
  permission_ = PROTOBUF_ULONGLONG(0);
  _has_bits_[0] &= ~0x00000002u;
}
inline ::google::protobuf::uint64 EosTxActionAck_EosActionDeleteAuth::permission() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.eos.EosTxActionAck.EosActionDeleteAuth.permission)
  return permission_;
}
inline void EosTxActionAck_EosActionDeleteAuth::set_permission(::google::protobuf::uint64 value) {
  _has_bits_[0] |= 0x00000002u;
  permission_ = value;
  // @@protoc_insertion_point(field_set:hw.trezor.messages.eos.EosTxActionAck.EosActionDeleteAuth.permission)
}

// -------------------------------------------------------------------

// EosTxActionAck_EosActionLinkAuth

// optional uint64 account = 1;
inline bool EosTxActionAck_EosActionLinkAuth::has_account() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void EosTxActionAck_EosActionLinkAuth::clear_account() {
  account_ = PROTOBUF_ULONGLONG(0);
  _has_bits_[0] &= ~0x00000001u;
}
inline ::google::protobuf::uint64 EosTxActionAck_EosActionLinkAuth::account() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.eos.EosTxActionAck.EosActionLinkAuth.account)
  return account_;
}
inline void EosTxActionAck_EosActionLinkAuth::set_account(::google::protobuf::uint64 value) {
  _has_bits_[0] |= 0x00000001u;
  account_ = value;
  // @@protoc_insertion_point(field_set:hw.trezor.messages.eos.EosTxActionAck.EosActionLinkAuth.account)
}

// optional uint64 code = 2;
inline bool EosTxActionAck_EosActionLinkAuth::has_code() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void EosTxActionAck_EosActionLinkAuth::clear_code() {
  code_ = PROTOBUF_ULONGLONG(0);
  _has_bits_[0] &= ~0x00000002u;
}
inline ::google::protobuf::uint64 EosTxActionAck_EosActionLinkAuth::code() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.eos.EosTxActionAck.EosActionLinkAuth.code)
  return code_;
}
inline void EosTxActionAck_EosActionLinkAuth::set_code(::google::protobuf::uint64 value) {
  _has_bits_[0] |= 0x00000002u;
  code_ = value;
  // @@protoc_insertion_point(field_set:hw.trezor.messages.eos.EosTxActionAck.EosActionLinkAuth.code)
}

// optional uint64 type = 3;
inline bool EosTxActionAck_EosActionLinkAuth::has_type() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void EosTxActionAck_EosActionLinkAuth::clear_type() {
  type_ = PROTOBUF_ULONGLONG(0);
  _has_bits_[0] &= ~0x00000004u;
}
inline ::google::protobuf::uint64 EosTxActionAck_EosActionLinkAuth::type() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.eos.EosTxActionAck.EosActionLinkAuth.type)
  return type_;
}
inline void EosTxActionAck_EosActionLinkAuth::set_type(::google::protobuf::uint64 value) {
  _has_bits_[0] |= 0x00000004u;
  type_ = value;
  // @@protoc_insertion_point(field_set:hw.trezor.messages.eos.EosTxActionAck.EosActionLinkAuth.type)
}

// optional uint64 requirement = 4;
inline bool EosTxActionAck_EosActionLinkAuth::has_requirement() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void EosTxActionAck_EosActionLinkAuth::clear_requirement() {
  requirement_ = PROTOBUF_ULONGLONG(0);
  _has_bits_[0] &= ~0x00000008u;
}
inline ::google::protobuf::uint64 EosTxActionAck_EosActionLinkAuth::requirement() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.eos.EosTxActionAck.EosActionLinkAuth.requirement)
  return requirement_;
}
inline void EosTxActionAck_EosActionLinkAuth::set_requirement(::google::protobuf::uint64 value) {
  _has_bits_[0] |= 0x00000008u;
  requirement_ = value;
  // @@protoc_insertion_point(field_set:hw.trezor.messages.eos.EosTxActionAck.EosActionLinkAuth.requirement)
}

// -------------------------------------------------------------------

// EosTxActionAck_EosActionUnlinkAuth

// optional uint64 account = 1;
inline bool EosTxActionAck_EosActionUnlinkAuth::has_account() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void EosTxActionAck_EosActionUnlinkAuth::clear_account() {
  account_ = PROTOBUF_ULONGLONG(0);
  _has_bits_[0] &= ~0x00000001u;
}
inline ::google::protobuf::uint64 EosTxActionAck_EosActionUnlinkAuth::account() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.eos.EosTxActionAck.EosActionUnlinkAuth.account)
  return account_;
}
inline void EosTxActionAck_EosActionUnlinkAuth::set_account(::google::protobuf::uint64 value) {
  _has_bits_[0] |= 0x00000001u;
  account_ = value;
  // @@protoc_insertion_point(field_set:hw.trezor.messages.eos.EosTxActionAck.EosActionUnlinkAuth.account)
}

// optional uint64 code = 2;
inline bool EosTxActionAck_EosActionUnlinkAuth::has_code() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void EosTxActionAck_EosActionUnlinkAuth::clear_code() {
  code_ = PROTOBUF_ULONGLONG(0);
  _has_bits_[0] &= ~0x00000002u;
}
inline ::google::protobuf::uint64 EosTxActionAck_EosActionUnlinkAuth::code() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.eos.EosTxActionAck.EosActionUnlinkAuth.code)
  return code_;
}
inline void EosTxActionAck_EosActionUnlinkAuth::set_code(::google::protobuf::uint64 value) {
  _has_bits_[0] |= 0x00000002u;
  code_ = value;
  // @@protoc_insertion_point(field_set:hw.trezor.messages.eos.EosTxActionAck.EosActionUnlinkAuth.code)
}

// optional uint64 type = 3;
inline bool EosTxActionAck_EosActionUnlinkAuth::has_type() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void EosTxActionAck_EosActionUnlinkAuth::clear_type() {
  type_ = PROTOBUF_ULONGLONG(0);
  _has_bits_[0] &= ~0x00000004u;
}
inline ::google::protobuf::uint64 EosTxActionAck_EosActionUnlinkAuth::type() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.eos.EosTxActionAck.EosActionUnlinkAuth.type)
  return type_;
}
inline void EosTxActionAck_EosActionUnlinkAuth::set_type(::google::protobuf::uint64 value) {
  _has_bits_[0] |= 0x00000004u;
  type_ = value;
  // @@protoc_insertion_point(field_set:hw.trezor.messages.eos.EosTxActionAck.EosActionUnlinkAuth.type)
}

// -------------------------------------------------------------------

// EosTxActionAck_EosActionNewAccount

// optional uint64 creator = 1;
inline bool EosTxActionAck_EosActionNewAccount::has_creator() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void EosTxActionAck_EosActionNewAccount::clear_creator() {
  creator_ = PROTOBUF_ULONGLONG(0);
  _has_bits_[0] &= ~0x00000004u;
}
inline ::google::protobuf::uint64 EosTxActionAck_EosActionNewAccount::creator() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.eos.EosTxActionAck.EosActionNewAccount.creator)
  return creator_;
}
inline void EosTxActionAck_EosActionNewAccount::set_creator(::google::protobuf::uint64 value) {
  _has_bits_[0] |= 0x00000004u;
  creator_ = value;
  // @@protoc_insertion_point(field_set:hw.trezor.messages.eos.EosTxActionAck.EosActionNewAccount.creator)
}

// optional uint64 name = 2;
inline bool EosTxActionAck_EosActionNewAccount::has_name() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void EosTxActionAck_EosActionNewAccount::clear_name() {
  name_ = PROTOBUF_ULONGLONG(0);
  _has_bits_[0] &= ~0x00000008u;
}
inline ::google::protobuf::uint64 EosTxActionAck_EosActionNewAccount::name() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.eos.EosTxActionAck.EosActionNewAccount.name)
  return name_;
}
inline void EosTxActionAck_EosActionNewAccount::set_name(::google::protobuf::uint64 value) {
  _has_bits_[0] |= 0x00000008u;
  name_ = value;
  // @@protoc_insertion_point(field_set:hw.trezor.messages.eos.EosTxActionAck.EosActionNewAccount.name)
}

// optional .hw.trezor.messages.eos.EosTxActionAck.EosAuthorization owner = 3;
inline bool EosTxActionAck_EosActionNewAccount::has_owner() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void EosTxActionAck_EosActionNewAccount::clear_owner() {
  if (owner_ != nullptr) owner_->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::hw::trezor::messages::eos::EosTxActionAck_EosAuthorization& EosTxActionAck_EosActionNewAccount::owner() const {
  const ::hw::trezor::messages::eos::EosTxActionAck_EosAuthorization* p = owner_;
  // @@protoc_insertion_point(field_get:hw.trezor.messages.eos.EosTxActionAck.EosActionNewAccount.owner)
  return p != nullptr ? *p : *reinterpret_cast<const ::hw::trezor::messages::eos::EosTxActionAck_EosAuthorization*>(
      &::hw::trezor::messages::eos::_EosTxActionAck_EosAuthorization_default_instance_);
}
inline ::hw::trezor::messages::eos::EosTxActionAck_EosAuthorization* EosTxActionAck_EosActionNewAccount::release_owner() {
  // @@protoc_insertion_point(field_release:hw.trezor.messages.eos.EosTxActionAck.EosActionNewAccount.owner)
  _has_bits_[0] &= ~0x00000001u;
  ::hw::trezor::messages::eos::EosTxActionAck_EosAuthorization* temp = owner_;
  owner_ = nullptr;
  return temp;
}
inline ::hw::trezor::messages::eos::EosTxActionAck_EosAuthorization* EosTxActionAck_EosActionNewAccount::mutable_owner() {
  _has_bits_[0] |= 0x00000001u;
  if (owner_ == nullptr) {
    auto* p = CreateMaybeMessage<::hw::trezor::messages::eos::EosTxActionAck_EosAuthorization>(GetArenaNoVirtual());
    owner_ = p;
  }
  // @@protoc_insertion_point(field_mutable:hw.trezor.messages.eos.EosTxActionAck.EosActionNewAccount.owner)
  return owner_;
}
inline void EosTxActionAck_EosActionNewAccount::set_allocated_owner(::hw::trezor::messages::eos::EosTxActionAck_EosAuthorization* owner) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete owner_;
  }
  if (owner) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      owner = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, owner, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  owner_ = owner;
  // @@protoc_insertion_point(field_set_allocated:hw.trezor.messages.eos.EosTxActionAck.EosActionNewAccount.owner)
}

// optional .hw.trezor.messages.eos.EosTxActionAck.EosAuthorization active = 4;
inline bool EosTxActionAck_EosActionNewAccount::has_active() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void EosTxActionAck_EosActionNewAccount::clear_active() {
  if (active_ != nullptr) active_->Clear();
  _has_bits_[0] &= ~0x00000002u;
}
inline const ::hw::trezor::messages::eos::EosTxActionAck_EosAuthorization& EosTxActionAck_EosActionNewAccount::active() const {
  const ::hw::trezor::messages::eos::EosTxActionAck_EosAuthorization* p = active_;
  // @@protoc_insertion_point(field_get:hw.trezor.messages.eos.EosTxActionAck.EosActionNewAccount.active)
  return p != nullptr ? *p : *reinterpret_cast<const ::hw::trezor::messages::eos::EosTxActionAck_EosAuthorization*>(
      &::hw::trezor::messages::eos::_EosTxActionAck_EosAuthorization_default_instance_);
}
inline ::hw::trezor::messages::eos::EosTxActionAck_EosAuthorization* EosTxActionAck_EosActionNewAccount::release_active() {
  // @@protoc_insertion_point(field_release:hw.trezor.messages.eos.EosTxActionAck.EosActionNewAccount.active)
  _has_bits_[0] &= ~0x00000002u;
  ::hw::trezor::messages::eos::EosTxActionAck_EosAuthorization* temp = active_;
  active_ = nullptr;
  return temp;
}
inline ::hw::trezor::messages::eos::EosTxActionAck_EosAuthorization* EosTxActionAck_EosActionNewAccount::mutable_active() {
  _has_bits_[0] |= 0x00000002u;
  if (active_ == nullptr) {
    auto* p = CreateMaybeMessage<::hw::trezor::messages::eos::EosTxActionAck_EosAuthorization>(GetArenaNoVirtual());
    active_ = p;
  }
  // @@protoc_insertion_point(field_mutable:hw.trezor.messages.eos.EosTxActionAck.EosActionNewAccount.active)
  return active_;
}
inline void EosTxActionAck_EosActionNewAccount::set_allocated_active(::hw::trezor::messages::eos::EosTxActionAck_EosAuthorization* active) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete active_;
  }
  if (active) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      active = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, active, submessage_arena);
    }
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  active_ = active;
  // @@protoc_insertion_point(field_set_allocated:hw.trezor.messages.eos.EosTxActionAck.EosActionNewAccount.active)
}

// -------------------------------------------------------------------

// EosTxActionAck_EosActionUnknown

// optional uint32 data_size = 1;
inline bool EosTxActionAck_EosActionUnknown::has_data_size() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void EosTxActionAck_EosActionUnknown::clear_data_size() {
  data_size_ = 0u;
  _has_bits_[0] &= ~0x00000002u;
}
inline ::google::protobuf::uint32 EosTxActionAck_EosActionUnknown::data_size() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.eos.EosTxActionAck.EosActionUnknown.data_size)
  return data_size_;
}
inline void EosTxActionAck_EosActionUnknown::set_data_size(::google::protobuf::uint32 value) {
  _has_bits_[0] |= 0x00000002u;
  data_size_ = value;
  // @@protoc_insertion_point(field_set:hw.trezor.messages.eos.EosTxActionAck.EosActionUnknown.data_size)
}

// optional bytes data_chunk = 2;
inline bool EosTxActionAck_EosActionUnknown::has_data_chunk() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void EosTxActionAck_EosActionUnknown::clear_data_chunk() {
  data_chunk_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::std::string& EosTxActionAck_EosActionUnknown::data_chunk() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.eos.EosTxActionAck.EosActionUnknown.data_chunk)
  return data_chunk_.GetNoArena();
}
inline void EosTxActionAck_EosActionUnknown::set_data_chunk(const ::std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  data_chunk_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:hw.trezor.messages.eos.EosTxActionAck.EosActionUnknown.data_chunk)
}
#if LANG_CXX11
inline void EosTxActionAck_EosActionUnknown::set_data_chunk(::std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  data_chunk_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:hw.trezor.messages.eos.EosTxActionAck.EosActionUnknown.data_chunk)
}
#endif
inline void EosTxActionAck_EosActionUnknown::set_data_chunk(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  data_chunk_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:hw.trezor.messages.eos.EosTxActionAck.EosActionUnknown.data_chunk)
}
inline void EosTxActionAck_EosActionUnknown::set_data_chunk(const void* value, size_t size) {
  _has_bits_[0] |= 0x00000001u;
  data_chunk_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:hw.trezor.messages.eos.EosTxActionAck.EosActionUnknown.data_chunk)
}
inline ::std::string* EosTxActionAck_EosActionUnknown::mutable_data_chunk() {
  _has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_mutable:hw.trezor.messages.eos.EosTxActionAck.EosActionUnknown.data_chunk)
  return data_chunk_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* EosTxActionAck_EosActionUnknown::release_data_chunk() {
  // @@protoc_insertion_point(field_release:hw.trezor.messages.eos.EosTxActionAck.EosActionUnknown.data_chunk)
  if (!has_data_chunk()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return data_chunk_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void EosTxActionAck_EosActionUnknown::set_allocated_data_chunk(::std::string* data_chunk) {
  if (data_chunk != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  data_chunk_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), data_chunk);
  // @@protoc_insertion_point(field_set_allocated:hw.trezor.messages.eos.EosTxActionAck.EosActionUnknown.data_chunk)
}

// -------------------------------------------------------------------

// EosTxActionAck

// optional .hw.trezor.messages.eos.EosTxActionAck.EosActionCommon common = 1;
inline bool EosTxActionAck::has_common() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void EosTxActionAck::clear_common() {
  if (common_ != nullptr) common_->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::hw::trezor::messages::eos::EosTxActionAck_EosActionCommon& EosTxActionAck::common() const {
  const ::hw::trezor::messages::eos::EosTxActionAck_EosActionCommon* p = common_;
  // @@protoc_insertion_point(field_get:hw.trezor.messages.eos.EosTxActionAck.common)
  return p != nullptr ? *p : *reinterpret_cast<const ::hw::trezor::messages::eos::EosTxActionAck_EosActionCommon*>(
      &::hw::trezor::messages::eos::_EosTxActionAck_EosActionCommon_default_instance_);
}
inline ::hw::trezor::messages::eos::EosTxActionAck_EosActionCommon* EosTxActionAck::release_common() {
  // @@protoc_insertion_point(field_release:hw.trezor.messages.eos.EosTxActionAck.common)
  _has_bits_[0] &= ~0x00000001u;
  ::hw::trezor::messages::eos::EosTxActionAck_EosActionCommon* temp = common_;
  common_ = nullptr;
  return temp;
}
inline ::hw::trezor::messages::eos::EosTxActionAck_EosActionCommon* EosTxActionAck::mutable_common() {
  _has_bits_[0] |= 0x00000001u;
  if (common_ == nullptr) {
    auto* p = CreateMaybeMessage<::hw::trezor::messages::eos::EosTxActionAck_EosActionCommon>(GetArenaNoVirtual());
    common_ = p;
  }
  // @@protoc_insertion_point(field_mutable:hw.trezor.messages.eos.EosTxActionAck.common)
  return common_;
}
inline void EosTxActionAck::set_allocated_common(::hw::trezor::messages::eos::EosTxActionAck_EosActionCommon* common) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete common_;
  }
  if (common) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      common = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, common, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  common_ = common;
  // @@protoc_insertion_point(field_set_allocated:hw.trezor.messages.eos.EosTxActionAck.common)
}

// optional .hw.trezor.messages.eos.EosTxActionAck.EosActionTransfer transfer = 2;
inline bool EosTxActionAck::has_transfer() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void EosTxActionAck::clear_transfer() {
  if (transfer_ != nullptr) transfer_->Clear();
  _has_bits_[0] &= ~0x00000002u;
}
inline const ::hw::trezor::messages::eos::EosTxActionAck_EosActionTransfer& EosTxActionAck::transfer() const {
  const ::hw::trezor::messages::eos::EosTxActionAck_EosActionTransfer* p = transfer_;
  // @@protoc_insertion_point(field_get:hw.trezor.messages.eos.EosTxActionAck.transfer)
  return p != nullptr ? *p : *reinterpret_cast<const ::hw::trezor::messages::eos::EosTxActionAck_EosActionTransfer*>(
      &::hw::trezor::messages::eos::_EosTxActionAck_EosActionTransfer_default_instance_);
}
inline ::hw::trezor::messages::eos::EosTxActionAck_EosActionTransfer* EosTxActionAck::release_transfer() {
  // @@protoc_insertion_point(field_release:hw.trezor.messages.eos.EosTxActionAck.transfer)
  _has_bits_[0] &= ~0x00000002u;
  ::hw::trezor::messages::eos::EosTxActionAck_EosActionTransfer* temp = transfer_;
  transfer_ = nullptr;
  return temp;
}
inline ::hw::trezor::messages::eos::EosTxActionAck_EosActionTransfer* EosTxActionAck::mutable_transfer() {
  _has_bits_[0] |= 0x00000002u;
  if (transfer_ == nullptr) {
    auto* p = CreateMaybeMessage<::hw::trezor::messages::eos::EosTxActionAck_EosActionTransfer>(GetArenaNoVirtual());
    transfer_ = p;
  }
  // @@protoc_insertion_point(field_mutable:hw.trezor.messages.eos.EosTxActionAck.transfer)
  return transfer_;
}
inline void EosTxActionAck::set_allocated_transfer(::hw::trezor::messages::eos::EosTxActionAck_EosActionTransfer* transfer) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete transfer_;
  }
  if (transfer) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      transfer = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, transfer, submessage_arena);
    }
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  transfer_ = transfer;
  // @@protoc_insertion_point(field_set_allocated:hw.trezor.messages.eos.EosTxActionAck.transfer)
}

// optional .hw.trezor.messages.eos.EosTxActionAck.EosActionDelegate delegate = 3;
inline bool EosTxActionAck::has_delegate() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void EosTxActionAck::clear_delegate() {
  if (delegate_ != nullptr) delegate_->Clear();
  _has_bits_[0] &= ~0x00000004u;
}
inline const ::hw::trezor::messages::eos::EosTxActionAck_EosActionDelegate& EosTxActionAck::delegate() const {
  const ::hw::trezor::messages::eos::EosTxActionAck_EosActionDelegate* p = delegate_;
  // @@protoc_insertion_point(field_get:hw.trezor.messages.eos.EosTxActionAck.delegate)
  return p != nullptr ? *p : *reinterpret_cast<const ::hw::trezor::messages::eos::EosTxActionAck_EosActionDelegate*>(
      &::hw::trezor::messages::eos::_EosTxActionAck_EosActionDelegate_default_instance_);
}
inline ::hw::trezor::messages::eos::EosTxActionAck_EosActionDelegate* EosTxActionAck::release_delegate() {
  // @@protoc_insertion_point(field_release:hw.trezor.messages.eos.EosTxActionAck.delegate)
  _has_bits_[0] &= ~0x00000004u;
  ::hw::trezor::messages::eos::EosTxActionAck_EosActionDelegate* temp = delegate_;
  delegate_ = nullptr;
  return temp;
}
inline ::hw::trezor::messages::eos::EosTxActionAck_EosActionDelegate* EosTxActionAck::mutable_delegate() {
  _has_bits_[0] |= 0x00000004u;
  if (delegate_ == nullptr) {
    auto* p = CreateMaybeMessage<::hw::trezor::messages::eos::EosTxActionAck_EosActionDelegate>(GetArenaNoVirtual());
    delegate_ = p;
  }
  // @@protoc_insertion_point(field_mutable:hw.trezor.messages.eos.EosTxActionAck.delegate)
  return delegate_;
}
inline void EosTxActionAck::set_allocated_delegate(::hw::trezor::messages::eos::EosTxActionAck_EosActionDelegate* delegate) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete delegate_;
  }
  if (delegate) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      delegate = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, delegate, submessage_arena);
    }
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  delegate_ = delegate;
  // @@protoc_insertion_point(field_set_allocated:hw.trezor.messages.eos.EosTxActionAck.delegate)
}

// optional .hw.trezor.messages.eos.EosTxActionAck.EosActionUndelegate undelegate = 4;
inline bool EosTxActionAck::has_undelegate() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void EosTxActionAck::clear_undelegate() {
  if (undelegate_ != nullptr) undelegate_->Clear();
  _has_bits_[0] &= ~0x00000008u;
}
inline const ::hw::trezor::messages::eos::EosTxActionAck_EosActionUndelegate& EosTxActionAck::undelegate() const {
  const ::hw::trezor::messages::eos::EosTxActionAck_EosActionUndelegate* p = undelegate_;
  // @@protoc_insertion_point(field_get:hw.trezor.messages.eos.EosTxActionAck.undelegate)
  return p != nullptr ? *p : *reinterpret_cast<const ::hw::trezor::messages::eos::EosTxActionAck_EosActionUndelegate*>(
      &::hw::trezor::messages::eos::_EosTxActionAck_EosActionUndelegate_default_instance_);
}
inline ::hw::trezor::messages::eos::EosTxActionAck_EosActionUndelegate* EosTxActionAck::release_undelegate() {
  // @@protoc_insertion_point(field_release:hw.trezor.messages.eos.EosTxActionAck.undelegate)
  _has_bits_[0] &= ~0x00000008u;
  ::hw::trezor::messages::eos::EosTxActionAck_EosActionUndelegate* temp = undelegate_;
  undelegate_ = nullptr;
  return temp;
}
inline ::hw::trezor::messages::eos::EosTxActionAck_EosActionUndelegate* EosTxActionAck::mutable_undelegate() {
  _has_bits_[0] |= 0x00000008u;
  if (undelegate_ == nullptr) {
    auto* p = CreateMaybeMessage<::hw::trezor::messages::eos::EosTxActionAck_EosActionUndelegate>(GetArenaNoVirtual());
    undelegate_ = p;
  }
  // @@protoc_insertion_point(field_mutable:hw.trezor.messages.eos.EosTxActionAck.undelegate)
  return undelegate_;
}
inline void EosTxActionAck::set_allocated_undelegate(::hw::trezor::messages::eos::EosTxActionAck_EosActionUndelegate* undelegate) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete undelegate_;
  }
  if (undelegate) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      undelegate = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, undelegate, submessage_arena);
    }
    _has_bits_[0] |= 0x00000008u;
  } else {
    _has_bits_[0] &= ~0x00000008u;
  }
  undelegate_ = undelegate;
  // @@protoc_insertion_point(field_set_allocated:hw.trezor.messages.eos.EosTxActionAck.undelegate)
}

// optional .hw.trezor.messages.eos.EosTxActionAck.EosActionRefund refund = 5;
inline bool EosTxActionAck::has_refund() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void EosTxActionAck::clear_refund() {
  if (refund_ != nullptr) refund_->Clear();
  _has_bits_[0] &= ~0x00000010u;
}
inline const ::hw::trezor::messages::eos::EosTxActionAck_EosActionRefund& EosTxActionAck::refund() const {
  const ::hw::trezor::messages::eos::EosTxActionAck_EosActionRefund* p = refund_;
  // @@protoc_insertion_point(field_get:hw.trezor.messages.eos.EosTxActionAck.refund)
  return p != nullptr ? *p : *reinterpret_cast<const ::hw::trezor::messages::eos::EosTxActionAck_EosActionRefund*>(
      &::hw::trezor::messages::eos::_EosTxActionAck_EosActionRefund_default_instance_);
}
inline ::hw::trezor::messages::eos::EosTxActionAck_EosActionRefund* EosTxActionAck::release_refund() {
  // @@protoc_insertion_point(field_release:hw.trezor.messages.eos.EosTxActionAck.refund)
  _has_bits_[0] &= ~0x00000010u;
  ::hw::trezor::messages::eos::EosTxActionAck_EosActionRefund* temp = refund_;
  refund_ = nullptr;
  return temp;
}
inline ::hw::trezor::messages::eos::EosTxActionAck_EosActionRefund* EosTxActionAck::mutable_refund() {
  _has_bits_[0] |= 0x00000010u;
  if (refund_ == nullptr) {
    auto* p = CreateMaybeMessage<::hw::trezor::messages::eos::EosTxActionAck_EosActionRefund>(GetArenaNoVirtual());
    refund_ = p;
  }
  // @@protoc_insertion_point(field_mutable:hw.trezor.messages.eos.EosTxActionAck.refund)
  return refund_;
}
inline void EosTxActionAck::set_allocated_refund(::hw::trezor::messages::eos::EosTxActionAck_EosActionRefund* refund) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete refund_;
  }
  if (refund) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      refund = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, refund, submessage_arena);
    }
    _has_bits_[0] |= 0x00000010u;
  } else {
    _has_bits_[0] &= ~0x00000010u;
  }
  refund_ = refund;
  // @@protoc_insertion_point(field_set_allocated:hw.trezor.messages.eos.EosTxActionAck.refund)
}

// optional .hw.trezor.messages.eos.EosTxActionAck.EosActionBuyRam buy_ram = 6;
inline bool EosTxActionAck::has_buy_ram() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void EosTxActionAck::clear_buy_ram() {
  if (buy_ram_ != nullptr) buy_ram_->Clear();
  _has_bits_[0] &= ~0x00000020u;
}
inline const ::hw::trezor::messages::eos::EosTxActionAck_EosActionBuyRam& EosTxActionAck::buy_ram() const {
  const ::hw::trezor::messages::eos::EosTxActionAck_EosActionBuyRam* p = buy_ram_;
  // @@protoc_insertion_point(field_get:hw.trezor.messages.eos.EosTxActionAck.buy_ram)
  return p != nullptr ? *p : *reinterpret_cast<const ::hw::trezor::messages::eos::EosTxActionAck_EosActionBuyRam*>(
      &::hw::trezor::messages::eos::_EosTxActionAck_EosActionBuyRam_default_instance_);
}
inline ::hw::trezor::messages::eos::EosTxActionAck_EosActionBuyRam* EosTxActionAck::release_buy_ram() {
  // @@protoc_insertion_point(field_release:hw.trezor.messages.eos.EosTxActionAck.buy_ram)
  _has_bits_[0] &= ~0x00000020u;
  ::hw::trezor::messages::eos::EosTxActionAck_EosActionBuyRam* temp = buy_ram_;
  buy_ram_ = nullptr;
  return temp;
}
inline ::hw::trezor::messages::eos::EosTxActionAck_EosActionBuyRam* EosTxActionAck::mutable_buy_ram() {
  _has_bits_[0] |= 0x00000020u;
  if (buy_ram_ == nullptr) {
    auto* p = CreateMaybeMessage<::hw::trezor::messages::eos::EosTxActionAck_EosActionBuyRam>(GetArenaNoVirtual());
    buy_ram_ = p;
  }
  // @@protoc_insertion_point(field_mutable:hw.trezor.messages.eos.EosTxActionAck.buy_ram)
  return buy_ram_;
}
inline void EosTxActionAck::set_allocated_buy_ram(::hw::trezor::messages::eos::EosTxActionAck_EosActionBuyRam* buy_ram) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete buy_ram_;
  }
  if (buy_ram) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      buy_ram = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, buy_ram, submessage_arena);
    }
    _has_bits_[0] |= 0x00000020u;
  } else {
    _has_bits_[0] &= ~0x00000020u;
  }
  buy_ram_ = buy_ram;
  // @@protoc_insertion_point(field_set_allocated:hw.trezor.messages.eos.EosTxActionAck.buy_ram)
}

// optional .hw.trezor.messages.eos.EosTxActionAck.EosActionBuyRamBytes buy_ram_bytes = 7;
inline bool EosTxActionAck::has_buy_ram_bytes() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void EosTxActionAck::clear_buy_ram_bytes() {
  if (buy_ram_bytes_ != nullptr) buy_ram_bytes_->Clear();
  _has_bits_[0] &= ~0x00000040u;
}
inline const ::hw::trezor::messages::eos::EosTxActionAck_EosActionBuyRamBytes& EosTxActionAck::buy_ram_bytes() const {
  const ::hw::trezor::messages::eos::EosTxActionAck_EosActionBuyRamBytes* p = buy_ram_bytes_;
  // @@protoc_insertion_point(field_get:hw.trezor.messages.eos.EosTxActionAck.buy_ram_bytes)
  return p != nullptr ? *p : *reinterpret_cast<const ::hw::trezor::messages::eos::EosTxActionAck_EosActionBuyRamBytes*>(
      &::hw::trezor::messages::eos::_EosTxActionAck_EosActionBuyRamBytes_default_instance_);
}
inline ::hw::trezor::messages::eos::EosTxActionAck_EosActionBuyRamBytes* EosTxActionAck::release_buy_ram_bytes() {
  // @@protoc_insertion_point(field_release:hw.trezor.messages.eos.EosTxActionAck.buy_ram_bytes)
  _has_bits_[0] &= ~0x00000040u;
  ::hw::trezor::messages::eos::EosTxActionAck_EosActionBuyRamBytes* temp = buy_ram_bytes_;
  buy_ram_bytes_ = nullptr;
  return temp;
}
inline ::hw::trezor::messages::eos::EosTxActionAck_EosActionBuyRamBytes* EosTxActionAck::mutable_buy_ram_bytes() {
  _has_bits_[0] |= 0x00000040u;
  if (buy_ram_bytes_ == nullptr) {
    auto* p = CreateMaybeMessage<::hw::trezor::messages::eos::EosTxActionAck_EosActionBuyRamBytes>(GetArenaNoVirtual());
    buy_ram_bytes_ = p;
  }
  // @@protoc_insertion_point(field_mutable:hw.trezor.messages.eos.EosTxActionAck.buy_ram_bytes)
  return buy_ram_bytes_;
}
inline void EosTxActionAck::set_allocated_buy_ram_bytes(::hw::trezor::messages::eos::EosTxActionAck_EosActionBuyRamBytes* buy_ram_bytes) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete buy_ram_bytes_;
  }
  if (buy_ram_bytes) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      buy_ram_bytes = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, buy_ram_bytes, submessage_arena);
    }
    _has_bits_[0] |= 0x00000040u;
  } else {
    _has_bits_[0] &= ~0x00000040u;
  }
  buy_ram_bytes_ = buy_ram_bytes;
  // @@protoc_insertion_point(field_set_allocated:hw.trezor.messages.eos.EosTxActionAck.buy_ram_bytes)
}

// optional .hw.trezor.messages.eos.EosTxActionAck.EosActionSellRam sell_ram = 8;
inline bool EosTxActionAck::has_sell_ram() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void EosTxActionAck::clear_sell_ram() {
  if (sell_ram_ != nullptr) sell_ram_->Clear();
  _has_bits_[0] &= ~0x00000080u;
}
inline const ::hw::trezor::messages::eos::EosTxActionAck_EosActionSellRam& EosTxActionAck::sell_ram() const {
  const ::hw::trezor::messages::eos::EosTxActionAck_EosActionSellRam* p = sell_ram_;
  // @@protoc_insertion_point(field_get:hw.trezor.messages.eos.EosTxActionAck.sell_ram)
  return p != nullptr ? *p : *reinterpret_cast<const ::hw::trezor::messages::eos::EosTxActionAck_EosActionSellRam*>(
      &::hw::trezor::messages::eos::_EosTxActionAck_EosActionSellRam_default_instance_);
}
inline ::hw::trezor::messages::eos::EosTxActionAck_EosActionSellRam* EosTxActionAck::release_sell_ram() {
  // @@protoc_insertion_point(field_release:hw.trezor.messages.eos.EosTxActionAck.sell_ram)
  _has_bits_[0] &= ~0x00000080u;
  ::hw::trezor::messages::eos::EosTxActionAck_EosActionSellRam* temp = sell_ram_;
  sell_ram_ = nullptr;
  return temp;
}
inline ::hw::trezor::messages::eos::EosTxActionAck_EosActionSellRam* EosTxActionAck::mutable_sell_ram() {
  _has_bits_[0] |= 0x00000080u;
  if (sell_ram_ == nullptr) {
    auto* p = CreateMaybeMessage<::hw::trezor::messages::eos::EosTxActionAck_EosActionSellRam>(GetArenaNoVirtual());
    sell_ram_ = p;
  }
  // @@protoc_insertion_point(field_mutable:hw.trezor.messages.eos.EosTxActionAck.sell_ram)
  return sell_ram_;
}
inline void EosTxActionAck::set_allocated_sell_ram(::hw::trezor::messages::eos::EosTxActionAck_EosActionSellRam* sell_ram) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete sell_ram_;
  }
  if (sell_ram) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      sell_ram = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, sell_ram, submessage_arena);
    }
    _has_bits_[0] |= 0x00000080u;
  } else {
    _has_bits_[0] &= ~0x00000080u;
  }
  sell_ram_ = sell_ram;
  // @@protoc_insertion_point(field_set_allocated:hw.trezor.messages.eos.EosTxActionAck.sell_ram)
}

// optional .hw.trezor.messages.eos.EosTxActionAck.EosActionVoteProducer vote_producer = 9;
inline bool EosTxActionAck::has_vote_producer() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void EosTxActionAck::clear_vote_producer() {
  if (vote_producer_ != nullptr) vote_producer_->Clear();
  _has_bits_[0] &= ~0x00000100u;
}
inline const ::hw::trezor::messages::eos::EosTxActionAck_EosActionVoteProducer& EosTxActionAck::vote_producer() const {
  const ::hw::trezor::messages::eos::EosTxActionAck_EosActionVoteProducer* p = vote_producer_;
  // @@protoc_insertion_point(field_get:hw.trezor.messages.eos.EosTxActionAck.vote_producer)
  return p != nullptr ? *p : *reinterpret_cast<const ::hw::trezor::messages::eos::EosTxActionAck_EosActionVoteProducer*>(
      &::hw::trezor::messages::eos::_EosTxActionAck_EosActionVoteProducer_default_instance_);
}
inline ::hw::trezor::messages::eos::EosTxActionAck_EosActionVoteProducer* EosTxActionAck::release_vote_producer() {
  // @@protoc_insertion_point(field_release:hw.trezor.messages.eos.EosTxActionAck.vote_producer)
  _has_bits_[0] &= ~0x00000100u;
  ::hw::trezor::messages::eos::EosTxActionAck_EosActionVoteProducer* temp = vote_producer_;
  vote_producer_ = nullptr;
  return temp;
}
inline ::hw::trezor::messages::eos::EosTxActionAck_EosActionVoteProducer* EosTxActionAck::mutable_vote_producer() {
  _has_bits_[0] |= 0x00000100u;
  if (vote_producer_ == nullptr) {
    auto* p = CreateMaybeMessage<::hw::trezor::messages::eos::EosTxActionAck_EosActionVoteProducer>(GetArenaNoVirtual());
    vote_producer_ = p;
  }
  // @@protoc_insertion_point(field_mutable:hw.trezor.messages.eos.EosTxActionAck.vote_producer)
  return vote_producer_;
}
inline void EosTxActionAck::set_allocated_vote_producer(::hw::trezor::messages::eos::EosTxActionAck_EosActionVoteProducer* vote_producer) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete vote_producer_;
  }
  if (vote_producer) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      vote_producer = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, vote_producer, submessage_arena);
    }
    _has_bits_[0] |= 0x00000100u;
  } else {
    _has_bits_[0] &= ~0x00000100u;
  }
  vote_producer_ = vote_producer;
  // @@protoc_insertion_point(field_set_allocated:hw.trezor.messages.eos.EosTxActionAck.vote_producer)
}

// optional .hw.trezor.messages.eos.EosTxActionAck.EosActionUpdateAuth update_auth = 10;
inline bool EosTxActionAck::has_update_auth() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void EosTxActionAck::clear_update_auth() {
  if (update_auth_ != nullptr) update_auth_->Clear();
  _has_bits_[0] &= ~0x00000200u;
}
inline const ::hw::trezor::messages::eos::EosTxActionAck_EosActionUpdateAuth& EosTxActionAck::update_auth() const {
  const ::hw::trezor::messages::eos::EosTxActionAck_EosActionUpdateAuth* p = update_auth_;
  // @@protoc_insertion_point(field_get:hw.trezor.messages.eos.EosTxActionAck.update_auth)
  return p != nullptr ? *p : *reinterpret_cast<const ::hw::trezor::messages::eos::EosTxActionAck_EosActionUpdateAuth*>(
      &::hw::trezor::messages::eos::_EosTxActionAck_EosActionUpdateAuth_default_instance_);
}
inline ::hw::trezor::messages::eos::EosTxActionAck_EosActionUpdateAuth* EosTxActionAck::release_update_auth() {
  // @@protoc_insertion_point(field_release:hw.trezor.messages.eos.EosTxActionAck.update_auth)
  _has_bits_[0] &= ~0x00000200u;
  ::hw::trezor::messages::eos::EosTxActionAck_EosActionUpdateAuth* temp = update_auth_;
  update_auth_ = nullptr;
  return temp;
}
inline ::hw::trezor::messages::eos::EosTxActionAck_EosActionUpdateAuth* EosTxActionAck::mutable_update_auth() {
  _has_bits_[0] |= 0x00000200u;
  if (update_auth_ == nullptr) {
    auto* p = CreateMaybeMessage<::hw::trezor::messages::eos::EosTxActionAck_EosActionUpdateAuth>(GetArenaNoVirtual());
    update_auth_ = p;
  }
  // @@protoc_insertion_point(field_mutable:hw.trezor.messages.eos.EosTxActionAck.update_auth)
  return update_auth_;
}
inline void EosTxActionAck::set_allocated_update_auth(::hw::trezor::messages::eos::EosTxActionAck_EosActionUpdateAuth* update_auth) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete update_auth_;
  }
  if (update_auth) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      update_auth = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, update_auth, submessage_arena);
    }
    _has_bits_[0] |= 0x00000200u;
  } else {
    _has_bits_[0] &= ~0x00000200u;
  }
  update_auth_ = update_auth;
  // @@protoc_insertion_point(field_set_allocated:hw.trezor.messages.eos.EosTxActionAck.update_auth)
}

// optional .hw.trezor.messages.eos.EosTxActionAck.EosActionDeleteAuth delete_auth = 11;
inline bool EosTxActionAck::has_delete_auth() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void EosTxActionAck::clear_delete_auth() {
  if (delete_auth_ != nullptr) delete_auth_->Clear();
  _has_bits_[0] &= ~0x00000400u;
}
inline const ::hw::trezor::messages::eos::EosTxActionAck_EosActionDeleteAuth& EosTxActionAck::delete_auth() const {
  const ::hw::trezor::messages::eos::EosTxActionAck_EosActionDeleteAuth* p = delete_auth_;
  // @@protoc_insertion_point(field_get:hw.trezor.messages.eos.EosTxActionAck.delete_auth)
  return p != nullptr ? *p : *reinterpret_cast<const ::hw::trezor::messages::eos::EosTxActionAck_EosActionDeleteAuth*>(
      &::hw::trezor::messages::eos::_EosTxActionAck_EosActionDeleteAuth_default_instance_);
}
inline ::hw::trezor::messages::eos::EosTxActionAck_EosActionDeleteAuth* EosTxActionAck::release_delete_auth() {
  // @@protoc_insertion_point(field_release:hw.trezor.messages.eos.EosTxActionAck.delete_auth)
  _has_bits_[0] &= ~0x00000400u;
  ::hw::trezor::messages::eos::EosTxActionAck_EosActionDeleteAuth* temp = delete_auth_;
  delete_auth_ = nullptr;
  return temp;
}
inline ::hw::trezor::messages::eos::EosTxActionAck_EosActionDeleteAuth* EosTxActionAck::mutable_delete_auth() {
  _has_bits_[0] |= 0x00000400u;
  if (delete_auth_ == nullptr) {
    auto* p = CreateMaybeMessage<::hw::trezor::messages::eos::EosTxActionAck_EosActionDeleteAuth>(GetArenaNoVirtual());
    delete_auth_ = p;
  }
  // @@protoc_insertion_point(field_mutable:hw.trezor.messages.eos.EosTxActionAck.delete_auth)
  return delete_auth_;
}
inline void EosTxActionAck::set_allocated_delete_auth(::hw::trezor::messages::eos::EosTxActionAck_EosActionDeleteAuth* delete_auth) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete delete_auth_;
  }
  if (delete_auth) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      delete_auth = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, delete_auth, submessage_arena);
    }
    _has_bits_[0] |= 0x00000400u;
  } else {
    _has_bits_[0] &= ~0x00000400u;
  }
  delete_auth_ = delete_auth;
  // @@protoc_insertion_point(field_set_allocated:hw.trezor.messages.eos.EosTxActionAck.delete_auth)
}

// optional .hw.trezor.messages.eos.EosTxActionAck.EosActionLinkAuth link_auth = 12;
inline bool EosTxActionAck::has_link_auth() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void EosTxActionAck::clear_link_auth() {
  if (link_auth_ != nullptr) link_auth_->Clear();
  _has_bits_[0] &= ~0x00000800u;
}
inline const ::hw::trezor::messages::eos::EosTxActionAck_EosActionLinkAuth& EosTxActionAck::link_auth() const {
  const ::hw::trezor::messages::eos::EosTxActionAck_EosActionLinkAuth* p = link_auth_;
  // @@protoc_insertion_point(field_get:hw.trezor.messages.eos.EosTxActionAck.link_auth)
  return p != nullptr ? *p : *reinterpret_cast<const ::hw::trezor::messages::eos::EosTxActionAck_EosActionLinkAuth*>(
      &::hw::trezor::messages::eos::_EosTxActionAck_EosActionLinkAuth_default_instance_);
}
inline ::hw::trezor::messages::eos::EosTxActionAck_EosActionLinkAuth* EosTxActionAck::release_link_auth() {
  // @@protoc_insertion_point(field_release:hw.trezor.messages.eos.EosTxActionAck.link_auth)
  _has_bits_[0] &= ~0x00000800u;
  ::hw::trezor::messages::eos::EosTxActionAck_EosActionLinkAuth* temp = link_auth_;
  link_auth_ = nullptr;
  return temp;
}
inline ::hw::trezor::messages::eos::EosTxActionAck_EosActionLinkAuth* EosTxActionAck::mutable_link_auth() {
  _has_bits_[0] |= 0x00000800u;
  if (link_auth_ == nullptr) {
    auto* p = CreateMaybeMessage<::hw::trezor::messages::eos::EosTxActionAck_EosActionLinkAuth>(GetArenaNoVirtual());
    link_auth_ = p;
  }
  // @@protoc_insertion_point(field_mutable:hw.trezor.messages.eos.EosTxActionAck.link_auth)
  return link_auth_;
}
inline void EosTxActionAck::set_allocated_link_auth(::hw::trezor::messages::eos::EosTxActionAck_EosActionLinkAuth* link_auth) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete link_auth_;
  }
  if (link_auth) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      link_auth = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, link_auth, submessage_arena);
    }
    _has_bits_[0] |= 0x00000800u;
  } else {
    _has_bits_[0] &= ~0x00000800u;
  }
  link_auth_ = link_auth;
  // @@protoc_insertion_point(field_set_allocated:hw.trezor.messages.eos.EosTxActionAck.link_auth)
}

// optional .hw.trezor.messages.eos.EosTxActionAck.EosActionUnlinkAuth unlink_auth = 13;
inline bool EosTxActionAck::has_unlink_auth() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void EosTxActionAck::clear_unlink_auth() {
  if (unlink_auth_ != nullptr) unlink_auth_->Clear();
  _has_bits_[0] &= ~0x00001000u;
}
inline const ::hw::trezor::messages::eos::EosTxActionAck_EosActionUnlinkAuth& EosTxActionAck::unlink_auth() const {
  const ::hw::trezor::messages::eos::EosTxActionAck_EosActionUnlinkAuth* p = unlink_auth_;
  // @@protoc_insertion_point(field_get:hw.trezor.messages.eos.EosTxActionAck.unlink_auth)
  return p != nullptr ? *p : *reinterpret_cast<const ::hw::trezor::messages::eos::EosTxActionAck_EosActionUnlinkAuth*>(
      &::hw::trezor::messages::eos::_EosTxActionAck_EosActionUnlinkAuth_default_instance_);
}
inline ::hw::trezor::messages::eos::EosTxActionAck_EosActionUnlinkAuth* EosTxActionAck::release_unlink_auth() {
  // @@protoc_insertion_point(field_release:hw.trezor.messages.eos.EosTxActionAck.unlink_auth)
  _has_bits_[0] &= ~0x00001000u;
  ::hw::trezor::messages::eos::EosTxActionAck_EosActionUnlinkAuth* temp = unlink_auth_;
  unlink_auth_ = nullptr;
  return temp;
}
inline ::hw::trezor::messages::eos::EosTxActionAck_EosActionUnlinkAuth* EosTxActionAck::mutable_unlink_auth() {
  _has_bits_[0] |= 0x00001000u;
  if (unlink_auth_ == nullptr) {
    auto* p = CreateMaybeMessage<::hw::trezor::messages::eos::EosTxActionAck_EosActionUnlinkAuth>(GetArenaNoVirtual());
    unlink_auth_ = p;
  }
  // @@protoc_insertion_point(field_mutable:hw.trezor.messages.eos.EosTxActionAck.unlink_auth)
  return unlink_auth_;
}
inline void EosTxActionAck::set_allocated_unlink_auth(::hw::trezor::messages::eos::EosTxActionAck_EosActionUnlinkAuth* unlink_auth) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete unlink_auth_;
  }
  if (unlink_auth) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      unlink_auth = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, unlink_auth, submessage_arena);
    }
    _has_bits_[0] |= 0x00001000u;
  } else {
    _has_bits_[0] &= ~0x00001000u;
  }
  unlink_auth_ = unlink_auth;
  // @@protoc_insertion_point(field_set_allocated:hw.trezor.messages.eos.EosTxActionAck.unlink_auth)
}

// optional .hw.trezor.messages.eos.EosTxActionAck.EosActionNewAccount new_account = 14;
inline bool EosTxActionAck::has_new_account() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void EosTxActionAck::clear_new_account() {
  if (new_account_ != nullptr) new_account_->Clear();
  _has_bits_[0] &= ~0x00002000u;
}
inline const ::hw::trezor::messages::eos::EosTxActionAck_EosActionNewAccount& EosTxActionAck::new_account() const {
  const ::hw::trezor::messages::eos::EosTxActionAck_EosActionNewAccount* p = new_account_;
  // @@protoc_insertion_point(field_get:hw.trezor.messages.eos.EosTxActionAck.new_account)
  return p != nullptr ? *p : *reinterpret_cast<const ::hw::trezor::messages::eos::EosTxActionAck_EosActionNewAccount*>(
      &::hw::trezor::messages::eos::_EosTxActionAck_EosActionNewAccount_default_instance_);
}
inline ::hw::trezor::messages::eos::EosTxActionAck_EosActionNewAccount* EosTxActionAck::release_new_account() {
  // @@protoc_insertion_point(field_release:hw.trezor.messages.eos.EosTxActionAck.new_account)
  _has_bits_[0] &= ~0x00002000u;
  ::hw::trezor::messages::eos::EosTxActionAck_EosActionNewAccount* temp = new_account_;
  new_account_ = nullptr;
  return temp;
}
inline ::hw::trezor::messages::eos::EosTxActionAck_EosActionNewAccount* EosTxActionAck::mutable_new_account() {
  _has_bits_[0] |= 0x00002000u;
  if (new_account_ == nullptr) {
    auto* p = CreateMaybeMessage<::hw::trezor::messages::eos::EosTxActionAck_EosActionNewAccount>(GetArenaNoVirtual());
    new_account_ = p;
  }
  // @@protoc_insertion_point(field_mutable:hw.trezor.messages.eos.EosTxActionAck.new_account)
  return new_account_;
}
inline void EosTxActionAck::set_allocated_new_account(::hw::trezor::messages::eos::EosTxActionAck_EosActionNewAccount* new_account) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete new_account_;
  }
  if (new_account) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      new_account = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, new_account, submessage_arena);
    }
    _has_bits_[0] |= 0x00002000u;
  } else {
    _has_bits_[0] &= ~0x00002000u;
  }
  new_account_ = new_account;
  // @@protoc_insertion_point(field_set_allocated:hw.trezor.messages.eos.EosTxActionAck.new_account)
}

// optional .hw.trezor.messages.eos.EosTxActionAck.EosActionUnknown unknown = 15;
inline bool EosTxActionAck::has_unknown() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void EosTxActionAck::clear_unknown() {
  if (unknown_ != nullptr) unknown_->Clear();
  _has_bits_[0] &= ~0x00004000u;
}
inline const ::hw::trezor::messages::eos::EosTxActionAck_EosActionUnknown& EosTxActionAck::unknown() const {
  const ::hw::trezor::messages::eos::EosTxActionAck_EosActionUnknown* p = unknown_;
  // @@protoc_insertion_point(field_get:hw.trezor.messages.eos.EosTxActionAck.unknown)
  return p != nullptr ? *p : *reinterpret_cast<const ::hw::trezor::messages::eos::EosTxActionAck_EosActionUnknown*>(
      &::hw::trezor::messages::eos::_EosTxActionAck_EosActionUnknown_default_instance_);
}
inline ::hw::trezor::messages::eos::EosTxActionAck_EosActionUnknown* EosTxActionAck::release_unknown() {
  // @@protoc_insertion_point(field_release:hw.trezor.messages.eos.EosTxActionAck.unknown)
  _has_bits_[0] &= ~0x00004000u;
  ::hw::trezor::messages::eos::EosTxActionAck_EosActionUnknown* temp = unknown_;
  unknown_ = nullptr;
  return temp;
}
inline ::hw::trezor::messages::eos::EosTxActionAck_EosActionUnknown* EosTxActionAck::mutable_unknown() {
  _has_bits_[0] |= 0x00004000u;
  if (unknown_ == nullptr) {
    auto* p = CreateMaybeMessage<::hw::trezor::messages::eos::EosTxActionAck_EosActionUnknown>(GetArenaNoVirtual());
    unknown_ = p;
  }
  // @@protoc_insertion_point(field_mutable:hw.trezor.messages.eos.EosTxActionAck.unknown)
  return unknown_;
}
inline void EosTxActionAck::set_allocated_unknown(::hw::trezor::messages::eos::EosTxActionAck_EosActionUnknown* unknown) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete unknown_;
  }
  if (unknown) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      unknown = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, unknown, submessage_arena);
    }
    _has_bits_[0] |= 0x00004000u;
  } else {
    _has_bits_[0] &= ~0x00004000u;
  }
  unknown_ = unknown;
  // @@protoc_insertion_point(field_set_allocated:hw.trezor.messages.eos.EosTxActionAck.unknown)
}

// -------------------------------------------------------------------

// EosSignedTx

// optional uint32 signature_v = 1;
inline bool EosSignedTx::has_signature_v() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void EosSignedTx::clear_signature_v() {
  signature_v_ = 0u;
  _has_bits_[0] &= ~0x00000004u;
}
inline ::google::protobuf::uint32 EosSignedTx::signature_v() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.eos.EosSignedTx.signature_v)
  return signature_v_;
}
inline void EosSignedTx::set_signature_v(::google::protobuf::uint32 value) {
  _has_bits_[0] |= 0x00000004u;
  signature_v_ = value;
  // @@protoc_insertion_point(field_set:hw.trezor.messages.eos.EosSignedTx.signature_v)
}

// optional bytes signature_r = 2;
inline bool EosSignedTx::has_signature_r() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void EosSignedTx::clear_signature_r() {
  signature_r_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::std::string& EosSignedTx::signature_r() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.eos.EosSignedTx.signature_r)
  return signature_r_.GetNoArena();
}
inline void EosSignedTx::set_signature_r(const ::std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  signature_r_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:hw.trezor.messages.eos.EosSignedTx.signature_r)
}
#if LANG_CXX11
inline void EosSignedTx::set_signature_r(::std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  signature_r_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:hw.trezor.messages.eos.EosSignedTx.signature_r)
}
#endif
inline void EosSignedTx::set_signature_r(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  signature_r_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:hw.trezor.messages.eos.EosSignedTx.signature_r)
}
inline void EosSignedTx::set_signature_r(const void* value, size_t size) {
  _has_bits_[0] |= 0x00000001u;
  signature_r_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:hw.trezor.messages.eos.EosSignedTx.signature_r)
}
inline ::std::string* EosSignedTx::mutable_signature_r() {
  _has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_mutable:hw.trezor.messages.eos.EosSignedTx.signature_r)
  return signature_r_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* EosSignedTx::release_signature_r() {
  // @@protoc_insertion_point(field_release:hw.trezor.messages.eos.EosSignedTx.signature_r)
  if (!has_signature_r()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return signature_r_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void EosSignedTx::set_allocated_signature_r(::std::string* signature_r) {
  if (signature_r != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  signature_r_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), signature_r);
  // @@protoc_insertion_point(field_set_allocated:hw.trezor.messages.eos.EosSignedTx.signature_r)
}

// optional bytes signature_s = 3;
inline bool EosSignedTx::has_signature_s() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void EosSignedTx::clear_signature_s() {
  signature_s_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000002u;
}
inline const ::std::string& EosSignedTx::signature_s() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.eos.EosSignedTx.signature_s)
  return signature_s_.GetNoArena();
}
inline void EosSignedTx::set_signature_s(const ::std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  signature_s_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:hw.trezor.messages.eos.EosSignedTx.signature_s)
}
#if LANG_CXX11
inline void EosSignedTx::set_signature_s(::std::string&& value) {
  _has_bits_[0] |= 0x00000002u;
  signature_s_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:hw.trezor.messages.eos.EosSignedTx.signature_s)
}
#endif
inline void EosSignedTx::set_signature_s(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000002u;
  signature_s_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:hw.trezor.messages.eos.EosSignedTx.signature_s)
}
inline void EosSignedTx::set_signature_s(const void* value, size_t size) {
  _has_bits_[0] |= 0x00000002u;
  signature_s_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:hw.trezor.messages.eos.EosSignedTx.signature_s)
}
inline ::std::string* EosSignedTx::mutable_signature_s() {
  _has_bits_[0] |= 0x00000002u;
  // @@protoc_insertion_point(field_mutable:hw.trezor.messages.eos.EosSignedTx.signature_s)
  return signature_s_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* EosSignedTx::release_signature_s() {
  // @@protoc_insertion_point(field_release:hw.trezor.messages.eos.EosSignedTx.signature_s)
  if (!has_signature_s()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  return signature_s_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void EosSignedTx::set_allocated_signature_s(::std::string* signature_s) {
  if (signature_s != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  signature_s_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), signature_s);
  // @@protoc_insertion_point(field_set_allocated:hw.trezor.messages.eos.EosSignedTx.signature_s)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace eos
}  // namespace messages
}  // namespace trezor
}  // namespace hw

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // PROTOBUF_INCLUDED_messages_2deos_2eproto
