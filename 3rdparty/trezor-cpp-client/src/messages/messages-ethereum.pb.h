// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: messages-ethereum.proto

#ifndef PROTOBUF_INCLUDED_messages_2dethereum_2eproto
#define PROTOBUF_INCLUDED_messages_2dethereum_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3007000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3007000 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/unknown_field_set.h>
#include "messages-common.pb.h"
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_messages_2dethereum_2eproto

// Internal implementation detail -- do not use these members.
struct TableStruct_messages_2dethereum_2eproto {
  static const ::google::protobuf::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::google::protobuf::internal::ParseTable schema[10]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::google::protobuf::internal::FieldMetadata field_metadata[];
  static const ::google::protobuf::internal::SerializationTable serialization_table[];
  static const ::google::protobuf::uint32 offsets[];
};
void AddDescriptors_messages_2dethereum_2eproto();
namespace hw {
namespace trezor {
namespace messages {
namespace ethereum {
class EthereumAddress;
class EthereumAddressDefaultTypeInternal;
extern EthereumAddressDefaultTypeInternal _EthereumAddress_default_instance_;
class EthereumGetAddress;
class EthereumGetAddressDefaultTypeInternal;
extern EthereumGetAddressDefaultTypeInternal _EthereumGetAddress_default_instance_;
class EthereumGetPublicKey;
class EthereumGetPublicKeyDefaultTypeInternal;
extern EthereumGetPublicKeyDefaultTypeInternal _EthereumGetPublicKey_default_instance_;
class EthereumMessageSignature;
class EthereumMessageSignatureDefaultTypeInternal;
extern EthereumMessageSignatureDefaultTypeInternal _EthereumMessageSignature_default_instance_;
class EthereumPublicKey;
class EthereumPublicKeyDefaultTypeInternal;
extern EthereumPublicKeyDefaultTypeInternal _EthereumPublicKey_default_instance_;
class EthereumSignMessage;
class EthereumSignMessageDefaultTypeInternal;
extern EthereumSignMessageDefaultTypeInternal _EthereumSignMessage_default_instance_;
class EthereumSignTx;
class EthereumSignTxDefaultTypeInternal;
extern EthereumSignTxDefaultTypeInternal _EthereumSignTx_default_instance_;
class EthereumTxAck;
class EthereumTxAckDefaultTypeInternal;
extern EthereumTxAckDefaultTypeInternal _EthereumTxAck_default_instance_;
class EthereumTxRequest;
class EthereumTxRequestDefaultTypeInternal;
extern EthereumTxRequestDefaultTypeInternal _EthereumTxRequest_default_instance_;
class EthereumVerifyMessage;
class EthereumVerifyMessageDefaultTypeInternal;
extern EthereumVerifyMessageDefaultTypeInternal _EthereumVerifyMessage_default_instance_;
}  // namespace ethereum
}  // namespace messages
}  // namespace trezor
}  // namespace hw
namespace google {
namespace protobuf {
template<> ::hw::trezor::messages::ethereum::EthereumAddress* Arena::CreateMaybeMessage<::hw::trezor::messages::ethereum::EthereumAddress>(Arena*);
template<> ::hw::trezor::messages::ethereum::EthereumGetAddress* Arena::CreateMaybeMessage<::hw::trezor::messages::ethereum::EthereumGetAddress>(Arena*);
template<> ::hw::trezor::messages::ethereum::EthereumGetPublicKey* Arena::CreateMaybeMessage<::hw::trezor::messages::ethereum::EthereumGetPublicKey>(Arena*);
template<> ::hw::trezor::messages::ethereum::EthereumMessageSignature* Arena::CreateMaybeMessage<::hw::trezor::messages::ethereum::EthereumMessageSignature>(Arena*);
template<> ::hw::trezor::messages::ethereum::EthereumPublicKey* Arena::CreateMaybeMessage<::hw::trezor::messages::ethereum::EthereumPublicKey>(Arena*);
template<> ::hw::trezor::messages::ethereum::EthereumSignMessage* Arena::CreateMaybeMessage<::hw::trezor::messages::ethereum::EthereumSignMessage>(Arena*);
template<> ::hw::trezor::messages::ethereum::EthereumSignTx* Arena::CreateMaybeMessage<::hw::trezor::messages::ethereum::EthereumSignTx>(Arena*);
template<> ::hw::trezor::messages::ethereum::EthereumTxAck* Arena::CreateMaybeMessage<::hw::trezor::messages::ethereum::EthereumTxAck>(Arena*);
template<> ::hw::trezor::messages::ethereum::EthereumTxRequest* Arena::CreateMaybeMessage<::hw::trezor::messages::ethereum::EthereumTxRequest>(Arena*);
template<> ::hw::trezor::messages::ethereum::EthereumVerifyMessage* Arena::CreateMaybeMessage<::hw::trezor::messages::ethereum::EthereumVerifyMessage>(Arena*);
}  // namespace protobuf
}  // namespace google
namespace hw {
namespace trezor {
namespace messages {
namespace ethereum {

// ===================================================================

class EthereumGetPublicKey final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:hw.trezor.messages.ethereum.EthereumGetPublicKey) */ {
 public:
  EthereumGetPublicKey();
  virtual ~EthereumGetPublicKey();

  EthereumGetPublicKey(const EthereumGetPublicKey& from);

  inline EthereumGetPublicKey& operator=(const EthereumGetPublicKey& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  EthereumGetPublicKey(EthereumGetPublicKey&& from) noexcept
    : EthereumGetPublicKey() {
    *this = ::std::move(from);
  }

  inline EthereumGetPublicKey& operator=(EthereumGetPublicKey&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const EthereumGetPublicKey& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const EthereumGetPublicKey* internal_default_instance() {
    return reinterpret_cast<const EthereumGetPublicKey*>(
               &_EthereumGetPublicKey_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  void Swap(EthereumGetPublicKey* other);
  friend void swap(EthereumGetPublicKey& a, EthereumGetPublicKey& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline EthereumGetPublicKey* New() const final {
    return CreateMaybeMessage<EthereumGetPublicKey>(nullptr);
  }

  EthereumGetPublicKey* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<EthereumGetPublicKey>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const EthereumGetPublicKey& from);
  void MergeFrom(const EthereumGetPublicKey& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(EthereumGetPublicKey* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated uint32 address_n = 1;
  int address_n_size() const;
  void clear_address_n();
  static const int kAddressNFieldNumber = 1;
  ::google::protobuf::uint32 address_n(int index) const;
  void set_address_n(int index, ::google::protobuf::uint32 value);
  void add_address_n(::google::protobuf::uint32 value);
  const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      address_n() const;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable_address_n();

  // optional bool show_display = 2;
  bool has_show_display() const;
  void clear_show_display();
  static const int kShowDisplayFieldNumber = 2;
  bool show_display() const;
  void set_show_display(bool value);

  // @@protoc_insertion_point(class_scope:hw.trezor.messages.ethereum.EthereumGetPublicKey)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > address_n_;
  bool show_display_;
  friend struct ::TableStruct_messages_2dethereum_2eproto;
};
// -------------------------------------------------------------------

class EthereumPublicKey final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:hw.trezor.messages.ethereum.EthereumPublicKey) */ {
 public:
  EthereumPublicKey();
  virtual ~EthereumPublicKey();

  EthereumPublicKey(const EthereumPublicKey& from);

  inline EthereumPublicKey& operator=(const EthereumPublicKey& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  EthereumPublicKey(EthereumPublicKey&& from) noexcept
    : EthereumPublicKey() {
    *this = ::std::move(from);
  }

  inline EthereumPublicKey& operator=(EthereumPublicKey&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const EthereumPublicKey& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const EthereumPublicKey* internal_default_instance() {
    return reinterpret_cast<const EthereumPublicKey*>(
               &_EthereumPublicKey_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  void Swap(EthereumPublicKey* other);
  friend void swap(EthereumPublicKey& a, EthereumPublicKey& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline EthereumPublicKey* New() const final {
    return CreateMaybeMessage<EthereumPublicKey>(nullptr);
  }

  EthereumPublicKey* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<EthereumPublicKey>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const EthereumPublicKey& from);
  void MergeFrom(const EthereumPublicKey& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(EthereumPublicKey* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string xpub = 2;
  bool has_xpub() const;
  void clear_xpub();
  static const int kXpubFieldNumber = 2;
  const ::std::string& xpub() const;
  void set_xpub(const ::std::string& value);
  #if LANG_CXX11
  void set_xpub(::std::string&& value);
  #endif
  void set_xpub(const char* value);
  void set_xpub(const char* value, size_t size);
  ::std::string* mutable_xpub();
  ::std::string* release_xpub();
  void set_allocated_xpub(::std::string* xpub);

  // optional .hw.trezor.messages.common.HDNodeType node = 1;
  bool has_node() const;
  void clear_node();
  static const int kNodeFieldNumber = 1;
  const ::hw::trezor::messages::common::HDNodeType& node() const;
  ::hw::trezor::messages::common::HDNodeType* release_node();
  ::hw::trezor::messages::common::HDNodeType* mutable_node();
  void set_allocated_node(::hw::trezor::messages::common::HDNodeType* node);

  // @@protoc_insertion_point(class_scope:hw.trezor.messages.ethereum.EthereumPublicKey)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr xpub_;
  ::hw::trezor::messages::common::HDNodeType* node_;
  friend struct ::TableStruct_messages_2dethereum_2eproto;
};
// -------------------------------------------------------------------

class EthereumGetAddress final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:hw.trezor.messages.ethereum.EthereumGetAddress) */ {
 public:
  EthereumGetAddress();
  virtual ~EthereumGetAddress();

  EthereumGetAddress(const EthereumGetAddress& from);

  inline EthereumGetAddress& operator=(const EthereumGetAddress& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  EthereumGetAddress(EthereumGetAddress&& from) noexcept
    : EthereumGetAddress() {
    *this = ::std::move(from);
  }

  inline EthereumGetAddress& operator=(EthereumGetAddress&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const EthereumGetAddress& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const EthereumGetAddress* internal_default_instance() {
    return reinterpret_cast<const EthereumGetAddress*>(
               &_EthereumGetAddress_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  void Swap(EthereumGetAddress* other);
  friend void swap(EthereumGetAddress& a, EthereumGetAddress& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline EthereumGetAddress* New() const final {
    return CreateMaybeMessage<EthereumGetAddress>(nullptr);
  }

  EthereumGetAddress* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<EthereumGetAddress>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const EthereumGetAddress& from);
  void MergeFrom(const EthereumGetAddress& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(EthereumGetAddress* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated uint32 address_n = 1;
  int address_n_size() const;
  void clear_address_n();
  static const int kAddressNFieldNumber = 1;
  ::google::protobuf::uint32 address_n(int index) const;
  void set_address_n(int index, ::google::protobuf::uint32 value);
  void add_address_n(::google::protobuf::uint32 value);
  const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      address_n() const;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable_address_n();

  // optional bool show_display = 2;
  bool has_show_display() const;
  void clear_show_display();
  static const int kShowDisplayFieldNumber = 2;
  bool show_display() const;
  void set_show_display(bool value);

  // @@protoc_insertion_point(class_scope:hw.trezor.messages.ethereum.EthereumGetAddress)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > address_n_;
  bool show_display_;
  friend struct ::TableStruct_messages_2dethereum_2eproto;
};
// -------------------------------------------------------------------

class EthereumAddress final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:hw.trezor.messages.ethereum.EthereumAddress) */ {
 public:
  EthereumAddress();
  virtual ~EthereumAddress();

  EthereumAddress(const EthereumAddress& from);

  inline EthereumAddress& operator=(const EthereumAddress& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  EthereumAddress(EthereumAddress&& from) noexcept
    : EthereumAddress() {
    *this = ::std::move(from);
  }

  inline EthereumAddress& operator=(EthereumAddress&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const EthereumAddress& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const EthereumAddress* internal_default_instance() {
    return reinterpret_cast<const EthereumAddress*>(
               &_EthereumAddress_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  void Swap(EthereumAddress* other);
  friend void swap(EthereumAddress& a, EthereumAddress& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline EthereumAddress* New() const final {
    return CreateMaybeMessage<EthereumAddress>(nullptr);
  }

  EthereumAddress* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<EthereumAddress>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const EthereumAddress& from);
  void MergeFrom(const EthereumAddress& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(EthereumAddress* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string address = 2;
  bool has_address() const;
  void clear_address();
  static const int kAddressFieldNumber = 2;
  const ::std::string& address() const;
  void set_address(const ::std::string& value);
  #if LANG_CXX11
  void set_address(::std::string&& value);
  #endif
  void set_address(const char* value);
  void set_address(const char* value, size_t size);
  ::std::string* mutable_address();
  ::std::string* release_address();
  void set_allocated_address(::std::string* address);

  // @@protoc_insertion_point(class_scope:hw.trezor.messages.ethereum.EthereumAddress)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr address_;
  friend struct ::TableStruct_messages_2dethereum_2eproto;
};
// -------------------------------------------------------------------

class EthereumSignTx final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:hw.trezor.messages.ethereum.EthereumSignTx) */ {
 public:
  EthereumSignTx();
  virtual ~EthereumSignTx();

  EthereumSignTx(const EthereumSignTx& from);

  inline EthereumSignTx& operator=(const EthereumSignTx& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  EthereumSignTx(EthereumSignTx&& from) noexcept
    : EthereumSignTx() {
    *this = ::std::move(from);
  }

  inline EthereumSignTx& operator=(EthereumSignTx&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const EthereumSignTx& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const EthereumSignTx* internal_default_instance() {
    return reinterpret_cast<const EthereumSignTx*>(
               &_EthereumSignTx_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  void Swap(EthereumSignTx* other);
  friend void swap(EthereumSignTx& a, EthereumSignTx& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline EthereumSignTx* New() const final {
    return CreateMaybeMessage<EthereumSignTx>(nullptr);
  }

  EthereumSignTx* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<EthereumSignTx>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const EthereumSignTx& from);
  void MergeFrom(const EthereumSignTx& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(EthereumSignTx* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated uint32 address_n = 1;
  int address_n_size() const;
  void clear_address_n();
  static const int kAddressNFieldNumber = 1;
  ::google::protobuf::uint32 address_n(int index) const;
  void set_address_n(int index, ::google::protobuf::uint32 value);
  void add_address_n(::google::protobuf::uint32 value);
  const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      address_n() const;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable_address_n();

  // optional bytes nonce = 2;
  bool has_nonce() const;
  void clear_nonce();
  static const int kNonceFieldNumber = 2;
  const ::std::string& nonce() const;
  void set_nonce(const ::std::string& value);
  #if LANG_CXX11
  void set_nonce(::std::string&& value);
  #endif
  void set_nonce(const char* value);
  void set_nonce(const void* value, size_t size);
  ::std::string* mutable_nonce();
  ::std::string* release_nonce();
  void set_allocated_nonce(::std::string* nonce);

  // optional bytes gas_price = 3;
  bool has_gas_price() const;
  void clear_gas_price();
  static const int kGasPriceFieldNumber = 3;
  const ::std::string& gas_price() const;
  void set_gas_price(const ::std::string& value);
  #if LANG_CXX11
  void set_gas_price(::std::string&& value);
  #endif
  void set_gas_price(const char* value);
  void set_gas_price(const void* value, size_t size);
  ::std::string* mutable_gas_price();
  ::std::string* release_gas_price();
  void set_allocated_gas_price(::std::string* gas_price);

  // optional bytes gas_limit = 4;
  bool has_gas_limit() const;
  void clear_gas_limit();
  static const int kGasLimitFieldNumber = 4;
  const ::std::string& gas_limit() const;
  void set_gas_limit(const ::std::string& value);
  #if LANG_CXX11
  void set_gas_limit(::std::string&& value);
  #endif
  void set_gas_limit(const char* value);
  void set_gas_limit(const void* value, size_t size);
  ::std::string* mutable_gas_limit();
  ::std::string* release_gas_limit();
  void set_allocated_gas_limit(::std::string* gas_limit);

  // optional bytes value = 6;
  bool has_value() const;
  void clear_value();
  static const int kValueFieldNumber = 6;
  const ::std::string& value() const;
  void set_value(const ::std::string& value);
  #if LANG_CXX11
  void set_value(::std::string&& value);
  #endif
  void set_value(const char* value);
  void set_value(const void* value, size_t size);
  ::std::string* mutable_value();
  ::std::string* release_value();
  void set_allocated_value(::std::string* value);

  // optional bytes data_initial_chunk = 7;
  bool has_data_initial_chunk() const;
  void clear_data_initial_chunk();
  static const int kDataInitialChunkFieldNumber = 7;
  const ::std::string& data_initial_chunk() const;
  void set_data_initial_chunk(const ::std::string& value);
  #if LANG_CXX11
  void set_data_initial_chunk(::std::string&& value);
  #endif
  void set_data_initial_chunk(const char* value);
  void set_data_initial_chunk(const void* value, size_t size);
  ::std::string* mutable_data_initial_chunk();
  ::std::string* release_data_initial_chunk();
  void set_allocated_data_initial_chunk(::std::string* data_initial_chunk);

  // optional string to = 11;
  bool has_to() const;
  void clear_to();
  static const int kToFieldNumber = 11;
  const ::std::string& to() const;
  void set_to(const ::std::string& value);
  #if LANG_CXX11
  void set_to(::std::string&& value);
  #endif
  void set_to(const char* value);
  void set_to(const char* value, size_t size);
  ::std::string* mutable_to();
  ::std::string* release_to();
  void set_allocated_to(::std::string* to);

  // optional uint32 data_length = 8;
  bool has_data_length() const;
  void clear_data_length();
  static const int kDataLengthFieldNumber = 8;
  ::google::protobuf::uint32 data_length() const;
  void set_data_length(::google::protobuf::uint32 value);

  // optional uint32 chain_id = 9;
  bool has_chain_id() const;
  void clear_chain_id();
  static const int kChainIdFieldNumber = 9;
  ::google::protobuf::uint32 chain_id() const;
  void set_chain_id(::google::protobuf::uint32 value);

  // optional uint32 tx_type = 10;
  bool has_tx_type() const;
  void clear_tx_type();
  static const int kTxTypeFieldNumber = 10;
  ::google::protobuf::uint32 tx_type() const;
  void set_tx_type(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:hw.trezor.messages.ethereum.EthereumSignTx)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > address_n_;
  ::google::protobuf::internal::ArenaStringPtr nonce_;
  ::google::protobuf::internal::ArenaStringPtr gas_price_;
  ::google::protobuf::internal::ArenaStringPtr gas_limit_;
  ::google::protobuf::internal::ArenaStringPtr value_;
  ::google::protobuf::internal::ArenaStringPtr data_initial_chunk_;
  ::google::protobuf::internal::ArenaStringPtr to_;
  ::google::protobuf::uint32 data_length_;
  ::google::protobuf::uint32 chain_id_;
  ::google::protobuf::uint32 tx_type_;
  friend struct ::TableStruct_messages_2dethereum_2eproto;
};
// -------------------------------------------------------------------

class EthereumTxRequest final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:hw.trezor.messages.ethereum.EthereumTxRequest) */ {
 public:
  EthereumTxRequest();
  virtual ~EthereumTxRequest();

  EthereumTxRequest(const EthereumTxRequest& from);

  inline EthereumTxRequest& operator=(const EthereumTxRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  EthereumTxRequest(EthereumTxRequest&& from) noexcept
    : EthereumTxRequest() {
    *this = ::std::move(from);
  }

  inline EthereumTxRequest& operator=(EthereumTxRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const EthereumTxRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const EthereumTxRequest* internal_default_instance() {
    return reinterpret_cast<const EthereumTxRequest*>(
               &_EthereumTxRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  void Swap(EthereumTxRequest* other);
  friend void swap(EthereumTxRequest& a, EthereumTxRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline EthereumTxRequest* New() const final {
    return CreateMaybeMessage<EthereumTxRequest>(nullptr);
  }

  EthereumTxRequest* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<EthereumTxRequest>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const EthereumTxRequest& from);
  void MergeFrom(const EthereumTxRequest& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(EthereumTxRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bytes signature_r = 3;
  bool has_signature_r() const;
  void clear_signature_r();
  static const int kSignatureRFieldNumber = 3;
  const ::std::string& signature_r() const;
  void set_signature_r(const ::std::string& value);
  #if LANG_CXX11
  void set_signature_r(::std::string&& value);
  #endif
  void set_signature_r(const char* value);
  void set_signature_r(const void* value, size_t size);
  ::std::string* mutable_signature_r();
  ::std::string* release_signature_r();
  void set_allocated_signature_r(::std::string* signature_r);

  // optional bytes signature_s = 4;
  bool has_signature_s() const;
  void clear_signature_s();
  static const int kSignatureSFieldNumber = 4;
  const ::std::string& signature_s() const;
  void set_signature_s(const ::std::string& value);
  #if LANG_CXX11
  void set_signature_s(::std::string&& value);
  #endif
  void set_signature_s(const char* value);
  void set_signature_s(const void* value, size_t size);
  ::std::string* mutable_signature_s();
  ::std::string* release_signature_s();
  void set_allocated_signature_s(::std::string* signature_s);

  // optional uint32 data_length = 1;
  bool has_data_length() const;
  void clear_data_length();
  static const int kDataLengthFieldNumber = 1;
  ::google::protobuf::uint32 data_length() const;
  void set_data_length(::google::protobuf::uint32 value);

  // optional uint32 signature_v = 2;
  bool has_signature_v() const;
  void clear_signature_v();
  static const int kSignatureVFieldNumber = 2;
  ::google::protobuf::uint32 signature_v() const;
  void set_signature_v(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:hw.trezor.messages.ethereum.EthereumTxRequest)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr signature_r_;
  ::google::protobuf::internal::ArenaStringPtr signature_s_;
  ::google::protobuf::uint32 data_length_;
  ::google::protobuf::uint32 signature_v_;
  friend struct ::TableStruct_messages_2dethereum_2eproto;
};
// -------------------------------------------------------------------

class EthereumTxAck final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:hw.trezor.messages.ethereum.EthereumTxAck) */ {
 public:
  EthereumTxAck();
  virtual ~EthereumTxAck();

  EthereumTxAck(const EthereumTxAck& from);

  inline EthereumTxAck& operator=(const EthereumTxAck& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  EthereumTxAck(EthereumTxAck&& from) noexcept
    : EthereumTxAck() {
    *this = ::std::move(from);
  }

  inline EthereumTxAck& operator=(EthereumTxAck&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const EthereumTxAck& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const EthereumTxAck* internal_default_instance() {
    return reinterpret_cast<const EthereumTxAck*>(
               &_EthereumTxAck_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  void Swap(EthereumTxAck* other);
  friend void swap(EthereumTxAck& a, EthereumTxAck& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline EthereumTxAck* New() const final {
    return CreateMaybeMessage<EthereumTxAck>(nullptr);
  }

  EthereumTxAck* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<EthereumTxAck>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const EthereumTxAck& from);
  void MergeFrom(const EthereumTxAck& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(EthereumTxAck* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bytes data_chunk = 1;
  bool has_data_chunk() const;
  void clear_data_chunk();
  static const int kDataChunkFieldNumber = 1;
  const ::std::string& data_chunk() const;
  void set_data_chunk(const ::std::string& value);
  #if LANG_CXX11
  void set_data_chunk(::std::string&& value);
  #endif
  void set_data_chunk(const char* value);
  void set_data_chunk(const void* value, size_t size);
  ::std::string* mutable_data_chunk();
  ::std::string* release_data_chunk();
  void set_allocated_data_chunk(::std::string* data_chunk);

  // @@protoc_insertion_point(class_scope:hw.trezor.messages.ethereum.EthereumTxAck)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr data_chunk_;
  friend struct ::TableStruct_messages_2dethereum_2eproto;
};
// -------------------------------------------------------------------

class EthereumSignMessage final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:hw.trezor.messages.ethereum.EthereumSignMessage) */ {
 public:
  EthereumSignMessage();
  virtual ~EthereumSignMessage();

  EthereumSignMessage(const EthereumSignMessage& from);

  inline EthereumSignMessage& operator=(const EthereumSignMessage& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  EthereumSignMessage(EthereumSignMessage&& from) noexcept
    : EthereumSignMessage() {
    *this = ::std::move(from);
  }

  inline EthereumSignMessage& operator=(EthereumSignMessage&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const EthereumSignMessage& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const EthereumSignMessage* internal_default_instance() {
    return reinterpret_cast<const EthereumSignMessage*>(
               &_EthereumSignMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  void Swap(EthereumSignMessage* other);
  friend void swap(EthereumSignMessage& a, EthereumSignMessage& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline EthereumSignMessage* New() const final {
    return CreateMaybeMessage<EthereumSignMessage>(nullptr);
  }

  EthereumSignMessage* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<EthereumSignMessage>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const EthereumSignMessage& from);
  void MergeFrom(const EthereumSignMessage& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(EthereumSignMessage* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated uint32 address_n = 1;
  int address_n_size() const;
  void clear_address_n();
  static const int kAddressNFieldNumber = 1;
  ::google::protobuf::uint32 address_n(int index) const;
  void set_address_n(int index, ::google::protobuf::uint32 value);
  void add_address_n(::google::protobuf::uint32 value);
  const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      address_n() const;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable_address_n();

  // optional bytes message = 2;
  bool has_message() const;
  void clear_message();
  static const int kMessageFieldNumber = 2;
  const ::std::string& message() const;
  void set_message(const ::std::string& value);
  #if LANG_CXX11
  void set_message(::std::string&& value);
  #endif
  void set_message(const char* value);
  void set_message(const void* value, size_t size);
  ::std::string* mutable_message();
  ::std::string* release_message();
  void set_allocated_message(::std::string* message);

  // @@protoc_insertion_point(class_scope:hw.trezor.messages.ethereum.EthereumSignMessage)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > address_n_;
  ::google::protobuf::internal::ArenaStringPtr message_;
  friend struct ::TableStruct_messages_2dethereum_2eproto;
};
// -------------------------------------------------------------------

class EthereumMessageSignature final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:hw.trezor.messages.ethereum.EthereumMessageSignature) */ {
 public:
  EthereumMessageSignature();
  virtual ~EthereumMessageSignature();

  EthereumMessageSignature(const EthereumMessageSignature& from);

  inline EthereumMessageSignature& operator=(const EthereumMessageSignature& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  EthereumMessageSignature(EthereumMessageSignature&& from) noexcept
    : EthereumMessageSignature() {
    *this = ::std::move(from);
  }

  inline EthereumMessageSignature& operator=(EthereumMessageSignature&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const EthereumMessageSignature& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const EthereumMessageSignature* internal_default_instance() {
    return reinterpret_cast<const EthereumMessageSignature*>(
               &_EthereumMessageSignature_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  void Swap(EthereumMessageSignature* other);
  friend void swap(EthereumMessageSignature& a, EthereumMessageSignature& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline EthereumMessageSignature* New() const final {
    return CreateMaybeMessage<EthereumMessageSignature>(nullptr);
  }

  EthereumMessageSignature* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<EthereumMessageSignature>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const EthereumMessageSignature& from);
  void MergeFrom(const EthereumMessageSignature& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(EthereumMessageSignature* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bytes signature = 2;
  bool has_signature() const;
  void clear_signature();
  static const int kSignatureFieldNumber = 2;
  const ::std::string& signature() const;
  void set_signature(const ::std::string& value);
  #if LANG_CXX11
  void set_signature(::std::string&& value);
  #endif
  void set_signature(const char* value);
  void set_signature(const void* value, size_t size);
  ::std::string* mutable_signature();
  ::std::string* release_signature();
  void set_allocated_signature(::std::string* signature);

  // optional string address = 3;
  bool has_address() const;
  void clear_address();
  static const int kAddressFieldNumber = 3;
  const ::std::string& address() const;
  void set_address(const ::std::string& value);
  #if LANG_CXX11
  void set_address(::std::string&& value);
  #endif
  void set_address(const char* value);
  void set_address(const char* value, size_t size);
  ::std::string* mutable_address();
  ::std::string* release_address();
  void set_allocated_address(::std::string* address);

  // @@protoc_insertion_point(class_scope:hw.trezor.messages.ethereum.EthereumMessageSignature)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr signature_;
  ::google::protobuf::internal::ArenaStringPtr address_;
  friend struct ::TableStruct_messages_2dethereum_2eproto;
};
// -------------------------------------------------------------------

class EthereumVerifyMessage final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:hw.trezor.messages.ethereum.EthereumVerifyMessage) */ {
 public:
  EthereumVerifyMessage();
  virtual ~EthereumVerifyMessage();

  EthereumVerifyMessage(const EthereumVerifyMessage& from);

  inline EthereumVerifyMessage& operator=(const EthereumVerifyMessage& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  EthereumVerifyMessage(EthereumVerifyMessage&& from) noexcept
    : EthereumVerifyMessage() {
    *this = ::std::move(from);
  }

  inline EthereumVerifyMessage& operator=(EthereumVerifyMessage&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const EthereumVerifyMessage& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const EthereumVerifyMessage* internal_default_instance() {
    return reinterpret_cast<const EthereumVerifyMessage*>(
               &_EthereumVerifyMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  void Swap(EthereumVerifyMessage* other);
  friend void swap(EthereumVerifyMessage& a, EthereumVerifyMessage& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline EthereumVerifyMessage* New() const final {
    return CreateMaybeMessage<EthereumVerifyMessage>(nullptr);
  }

  EthereumVerifyMessage* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<EthereumVerifyMessage>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const EthereumVerifyMessage& from);
  void MergeFrom(const EthereumVerifyMessage& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(EthereumVerifyMessage* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bytes signature = 2;
  bool has_signature() const;
  void clear_signature();
  static const int kSignatureFieldNumber = 2;
  const ::std::string& signature() const;
  void set_signature(const ::std::string& value);
  #if LANG_CXX11
  void set_signature(::std::string&& value);
  #endif
  void set_signature(const char* value);
  void set_signature(const void* value, size_t size);
  ::std::string* mutable_signature();
  ::std::string* release_signature();
  void set_allocated_signature(::std::string* signature);

  // optional bytes message = 3;
  bool has_message() const;
  void clear_message();
  static const int kMessageFieldNumber = 3;
  const ::std::string& message() const;
  void set_message(const ::std::string& value);
  #if LANG_CXX11
  void set_message(::std::string&& value);
  #endif
  void set_message(const char* value);
  void set_message(const void* value, size_t size);
  ::std::string* mutable_message();
  ::std::string* release_message();
  void set_allocated_message(::std::string* message);

  // optional string address = 4;
  bool has_address() const;
  void clear_address();
  static const int kAddressFieldNumber = 4;
  const ::std::string& address() const;
  void set_address(const ::std::string& value);
  #if LANG_CXX11
  void set_address(::std::string&& value);
  #endif
  void set_address(const char* value);
  void set_address(const char* value, size_t size);
  ::std::string* mutable_address();
  ::std::string* release_address();
  void set_allocated_address(::std::string* address);

  // @@protoc_insertion_point(class_scope:hw.trezor.messages.ethereum.EthereumVerifyMessage)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr signature_;
  ::google::protobuf::internal::ArenaStringPtr message_;
  ::google::protobuf::internal::ArenaStringPtr address_;
  friend struct ::TableStruct_messages_2dethereum_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// EthereumGetPublicKey

// repeated uint32 address_n = 1;
inline int EthereumGetPublicKey::address_n_size() const {
  return address_n_.size();
}
inline void EthereumGetPublicKey::clear_address_n() {
  address_n_.Clear();
}
inline ::google::protobuf::uint32 EthereumGetPublicKey::address_n(int index) const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.ethereum.EthereumGetPublicKey.address_n)
  return address_n_.Get(index);
}
inline void EthereumGetPublicKey::set_address_n(int index, ::google::protobuf::uint32 value) {
  address_n_.Set(index, value);
  // @@protoc_insertion_point(field_set:hw.trezor.messages.ethereum.EthereumGetPublicKey.address_n)
}
inline void EthereumGetPublicKey::add_address_n(::google::protobuf::uint32 value) {
  address_n_.Add(value);
  // @@protoc_insertion_point(field_add:hw.trezor.messages.ethereum.EthereumGetPublicKey.address_n)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
EthereumGetPublicKey::address_n() const {
  // @@protoc_insertion_point(field_list:hw.trezor.messages.ethereum.EthereumGetPublicKey.address_n)
  return address_n_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
EthereumGetPublicKey::mutable_address_n() {
  // @@protoc_insertion_point(field_mutable_list:hw.trezor.messages.ethereum.EthereumGetPublicKey.address_n)
  return &address_n_;
}

// optional bool show_display = 2;
inline bool EthereumGetPublicKey::has_show_display() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void EthereumGetPublicKey::clear_show_display() {
  show_display_ = false;
  _has_bits_[0] &= ~0x00000001u;
}
inline bool EthereumGetPublicKey::show_display() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.ethereum.EthereumGetPublicKey.show_display)
  return show_display_;
}
inline void EthereumGetPublicKey::set_show_display(bool value) {
  _has_bits_[0] |= 0x00000001u;
  show_display_ = value;
  // @@protoc_insertion_point(field_set:hw.trezor.messages.ethereum.EthereumGetPublicKey.show_display)
}

// -------------------------------------------------------------------

// EthereumPublicKey

// optional .hw.trezor.messages.common.HDNodeType node = 1;
inline bool EthereumPublicKey::has_node() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline const ::hw::trezor::messages::common::HDNodeType& EthereumPublicKey::node() const {
  const ::hw::trezor::messages::common::HDNodeType* p = node_;
  // @@protoc_insertion_point(field_get:hw.trezor.messages.ethereum.EthereumPublicKey.node)
  return p != nullptr ? *p : *reinterpret_cast<const ::hw::trezor::messages::common::HDNodeType*>(
      &::hw::trezor::messages::common::_HDNodeType_default_instance_);
}
inline ::hw::trezor::messages::common::HDNodeType* EthereumPublicKey::release_node() {
  // @@protoc_insertion_point(field_release:hw.trezor.messages.ethereum.EthereumPublicKey.node)
  _has_bits_[0] &= ~0x00000002u;
  ::hw::trezor::messages::common::HDNodeType* temp = node_;
  node_ = nullptr;
  return temp;
}
inline ::hw::trezor::messages::common::HDNodeType* EthereumPublicKey::mutable_node() {
  _has_bits_[0] |= 0x00000002u;
  if (node_ == nullptr) {
    auto* p = CreateMaybeMessage<::hw::trezor::messages::common::HDNodeType>(GetArenaNoVirtual());
    node_ = p;
  }
  // @@protoc_insertion_point(field_mutable:hw.trezor.messages.ethereum.EthereumPublicKey.node)
  return node_;
}
inline void EthereumPublicKey::set_allocated_node(::hw::trezor::messages::common::HDNodeType* node) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(node_);
  }
  if (node) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      node = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, node, submessage_arena);
    }
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  node_ = node;
  // @@protoc_insertion_point(field_set_allocated:hw.trezor.messages.ethereum.EthereumPublicKey.node)
}

// optional string xpub = 2;
inline bool EthereumPublicKey::has_xpub() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void EthereumPublicKey::clear_xpub() {
  xpub_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::std::string& EthereumPublicKey::xpub() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.ethereum.EthereumPublicKey.xpub)
  return xpub_.GetNoArena();
}
inline void EthereumPublicKey::set_xpub(const ::std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  xpub_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:hw.trezor.messages.ethereum.EthereumPublicKey.xpub)
}
#if LANG_CXX11
inline void EthereumPublicKey::set_xpub(::std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  xpub_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:hw.trezor.messages.ethereum.EthereumPublicKey.xpub)
}
#endif
inline void EthereumPublicKey::set_xpub(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  xpub_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:hw.trezor.messages.ethereum.EthereumPublicKey.xpub)
}
inline void EthereumPublicKey::set_xpub(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000001u;
  xpub_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:hw.trezor.messages.ethereum.EthereumPublicKey.xpub)
}
inline ::std::string* EthereumPublicKey::mutable_xpub() {
  _has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_mutable:hw.trezor.messages.ethereum.EthereumPublicKey.xpub)
  return xpub_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* EthereumPublicKey::release_xpub() {
  // @@protoc_insertion_point(field_release:hw.trezor.messages.ethereum.EthereumPublicKey.xpub)
  if (!has_xpub()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return xpub_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void EthereumPublicKey::set_allocated_xpub(::std::string* xpub) {
  if (xpub != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  xpub_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), xpub);
  // @@protoc_insertion_point(field_set_allocated:hw.trezor.messages.ethereum.EthereumPublicKey.xpub)
}

// -------------------------------------------------------------------

// EthereumGetAddress

// repeated uint32 address_n = 1;
inline int EthereumGetAddress::address_n_size() const {
  return address_n_.size();
}
inline void EthereumGetAddress::clear_address_n() {
  address_n_.Clear();
}
inline ::google::protobuf::uint32 EthereumGetAddress::address_n(int index) const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.ethereum.EthereumGetAddress.address_n)
  return address_n_.Get(index);
}
inline void EthereumGetAddress::set_address_n(int index, ::google::protobuf::uint32 value) {
  address_n_.Set(index, value);
  // @@protoc_insertion_point(field_set:hw.trezor.messages.ethereum.EthereumGetAddress.address_n)
}
inline void EthereumGetAddress::add_address_n(::google::protobuf::uint32 value) {
  address_n_.Add(value);
  // @@protoc_insertion_point(field_add:hw.trezor.messages.ethereum.EthereumGetAddress.address_n)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
EthereumGetAddress::address_n() const {
  // @@protoc_insertion_point(field_list:hw.trezor.messages.ethereum.EthereumGetAddress.address_n)
  return address_n_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
EthereumGetAddress::mutable_address_n() {
  // @@protoc_insertion_point(field_mutable_list:hw.trezor.messages.ethereum.EthereumGetAddress.address_n)
  return &address_n_;
}

// optional bool show_display = 2;
inline bool EthereumGetAddress::has_show_display() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void EthereumGetAddress::clear_show_display() {
  show_display_ = false;
  _has_bits_[0] &= ~0x00000001u;
}
inline bool EthereumGetAddress::show_display() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.ethereum.EthereumGetAddress.show_display)
  return show_display_;
}
inline void EthereumGetAddress::set_show_display(bool value) {
  _has_bits_[0] |= 0x00000001u;
  show_display_ = value;
  // @@protoc_insertion_point(field_set:hw.trezor.messages.ethereum.EthereumGetAddress.show_display)
}

// -------------------------------------------------------------------

// EthereumAddress

// optional string address = 2;
inline bool EthereumAddress::has_address() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void EthereumAddress::clear_address() {
  address_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::std::string& EthereumAddress::address() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.ethereum.EthereumAddress.address)
  return address_.GetNoArena();
}
inline void EthereumAddress::set_address(const ::std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  address_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:hw.trezor.messages.ethereum.EthereumAddress.address)
}
#if LANG_CXX11
inline void EthereumAddress::set_address(::std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  address_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:hw.trezor.messages.ethereum.EthereumAddress.address)
}
#endif
inline void EthereumAddress::set_address(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  address_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:hw.trezor.messages.ethereum.EthereumAddress.address)
}
inline void EthereumAddress::set_address(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000001u;
  address_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:hw.trezor.messages.ethereum.EthereumAddress.address)
}
inline ::std::string* EthereumAddress::mutable_address() {
  _has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_mutable:hw.trezor.messages.ethereum.EthereumAddress.address)
  return address_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* EthereumAddress::release_address() {
  // @@protoc_insertion_point(field_release:hw.trezor.messages.ethereum.EthereumAddress.address)
  if (!has_address()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return address_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void EthereumAddress::set_allocated_address(::std::string* address) {
  if (address != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  address_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), address);
  // @@protoc_insertion_point(field_set_allocated:hw.trezor.messages.ethereum.EthereumAddress.address)
}

// -------------------------------------------------------------------

// EthereumSignTx

// repeated uint32 address_n = 1;
inline int EthereumSignTx::address_n_size() const {
  return address_n_.size();
}
inline void EthereumSignTx::clear_address_n() {
  address_n_.Clear();
}
inline ::google::protobuf::uint32 EthereumSignTx::address_n(int index) const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.ethereum.EthereumSignTx.address_n)
  return address_n_.Get(index);
}
inline void EthereumSignTx::set_address_n(int index, ::google::protobuf::uint32 value) {
  address_n_.Set(index, value);
  // @@protoc_insertion_point(field_set:hw.trezor.messages.ethereum.EthereumSignTx.address_n)
}
inline void EthereumSignTx::add_address_n(::google::protobuf::uint32 value) {
  address_n_.Add(value);
  // @@protoc_insertion_point(field_add:hw.trezor.messages.ethereum.EthereumSignTx.address_n)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
EthereumSignTx::address_n() const {
  // @@protoc_insertion_point(field_list:hw.trezor.messages.ethereum.EthereumSignTx.address_n)
  return address_n_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
EthereumSignTx::mutable_address_n() {
  // @@protoc_insertion_point(field_mutable_list:hw.trezor.messages.ethereum.EthereumSignTx.address_n)
  return &address_n_;
}

// optional bytes nonce = 2;
inline bool EthereumSignTx::has_nonce() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void EthereumSignTx::clear_nonce() {
  nonce_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::std::string& EthereumSignTx::nonce() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.ethereum.EthereumSignTx.nonce)
  return nonce_.GetNoArena();
}
inline void EthereumSignTx::set_nonce(const ::std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  nonce_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:hw.trezor.messages.ethereum.EthereumSignTx.nonce)
}
#if LANG_CXX11
inline void EthereumSignTx::set_nonce(::std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  nonce_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:hw.trezor.messages.ethereum.EthereumSignTx.nonce)
}
#endif
inline void EthereumSignTx::set_nonce(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  nonce_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:hw.trezor.messages.ethereum.EthereumSignTx.nonce)
}
inline void EthereumSignTx::set_nonce(const void* value, size_t size) {
  _has_bits_[0] |= 0x00000001u;
  nonce_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:hw.trezor.messages.ethereum.EthereumSignTx.nonce)
}
inline ::std::string* EthereumSignTx::mutable_nonce() {
  _has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_mutable:hw.trezor.messages.ethereum.EthereumSignTx.nonce)
  return nonce_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* EthereumSignTx::release_nonce() {
  // @@protoc_insertion_point(field_release:hw.trezor.messages.ethereum.EthereumSignTx.nonce)
  if (!has_nonce()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return nonce_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void EthereumSignTx::set_allocated_nonce(::std::string* nonce) {
  if (nonce != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  nonce_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), nonce);
  // @@protoc_insertion_point(field_set_allocated:hw.trezor.messages.ethereum.EthereumSignTx.nonce)
}

// optional bytes gas_price = 3;
inline bool EthereumSignTx::has_gas_price() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void EthereumSignTx::clear_gas_price() {
  gas_price_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000002u;
}
inline const ::std::string& EthereumSignTx::gas_price() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.ethereum.EthereumSignTx.gas_price)
  return gas_price_.GetNoArena();
}
inline void EthereumSignTx::set_gas_price(const ::std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  gas_price_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:hw.trezor.messages.ethereum.EthereumSignTx.gas_price)
}
#if LANG_CXX11
inline void EthereumSignTx::set_gas_price(::std::string&& value) {
  _has_bits_[0] |= 0x00000002u;
  gas_price_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:hw.trezor.messages.ethereum.EthereumSignTx.gas_price)
}
#endif
inline void EthereumSignTx::set_gas_price(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000002u;
  gas_price_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:hw.trezor.messages.ethereum.EthereumSignTx.gas_price)
}
inline void EthereumSignTx::set_gas_price(const void* value, size_t size) {
  _has_bits_[0] |= 0x00000002u;
  gas_price_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:hw.trezor.messages.ethereum.EthereumSignTx.gas_price)
}
inline ::std::string* EthereumSignTx::mutable_gas_price() {
  _has_bits_[0] |= 0x00000002u;
  // @@protoc_insertion_point(field_mutable:hw.trezor.messages.ethereum.EthereumSignTx.gas_price)
  return gas_price_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* EthereumSignTx::release_gas_price() {
  // @@protoc_insertion_point(field_release:hw.trezor.messages.ethereum.EthereumSignTx.gas_price)
  if (!has_gas_price()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  return gas_price_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void EthereumSignTx::set_allocated_gas_price(::std::string* gas_price) {
  if (gas_price != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  gas_price_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), gas_price);
  // @@protoc_insertion_point(field_set_allocated:hw.trezor.messages.ethereum.EthereumSignTx.gas_price)
}

// optional bytes gas_limit = 4;
inline bool EthereumSignTx::has_gas_limit() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void EthereumSignTx::clear_gas_limit() {
  gas_limit_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000004u;
}
inline const ::std::string& EthereumSignTx::gas_limit() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.ethereum.EthereumSignTx.gas_limit)
  return gas_limit_.GetNoArena();
}
inline void EthereumSignTx::set_gas_limit(const ::std::string& value) {
  _has_bits_[0] |= 0x00000004u;
  gas_limit_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:hw.trezor.messages.ethereum.EthereumSignTx.gas_limit)
}
#if LANG_CXX11
inline void EthereumSignTx::set_gas_limit(::std::string&& value) {
  _has_bits_[0] |= 0x00000004u;
  gas_limit_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:hw.trezor.messages.ethereum.EthereumSignTx.gas_limit)
}
#endif
inline void EthereumSignTx::set_gas_limit(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000004u;
  gas_limit_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:hw.trezor.messages.ethereum.EthereumSignTx.gas_limit)
}
inline void EthereumSignTx::set_gas_limit(const void* value, size_t size) {
  _has_bits_[0] |= 0x00000004u;
  gas_limit_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:hw.trezor.messages.ethereum.EthereumSignTx.gas_limit)
}
inline ::std::string* EthereumSignTx::mutable_gas_limit() {
  _has_bits_[0] |= 0x00000004u;
  // @@protoc_insertion_point(field_mutable:hw.trezor.messages.ethereum.EthereumSignTx.gas_limit)
  return gas_limit_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* EthereumSignTx::release_gas_limit() {
  // @@protoc_insertion_point(field_release:hw.trezor.messages.ethereum.EthereumSignTx.gas_limit)
  if (!has_gas_limit()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000004u;
  return gas_limit_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void EthereumSignTx::set_allocated_gas_limit(::std::string* gas_limit) {
  if (gas_limit != nullptr) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  gas_limit_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), gas_limit);
  // @@protoc_insertion_point(field_set_allocated:hw.trezor.messages.ethereum.EthereumSignTx.gas_limit)
}

// optional string to = 11;
inline bool EthereumSignTx::has_to() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void EthereumSignTx::clear_to() {
  to_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000020u;
}
inline const ::std::string& EthereumSignTx::to() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.ethereum.EthereumSignTx.to)
  return to_.GetNoArena();
}
inline void EthereumSignTx::set_to(const ::std::string& value) {
  _has_bits_[0] |= 0x00000020u;
  to_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:hw.trezor.messages.ethereum.EthereumSignTx.to)
}
#if LANG_CXX11
inline void EthereumSignTx::set_to(::std::string&& value) {
  _has_bits_[0] |= 0x00000020u;
  to_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:hw.trezor.messages.ethereum.EthereumSignTx.to)
}
#endif
inline void EthereumSignTx::set_to(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000020u;
  to_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:hw.trezor.messages.ethereum.EthereumSignTx.to)
}
inline void EthereumSignTx::set_to(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000020u;
  to_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:hw.trezor.messages.ethereum.EthereumSignTx.to)
}
inline ::std::string* EthereumSignTx::mutable_to() {
  _has_bits_[0] |= 0x00000020u;
  // @@protoc_insertion_point(field_mutable:hw.trezor.messages.ethereum.EthereumSignTx.to)
  return to_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* EthereumSignTx::release_to() {
  // @@protoc_insertion_point(field_release:hw.trezor.messages.ethereum.EthereumSignTx.to)
  if (!has_to()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000020u;
  return to_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void EthereumSignTx::set_allocated_to(::std::string* to) {
  if (to != nullptr) {
    _has_bits_[0] |= 0x00000020u;
  } else {
    _has_bits_[0] &= ~0x00000020u;
  }
  to_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), to);
  // @@protoc_insertion_point(field_set_allocated:hw.trezor.messages.ethereum.EthereumSignTx.to)
}

// optional bytes value = 6;
inline bool EthereumSignTx::has_value() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void EthereumSignTx::clear_value() {
  value_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000008u;
}
inline const ::std::string& EthereumSignTx::value() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.ethereum.EthereumSignTx.value)
  return value_.GetNoArena();
}
inline void EthereumSignTx::set_value(const ::std::string& value) {
  _has_bits_[0] |= 0x00000008u;
  value_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:hw.trezor.messages.ethereum.EthereumSignTx.value)
}
#if LANG_CXX11
inline void EthereumSignTx::set_value(::std::string&& value) {
  _has_bits_[0] |= 0x00000008u;
  value_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:hw.trezor.messages.ethereum.EthereumSignTx.value)
}
#endif
inline void EthereumSignTx::set_value(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000008u;
  value_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:hw.trezor.messages.ethereum.EthereumSignTx.value)
}
inline void EthereumSignTx::set_value(const void* value, size_t size) {
  _has_bits_[0] |= 0x00000008u;
  value_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:hw.trezor.messages.ethereum.EthereumSignTx.value)
}
inline ::std::string* EthereumSignTx::mutable_value() {
  _has_bits_[0] |= 0x00000008u;
  // @@protoc_insertion_point(field_mutable:hw.trezor.messages.ethereum.EthereumSignTx.value)
  return value_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* EthereumSignTx::release_value() {
  // @@protoc_insertion_point(field_release:hw.trezor.messages.ethereum.EthereumSignTx.value)
  if (!has_value()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000008u;
  return value_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void EthereumSignTx::set_allocated_value(::std::string* value) {
  if (value != nullptr) {
    _has_bits_[0] |= 0x00000008u;
  } else {
    _has_bits_[0] &= ~0x00000008u;
  }
  value_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set_allocated:hw.trezor.messages.ethereum.EthereumSignTx.value)
}

// optional bytes data_initial_chunk = 7;
inline bool EthereumSignTx::has_data_initial_chunk() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void EthereumSignTx::clear_data_initial_chunk() {
  data_initial_chunk_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000010u;
}
inline const ::std::string& EthereumSignTx::data_initial_chunk() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.ethereum.EthereumSignTx.data_initial_chunk)
  return data_initial_chunk_.GetNoArena();
}
inline void EthereumSignTx::set_data_initial_chunk(const ::std::string& value) {
  _has_bits_[0] |= 0x00000010u;
  data_initial_chunk_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:hw.trezor.messages.ethereum.EthereumSignTx.data_initial_chunk)
}
#if LANG_CXX11
inline void EthereumSignTx::set_data_initial_chunk(::std::string&& value) {
  _has_bits_[0] |= 0x00000010u;
  data_initial_chunk_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:hw.trezor.messages.ethereum.EthereumSignTx.data_initial_chunk)
}
#endif
inline void EthereumSignTx::set_data_initial_chunk(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000010u;
  data_initial_chunk_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:hw.trezor.messages.ethereum.EthereumSignTx.data_initial_chunk)
}
inline void EthereumSignTx::set_data_initial_chunk(const void* value, size_t size) {
  _has_bits_[0] |= 0x00000010u;
  data_initial_chunk_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:hw.trezor.messages.ethereum.EthereumSignTx.data_initial_chunk)
}
inline ::std::string* EthereumSignTx::mutable_data_initial_chunk() {
  _has_bits_[0] |= 0x00000010u;
  // @@protoc_insertion_point(field_mutable:hw.trezor.messages.ethereum.EthereumSignTx.data_initial_chunk)
  return data_initial_chunk_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* EthereumSignTx::release_data_initial_chunk() {
  // @@protoc_insertion_point(field_release:hw.trezor.messages.ethereum.EthereumSignTx.data_initial_chunk)
  if (!has_data_initial_chunk()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000010u;
  return data_initial_chunk_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void EthereumSignTx::set_allocated_data_initial_chunk(::std::string* data_initial_chunk) {
  if (data_initial_chunk != nullptr) {
    _has_bits_[0] |= 0x00000010u;
  } else {
    _has_bits_[0] &= ~0x00000010u;
  }
  data_initial_chunk_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), data_initial_chunk);
  // @@protoc_insertion_point(field_set_allocated:hw.trezor.messages.ethereum.EthereumSignTx.data_initial_chunk)
}

// optional uint32 data_length = 8;
inline bool EthereumSignTx::has_data_length() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void EthereumSignTx::clear_data_length() {
  data_length_ = 0u;
  _has_bits_[0] &= ~0x00000040u;
}
inline ::google::protobuf::uint32 EthereumSignTx::data_length() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.ethereum.EthereumSignTx.data_length)
  return data_length_;
}
inline void EthereumSignTx::set_data_length(::google::protobuf::uint32 value) {
  _has_bits_[0] |= 0x00000040u;
  data_length_ = value;
  // @@protoc_insertion_point(field_set:hw.trezor.messages.ethereum.EthereumSignTx.data_length)
}

// optional uint32 chain_id = 9;
inline bool EthereumSignTx::has_chain_id() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void EthereumSignTx::clear_chain_id() {
  chain_id_ = 0u;
  _has_bits_[0] &= ~0x00000080u;
}
inline ::google::protobuf::uint32 EthereumSignTx::chain_id() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.ethereum.EthereumSignTx.chain_id)
  return chain_id_;
}
inline void EthereumSignTx::set_chain_id(::google::protobuf::uint32 value) {
  _has_bits_[0] |= 0x00000080u;
  chain_id_ = value;
  // @@protoc_insertion_point(field_set:hw.trezor.messages.ethereum.EthereumSignTx.chain_id)
}

// optional uint32 tx_type = 10;
inline bool EthereumSignTx::has_tx_type() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void EthereumSignTx::clear_tx_type() {
  tx_type_ = 0u;
  _has_bits_[0] &= ~0x00000100u;
}
inline ::google::protobuf::uint32 EthereumSignTx::tx_type() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.ethereum.EthereumSignTx.tx_type)
  return tx_type_;
}
inline void EthereumSignTx::set_tx_type(::google::protobuf::uint32 value) {
  _has_bits_[0] |= 0x00000100u;
  tx_type_ = value;
  // @@protoc_insertion_point(field_set:hw.trezor.messages.ethereum.EthereumSignTx.tx_type)
}

// -------------------------------------------------------------------

// EthereumTxRequest

// optional uint32 data_length = 1;
inline bool EthereumTxRequest::has_data_length() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void EthereumTxRequest::clear_data_length() {
  data_length_ = 0u;
  _has_bits_[0] &= ~0x00000004u;
}
inline ::google::protobuf::uint32 EthereumTxRequest::data_length() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.ethereum.EthereumTxRequest.data_length)
  return data_length_;
}
inline void EthereumTxRequest::set_data_length(::google::protobuf::uint32 value) {
  _has_bits_[0] |= 0x00000004u;
  data_length_ = value;
  // @@protoc_insertion_point(field_set:hw.trezor.messages.ethereum.EthereumTxRequest.data_length)
}

// optional uint32 signature_v = 2;
inline bool EthereumTxRequest::has_signature_v() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void EthereumTxRequest::clear_signature_v() {
  signature_v_ = 0u;
  _has_bits_[0] &= ~0x00000008u;
}
inline ::google::protobuf::uint32 EthereumTxRequest::signature_v() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.ethereum.EthereumTxRequest.signature_v)
  return signature_v_;
}
inline void EthereumTxRequest::set_signature_v(::google::protobuf::uint32 value) {
  _has_bits_[0] |= 0x00000008u;
  signature_v_ = value;
  // @@protoc_insertion_point(field_set:hw.trezor.messages.ethereum.EthereumTxRequest.signature_v)
}

// optional bytes signature_r = 3;
inline bool EthereumTxRequest::has_signature_r() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void EthereumTxRequest::clear_signature_r() {
  signature_r_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::std::string& EthereumTxRequest::signature_r() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.ethereum.EthereumTxRequest.signature_r)
  return signature_r_.GetNoArena();
}
inline void EthereumTxRequest::set_signature_r(const ::std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  signature_r_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:hw.trezor.messages.ethereum.EthereumTxRequest.signature_r)
}
#if LANG_CXX11
inline void EthereumTxRequest::set_signature_r(::std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  signature_r_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:hw.trezor.messages.ethereum.EthereumTxRequest.signature_r)
}
#endif
inline void EthereumTxRequest::set_signature_r(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  signature_r_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:hw.trezor.messages.ethereum.EthereumTxRequest.signature_r)
}
inline void EthereumTxRequest::set_signature_r(const void* value, size_t size) {
  _has_bits_[0] |= 0x00000001u;
  signature_r_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:hw.trezor.messages.ethereum.EthereumTxRequest.signature_r)
}
inline ::std::string* EthereumTxRequest::mutable_signature_r() {
  _has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_mutable:hw.trezor.messages.ethereum.EthereumTxRequest.signature_r)
  return signature_r_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* EthereumTxRequest::release_signature_r() {
  // @@protoc_insertion_point(field_release:hw.trezor.messages.ethereum.EthereumTxRequest.signature_r)
  if (!has_signature_r()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return signature_r_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void EthereumTxRequest::set_allocated_signature_r(::std::string* signature_r) {
  if (signature_r != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  signature_r_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), signature_r);
  // @@protoc_insertion_point(field_set_allocated:hw.trezor.messages.ethereum.EthereumTxRequest.signature_r)
}

// optional bytes signature_s = 4;
inline bool EthereumTxRequest::has_signature_s() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void EthereumTxRequest::clear_signature_s() {
  signature_s_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000002u;
}
inline const ::std::string& EthereumTxRequest::signature_s() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.ethereum.EthereumTxRequest.signature_s)
  return signature_s_.GetNoArena();
}
inline void EthereumTxRequest::set_signature_s(const ::std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  signature_s_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:hw.trezor.messages.ethereum.EthereumTxRequest.signature_s)
}
#if LANG_CXX11
inline void EthereumTxRequest::set_signature_s(::std::string&& value) {
  _has_bits_[0] |= 0x00000002u;
  signature_s_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:hw.trezor.messages.ethereum.EthereumTxRequest.signature_s)
}
#endif
inline void EthereumTxRequest::set_signature_s(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000002u;
  signature_s_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:hw.trezor.messages.ethereum.EthereumTxRequest.signature_s)
}
inline void EthereumTxRequest::set_signature_s(const void* value, size_t size) {
  _has_bits_[0] |= 0x00000002u;
  signature_s_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:hw.trezor.messages.ethereum.EthereumTxRequest.signature_s)
}
inline ::std::string* EthereumTxRequest::mutable_signature_s() {
  _has_bits_[0] |= 0x00000002u;
  // @@protoc_insertion_point(field_mutable:hw.trezor.messages.ethereum.EthereumTxRequest.signature_s)
  return signature_s_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* EthereumTxRequest::release_signature_s() {
  // @@protoc_insertion_point(field_release:hw.trezor.messages.ethereum.EthereumTxRequest.signature_s)
  if (!has_signature_s()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  return signature_s_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void EthereumTxRequest::set_allocated_signature_s(::std::string* signature_s) {
  if (signature_s != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  signature_s_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), signature_s);
  // @@protoc_insertion_point(field_set_allocated:hw.trezor.messages.ethereum.EthereumTxRequest.signature_s)
}

// -------------------------------------------------------------------

// EthereumTxAck

// optional bytes data_chunk = 1;
inline bool EthereumTxAck::has_data_chunk() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void EthereumTxAck::clear_data_chunk() {
  data_chunk_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::std::string& EthereumTxAck::data_chunk() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.ethereum.EthereumTxAck.data_chunk)
  return data_chunk_.GetNoArena();
}
inline void EthereumTxAck::set_data_chunk(const ::std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  data_chunk_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:hw.trezor.messages.ethereum.EthereumTxAck.data_chunk)
}
#if LANG_CXX11
inline void EthereumTxAck::set_data_chunk(::std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  data_chunk_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:hw.trezor.messages.ethereum.EthereumTxAck.data_chunk)
}
#endif
inline void EthereumTxAck::set_data_chunk(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  data_chunk_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:hw.trezor.messages.ethereum.EthereumTxAck.data_chunk)
}
inline void EthereumTxAck::set_data_chunk(const void* value, size_t size) {
  _has_bits_[0] |= 0x00000001u;
  data_chunk_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:hw.trezor.messages.ethereum.EthereumTxAck.data_chunk)
}
inline ::std::string* EthereumTxAck::mutable_data_chunk() {
  _has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_mutable:hw.trezor.messages.ethereum.EthereumTxAck.data_chunk)
  return data_chunk_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* EthereumTxAck::release_data_chunk() {
  // @@protoc_insertion_point(field_release:hw.trezor.messages.ethereum.EthereumTxAck.data_chunk)
  if (!has_data_chunk()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return data_chunk_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void EthereumTxAck::set_allocated_data_chunk(::std::string* data_chunk) {
  if (data_chunk != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  data_chunk_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), data_chunk);
  // @@protoc_insertion_point(field_set_allocated:hw.trezor.messages.ethereum.EthereumTxAck.data_chunk)
}

// -------------------------------------------------------------------

// EthereumSignMessage

// repeated uint32 address_n = 1;
inline int EthereumSignMessage::address_n_size() const {
  return address_n_.size();
}
inline void EthereumSignMessage::clear_address_n() {
  address_n_.Clear();
}
inline ::google::protobuf::uint32 EthereumSignMessage::address_n(int index) const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.ethereum.EthereumSignMessage.address_n)
  return address_n_.Get(index);
}
inline void EthereumSignMessage::set_address_n(int index, ::google::protobuf::uint32 value) {
  address_n_.Set(index, value);
  // @@protoc_insertion_point(field_set:hw.trezor.messages.ethereum.EthereumSignMessage.address_n)
}
inline void EthereumSignMessage::add_address_n(::google::protobuf::uint32 value) {
  address_n_.Add(value);
  // @@protoc_insertion_point(field_add:hw.trezor.messages.ethereum.EthereumSignMessage.address_n)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
EthereumSignMessage::address_n() const {
  // @@protoc_insertion_point(field_list:hw.trezor.messages.ethereum.EthereumSignMessage.address_n)
  return address_n_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
EthereumSignMessage::mutable_address_n() {
  // @@protoc_insertion_point(field_mutable_list:hw.trezor.messages.ethereum.EthereumSignMessage.address_n)
  return &address_n_;
}

// optional bytes message = 2;
inline bool EthereumSignMessage::has_message() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void EthereumSignMessage::clear_message() {
  message_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::std::string& EthereumSignMessage::message() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.ethereum.EthereumSignMessage.message)
  return message_.GetNoArena();
}
inline void EthereumSignMessage::set_message(const ::std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  message_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:hw.trezor.messages.ethereum.EthereumSignMessage.message)
}
#if LANG_CXX11
inline void EthereumSignMessage::set_message(::std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  message_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:hw.trezor.messages.ethereum.EthereumSignMessage.message)
}
#endif
inline void EthereumSignMessage::set_message(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  message_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:hw.trezor.messages.ethereum.EthereumSignMessage.message)
}
inline void EthereumSignMessage::set_message(const void* value, size_t size) {
  _has_bits_[0] |= 0x00000001u;
  message_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:hw.trezor.messages.ethereum.EthereumSignMessage.message)
}
inline ::std::string* EthereumSignMessage::mutable_message() {
  _has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_mutable:hw.trezor.messages.ethereum.EthereumSignMessage.message)
  return message_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* EthereumSignMessage::release_message() {
  // @@protoc_insertion_point(field_release:hw.trezor.messages.ethereum.EthereumSignMessage.message)
  if (!has_message()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return message_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void EthereumSignMessage::set_allocated_message(::std::string* message) {
  if (message != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  message_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), message);
  // @@protoc_insertion_point(field_set_allocated:hw.trezor.messages.ethereum.EthereumSignMessage.message)
}

// -------------------------------------------------------------------

// EthereumMessageSignature

// optional bytes signature = 2;
inline bool EthereumMessageSignature::has_signature() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void EthereumMessageSignature::clear_signature() {
  signature_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::std::string& EthereumMessageSignature::signature() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.ethereum.EthereumMessageSignature.signature)
  return signature_.GetNoArena();
}
inline void EthereumMessageSignature::set_signature(const ::std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  signature_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:hw.trezor.messages.ethereum.EthereumMessageSignature.signature)
}
#if LANG_CXX11
inline void EthereumMessageSignature::set_signature(::std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  signature_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:hw.trezor.messages.ethereum.EthereumMessageSignature.signature)
}
#endif
inline void EthereumMessageSignature::set_signature(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  signature_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:hw.trezor.messages.ethereum.EthereumMessageSignature.signature)
}
inline void EthereumMessageSignature::set_signature(const void* value, size_t size) {
  _has_bits_[0] |= 0x00000001u;
  signature_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:hw.trezor.messages.ethereum.EthereumMessageSignature.signature)
}
inline ::std::string* EthereumMessageSignature::mutable_signature() {
  _has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_mutable:hw.trezor.messages.ethereum.EthereumMessageSignature.signature)
  return signature_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* EthereumMessageSignature::release_signature() {
  // @@protoc_insertion_point(field_release:hw.trezor.messages.ethereum.EthereumMessageSignature.signature)
  if (!has_signature()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return signature_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void EthereumMessageSignature::set_allocated_signature(::std::string* signature) {
  if (signature != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  signature_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), signature);
  // @@protoc_insertion_point(field_set_allocated:hw.trezor.messages.ethereum.EthereumMessageSignature.signature)
}

// optional string address = 3;
inline bool EthereumMessageSignature::has_address() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void EthereumMessageSignature::clear_address() {
  address_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000002u;
}
inline const ::std::string& EthereumMessageSignature::address() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.ethereum.EthereumMessageSignature.address)
  return address_.GetNoArena();
}
inline void EthereumMessageSignature::set_address(const ::std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  address_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:hw.trezor.messages.ethereum.EthereumMessageSignature.address)
}
#if LANG_CXX11
inline void EthereumMessageSignature::set_address(::std::string&& value) {
  _has_bits_[0] |= 0x00000002u;
  address_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:hw.trezor.messages.ethereum.EthereumMessageSignature.address)
}
#endif
inline void EthereumMessageSignature::set_address(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000002u;
  address_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:hw.trezor.messages.ethereum.EthereumMessageSignature.address)
}
inline void EthereumMessageSignature::set_address(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000002u;
  address_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:hw.trezor.messages.ethereum.EthereumMessageSignature.address)
}
inline ::std::string* EthereumMessageSignature::mutable_address() {
  _has_bits_[0] |= 0x00000002u;
  // @@protoc_insertion_point(field_mutable:hw.trezor.messages.ethereum.EthereumMessageSignature.address)
  return address_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* EthereumMessageSignature::release_address() {
  // @@protoc_insertion_point(field_release:hw.trezor.messages.ethereum.EthereumMessageSignature.address)
  if (!has_address()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  return address_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void EthereumMessageSignature::set_allocated_address(::std::string* address) {
  if (address != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  address_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), address);
  // @@protoc_insertion_point(field_set_allocated:hw.trezor.messages.ethereum.EthereumMessageSignature.address)
}

// -------------------------------------------------------------------

// EthereumVerifyMessage

// optional bytes signature = 2;
inline bool EthereumVerifyMessage::has_signature() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void EthereumVerifyMessage::clear_signature() {
  signature_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::std::string& EthereumVerifyMessage::signature() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.ethereum.EthereumVerifyMessage.signature)
  return signature_.GetNoArena();
}
inline void EthereumVerifyMessage::set_signature(const ::std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  signature_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:hw.trezor.messages.ethereum.EthereumVerifyMessage.signature)
}
#if LANG_CXX11
inline void EthereumVerifyMessage::set_signature(::std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  signature_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:hw.trezor.messages.ethereum.EthereumVerifyMessage.signature)
}
#endif
inline void EthereumVerifyMessage::set_signature(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  signature_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:hw.trezor.messages.ethereum.EthereumVerifyMessage.signature)
}
inline void EthereumVerifyMessage::set_signature(const void* value, size_t size) {
  _has_bits_[0] |= 0x00000001u;
  signature_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:hw.trezor.messages.ethereum.EthereumVerifyMessage.signature)
}
inline ::std::string* EthereumVerifyMessage::mutable_signature() {
  _has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_mutable:hw.trezor.messages.ethereum.EthereumVerifyMessage.signature)
  return signature_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* EthereumVerifyMessage::release_signature() {
  // @@protoc_insertion_point(field_release:hw.trezor.messages.ethereum.EthereumVerifyMessage.signature)
  if (!has_signature()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return signature_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void EthereumVerifyMessage::set_allocated_signature(::std::string* signature) {
  if (signature != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  signature_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), signature);
  // @@protoc_insertion_point(field_set_allocated:hw.trezor.messages.ethereum.EthereumVerifyMessage.signature)
}

// optional bytes message = 3;
inline bool EthereumVerifyMessage::has_message() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void EthereumVerifyMessage::clear_message() {
  message_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000002u;
}
inline const ::std::string& EthereumVerifyMessage::message() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.ethereum.EthereumVerifyMessage.message)
  return message_.GetNoArena();
}
inline void EthereumVerifyMessage::set_message(const ::std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  message_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:hw.trezor.messages.ethereum.EthereumVerifyMessage.message)
}
#if LANG_CXX11
inline void EthereumVerifyMessage::set_message(::std::string&& value) {
  _has_bits_[0] |= 0x00000002u;
  message_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:hw.trezor.messages.ethereum.EthereumVerifyMessage.message)
}
#endif
inline void EthereumVerifyMessage::set_message(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000002u;
  message_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:hw.trezor.messages.ethereum.EthereumVerifyMessage.message)
}
inline void EthereumVerifyMessage::set_message(const void* value, size_t size) {
  _has_bits_[0] |= 0x00000002u;
  message_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:hw.trezor.messages.ethereum.EthereumVerifyMessage.message)
}
inline ::std::string* EthereumVerifyMessage::mutable_message() {
  _has_bits_[0] |= 0x00000002u;
  // @@protoc_insertion_point(field_mutable:hw.trezor.messages.ethereum.EthereumVerifyMessage.message)
  return message_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* EthereumVerifyMessage::release_message() {
  // @@protoc_insertion_point(field_release:hw.trezor.messages.ethereum.EthereumVerifyMessage.message)
  if (!has_message()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  return message_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void EthereumVerifyMessage::set_allocated_message(::std::string* message) {
  if (message != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  message_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), message);
  // @@protoc_insertion_point(field_set_allocated:hw.trezor.messages.ethereum.EthereumVerifyMessage.message)
}

// optional string address = 4;
inline bool EthereumVerifyMessage::has_address() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void EthereumVerifyMessage::clear_address() {
  address_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000004u;
}
inline const ::std::string& EthereumVerifyMessage::address() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.ethereum.EthereumVerifyMessage.address)
  return address_.GetNoArena();
}
inline void EthereumVerifyMessage::set_address(const ::std::string& value) {
  _has_bits_[0] |= 0x00000004u;
  address_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:hw.trezor.messages.ethereum.EthereumVerifyMessage.address)
}
#if LANG_CXX11
inline void EthereumVerifyMessage::set_address(::std::string&& value) {
  _has_bits_[0] |= 0x00000004u;
  address_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:hw.trezor.messages.ethereum.EthereumVerifyMessage.address)
}
#endif
inline void EthereumVerifyMessage::set_address(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000004u;
  address_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:hw.trezor.messages.ethereum.EthereumVerifyMessage.address)
}
inline void EthereumVerifyMessage::set_address(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000004u;
  address_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:hw.trezor.messages.ethereum.EthereumVerifyMessage.address)
}
inline ::std::string* EthereumVerifyMessage::mutable_address() {
  _has_bits_[0] |= 0x00000004u;
  // @@protoc_insertion_point(field_mutable:hw.trezor.messages.ethereum.EthereumVerifyMessage.address)
  return address_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* EthereumVerifyMessage::release_address() {
  // @@protoc_insertion_point(field_release:hw.trezor.messages.ethereum.EthereumVerifyMessage.address)
  if (!has_address()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000004u;
  return address_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void EthereumVerifyMessage::set_allocated_address(::std::string* address) {
  if (address != nullptr) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  address_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), address);
  // @@protoc_insertion_point(field_set_allocated:hw.trezor.messages.ethereum.EthereumVerifyMessage.address)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace ethereum
}  // namespace messages
}  // namespace trezor
}  // namespace hw

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // PROTOBUF_INCLUDED_messages_2dethereum_2eproto
