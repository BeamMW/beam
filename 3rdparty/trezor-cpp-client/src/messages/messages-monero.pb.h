// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: messages-monero.proto

#ifndef PROTOBUF_INCLUDED_messages_2dmonero_2eproto
#define PROTOBUF_INCLUDED_messages_2dmonero_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3007000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3007000 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_messages_2dmonero_2eproto

// Internal implementation detail -- do not use these members.
struct TableStruct_messages_2dmonero_2eproto {
  static const ::google::protobuf::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::google::protobuf::internal::ParseTable schema[50]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::google::protobuf::internal::FieldMetadata field_metadata[];
  static const ::google::protobuf::internal::SerializationTable serialization_table[];
  static const ::google::protobuf::uint32 offsets[];
};
void AddDescriptors_messages_2dmonero_2eproto();
namespace hw {
namespace trezor {
namespace messages {
namespace monero {
class DebugMoneroDiagAck;
class DebugMoneroDiagAckDefaultTypeInternal;
extern DebugMoneroDiagAckDefaultTypeInternal _DebugMoneroDiagAck_default_instance_;
class DebugMoneroDiagRequest;
class DebugMoneroDiagRequestDefaultTypeInternal;
extern DebugMoneroDiagRequestDefaultTypeInternal _DebugMoneroDiagRequest_default_instance_;
class MoneroAddress;
class MoneroAddressDefaultTypeInternal;
extern MoneroAddressDefaultTypeInternal _MoneroAddress_default_instance_;
class MoneroGetAddress;
class MoneroGetAddressDefaultTypeInternal;
extern MoneroGetAddressDefaultTypeInternal _MoneroGetAddress_default_instance_;
class MoneroGetTxKeyAck;
class MoneroGetTxKeyAckDefaultTypeInternal;
extern MoneroGetTxKeyAckDefaultTypeInternal _MoneroGetTxKeyAck_default_instance_;
class MoneroGetTxKeyRequest;
class MoneroGetTxKeyRequestDefaultTypeInternal;
extern MoneroGetTxKeyRequestDefaultTypeInternal _MoneroGetTxKeyRequest_default_instance_;
class MoneroGetWatchKey;
class MoneroGetWatchKeyDefaultTypeInternal;
extern MoneroGetWatchKeyDefaultTypeInternal _MoneroGetWatchKey_default_instance_;
class MoneroKeyImageExportInitAck;
class MoneroKeyImageExportInitAckDefaultTypeInternal;
extern MoneroKeyImageExportInitAckDefaultTypeInternal _MoneroKeyImageExportInitAck_default_instance_;
class MoneroKeyImageExportInitRequest;
class MoneroKeyImageExportInitRequestDefaultTypeInternal;
extern MoneroKeyImageExportInitRequestDefaultTypeInternal _MoneroKeyImageExportInitRequest_default_instance_;
class MoneroKeyImageExportInitRequest_MoneroSubAddressIndicesList;
class MoneroKeyImageExportInitRequest_MoneroSubAddressIndicesListDefaultTypeInternal;
extern MoneroKeyImageExportInitRequest_MoneroSubAddressIndicesListDefaultTypeInternal _MoneroKeyImageExportInitRequest_MoneroSubAddressIndicesList_default_instance_;
class MoneroKeyImageSyncFinalAck;
class MoneroKeyImageSyncFinalAckDefaultTypeInternal;
extern MoneroKeyImageSyncFinalAckDefaultTypeInternal _MoneroKeyImageSyncFinalAck_default_instance_;
class MoneroKeyImageSyncFinalRequest;
class MoneroKeyImageSyncFinalRequestDefaultTypeInternal;
extern MoneroKeyImageSyncFinalRequestDefaultTypeInternal _MoneroKeyImageSyncFinalRequest_default_instance_;
class MoneroKeyImageSyncStepAck;
class MoneroKeyImageSyncStepAckDefaultTypeInternal;
extern MoneroKeyImageSyncStepAckDefaultTypeInternal _MoneroKeyImageSyncStepAck_default_instance_;
class MoneroKeyImageSyncStepAck_MoneroExportedKeyImage;
class MoneroKeyImageSyncStepAck_MoneroExportedKeyImageDefaultTypeInternal;
extern MoneroKeyImageSyncStepAck_MoneroExportedKeyImageDefaultTypeInternal _MoneroKeyImageSyncStepAck_MoneroExportedKeyImage_default_instance_;
class MoneroKeyImageSyncStepRequest;
class MoneroKeyImageSyncStepRequestDefaultTypeInternal;
extern MoneroKeyImageSyncStepRequestDefaultTypeInternal _MoneroKeyImageSyncStepRequest_default_instance_;
class MoneroKeyImageSyncStepRequest_MoneroTransferDetails;
class MoneroKeyImageSyncStepRequest_MoneroTransferDetailsDefaultTypeInternal;
extern MoneroKeyImageSyncStepRequest_MoneroTransferDetailsDefaultTypeInternal _MoneroKeyImageSyncStepRequest_MoneroTransferDetails_default_instance_;
class MoneroLiveRefreshFinalAck;
class MoneroLiveRefreshFinalAckDefaultTypeInternal;
extern MoneroLiveRefreshFinalAckDefaultTypeInternal _MoneroLiveRefreshFinalAck_default_instance_;
class MoneroLiveRefreshFinalRequest;
class MoneroLiveRefreshFinalRequestDefaultTypeInternal;
extern MoneroLiveRefreshFinalRequestDefaultTypeInternal _MoneroLiveRefreshFinalRequest_default_instance_;
class MoneroLiveRefreshStartAck;
class MoneroLiveRefreshStartAckDefaultTypeInternal;
extern MoneroLiveRefreshStartAckDefaultTypeInternal _MoneroLiveRefreshStartAck_default_instance_;
class MoneroLiveRefreshStartRequest;
class MoneroLiveRefreshStartRequestDefaultTypeInternal;
extern MoneroLiveRefreshStartRequestDefaultTypeInternal _MoneroLiveRefreshStartRequest_default_instance_;
class MoneroLiveRefreshStepAck;
class MoneroLiveRefreshStepAckDefaultTypeInternal;
extern MoneroLiveRefreshStepAckDefaultTypeInternal _MoneroLiveRefreshStepAck_default_instance_;
class MoneroLiveRefreshStepRequest;
class MoneroLiveRefreshStepRequestDefaultTypeInternal;
extern MoneroLiveRefreshStepRequestDefaultTypeInternal _MoneroLiveRefreshStepRequest_default_instance_;
class MoneroTransactionAllInputsSetAck;
class MoneroTransactionAllInputsSetAckDefaultTypeInternal;
extern MoneroTransactionAllInputsSetAckDefaultTypeInternal _MoneroTransactionAllInputsSetAck_default_instance_;
class MoneroTransactionAllInputsSetRequest;
class MoneroTransactionAllInputsSetRequestDefaultTypeInternal;
extern MoneroTransactionAllInputsSetRequestDefaultTypeInternal _MoneroTransactionAllInputsSetRequest_default_instance_;
class MoneroTransactionAllOutSetAck;
class MoneroTransactionAllOutSetAckDefaultTypeInternal;
extern MoneroTransactionAllOutSetAckDefaultTypeInternal _MoneroTransactionAllOutSetAck_default_instance_;
class MoneroTransactionAllOutSetAck_MoneroRingCtSig;
class MoneroTransactionAllOutSetAck_MoneroRingCtSigDefaultTypeInternal;
extern MoneroTransactionAllOutSetAck_MoneroRingCtSigDefaultTypeInternal _MoneroTransactionAllOutSetAck_MoneroRingCtSig_default_instance_;
class MoneroTransactionAllOutSetRequest;
class MoneroTransactionAllOutSetRequestDefaultTypeInternal;
extern MoneroTransactionAllOutSetRequestDefaultTypeInternal _MoneroTransactionAllOutSetRequest_default_instance_;
class MoneroTransactionDestinationEntry;
class MoneroTransactionDestinationEntryDefaultTypeInternal;
extern MoneroTransactionDestinationEntryDefaultTypeInternal _MoneroTransactionDestinationEntry_default_instance_;
class MoneroTransactionDestinationEntry_MoneroAccountPublicAddress;
class MoneroTransactionDestinationEntry_MoneroAccountPublicAddressDefaultTypeInternal;
extern MoneroTransactionDestinationEntry_MoneroAccountPublicAddressDefaultTypeInternal _MoneroTransactionDestinationEntry_MoneroAccountPublicAddress_default_instance_;
class MoneroTransactionFinalAck;
class MoneroTransactionFinalAckDefaultTypeInternal;
extern MoneroTransactionFinalAckDefaultTypeInternal _MoneroTransactionFinalAck_default_instance_;
class MoneroTransactionFinalRequest;
class MoneroTransactionFinalRequestDefaultTypeInternal;
extern MoneroTransactionFinalRequestDefaultTypeInternal _MoneroTransactionFinalRequest_default_instance_;
class MoneroTransactionInitAck;
class MoneroTransactionInitAckDefaultTypeInternal;
extern MoneroTransactionInitAckDefaultTypeInternal _MoneroTransactionInitAck_default_instance_;
class MoneroTransactionInitRequest;
class MoneroTransactionInitRequestDefaultTypeInternal;
extern MoneroTransactionInitRequestDefaultTypeInternal _MoneroTransactionInitRequest_default_instance_;
class MoneroTransactionInitRequest_MoneroTransactionData;
class MoneroTransactionInitRequest_MoneroTransactionDataDefaultTypeInternal;
extern MoneroTransactionInitRequest_MoneroTransactionDataDefaultTypeInternal _MoneroTransactionInitRequest_MoneroTransactionData_default_instance_;
class MoneroTransactionInputViniAck;
class MoneroTransactionInputViniAckDefaultTypeInternal;
extern MoneroTransactionInputViniAckDefaultTypeInternal _MoneroTransactionInputViniAck_default_instance_;
class MoneroTransactionInputViniRequest;
class MoneroTransactionInputViniRequestDefaultTypeInternal;
extern MoneroTransactionInputViniRequestDefaultTypeInternal _MoneroTransactionInputViniRequest_default_instance_;
class MoneroTransactionInputsPermutationAck;
class MoneroTransactionInputsPermutationAckDefaultTypeInternal;
extern MoneroTransactionInputsPermutationAckDefaultTypeInternal _MoneroTransactionInputsPermutationAck_default_instance_;
class MoneroTransactionInputsPermutationRequest;
class MoneroTransactionInputsPermutationRequestDefaultTypeInternal;
extern MoneroTransactionInputsPermutationRequestDefaultTypeInternal _MoneroTransactionInputsPermutationRequest_default_instance_;
class MoneroTransactionRsigData;
class MoneroTransactionRsigDataDefaultTypeInternal;
extern MoneroTransactionRsigDataDefaultTypeInternal _MoneroTransactionRsigData_default_instance_;
class MoneroTransactionSetInputAck;
class MoneroTransactionSetInputAckDefaultTypeInternal;
extern MoneroTransactionSetInputAckDefaultTypeInternal _MoneroTransactionSetInputAck_default_instance_;
class MoneroTransactionSetInputRequest;
class MoneroTransactionSetInputRequestDefaultTypeInternal;
extern MoneroTransactionSetInputRequestDefaultTypeInternal _MoneroTransactionSetInputRequest_default_instance_;
class MoneroTransactionSetOutputAck;
class MoneroTransactionSetOutputAckDefaultTypeInternal;
extern MoneroTransactionSetOutputAckDefaultTypeInternal _MoneroTransactionSetOutputAck_default_instance_;
class MoneroTransactionSetOutputRequest;
class MoneroTransactionSetOutputRequestDefaultTypeInternal;
extern MoneroTransactionSetOutputRequestDefaultTypeInternal _MoneroTransactionSetOutputRequest_default_instance_;
class MoneroTransactionSignInputAck;
class MoneroTransactionSignInputAckDefaultTypeInternal;
extern MoneroTransactionSignInputAckDefaultTypeInternal _MoneroTransactionSignInputAck_default_instance_;
class MoneroTransactionSignInputRequest;
class MoneroTransactionSignInputRequestDefaultTypeInternal;
extern MoneroTransactionSignInputRequestDefaultTypeInternal _MoneroTransactionSignInputRequest_default_instance_;
class MoneroTransactionSourceEntry;
class MoneroTransactionSourceEntryDefaultTypeInternal;
extern MoneroTransactionSourceEntryDefaultTypeInternal _MoneroTransactionSourceEntry_default_instance_;
class MoneroTransactionSourceEntry_MoneroMultisigKLRki;
class MoneroTransactionSourceEntry_MoneroMultisigKLRkiDefaultTypeInternal;
extern MoneroTransactionSourceEntry_MoneroMultisigKLRkiDefaultTypeInternal _MoneroTransactionSourceEntry_MoneroMultisigKLRki_default_instance_;
class MoneroTransactionSourceEntry_MoneroOutputEntry;
class MoneroTransactionSourceEntry_MoneroOutputEntryDefaultTypeInternal;
extern MoneroTransactionSourceEntry_MoneroOutputEntryDefaultTypeInternal _MoneroTransactionSourceEntry_MoneroOutputEntry_default_instance_;
class MoneroTransactionSourceEntry_MoneroOutputEntry_MoneroRctKeyPublic;
class MoneroTransactionSourceEntry_MoneroOutputEntry_MoneroRctKeyPublicDefaultTypeInternal;
extern MoneroTransactionSourceEntry_MoneroOutputEntry_MoneroRctKeyPublicDefaultTypeInternal _MoneroTransactionSourceEntry_MoneroOutputEntry_MoneroRctKeyPublic_default_instance_;
class MoneroWatchKey;
class MoneroWatchKeyDefaultTypeInternal;
extern MoneroWatchKeyDefaultTypeInternal _MoneroWatchKey_default_instance_;
}  // namespace monero
}  // namespace messages
}  // namespace trezor
}  // namespace hw
namespace google {
namespace protobuf {
template<> ::hw::trezor::messages::monero::DebugMoneroDiagAck* Arena::CreateMaybeMessage<::hw::trezor::messages::monero::DebugMoneroDiagAck>(Arena*);
template<> ::hw::trezor::messages::monero::DebugMoneroDiagRequest* Arena::CreateMaybeMessage<::hw::trezor::messages::monero::DebugMoneroDiagRequest>(Arena*);
template<> ::hw::trezor::messages::monero::MoneroAddress* Arena::CreateMaybeMessage<::hw::trezor::messages::monero::MoneroAddress>(Arena*);
template<> ::hw::trezor::messages::monero::MoneroGetAddress* Arena::CreateMaybeMessage<::hw::trezor::messages::monero::MoneroGetAddress>(Arena*);
template<> ::hw::trezor::messages::monero::MoneroGetTxKeyAck* Arena::CreateMaybeMessage<::hw::trezor::messages::monero::MoneroGetTxKeyAck>(Arena*);
template<> ::hw::trezor::messages::monero::MoneroGetTxKeyRequest* Arena::CreateMaybeMessage<::hw::trezor::messages::monero::MoneroGetTxKeyRequest>(Arena*);
template<> ::hw::trezor::messages::monero::MoneroGetWatchKey* Arena::CreateMaybeMessage<::hw::trezor::messages::monero::MoneroGetWatchKey>(Arena*);
template<> ::hw::trezor::messages::monero::MoneroKeyImageExportInitAck* Arena::CreateMaybeMessage<::hw::trezor::messages::monero::MoneroKeyImageExportInitAck>(Arena*);
template<> ::hw::trezor::messages::monero::MoneroKeyImageExportInitRequest* Arena::CreateMaybeMessage<::hw::trezor::messages::monero::MoneroKeyImageExportInitRequest>(Arena*);
template<> ::hw::trezor::messages::monero::MoneroKeyImageExportInitRequest_MoneroSubAddressIndicesList* Arena::CreateMaybeMessage<::hw::trezor::messages::monero::MoneroKeyImageExportInitRequest_MoneroSubAddressIndicesList>(Arena*);
template<> ::hw::trezor::messages::monero::MoneroKeyImageSyncFinalAck* Arena::CreateMaybeMessage<::hw::trezor::messages::monero::MoneroKeyImageSyncFinalAck>(Arena*);
template<> ::hw::trezor::messages::monero::MoneroKeyImageSyncFinalRequest* Arena::CreateMaybeMessage<::hw::trezor::messages::monero::MoneroKeyImageSyncFinalRequest>(Arena*);
template<> ::hw::trezor::messages::monero::MoneroKeyImageSyncStepAck* Arena::CreateMaybeMessage<::hw::trezor::messages::monero::MoneroKeyImageSyncStepAck>(Arena*);
template<> ::hw::trezor::messages::monero::MoneroKeyImageSyncStepAck_MoneroExportedKeyImage* Arena::CreateMaybeMessage<::hw::trezor::messages::monero::MoneroKeyImageSyncStepAck_MoneroExportedKeyImage>(Arena*);
template<> ::hw::trezor::messages::monero::MoneroKeyImageSyncStepRequest* Arena::CreateMaybeMessage<::hw::trezor::messages::monero::MoneroKeyImageSyncStepRequest>(Arena*);
template<> ::hw::trezor::messages::monero::MoneroKeyImageSyncStepRequest_MoneroTransferDetails* Arena::CreateMaybeMessage<::hw::trezor::messages::monero::MoneroKeyImageSyncStepRequest_MoneroTransferDetails>(Arena*);
template<> ::hw::trezor::messages::monero::MoneroLiveRefreshFinalAck* Arena::CreateMaybeMessage<::hw::trezor::messages::monero::MoneroLiveRefreshFinalAck>(Arena*);
template<> ::hw::trezor::messages::monero::MoneroLiveRefreshFinalRequest* Arena::CreateMaybeMessage<::hw::trezor::messages::monero::MoneroLiveRefreshFinalRequest>(Arena*);
template<> ::hw::trezor::messages::monero::MoneroLiveRefreshStartAck* Arena::CreateMaybeMessage<::hw::trezor::messages::monero::MoneroLiveRefreshStartAck>(Arena*);
template<> ::hw::trezor::messages::monero::MoneroLiveRefreshStartRequest* Arena::CreateMaybeMessage<::hw::trezor::messages::monero::MoneroLiveRefreshStartRequest>(Arena*);
template<> ::hw::trezor::messages::monero::MoneroLiveRefreshStepAck* Arena::CreateMaybeMessage<::hw::trezor::messages::monero::MoneroLiveRefreshStepAck>(Arena*);
template<> ::hw::trezor::messages::monero::MoneroLiveRefreshStepRequest* Arena::CreateMaybeMessage<::hw::trezor::messages::monero::MoneroLiveRefreshStepRequest>(Arena*);
template<> ::hw::trezor::messages::monero::MoneroTransactionAllInputsSetAck* Arena::CreateMaybeMessage<::hw::trezor::messages::monero::MoneroTransactionAllInputsSetAck>(Arena*);
template<> ::hw::trezor::messages::monero::MoneroTransactionAllInputsSetRequest* Arena::CreateMaybeMessage<::hw::trezor::messages::monero::MoneroTransactionAllInputsSetRequest>(Arena*);
template<> ::hw::trezor::messages::monero::MoneroTransactionAllOutSetAck* Arena::CreateMaybeMessage<::hw::trezor::messages::monero::MoneroTransactionAllOutSetAck>(Arena*);
template<> ::hw::trezor::messages::monero::MoneroTransactionAllOutSetAck_MoneroRingCtSig* Arena::CreateMaybeMessage<::hw::trezor::messages::monero::MoneroTransactionAllOutSetAck_MoneroRingCtSig>(Arena*);
template<> ::hw::trezor::messages::monero::MoneroTransactionAllOutSetRequest* Arena::CreateMaybeMessage<::hw::trezor::messages::monero::MoneroTransactionAllOutSetRequest>(Arena*);
template<> ::hw::trezor::messages::monero::MoneroTransactionDestinationEntry* Arena::CreateMaybeMessage<::hw::trezor::messages::monero::MoneroTransactionDestinationEntry>(Arena*);
template<> ::hw::trezor::messages::monero::MoneroTransactionDestinationEntry_MoneroAccountPublicAddress* Arena::CreateMaybeMessage<::hw::trezor::messages::monero::MoneroTransactionDestinationEntry_MoneroAccountPublicAddress>(Arena*);
template<> ::hw::trezor::messages::monero::MoneroTransactionFinalAck* Arena::CreateMaybeMessage<::hw::trezor::messages::monero::MoneroTransactionFinalAck>(Arena*);
template<> ::hw::trezor::messages::monero::MoneroTransactionFinalRequest* Arena::CreateMaybeMessage<::hw::trezor::messages::monero::MoneroTransactionFinalRequest>(Arena*);
template<> ::hw::trezor::messages::monero::MoneroTransactionInitAck* Arena::CreateMaybeMessage<::hw::trezor::messages::monero::MoneroTransactionInitAck>(Arena*);
template<> ::hw::trezor::messages::monero::MoneroTransactionInitRequest* Arena::CreateMaybeMessage<::hw::trezor::messages::monero::MoneroTransactionInitRequest>(Arena*);
template<> ::hw::trezor::messages::monero::MoneroTransactionInitRequest_MoneroTransactionData* Arena::CreateMaybeMessage<::hw::trezor::messages::monero::MoneroTransactionInitRequest_MoneroTransactionData>(Arena*);
template<> ::hw::trezor::messages::monero::MoneroTransactionInputViniAck* Arena::CreateMaybeMessage<::hw::trezor::messages::monero::MoneroTransactionInputViniAck>(Arena*);
template<> ::hw::trezor::messages::monero::MoneroTransactionInputViniRequest* Arena::CreateMaybeMessage<::hw::trezor::messages::monero::MoneroTransactionInputViniRequest>(Arena*);
template<> ::hw::trezor::messages::monero::MoneroTransactionInputsPermutationAck* Arena::CreateMaybeMessage<::hw::trezor::messages::monero::MoneroTransactionInputsPermutationAck>(Arena*);
template<> ::hw::trezor::messages::monero::MoneroTransactionInputsPermutationRequest* Arena::CreateMaybeMessage<::hw::trezor::messages::monero::MoneroTransactionInputsPermutationRequest>(Arena*);
template<> ::hw::trezor::messages::monero::MoneroTransactionRsigData* Arena::CreateMaybeMessage<::hw::trezor::messages::monero::MoneroTransactionRsigData>(Arena*);
template<> ::hw::trezor::messages::monero::MoneroTransactionSetInputAck* Arena::CreateMaybeMessage<::hw::trezor::messages::monero::MoneroTransactionSetInputAck>(Arena*);
template<> ::hw::trezor::messages::monero::MoneroTransactionSetInputRequest* Arena::CreateMaybeMessage<::hw::trezor::messages::monero::MoneroTransactionSetInputRequest>(Arena*);
template<> ::hw::trezor::messages::monero::MoneroTransactionSetOutputAck* Arena::CreateMaybeMessage<::hw::trezor::messages::monero::MoneroTransactionSetOutputAck>(Arena*);
template<> ::hw::trezor::messages::monero::MoneroTransactionSetOutputRequest* Arena::CreateMaybeMessage<::hw::trezor::messages::monero::MoneroTransactionSetOutputRequest>(Arena*);
template<> ::hw::trezor::messages::monero::MoneroTransactionSignInputAck* Arena::CreateMaybeMessage<::hw::trezor::messages::monero::MoneroTransactionSignInputAck>(Arena*);
template<> ::hw::trezor::messages::monero::MoneroTransactionSignInputRequest* Arena::CreateMaybeMessage<::hw::trezor::messages::monero::MoneroTransactionSignInputRequest>(Arena*);
template<> ::hw::trezor::messages::monero::MoneroTransactionSourceEntry* Arena::CreateMaybeMessage<::hw::trezor::messages::monero::MoneroTransactionSourceEntry>(Arena*);
template<> ::hw::trezor::messages::monero::MoneroTransactionSourceEntry_MoneroMultisigKLRki* Arena::CreateMaybeMessage<::hw::trezor::messages::monero::MoneroTransactionSourceEntry_MoneroMultisigKLRki>(Arena*);
template<> ::hw::trezor::messages::monero::MoneroTransactionSourceEntry_MoneroOutputEntry* Arena::CreateMaybeMessage<::hw::trezor::messages::monero::MoneroTransactionSourceEntry_MoneroOutputEntry>(Arena*);
template<> ::hw::trezor::messages::monero::MoneroTransactionSourceEntry_MoneroOutputEntry_MoneroRctKeyPublic* Arena::CreateMaybeMessage<::hw::trezor::messages::monero::MoneroTransactionSourceEntry_MoneroOutputEntry_MoneroRctKeyPublic>(Arena*);
template<> ::hw::trezor::messages::monero::MoneroWatchKey* Arena::CreateMaybeMessage<::hw::trezor::messages::monero::MoneroWatchKey>(Arena*);
}  // namespace protobuf
}  // namespace google
namespace hw {
namespace trezor {
namespace messages {
namespace monero {

// ===================================================================

class MoneroTransactionSourceEntry_MoneroOutputEntry_MoneroRctKeyPublic final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:hw.trezor.messages.monero.MoneroTransactionSourceEntry.MoneroOutputEntry.MoneroRctKeyPublic) */ {
 public:
  MoneroTransactionSourceEntry_MoneroOutputEntry_MoneroRctKeyPublic();
  virtual ~MoneroTransactionSourceEntry_MoneroOutputEntry_MoneroRctKeyPublic();

  MoneroTransactionSourceEntry_MoneroOutputEntry_MoneroRctKeyPublic(const MoneroTransactionSourceEntry_MoneroOutputEntry_MoneroRctKeyPublic& from);

  inline MoneroTransactionSourceEntry_MoneroOutputEntry_MoneroRctKeyPublic& operator=(const MoneroTransactionSourceEntry_MoneroOutputEntry_MoneroRctKeyPublic& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  MoneroTransactionSourceEntry_MoneroOutputEntry_MoneroRctKeyPublic(MoneroTransactionSourceEntry_MoneroOutputEntry_MoneroRctKeyPublic&& from) noexcept
    : MoneroTransactionSourceEntry_MoneroOutputEntry_MoneroRctKeyPublic() {
    *this = ::std::move(from);
  }

  inline MoneroTransactionSourceEntry_MoneroOutputEntry_MoneroRctKeyPublic& operator=(MoneroTransactionSourceEntry_MoneroOutputEntry_MoneroRctKeyPublic&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const MoneroTransactionSourceEntry_MoneroOutputEntry_MoneroRctKeyPublic& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const MoneroTransactionSourceEntry_MoneroOutputEntry_MoneroRctKeyPublic* internal_default_instance() {
    return reinterpret_cast<const MoneroTransactionSourceEntry_MoneroOutputEntry_MoneroRctKeyPublic*>(
               &_MoneroTransactionSourceEntry_MoneroOutputEntry_MoneroRctKeyPublic_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  void Swap(MoneroTransactionSourceEntry_MoneroOutputEntry_MoneroRctKeyPublic* other);
  friend void swap(MoneroTransactionSourceEntry_MoneroOutputEntry_MoneroRctKeyPublic& a, MoneroTransactionSourceEntry_MoneroOutputEntry_MoneroRctKeyPublic& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline MoneroTransactionSourceEntry_MoneroOutputEntry_MoneroRctKeyPublic* New() const final {
    return CreateMaybeMessage<MoneroTransactionSourceEntry_MoneroOutputEntry_MoneroRctKeyPublic>(nullptr);
  }

  MoneroTransactionSourceEntry_MoneroOutputEntry_MoneroRctKeyPublic* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<MoneroTransactionSourceEntry_MoneroOutputEntry_MoneroRctKeyPublic>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const MoneroTransactionSourceEntry_MoneroOutputEntry_MoneroRctKeyPublic& from);
  void MergeFrom(const MoneroTransactionSourceEntry_MoneroOutputEntry_MoneroRctKeyPublic& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MoneroTransactionSourceEntry_MoneroOutputEntry_MoneroRctKeyPublic* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bytes dest = 1;
  bool has_dest() const;
  void clear_dest();
  static const int kDestFieldNumber = 1;
  const ::std::string& dest() const;
  void set_dest(const ::std::string& value);
  #if LANG_CXX11
  void set_dest(::std::string&& value);
  #endif
  void set_dest(const char* value);
  void set_dest(const void* value, size_t size);
  ::std::string* mutable_dest();
  ::std::string* release_dest();
  void set_allocated_dest(::std::string* dest);

  // optional bytes commitment = 2;
  bool has_commitment() const;
  void clear_commitment();
  static const int kCommitmentFieldNumber = 2;
  const ::std::string& commitment() const;
  void set_commitment(const ::std::string& value);
  #if LANG_CXX11
  void set_commitment(::std::string&& value);
  #endif
  void set_commitment(const char* value);
  void set_commitment(const void* value, size_t size);
  ::std::string* mutable_commitment();
  ::std::string* release_commitment();
  void set_allocated_commitment(::std::string* commitment);

  // @@protoc_insertion_point(class_scope:hw.trezor.messages.monero.MoneroTransactionSourceEntry.MoneroOutputEntry.MoneroRctKeyPublic)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr dest_;
  ::google::protobuf::internal::ArenaStringPtr commitment_;
  friend struct ::TableStruct_messages_2dmonero_2eproto;
};
// -------------------------------------------------------------------

class MoneroTransactionSourceEntry_MoneroOutputEntry final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:hw.trezor.messages.monero.MoneroTransactionSourceEntry.MoneroOutputEntry) */ {
 public:
  MoneroTransactionSourceEntry_MoneroOutputEntry();
  virtual ~MoneroTransactionSourceEntry_MoneroOutputEntry();

  MoneroTransactionSourceEntry_MoneroOutputEntry(const MoneroTransactionSourceEntry_MoneroOutputEntry& from);

  inline MoneroTransactionSourceEntry_MoneroOutputEntry& operator=(const MoneroTransactionSourceEntry_MoneroOutputEntry& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  MoneroTransactionSourceEntry_MoneroOutputEntry(MoneroTransactionSourceEntry_MoneroOutputEntry&& from) noexcept
    : MoneroTransactionSourceEntry_MoneroOutputEntry() {
    *this = ::std::move(from);
  }

  inline MoneroTransactionSourceEntry_MoneroOutputEntry& operator=(MoneroTransactionSourceEntry_MoneroOutputEntry&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const MoneroTransactionSourceEntry_MoneroOutputEntry& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const MoneroTransactionSourceEntry_MoneroOutputEntry* internal_default_instance() {
    return reinterpret_cast<const MoneroTransactionSourceEntry_MoneroOutputEntry*>(
               &_MoneroTransactionSourceEntry_MoneroOutputEntry_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  void Swap(MoneroTransactionSourceEntry_MoneroOutputEntry* other);
  friend void swap(MoneroTransactionSourceEntry_MoneroOutputEntry& a, MoneroTransactionSourceEntry_MoneroOutputEntry& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline MoneroTransactionSourceEntry_MoneroOutputEntry* New() const final {
    return CreateMaybeMessage<MoneroTransactionSourceEntry_MoneroOutputEntry>(nullptr);
  }

  MoneroTransactionSourceEntry_MoneroOutputEntry* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<MoneroTransactionSourceEntry_MoneroOutputEntry>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const MoneroTransactionSourceEntry_MoneroOutputEntry& from);
  void MergeFrom(const MoneroTransactionSourceEntry_MoneroOutputEntry& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MoneroTransactionSourceEntry_MoneroOutputEntry* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef MoneroTransactionSourceEntry_MoneroOutputEntry_MoneroRctKeyPublic MoneroRctKeyPublic;

  // accessors -------------------------------------------------------

  // optional .hw.trezor.messages.monero.MoneroTransactionSourceEntry.MoneroOutputEntry.MoneroRctKeyPublic key = 2;
  bool has_key() const;
  void clear_key();
  static const int kKeyFieldNumber = 2;
  const ::hw::trezor::messages::monero::MoneroTransactionSourceEntry_MoneroOutputEntry_MoneroRctKeyPublic& key() const;
  ::hw::trezor::messages::monero::MoneroTransactionSourceEntry_MoneroOutputEntry_MoneroRctKeyPublic* release_key();
  ::hw::trezor::messages::monero::MoneroTransactionSourceEntry_MoneroOutputEntry_MoneroRctKeyPublic* mutable_key();
  void set_allocated_key(::hw::trezor::messages::monero::MoneroTransactionSourceEntry_MoneroOutputEntry_MoneroRctKeyPublic* key);

  // optional uint64 idx = 1;
  bool has_idx() const;
  void clear_idx();
  static const int kIdxFieldNumber = 1;
  ::google::protobuf::uint64 idx() const;
  void set_idx(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:hw.trezor.messages.monero.MoneroTransactionSourceEntry.MoneroOutputEntry)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::hw::trezor::messages::monero::MoneroTransactionSourceEntry_MoneroOutputEntry_MoneroRctKeyPublic* key_;
  ::google::protobuf::uint64 idx_;
  friend struct ::TableStruct_messages_2dmonero_2eproto;
};
// -------------------------------------------------------------------

class MoneroTransactionSourceEntry_MoneroMultisigKLRki final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:hw.trezor.messages.monero.MoneroTransactionSourceEntry.MoneroMultisigKLRki) */ {
 public:
  MoneroTransactionSourceEntry_MoneroMultisigKLRki();
  virtual ~MoneroTransactionSourceEntry_MoneroMultisigKLRki();

  MoneroTransactionSourceEntry_MoneroMultisigKLRki(const MoneroTransactionSourceEntry_MoneroMultisigKLRki& from);

  inline MoneroTransactionSourceEntry_MoneroMultisigKLRki& operator=(const MoneroTransactionSourceEntry_MoneroMultisigKLRki& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  MoneroTransactionSourceEntry_MoneroMultisigKLRki(MoneroTransactionSourceEntry_MoneroMultisigKLRki&& from) noexcept
    : MoneroTransactionSourceEntry_MoneroMultisigKLRki() {
    *this = ::std::move(from);
  }

  inline MoneroTransactionSourceEntry_MoneroMultisigKLRki& operator=(MoneroTransactionSourceEntry_MoneroMultisigKLRki&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const MoneroTransactionSourceEntry_MoneroMultisigKLRki& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const MoneroTransactionSourceEntry_MoneroMultisigKLRki* internal_default_instance() {
    return reinterpret_cast<const MoneroTransactionSourceEntry_MoneroMultisigKLRki*>(
               &_MoneroTransactionSourceEntry_MoneroMultisigKLRki_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  void Swap(MoneroTransactionSourceEntry_MoneroMultisigKLRki* other);
  friend void swap(MoneroTransactionSourceEntry_MoneroMultisigKLRki& a, MoneroTransactionSourceEntry_MoneroMultisigKLRki& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline MoneroTransactionSourceEntry_MoneroMultisigKLRki* New() const final {
    return CreateMaybeMessage<MoneroTransactionSourceEntry_MoneroMultisigKLRki>(nullptr);
  }

  MoneroTransactionSourceEntry_MoneroMultisigKLRki* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<MoneroTransactionSourceEntry_MoneroMultisigKLRki>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const MoneroTransactionSourceEntry_MoneroMultisigKLRki& from);
  void MergeFrom(const MoneroTransactionSourceEntry_MoneroMultisigKLRki& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MoneroTransactionSourceEntry_MoneroMultisigKLRki* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bytes K = 1;
  bool has_k() const;
  void clear_k();
  static const int kKFieldNumber = 1;
  const ::std::string& k() const;
  void set_k(const ::std::string& value);
  #if LANG_CXX11
  void set_k(::std::string&& value);
  #endif
  void set_k(const char* value);
  void set_k(const void* value, size_t size);
  ::std::string* mutable_k();
  ::std::string* release_k();
  void set_allocated_k(::std::string* k);

  // optional bytes L = 2;
  bool has_l() const;
  void clear_l();
  static const int kLFieldNumber = 2;
  const ::std::string& l() const;
  void set_l(const ::std::string& value);
  #if LANG_CXX11
  void set_l(::std::string&& value);
  #endif
  void set_l(const char* value);
  void set_l(const void* value, size_t size);
  ::std::string* mutable_l();
  ::std::string* release_l();
  void set_allocated_l(::std::string* l);

  // optional bytes R = 3;
  bool has_r() const;
  void clear_r();
  static const int kRFieldNumber = 3;
  const ::std::string& r() const;
  void set_r(const ::std::string& value);
  #if LANG_CXX11
  void set_r(::std::string&& value);
  #endif
  void set_r(const char* value);
  void set_r(const void* value, size_t size);
  ::std::string* mutable_r();
  ::std::string* release_r();
  void set_allocated_r(::std::string* r);

  // optional bytes ki = 4;
  bool has_ki() const;
  void clear_ki();
  static const int kKiFieldNumber = 4;
  const ::std::string& ki() const;
  void set_ki(const ::std::string& value);
  #if LANG_CXX11
  void set_ki(::std::string&& value);
  #endif
  void set_ki(const char* value);
  void set_ki(const void* value, size_t size);
  ::std::string* mutable_ki();
  ::std::string* release_ki();
  void set_allocated_ki(::std::string* ki);

  // @@protoc_insertion_point(class_scope:hw.trezor.messages.monero.MoneroTransactionSourceEntry.MoneroMultisigKLRki)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr k_;
  ::google::protobuf::internal::ArenaStringPtr l_;
  ::google::protobuf::internal::ArenaStringPtr r_;
  ::google::protobuf::internal::ArenaStringPtr ki_;
  friend struct ::TableStruct_messages_2dmonero_2eproto;
};
// -------------------------------------------------------------------

class MoneroTransactionSourceEntry final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:hw.trezor.messages.monero.MoneroTransactionSourceEntry) */ {
 public:
  MoneroTransactionSourceEntry();
  virtual ~MoneroTransactionSourceEntry();

  MoneroTransactionSourceEntry(const MoneroTransactionSourceEntry& from);

  inline MoneroTransactionSourceEntry& operator=(const MoneroTransactionSourceEntry& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  MoneroTransactionSourceEntry(MoneroTransactionSourceEntry&& from) noexcept
    : MoneroTransactionSourceEntry() {
    *this = ::std::move(from);
  }

  inline MoneroTransactionSourceEntry& operator=(MoneroTransactionSourceEntry&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const MoneroTransactionSourceEntry& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const MoneroTransactionSourceEntry* internal_default_instance() {
    return reinterpret_cast<const MoneroTransactionSourceEntry*>(
               &_MoneroTransactionSourceEntry_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  void Swap(MoneroTransactionSourceEntry* other);
  friend void swap(MoneroTransactionSourceEntry& a, MoneroTransactionSourceEntry& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline MoneroTransactionSourceEntry* New() const final {
    return CreateMaybeMessage<MoneroTransactionSourceEntry>(nullptr);
  }

  MoneroTransactionSourceEntry* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<MoneroTransactionSourceEntry>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const MoneroTransactionSourceEntry& from);
  void MergeFrom(const MoneroTransactionSourceEntry& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MoneroTransactionSourceEntry* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef MoneroTransactionSourceEntry_MoneroOutputEntry MoneroOutputEntry;
  typedef MoneroTransactionSourceEntry_MoneroMultisigKLRki MoneroMultisigKLRki;

  // accessors -------------------------------------------------------

  // repeated .hw.trezor.messages.monero.MoneroTransactionSourceEntry.MoneroOutputEntry outputs = 1;
  int outputs_size() const;
  void clear_outputs();
  static const int kOutputsFieldNumber = 1;
  ::hw::trezor::messages::monero::MoneroTransactionSourceEntry_MoneroOutputEntry* mutable_outputs(int index);
  ::google::protobuf::RepeatedPtrField< ::hw::trezor::messages::monero::MoneroTransactionSourceEntry_MoneroOutputEntry >*
      mutable_outputs();
  const ::hw::trezor::messages::monero::MoneroTransactionSourceEntry_MoneroOutputEntry& outputs(int index) const;
  ::hw::trezor::messages::monero::MoneroTransactionSourceEntry_MoneroOutputEntry* add_outputs();
  const ::google::protobuf::RepeatedPtrField< ::hw::trezor::messages::monero::MoneroTransactionSourceEntry_MoneroOutputEntry >&
      outputs() const;

  // repeated bytes real_out_additional_tx_keys = 4;
  int real_out_additional_tx_keys_size() const;
  void clear_real_out_additional_tx_keys();
  static const int kRealOutAdditionalTxKeysFieldNumber = 4;
  const ::std::string& real_out_additional_tx_keys(int index) const;
  ::std::string* mutable_real_out_additional_tx_keys(int index);
  void set_real_out_additional_tx_keys(int index, const ::std::string& value);
  #if LANG_CXX11
  void set_real_out_additional_tx_keys(int index, ::std::string&& value);
  #endif
  void set_real_out_additional_tx_keys(int index, const char* value);
  void set_real_out_additional_tx_keys(int index, const void* value, size_t size);
  ::std::string* add_real_out_additional_tx_keys();
  void add_real_out_additional_tx_keys(const ::std::string& value);
  #if LANG_CXX11
  void add_real_out_additional_tx_keys(::std::string&& value);
  #endif
  void add_real_out_additional_tx_keys(const char* value);
  void add_real_out_additional_tx_keys(const void* value, size_t size);
  const ::google::protobuf::RepeatedPtrField<::std::string>& real_out_additional_tx_keys() const;
  ::google::protobuf::RepeatedPtrField<::std::string>* mutable_real_out_additional_tx_keys();

  // optional bytes real_out_tx_key = 3;
  bool has_real_out_tx_key() const;
  void clear_real_out_tx_key();
  static const int kRealOutTxKeyFieldNumber = 3;
  const ::std::string& real_out_tx_key() const;
  void set_real_out_tx_key(const ::std::string& value);
  #if LANG_CXX11
  void set_real_out_tx_key(::std::string&& value);
  #endif
  void set_real_out_tx_key(const char* value);
  void set_real_out_tx_key(const void* value, size_t size);
  ::std::string* mutable_real_out_tx_key();
  ::std::string* release_real_out_tx_key();
  void set_allocated_real_out_tx_key(::std::string* real_out_tx_key);

  // optional bytes mask = 8;
  bool has_mask() const;
  void clear_mask();
  static const int kMaskFieldNumber = 8;
  const ::std::string& mask() const;
  void set_mask(const ::std::string& value);
  #if LANG_CXX11
  void set_mask(::std::string&& value);
  #endif
  void set_mask(const char* value);
  void set_mask(const void* value, size_t size);
  ::std::string* mutable_mask();
  ::std::string* release_mask();
  void set_allocated_mask(::std::string* mask);

  // optional .hw.trezor.messages.monero.MoneroTransactionSourceEntry.MoneroMultisigKLRki multisig_kLRki = 9;
  bool has_multisig_klrki() const;
  void clear_multisig_klrki();
  static const int kMultisigKLRkiFieldNumber = 9;
  const ::hw::trezor::messages::monero::MoneroTransactionSourceEntry_MoneroMultisigKLRki& multisig_klrki() const;
  ::hw::trezor::messages::monero::MoneroTransactionSourceEntry_MoneroMultisigKLRki* release_multisig_klrki();
  ::hw::trezor::messages::monero::MoneroTransactionSourceEntry_MoneroMultisigKLRki* mutable_multisig_klrki();
  void set_allocated_multisig_klrki(::hw::trezor::messages::monero::MoneroTransactionSourceEntry_MoneroMultisigKLRki* multisig_klrki);

  // optional uint64 real_output = 2;
  bool has_real_output() const;
  void clear_real_output();
  static const int kRealOutputFieldNumber = 2;
  ::google::protobuf::uint64 real_output() const;
  void set_real_output(::google::protobuf::uint64 value);

  // optional uint64 real_output_in_tx_index = 5;
  bool has_real_output_in_tx_index() const;
  void clear_real_output_in_tx_index();
  static const int kRealOutputInTxIndexFieldNumber = 5;
  ::google::protobuf::uint64 real_output_in_tx_index() const;
  void set_real_output_in_tx_index(::google::protobuf::uint64 value);

  // optional uint64 amount = 6;
  bool has_amount() const;
  void clear_amount();
  static const int kAmountFieldNumber = 6;
  ::google::protobuf::uint64 amount() const;
  void set_amount(::google::protobuf::uint64 value);

  // optional bool rct = 7;
  bool has_rct() const;
  void clear_rct();
  static const int kRctFieldNumber = 7;
  bool rct() const;
  void set_rct(bool value);

  // @@protoc_insertion_point(class_scope:hw.trezor.messages.monero.MoneroTransactionSourceEntry)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::hw::trezor::messages::monero::MoneroTransactionSourceEntry_MoneroOutputEntry > outputs_;
  ::google::protobuf::RepeatedPtrField<::std::string> real_out_additional_tx_keys_;
  ::google::protobuf::internal::ArenaStringPtr real_out_tx_key_;
  ::google::protobuf::internal::ArenaStringPtr mask_;
  ::hw::trezor::messages::monero::MoneroTransactionSourceEntry_MoneroMultisigKLRki* multisig_klrki_;
  ::google::protobuf::uint64 real_output_;
  ::google::protobuf::uint64 real_output_in_tx_index_;
  ::google::protobuf::uint64 amount_;
  bool rct_;
  friend struct ::TableStruct_messages_2dmonero_2eproto;
};
// -------------------------------------------------------------------

class MoneroTransactionDestinationEntry_MoneroAccountPublicAddress final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:hw.trezor.messages.monero.MoneroTransactionDestinationEntry.MoneroAccountPublicAddress) */ {
 public:
  MoneroTransactionDestinationEntry_MoneroAccountPublicAddress();
  virtual ~MoneroTransactionDestinationEntry_MoneroAccountPublicAddress();

  MoneroTransactionDestinationEntry_MoneroAccountPublicAddress(const MoneroTransactionDestinationEntry_MoneroAccountPublicAddress& from);

  inline MoneroTransactionDestinationEntry_MoneroAccountPublicAddress& operator=(const MoneroTransactionDestinationEntry_MoneroAccountPublicAddress& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  MoneroTransactionDestinationEntry_MoneroAccountPublicAddress(MoneroTransactionDestinationEntry_MoneroAccountPublicAddress&& from) noexcept
    : MoneroTransactionDestinationEntry_MoneroAccountPublicAddress() {
    *this = ::std::move(from);
  }

  inline MoneroTransactionDestinationEntry_MoneroAccountPublicAddress& operator=(MoneroTransactionDestinationEntry_MoneroAccountPublicAddress&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const MoneroTransactionDestinationEntry_MoneroAccountPublicAddress& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const MoneroTransactionDestinationEntry_MoneroAccountPublicAddress* internal_default_instance() {
    return reinterpret_cast<const MoneroTransactionDestinationEntry_MoneroAccountPublicAddress*>(
               &_MoneroTransactionDestinationEntry_MoneroAccountPublicAddress_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  void Swap(MoneroTransactionDestinationEntry_MoneroAccountPublicAddress* other);
  friend void swap(MoneroTransactionDestinationEntry_MoneroAccountPublicAddress& a, MoneroTransactionDestinationEntry_MoneroAccountPublicAddress& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline MoneroTransactionDestinationEntry_MoneroAccountPublicAddress* New() const final {
    return CreateMaybeMessage<MoneroTransactionDestinationEntry_MoneroAccountPublicAddress>(nullptr);
  }

  MoneroTransactionDestinationEntry_MoneroAccountPublicAddress* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<MoneroTransactionDestinationEntry_MoneroAccountPublicAddress>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const MoneroTransactionDestinationEntry_MoneroAccountPublicAddress& from);
  void MergeFrom(const MoneroTransactionDestinationEntry_MoneroAccountPublicAddress& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MoneroTransactionDestinationEntry_MoneroAccountPublicAddress* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bytes spend_public_key = 1;
  bool has_spend_public_key() const;
  void clear_spend_public_key();
  static const int kSpendPublicKeyFieldNumber = 1;
  const ::std::string& spend_public_key() const;
  void set_spend_public_key(const ::std::string& value);
  #if LANG_CXX11
  void set_spend_public_key(::std::string&& value);
  #endif
  void set_spend_public_key(const char* value);
  void set_spend_public_key(const void* value, size_t size);
  ::std::string* mutable_spend_public_key();
  ::std::string* release_spend_public_key();
  void set_allocated_spend_public_key(::std::string* spend_public_key);

  // optional bytes view_public_key = 2;
  bool has_view_public_key() const;
  void clear_view_public_key();
  static const int kViewPublicKeyFieldNumber = 2;
  const ::std::string& view_public_key() const;
  void set_view_public_key(const ::std::string& value);
  #if LANG_CXX11
  void set_view_public_key(::std::string&& value);
  #endif
  void set_view_public_key(const char* value);
  void set_view_public_key(const void* value, size_t size);
  ::std::string* mutable_view_public_key();
  ::std::string* release_view_public_key();
  void set_allocated_view_public_key(::std::string* view_public_key);

  // @@protoc_insertion_point(class_scope:hw.trezor.messages.monero.MoneroTransactionDestinationEntry.MoneroAccountPublicAddress)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr spend_public_key_;
  ::google::protobuf::internal::ArenaStringPtr view_public_key_;
  friend struct ::TableStruct_messages_2dmonero_2eproto;
};
// -------------------------------------------------------------------

class MoneroTransactionDestinationEntry final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:hw.trezor.messages.monero.MoneroTransactionDestinationEntry) */ {
 public:
  MoneroTransactionDestinationEntry();
  virtual ~MoneroTransactionDestinationEntry();

  MoneroTransactionDestinationEntry(const MoneroTransactionDestinationEntry& from);

  inline MoneroTransactionDestinationEntry& operator=(const MoneroTransactionDestinationEntry& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  MoneroTransactionDestinationEntry(MoneroTransactionDestinationEntry&& from) noexcept
    : MoneroTransactionDestinationEntry() {
    *this = ::std::move(from);
  }

  inline MoneroTransactionDestinationEntry& operator=(MoneroTransactionDestinationEntry&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const MoneroTransactionDestinationEntry& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const MoneroTransactionDestinationEntry* internal_default_instance() {
    return reinterpret_cast<const MoneroTransactionDestinationEntry*>(
               &_MoneroTransactionDestinationEntry_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  void Swap(MoneroTransactionDestinationEntry* other);
  friend void swap(MoneroTransactionDestinationEntry& a, MoneroTransactionDestinationEntry& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline MoneroTransactionDestinationEntry* New() const final {
    return CreateMaybeMessage<MoneroTransactionDestinationEntry>(nullptr);
  }

  MoneroTransactionDestinationEntry* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<MoneroTransactionDestinationEntry>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const MoneroTransactionDestinationEntry& from);
  void MergeFrom(const MoneroTransactionDestinationEntry& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MoneroTransactionDestinationEntry* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef MoneroTransactionDestinationEntry_MoneroAccountPublicAddress MoneroAccountPublicAddress;

  // accessors -------------------------------------------------------

  // optional .hw.trezor.messages.monero.MoneroTransactionDestinationEntry.MoneroAccountPublicAddress addr = 2;
  bool has_addr() const;
  void clear_addr();
  static const int kAddrFieldNumber = 2;
  const ::hw::trezor::messages::monero::MoneroTransactionDestinationEntry_MoneroAccountPublicAddress& addr() const;
  ::hw::trezor::messages::monero::MoneroTransactionDestinationEntry_MoneroAccountPublicAddress* release_addr();
  ::hw::trezor::messages::monero::MoneroTransactionDestinationEntry_MoneroAccountPublicAddress* mutable_addr();
  void set_allocated_addr(::hw::trezor::messages::monero::MoneroTransactionDestinationEntry_MoneroAccountPublicAddress* addr);

  // optional uint64 amount = 1;
  bool has_amount() const;
  void clear_amount();
  static const int kAmountFieldNumber = 1;
  ::google::protobuf::uint64 amount() const;
  void set_amount(::google::protobuf::uint64 value);

  // optional bool is_subaddress = 3;
  bool has_is_subaddress() const;
  void clear_is_subaddress();
  static const int kIsSubaddressFieldNumber = 3;
  bool is_subaddress() const;
  void set_is_subaddress(bool value);

  // @@protoc_insertion_point(class_scope:hw.trezor.messages.monero.MoneroTransactionDestinationEntry)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::hw::trezor::messages::monero::MoneroTransactionDestinationEntry_MoneroAccountPublicAddress* addr_;
  ::google::protobuf::uint64 amount_;
  bool is_subaddress_;
  friend struct ::TableStruct_messages_2dmonero_2eproto;
};
// -------------------------------------------------------------------

class MoneroTransactionRsigData final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:hw.trezor.messages.monero.MoneroTransactionRsigData) */ {
 public:
  MoneroTransactionRsigData();
  virtual ~MoneroTransactionRsigData();

  MoneroTransactionRsigData(const MoneroTransactionRsigData& from);

  inline MoneroTransactionRsigData& operator=(const MoneroTransactionRsigData& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  MoneroTransactionRsigData(MoneroTransactionRsigData&& from) noexcept
    : MoneroTransactionRsigData() {
    *this = ::std::move(from);
  }

  inline MoneroTransactionRsigData& operator=(MoneroTransactionRsigData&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const MoneroTransactionRsigData& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const MoneroTransactionRsigData* internal_default_instance() {
    return reinterpret_cast<const MoneroTransactionRsigData*>(
               &_MoneroTransactionRsigData_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  void Swap(MoneroTransactionRsigData* other);
  friend void swap(MoneroTransactionRsigData& a, MoneroTransactionRsigData& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline MoneroTransactionRsigData* New() const final {
    return CreateMaybeMessage<MoneroTransactionRsigData>(nullptr);
  }

  MoneroTransactionRsigData* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<MoneroTransactionRsigData>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const MoneroTransactionRsigData& from);
  void MergeFrom(const MoneroTransactionRsigData& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MoneroTransactionRsigData* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated uint64 grouping = 3;
  int grouping_size() const;
  void clear_grouping();
  static const int kGroupingFieldNumber = 3;
  ::google::protobuf::uint64 grouping(int index) const;
  void set_grouping(int index, ::google::protobuf::uint64 value);
  void add_grouping(::google::protobuf::uint64 value);
  const ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >&
      grouping() const;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >*
      mutable_grouping();

  // repeated bytes rsig_parts = 6;
  int rsig_parts_size() const;
  void clear_rsig_parts();
  static const int kRsigPartsFieldNumber = 6;
  const ::std::string& rsig_parts(int index) const;
  ::std::string* mutable_rsig_parts(int index);
  void set_rsig_parts(int index, const ::std::string& value);
  #if LANG_CXX11
  void set_rsig_parts(int index, ::std::string&& value);
  #endif
  void set_rsig_parts(int index, const char* value);
  void set_rsig_parts(int index, const void* value, size_t size);
  ::std::string* add_rsig_parts();
  void add_rsig_parts(const ::std::string& value);
  #if LANG_CXX11
  void add_rsig_parts(::std::string&& value);
  #endif
  void add_rsig_parts(const char* value);
  void add_rsig_parts(const void* value, size_t size);
  const ::google::protobuf::RepeatedPtrField<::std::string>& rsig_parts() const;
  ::google::protobuf::RepeatedPtrField<::std::string>* mutable_rsig_parts();

  // optional bytes mask = 4;
  bool has_mask() const;
  void clear_mask();
  static const int kMaskFieldNumber = 4;
  const ::std::string& mask() const;
  void set_mask(const ::std::string& value);
  #if LANG_CXX11
  void set_mask(::std::string&& value);
  #endif
  void set_mask(const char* value);
  void set_mask(const void* value, size_t size);
  ::std::string* mutable_mask();
  ::std::string* release_mask();
  void set_allocated_mask(::std::string* mask);

  // optional bytes rsig = 5;
  bool has_rsig() const;
  void clear_rsig();
  static const int kRsigFieldNumber = 5;
  const ::std::string& rsig() const;
  void set_rsig(const ::std::string& value);
  #if LANG_CXX11
  void set_rsig(::std::string&& value);
  #endif
  void set_rsig(const char* value);
  void set_rsig(const void* value, size_t size);
  ::std::string* mutable_rsig();
  ::std::string* release_rsig();
  void set_allocated_rsig(::std::string* rsig);

  // optional uint32 rsig_type = 1;
  bool has_rsig_type() const;
  void clear_rsig_type();
  static const int kRsigTypeFieldNumber = 1;
  ::google::protobuf::uint32 rsig_type() const;
  void set_rsig_type(::google::protobuf::uint32 value);

  // optional uint32 offload_type = 2;
  bool has_offload_type() const;
  void clear_offload_type();
  static const int kOffloadTypeFieldNumber = 2;
  ::google::protobuf::uint32 offload_type() const;
  void set_offload_type(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:hw.trezor.messages.monero.MoneroTransactionRsigData)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint64 > grouping_;
  ::google::protobuf::RepeatedPtrField<::std::string> rsig_parts_;
  ::google::protobuf::internal::ArenaStringPtr mask_;
  ::google::protobuf::internal::ArenaStringPtr rsig_;
  ::google::protobuf::uint32 rsig_type_;
  ::google::protobuf::uint32 offload_type_;
  friend struct ::TableStruct_messages_2dmonero_2eproto;
};
// -------------------------------------------------------------------

class MoneroGetAddress final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:hw.trezor.messages.monero.MoneroGetAddress) */ {
 public:
  MoneroGetAddress();
  virtual ~MoneroGetAddress();

  MoneroGetAddress(const MoneroGetAddress& from);

  inline MoneroGetAddress& operator=(const MoneroGetAddress& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  MoneroGetAddress(MoneroGetAddress&& from) noexcept
    : MoneroGetAddress() {
    *this = ::std::move(from);
  }

  inline MoneroGetAddress& operator=(MoneroGetAddress&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const MoneroGetAddress& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const MoneroGetAddress* internal_default_instance() {
    return reinterpret_cast<const MoneroGetAddress*>(
               &_MoneroGetAddress_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  void Swap(MoneroGetAddress* other);
  friend void swap(MoneroGetAddress& a, MoneroGetAddress& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline MoneroGetAddress* New() const final {
    return CreateMaybeMessage<MoneroGetAddress>(nullptr);
  }

  MoneroGetAddress* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<MoneroGetAddress>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const MoneroGetAddress& from);
  void MergeFrom(const MoneroGetAddress& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MoneroGetAddress* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated uint32 address_n = 1;
  int address_n_size() const;
  void clear_address_n();
  static const int kAddressNFieldNumber = 1;
  ::google::protobuf::uint32 address_n(int index) const;
  void set_address_n(int index, ::google::protobuf::uint32 value);
  void add_address_n(::google::protobuf::uint32 value);
  const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      address_n() const;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable_address_n();

  // optional bool show_display = 2;
  bool has_show_display() const;
  void clear_show_display();
  static const int kShowDisplayFieldNumber = 2;
  bool show_display() const;
  void set_show_display(bool value);

  // optional uint32 network_type = 3;
  bool has_network_type() const;
  void clear_network_type();
  static const int kNetworkTypeFieldNumber = 3;
  ::google::protobuf::uint32 network_type() const;
  void set_network_type(::google::protobuf::uint32 value);

  // optional uint32 account = 4;
  bool has_account() const;
  void clear_account();
  static const int kAccountFieldNumber = 4;
  ::google::protobuf::uint32 account() const;
  void set_account(::google::protobuf::uint32 value);

  // optional uint32 minor = 5;
  bool has_minor() const;
  void clear_minor();
  static const int kMinorFieldNumber = 5;
  ::google::protobuf::uint32 minor() const;
  void set_minor(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:hw.trezor.messages.monero.MoneroGetAddress)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > address_n_;
  bool show_display_;
  ::google::protobuf::uint32 network_type_;
  ::google::protobuf::uint32 account_;
  ::google::protobuf::uint32 minor_;
  friend struct ::TableStruct_messages_2dmonero_2eproto;
};
// -------------------------------------------------------------------

class MoneroAddress final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:hw.trezor.messages.monero.MoneroAddress) */ {
 public:
  MoneroAddress();
  virtual ~MoneroAddress();

  MoneroAddress(const MoneroAddress& from);

  inline MoneroAddress& operator=(const MoneroAddress& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  MoneroAddress(MoneroAddress&& from) noexcept
    : MoneroAddress() {
    *this = ::std::move(from);
  }

  inline MoneroAddress& operator=(MoneroAddress&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const MoneroAddress& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const MoneroAddress* internal_default_instance() {
    return reinterpret_cast<const MoneroAddress*>(
               &_MoneroAddress_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  void Swap(MoneroAddress* other);
  friend void swap(MoneroAddress& a, MoneroAddress& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline MoneroAddress* New() const final {
    return CreateMaybeMessage<MoneroAddress>(nullptr);
  }

  MoneroAddress* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<MoneroAddress>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const MoneroAddress& from);
  void MergeFrom(const MoneroAddress& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MoneroAddress* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bytes address = 1;
  bool has_address() const;
  void clear_address();
  static const int kAddressFieldNumber = 1;
  const ::std::string& address() const;
  void set_address(const ::std::string& value);
  #if LANG_CXX11
  void set_address(::std::string&& value);
  #endif
  void set_address(const char* value);
  void set_address(const void* value, size_t size);
  ::std::string* mutable_address();
  ::std::string* release_address();
  void set_allocated_address(::std::string* address);

  // @@protoc_insertion_point(class_scope:hw.trezor.messages.monero.MoneroAddress)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr address_;
  friend struct ::TableStruct_messages_2dmonero_2eproto;
};
// -------------------------------------------------------------------

class MoneroGetWatchKey final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:hw.trezor.messages.monero.MoneroGetWatchKey) */ {
 public:
  MoneroGetWatchKey();
  virtual ~MoneroGetWatchKey();

  MoneroGetWatchKey(const MoneroGetWatchKey& from);

  inline MoneroGetWatchKey& operator=(const MoneroGetWatchKey& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  MoneroGetWatchKey(MoneroGetWatchKey&& from) noexcept
    : MoneroGetWatchKey() {
    *this = ::std::move(from);
  }

  inline MoneroGetWatchKey& operator=(MoneroGetWatchKey&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const MoneroGetWatchKey& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const MoneroGetWatchKey* internal_default_instance() {
    return reinterpret_cast<const MoneroGetWatchKey*>(
               &_MoneroGetWatchKey_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  void Swap(MoneroGetWatchKey* other);
  friend void swap(MoneroGetWatchKey& a, MoneroGetWatchKey& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline MoneroGetWatchKey* New() const final {
    return CreateMaybeMessage<MoneroGetWatchKey>(nullptr);
  }

  MoneroGetWatchKey* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<MoneroGetWatchKey>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const MoneroGetWatchKey& from);
  void MergeFrom(const MoneroGetWatchKey& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MoneroGetWatchKey* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated uint32 address_n = 1;
  int address_n_size() const;
  void clear_address_n();
  static const int kAddressNFieldNumber = 1;
  ::google::protobuf::uint32 address_n(int index) const;
  void set_address_n(int index, ::google::protobuf::uint32 value);
  void add_address_n(::google::protobuf::uint32 value);
  const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      address_n() const;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable_address_n();

  // optional uint32 network_type = 2;
  bool has_network_type() const;
  void clear_network_type();
  static const int kNetworkTypeFieldNumber = 2;
  ::google::protobuf::uint32 network_type() const;
  void set_network_type(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:hw.trezor.messages.monero.MoneroGetWatchKey)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > address_n_;
  ::google::protobuf::uint32 network_type_;
  friend struct ::TableStruct_messages_2dmonero_2eproto;
};
// -------------------------------------------------------------------

class MoneroWatchKey final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:hw.trezor.messages.monero.MoneroWatchKey) */ {
 public:
  MoneroWatchKey();
  virtual ~MoneroWatchKey();

  MoneroWatchKey(const MoneroWatchKey& from);

  inline MoneroWatchKey& operator=(const MoneroWatchKey& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  MoneroWatchKey(MoneroWatchKey&& from) noexcept
    : MoneroWatchKey() {
    *this = ::std::move(from);
  }

  inline MoneroWatchKey& operator=(MoneroWatchKey&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const MoneroWatchKey& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const MoneroWatchKey* internal_default_instance() {
    return reinterpret_cast<const MoneroWatchKey*>(
               &_MoneroWatchKey_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  void Swap(MoneroWatchKey* other);
  friend void swap(MoneroWatchKey& a, MoneroWatchKey& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline MoneroWatchKey* New() const final {
    return CreateMaybeMessage<MoneroWatchKey>(nullptr);
  }

  MoneroWatchKey* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<MoneroWatchKey>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const MoneroWatchKey& from);
  void MergeFrom(const MoneroWatchKey& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MoneroWatchKey* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bytes watch_key = 1;
  bool has_watch_key() const;
  void clear_watch_key();
  static const int kWatchKeyFieldNumber = 1;
  const ::std::string& watch_key() const;
  void set_watch_key(const ::std::string& value);
  #if LANG_CXX11
  void set_watch_key(::std::string&& value);
  #endif
  void set_watch_key(const char* value);
  void set_watch_key(const void* value, size_t size);
  ::std::string* mutable_watch_key();
  ::std::string* release_watch_key();
  void set_allocated_watch_key(::std::string* watch_key);

  // optional bytes address = 2;
  bool has_address() const;
  void clear_address();
  static const int kAddressFieldNumber = 2;
  const ::std::string& address() const;
  void set_address(const ::std::string& value);
  #if LANG_CXX11
  void set_address(::std::string&& value);
  #endif
  void set_address(const char* value);
  void set_address(const void* value, size_t size);
  ::std::string* mutable_address();
  ::std::string* release_address();
  void set_allocated_address(::std::string* address);

  // @@protoc_insertion_point(class_scope:hw.trezor.messages.monero.MoneroWatchKey)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr watch_key_;
  ::google::protobuf::internal::ArenaStringPtr address_;
  friend struct ::TableStruct_messages_2dmonero_2eproto;
};
// -------------------------------------------------------------------

class MoneroTransactionInitRequest_MoneroTransactionData final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:hw.trezor.messages.monero.MoneroTransactionInitRequest.MoneroTransactionData) */ {
 public:
  MoneroTransactionInitRequest_MoneroTransactionData();
  virtual ~MoneroTransactionInitRequest_MoneroTransactionData();

  MoneroTransactionInitRequest_MoneroTransactionData(const MoneroTransactionInitRequest_MoneroTransactionData& from);

  inline MoneroTransactionInitRequest_MoneroTransactionData& operator=(const MoneroTransactionInitRequest_MoneroTransactionData& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  MoneroTransactionInitRequest_MoneroTransactionData(MoneroTransactionInitRequest_MoneroTransactionData&& from) noexcept
    : MoneroTransactionInitRequest_MoneroTransactionData() {
    *this = ::std::move(from);
  }

  inline MoneroTransactionInitRequest_MoneroTransactionData& operator=(MoneroTransactionInitRequest_MoneroTransactionData&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const MoneroTransactionInitRequest_MoneroTransactionData& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const MoneroTransactionInitRequest_MoneroTransactionData* internal_default_instance() {
    return reinterpret_cast<const MoneroTransactionInitRequest_MoneroTransactionData*>(
               &_MoneroTransactionInitRequest_MoneroTransactionData_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  void Swap(MoneroTransactionInitRequest_MoneroTransactionData* other);
  friend void swap(MoneroTransactionInitRequest_MoneroTransactionData& a, MoneroTransactionInitRequest_MoneroTransactionData& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline MoneroTransactionInitRequest_MoneroTransactionData* New() const final {
    return CreateMaybeMessage<MoneroTransactionInitRequest_MoneroTransactionData>(nullptr);
  }

  MoneroTransactionInitRequest_MoneroTransactionData* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<MoneroTransactionInitRequest_MoneroTransactionData>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const MoneroTransactionInitRequest_MoneroTransactionData& from);
  void MergeFrom(const MoneroTransactionInitRequest_MoneroTransactionData& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MoneroTransactionInitRequest_MoneroTransactionData* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .hw.trezor.messages.monero.MoneroTransactionDestinationEntry outputs = 4;
  int outputs_size() const;
  void clear_outputs();
  static const int kOutputsFieldNumber = 4;
  ::hw::trezor::messages::monero::MoneroTransactionDestinationEntry* mutable_outputs(int index);
  ::google::protobuf::RepeatedPtrField< ::hw::trezor::messages::monero::MoneroTransactionDestinationEntry >*
      mutable_outputs();
  const ::hw::trezor::messages::monero::MoneroTransactionDestinationEntry& outputs(int index) const;
  ::hw::trezor::messages::monero::MoneroTransactionDestinationEntry* add_outputs();
  const ::google::protobuf::RepeatedPtrField< ::hw::trezor::messages::monero::MoneroTransactionDestinationEntry >&
      outputs() const;

  // repeated uint32 minor_indices = 10;
  int minor_indices_size() const;
  void clear_minor_indices();
  static const int kMinorIndicesFieldNumber = 10;
  ::google::protobuf::uint32 minor_indices(int index) const;
  void set_minor_indices(int index, ::google::protobuf::uint32 value);
  void add_minor_indices(::google::protobuf::uint32 value);
  const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      minor_indices() const;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable_minor_indices();

  // repeated uint32 integrated_indices = 12;
  int integrated_indices_size() const;
  void clear_integrated_indices();
  static const int kIntegratedIndicesFieldNumber = 12;
  ::google::protobuf::uint32 integrated_indices(int index) const;
  void set_integrated_indices(int index, ::google::protobuf::uint32 value);
  void add_integrated_indices(::google::protobuf::uint32 value);
  const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      integrated_indices() const;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable_integrated_indices();

  // optional bytes payment_id = 2;
  bool has_payment_id() const;
  void clear_payment_id();
  static const int kPaymentIdFieldNumber = 2;
  const ::std::string& payment_id() const;
  void set_payment_id(const ::std::string& value);
  #if LANG_CXX11
  void set_payment_id(::std::string&& value);
  #endif
  void set_payment_id(const char* value);
  void set_payment_id(const void* value, size_t size);
  ::std::string* mutable_payment_id();
  ::std::string* release_payment_id();
  void set_allocated_payment_id(::std::string* payment_id);

  // optional .hw.trezor.messages.monero.MoneroTransactionDestinationEntry change_dts = 5;
  bool has_change_dts() const;
  void clear_change_dts();
  static const int kChangeDtsFieldNumber = 5;
  const ::hw::trezor::messages::monero::MoneroTransactionDestinationEntry& change_dts() const;
  ::hw::trezor::messages::monero::MoneroTransactionDestinationEntry* release_change_dts();
  ::hw::trezor::messages::monero::MoneroTransactionDestinationEntry* mutable_change_dts();
  void set_allocated_change_dts(::hw::trezor::messages::monero::MoneroTransactionDestinationEntry* change_dts);

  // optional .hw.trezor.messages.monero.MoneroTransactionRsigData rsig_data = 11;
  bool has_rsig_data() const;
  void clear_rsig_data();
  static const int kRsigDataFieldNumber = 11;
  const ::hw::trezor::messages::monero::MoneroTransactionRsigData& rsig_data() const;
  ::hw::trezor::messages::monero::MoneroTransactionRsigData* release_rsig_data();
  ::hw::trezor::messages::monero::MoneroTransactionRsigData* mutable_rsig_data();
  void set_allocated_rsig_data(::hw::trezor::messages::monero::MoneroTransactionRsigData* rsig_data);

  // optional uint64 unlock_time = 3;
  bool has_unlock_time() const;
  void clear_unlock_time();
  static const int kUnlockTimeFieldNumber = 3;
  ::google::protobuf::uint64 unlock_time() const;
  void set_unlock_time(::google::protobuf::uint64 value);

  // optional uint32 version = 1;
  bool has_version() const;
  void clear_version();
  static const int kVersionFieldNumber = 1;
  ::google::protobuf::uint32 version() const;
  void set_version(::google::protobuf::uint32 value);

  // optional uint32 num_inputs = 6;
  bool has_num_inputs() const;
  void clear_num_inputs();
  static const int kNumInputsFieldNumber = 6;
  ::google::protobuf::uint32 num_inputs() const;
  void set_num_inputs(::google::protobuf::uint32 value);

  // optional uint64 fee = 8;
  bool has_fee() const;
  void clear_fee();
  static const int kFeeFieldNumber = 8;
  ::google::protobuf::uint64 fee() const;
  void set_fee(::google::protobuf::uint64 value);

  // optional uint32 mixin = 7;
  bool has_mixin() const;
  void clear_mixin();
  static const int kMixinFieldNumber = 7;
  ::google::protobuf::uint32 mixin() const;
  void set_mixin(::google::protobuf::uint32 value);

  // optional uint32 account = 9;
  bool has_account() const;
  void clear_account();
  static const int kAccountFieldNumber = 9;
  ::google::protobuf::uint32 account() const;
  void set_account(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:hw.trezor.messages.monero.MoneroTransactionInitRequest.MoneroTransactionData)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::hw::trezor::messages::monero::MoneroTransactionDestinationEntry > outputs_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > minor_indices_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > integrated_indices_;
  ::google::protobuf::internal::ArenaStringPtr payment_id_;
  ::hw::trezor::messages::monero::MoneroTransactionDestinationEntry* change_dts_;
  ::hw::trezor::messages::monero::MoneroTransactionRsigData* rsig_data_;
  ::google::protobuf::uint64 unlock_time_;
  ::google::protobuf::uint32 version_;
  ::google::protobuf::uint32 num_inputs_;
  ::google::protobuf::uint64 fee_;
  ::google::protobuf::uint32 mixin_;
  ::google::protobuf::uint32 account_;
  friend struct ::TableStruct_messages_2dmonero_2eproto;
};
// -------------------------------------------------------------------

class MoneroTransactionInitRequest final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:hw.trezor.messages.monero.MoneroTransactionInitRequest) */ {
 public:
  MoneroTransactionInitRequest();
  virtual ~MoneroTransactionInitRequest();

  MoneroTransactionInitRequest(const MoneroTransactionInitRequest& from);

  inline MoneroTransactionInitRequest& operator=(const MoneroTransactionInitRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  MoneroTransactionInitRequest(MoneroTransactionInitRequest&& from) noexcept
    : MoneroTransactionInitRequest() {
    *this = ::std::move(from);
  }

  inline MoneroTransactionInitRequest& operator=(MoneroTransactionInitRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const MoneroTransactionInitRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const MoneroTransactionInitRequest* internal_default_instance() {
    return reinterpret_cast<const MoneroTransactionInitRequest*>(
               &_MoneroTransactionInitRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  void Swap(MoneroTransactionInitRequest* other);
  friend void swap(MoneroTransactionInitRequest& a, MoneroTransactionInitRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline MoneroTransactionInitRequest* New() const final {
    return CreateMaybeMessage<MoneroTransactionInitRequest>(nullptr);
  }

  MoneroTransactionInitRequest* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<MoneroTransactionInitRequest>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const MoneroTransactionInitRequest& from);
  void MergeFrom(const MoneroTransactionInitRequest& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MoneroTransactionInitRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef MoneroTransactionInitRequest_MoneroTransactionData MoneroTransactionData;

  // accessors -------------------------------------------------------

  // repeated uint32 address_n = 2;
  int address_n_size() const;
  void clear_address_n();
  static const int kAddressNFieldNumber = 2;
  ::google::protobuf::uint32 address_n(int index) const;
  void set_address_n(int index, ::google::protobuf::uint32 value);
  void add_address_n(::google::protobuf::uint32 value);
  const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      address_n() const;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable_address_n();

  // optional .hw.trezor.messages.monero.MoneroTransactionInitRequest.MoneroTransactionData tsx_data = 4;
  bool has_tsx_data() const;
  void clear_tsx_data();
  static const int kTsxDataFieldNumber = 4;
  const ::hw::trezor::messages::monero::MoneroTransactionInitRequest_MoneroTransactionData& tsx_data() const;
  ::hw::trezor::messages::monero::MoneroTransactionInitRequest_MoneroTransactionData* release_tsx_data();
  ::hw::trezor::messages::monero::MoneroTransactionInitRequest_MoneroTransactionData* mutable_tsx_data();
  void set_allocated_tsx_data(::hw::trezor::messages::monero::MoneroTransactionInitRequest_MoneroTransactionData* tsx_data);

  // optional uint32 version = 1;
  bool has_version() const;
  void clear_version();
  static const int kVersionFieldNumber = 1;
  ::google::protobuf::uint32 version() const;
  void set_version(::google::protobuf::uint32 value);

  // optional uint32 network_type = 3;
  bool has_network_type() const;
  void clear_network_type();
  static const int kNetworkTypeFieldNumber = 3;
  ::google::protobuf::uint32 network_type() const;
  void set_network_type(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:hw.trezor.messages.monero.MoneroTransactionInitRequest)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > address_n_;
  ::hw::trezor::messages::monero::MoneroTransactionInitRequest_MoneroTransactionData* tsx_data_;
  ::google::protobuf::uint32 version_;
  ::google::protobuf::uint32 network_type_;
  friend struct ::TableStruct_messages_2dmonero_2eproto;
};
// -------------------------------------------------------------------

class MoneroTransactionInitAck final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:hw.trezor.messages.monero.MoneroTransactionInitAck) */ {
 public:
  MoneroTransactionInitAck();
  virtual ~MoneroTransactionInitAck();

  MoneroTransactionInitAck(const MoneroTransactionInitAck& from);

  inline MoneroTransactionInitAck& operator=(const MoneroTransactionInitAck& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  MoneroTransactionInitAck(MoneroTransactionInitAck&& from) noexcept
    : MoneroTransactionInitAck() {
    *this = ::std::move(from);
  }

  inline MoneroTransactionInitAck& operator=(MoneroTransactionInitAck&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const MoneroTransactionInitAck& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const MoneroTransactionInitAck* internal_default_instance() {
    return reinterpret_cast<const MoneroTransactionInitAck*>(
               &_MoneroTransactionInitAck_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  void Swap(MoneroTransactionInitAck* other);
  friend void swap(MoneroTransactionInitAck& a, MoneroTransactionInitAck& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline MoneroTransactionInitAck* New() const final {
    return CreateMaybeMessage<MoneroTransactionInitAck>(nullptr);
  }

  MoneroTransactionInitAck* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<MoneroTransactionInitAck>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const MoneroTransactionInitAck& from);
  void MergeFrom(const MoneroTransactionInitAck& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MoneroTransactionInitAck* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated bytes hmacs = 1;
  int hmacs_size() const;
  void clear_hmacs();
  static const int kHmacsFieldNumber = 1;
  const ::std::string& hmacs(int index) const;
  ::std::string* mutable_hmacs(int index);
  void set_hmacs(int index, const ::std::string& value);
  #if LANG_CXX11
  void set_hmacs(int index, ::std::string&& value);
  #endif
  void set_hmacs(int index, const char* value);
  void set_hmacs(int index, const void* value, size_t size);
  ::std::string* add_hmacs();
  void add_hmacs(const ::std::string& value);
  #if LANG_CXX11
  void add_hmacs(::std::string&& value);
  #endif
  void add_hmacs(const char* value);
  void add_hmacs(const void* value, size_t size);
  const ::google::protobuf::RepeatedPtrField<::std::string>& hmacs() const;
  ::google::protobuf::RepeatedPtrField<::std::string>* mutable_hmacs();

  // optional .hw.trezor.messages.monero.MoneroTransactionRsigData rsig_data = 2;
  bool has_rsig_data() const;
  void clear_rsig_data();
  static const int kRsigDataFieldNumber = 2;
  const ::hw::trezor::messages::monero::MoneroTransactionRsigData& rsig_data() const;
  ::hw::trezor::messages::monero::MoneroTransactionRsigData* release_rsig_data();
  ::hw::trezor::messages::monero::MoneroTransactionRsigData* mutable_rsig_data();
  void set_allocated_rsig_data(::hw::trezor::messages::monero::MoneroTransactionRsigData* rsig_data);

  // @@protoc_insertion_point(class_scope:hw.trezor.messages.monero.MoneroTransactionInitAck)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedPtrField<::std::string> hmacs_;
  ::hw::trezor::messages::monero::MoneroTransactionRsigData* rsig_data_;
  friend struct ::TableStruct_messages_2dmonero_2eproto;
};
// -------------------------------------------------------------------

class MoneroTransactionSetInputRequest final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:hw.trezor.messages.monero.MoneroTransactionSetInputRequest) */ {
 public:
  MoneroTransactionSetInputRequest();
  virtual ~MoneroTransactionSetInputRequest();

  MoneroTransactionSetInputRequest(const MoneroTransactionSetInputRequest& from);

  inline MoneroTransactionSetInputRequest& operator=(const MoneroTransactionSetInputRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  MoneroTransactionSetInputRequest(MoneroTransactionSetInputRequest&& from) noexcept
    : MoneroTransactionSetInputRequest() {
    *this = ::std::move(from);
  }

  inline MoneroTransactionSetInputRequest& operator=(MoneroTransactionSetInputRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const MoneroTransactionSetInputRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const MoneroTransactionSetInputRequest* internal_default_instance() {
    return reinterpret_cast<const MoneroTransactionSetInputRequest*>(
               &_MoneroTransactionSetInputRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  void Swap(MoneroTransactionSetInputRequest* other);
  friend void swap(MoneroTransactionSetInputRequest& a, MoneroTransactionSetInputRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline MoneroTransactionSetInputRequest* New() const final {
    return CreateMaybeMessage<MoneroTransactionSetInputRequest>(nullptr);
  }

  MoneroTransactionSetInputRequest* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<MoneroTransactionSetInputRequest>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const MoneroTransactionSetInputRequest& from);
  void MergeFrom(const MoneroTransactionSetInputRequest& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MoneroTransactionSetInputRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .hw.trezor.messages.monero.MoneroTransactionSourceEntry src_entr = 1;
  bool has_src_entr() const;
  void clear_src_entr();
  static const int kSrcEntrFieldNumber = 1;
  const ::hw::trezor::messages::monero::MoneroTransactionSourceEntry& src_entr() const;
  ::hw::trezor::messages::monero::MoneroTransactionSourceEntry* release_src_entr();
  ::hw::trezor::messages::monero::MoneroTransactionSourceEntry* mutable_src_entr();
  void set_allocated_src_entr(::hw::trezor::messages::monero::MoneroTransactionSourceEntry* src_entr);

  // @@protoc_insertion_point(class_scope:hw.trezor.messages.monero.MoneroTransactionSetInputRequest)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::hw::trezor::messages::monero::MoneroTransactionSourceEntry* src_entr_;
  friend struct ::TableStruct_messages_2dmonero_2eproto;
};
// -------------------------------------------------------------------

class MoneroTransactionSetInputAck final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:hw.trezor.messages.monero.MoneroTransactionSetInputAck) */ {
 public:
  MoneroTransactionSetInputAck();
  virtual ~MoneroTransactionSetInputAck();

  MoneroTransactionSetInputAck(const MoneroTransactionSetInputAck& from);

  inline MoneroTransactionSetInputAck& operator=(const MoneroTransactionSetInputAck& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  MoneroTransactionSetInputAck(MoneroTransactionSetInputAck&& from) noexcept
    : MoneroTransactionSetInputAck() {
    *this = ::std::move(from);
  }

  inline MoneroTransactionSetInputAck& operator=(MoneroTransactionSetInputAck&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const MoneroTransactionSetInputAck& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const MoneroTransactionSetInputAck* internal_default_instance() {
    return reinterpret_cast<const MoneroTransactionSetInputAck*>(
               &_MoneroTransactionSetInputAck_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  void Swap(MoneroTransactionSetInputAck* other);
  friend void swap(MoneroTransactionSetInputAck& a, MoneroTransactionSetInputAck& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline MoneroTransactionSetInputAck* New() const final {
    return CreateMaybeMessage<MoneroTransactionSetInputAck>(nullptr);
  }

  MoneroTransactionSetInputAck* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<MoneroTransactionSetInputAck>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const MoneroTransactionSetInputAck& from);
  void MergeFrom(const MoneroTransactionSetInputAck& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MoneroTransactionSetInputAck* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bytes vini = 1;
  bool has_vini() const;
  void clear_vini();
  static const int kViniFieldNumber = 1;
  const ::std::string& vini() const;
  void set_vini(const ::std::string& value);
  #if LANG_CXX11
  void set_vini(::std::string&& value);
  #endif
  void set_vini(const char* value);
  void set_vini(const void* value, size_t size);
  ::std::string* mutable_vini();
  ::std::string* release_vini();
  void set_allocated_vini(::std::string* vini);

  // optional bytes vini_hmac = 2;
  bool has_vini_hmac() const;
  void clear_vini_hmac();
  static const int kViniHmacFieldNumber = 2;
  const ::std::string& vini_hmac() const;
  void set_vini_hmac(const ::std::string& value);
  #if LANG_CXX11
  void set_vini_hmac(::std::string&& value);
  #endif
  void set_vini_hmac(const char* value);
  void set_vini_hmac(const void* value, size_t size);
  ::std::string* mutable_vini_hmac();
  ::std::string* release_vini_hmac();
  void set_allocated_vini_hmac(::std::string* vini_hmac);

  // optional bytes pseudo_out = 3;
  bool has_pseudo_out() const;
  void clear_pseudo_out();
  static const int kPseudoOutFieldNumber = 3;
  const ::std::string& pseudo_out() const;
  void set_pseudo_out(const ::std::string& value);
  #if LANG_CXX11
  void set_pseudo_out(::std::string&& value);
  #endif
  void set_pseudo_out(const char* value);
  void set_pseudo_out(const void* value, size_t size);
  ::std::string* mutable_pseudo_out();
  ::std::string* release_pseudo_out();
  void set_allocated_pseudo_out(::std::string* pseudo_out);

  // optional bytes pseudo_out_hmac = 4;
  bool has_pseudo_out_hmac() const;
  void clear_pseudo_out_hmac();
  static const int kPseudoOutHmacFieldNumber = 4;
  const ::std::string& pseudo_out_hmac() const;
  void set_pseudo_out_hmac(const ::std::string& value);
  #if LANG_CXX11
  void set_pseudo_out_hmac(::std::string&& value);
  #endif
  void set_pseudo_out_hmac(const char* value);
  void set_pseudo_out_hmac(const void* value, size_t size);
  ::std::string* mutable_pseudo_out_hmac();
  ::std::string* release_pseudo_out_hmac();
  void set_allocated_pseudo_out_hmac(::std::string* pseudo_out_hmac);

  // optional bytes pseudo_out_alpha = 5;
  bool has_pseudo_out_alpha() const;
  void clear_pseudo_out_alpha();
  static const int kPseudoOutAlphaFieldNumber = 5;
  const ::std::string& pseudo_out_alpha() const;
  void set_pseudo_out_alpha(const ::std::string& value);
  #if LANG_CXX11
  void set_pseudo_out_alpha(::std::string&& value);
  #endif
  void set_pseudo_out_alpha(const char* value);
  void set_pseudo_out_alpha(const void* value, size_t size);
  ::std::string* mutable_pseudo_out_alpha();
  ::std::string* release_pseudo_out_alpha();
  void set_allocated_pseudo_out_alpha(::std::string* pseudo_out_alpha);

  // optional bytes spend_key = 6;
  bool has_spend_key() const;
  void clear_spend_key();
  static const int kSpendKeyFieldNumber = 6;
  const ::std::string& spend_key() const;
  void set_spend_key(const ::std::string& value);
  #if LANG_CXX11
  void set_spend_key(::std::string&& value);
  #endif
  void set_spend_key(const char* value);
  void set_spend_key(const void* value, size_t size);
  ::std::string* mutable_spend_key();
  ::std::string* release_spend_key();
  void set_allocated_spend_key(::std::string* spend_key);

  // @@protoc_insertion_point(class_scope:hw.trezor.messages.monero.MoneroTransactionSetInputAck)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr vini_;
  ::google::protobuf::internal::ArenaStringPtr vini_hmac_;
  ::google::protobuf::internal::ArenaStringPtr pseudo_out_;
  ::google::protobuf::internal::ArenaStringPtr pseudo_out_hmac_;
  ::google::protobuf::internal::ArenaStringPtr pseudo_out_alpha_;
  ::google::protobuf::internal::ArenaStringPtr spend_key_;
  friend struct ::TableStruct_messages_2dmonero_2eproto;
};
// -------------------------------------------------------------------

class MoneroTransactionInputsPermutationRequest final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:hw.trezor.messages.monero.MoneroTransactionInputsPermutationRequest) */ {
 public:
  MoneroTransactionInputsPermutationRequest();
  virtual ~MoneroTransactionInputsPermutationRequest();

  MoneroTransactionInputsPermutationRequest(const MoneroTransactionInputsPermutationRequest& from);

  inline MoneroTransactionInputsPermutationRequest& operator=(const MoneroTransactionInputsPermutationRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  MoneroTransactionInputsPermutationRequest(MoneroTransactionInputsPermutationRequest&& from) noexcept
    : MoneroTransactionInputsPermutationRequest() {
    *this = ::std::move(from);
  }

  inline MoneroTransactionInputsPermutationRequest& operator=(MoneroTransactionInputsPermutationRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const MoneroTransactionInputsPermutationRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const MoneroTransactionInputsPermutationRequest* internal_default_instance() {
    return reinterpret_cast<const MoneroTransactionInputsPermutationRequest*>(
               &_MoneroTransactionInputsPermutationRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    16;

  void Swap(MoneroTransactionInputsPermutationRequest* other);
  friend void swap(MoneroTransactionInputsPermutationRequest& a, MoneroTransactionInputsPermutationRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline MoneroTransactionInputsPermutationRequest* New() const final {
    return CreateMaybeMessage<MoneroTransactionInputsPermutationRequest>(nullptr);
  }

  MoneroTransactionInputsPermutationRequest* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<MoneroTransactionInputsPermutationRequest>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const MoneroTransactionInputsPermutationRequest& from);
  void MergeFrom(const MoneroTransactionInputsPermutationRequest& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MoneroTransactionInputsPermutationRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated uint32 perm = 1;
  int perm_size() const;
  void clear_perm();
  static const int kPermFieldNumber = 1;
  ::google::protobuf::uint32 perm(int index) const;
  void set_perm(int index, ::google::protobuf::uint32 value);
  void add_perm(::google::protobuf::uint32 value);
  const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      perm() const;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable_perm();

  // @@protoc_insertion_point(class_scope:hw.trezor.messages.monero.MoneroTransactionInputsPermutationRequest)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > perm_;
  friend struct ::TableStruct_messages_2dmonero_2eproto;
};
// -------------------------------------------------------------------

class MoneroTransactionInputsPermutationAck final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:hw.trezor.messages.monero.MoneroTransactionInputsPermutationAck) */ {
 public:
  MoneroTransactionInputsPermutationAck();
  virtual ~MoneroTransactionInputsPermutationAck();

  MoneroTransactionInputsPermutationAck(const MoneroTransactionInputsPermutationAck& from);

  inline MoneroTransactionInputsPermutationAck& operator=(const MoneroTransactionInputsPermutationAck& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  MoneroTransactionInputsPermutationAck(MoneroTransactionInputsPermutationAck&& from) noexcept
    : MoneroTransactionInputsPermutationAck() {
    *this = ::std::move(from);
  }

  inline MoneroTransactionInputsPermutationAck& operator=(MoneroTransactionInputsPermutationAck&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const MoneroTransactionInputsPermutationAck& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const MoneroTransactionInputsPermutationAck* internal_default_instance() {
    return reinterpret_cast<const MoneroTransactionInputsPermutationAck*>(
               &_MoneroTransactionInputsPermutationAck_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    17;

  void Swap(MoneroTransactionInputsPermutationAck* other);
  friend void swap(MoneroTransactionInputsPermutationAck& a, MoneroTransactionInputsPermutationAck& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline MoneroTransactionInputsPermutationAck* New() const final {
    return CreateMaybeMessage<MoneroTransactionInputsPermutationAck>(nullptr);
  }

  MoneroTransactionInputsPermutationAck* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<MoneroTransactionInputsPermutationAck>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const MoneroTransactionInputsPermutationAck& from);
  void MergeFrom(const MoneroTransactionInputsPermutationAck& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MoneroTransactionInputsPermutationAck* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:hw.trezor.messages.monero.MoneroTransactionInputsPermutationAck)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_messages_2dmonero_2eproto;
};
// -------------------------------------------------------------------

class MoneroTransactionInputViniRequest final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:hw.trezor.messages.monero.MoneroTransactionInputViniRequest) */ {
 public:
  MoneroTransactionInputViniRequest();
  virtual ~MoneroTransactionInputViniRequest();

  MoneroTransactionInputViniRequest(const MoneroTransactionInputViniRequest& from);

  inline MoneroTransactionInputViniRequest& operator=(const MoneroTransactionInputViniRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  MoneroTransactionInputViniRequest(MoneroTransactionInputViniRequest&& from) noexcept
    : MoneroTransactionInputViniRequest() {
    *this = ::std::move(from);
  }

  inline MoneroTransactionInputViniRequest& operator=(MoneroTransactionInputViniRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const MoneroTransactionInputViniRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const MoneroTransactionInputViniRequest* internal_default_instance() {
    return reinterpret_cast<const MoneroTransactionInputViniRequest*>(
               &_MoneroTransactionInputViniRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    18;

  void Swap(MoneroTransactionInputViniRequest* other);
  friend void swap(MoneroTransactionInputViniRequest& a, MoneroTransactionInputViniRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline MoneroTransactionInputViniRequest* New() const final {
    return CreateMaybeMessage<MoneroTransactionInputViniRequest>(nullptr);
  }

  MoneroTransactionInputViniRequest* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<MoneroTransactionInputViniRequest>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const MoneroTransactionInputViniRequest& from);
  void MergeFrom(const MoneroTransactionInputViniRequest& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MoneroTransactionInputViniRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bytes vini = 2;
  bool has_vini() const;
  void clear_vini();
  static const int kViniFieldNumber = 2;
  const ::std::string& vini() const;
  void set_vini(const ::std::string& value);
  #if LANG_CXX11
  void set_vini(::std::string&& value);
  #endif
  void set_vini(const char* value);
  void set_vini(const void* value, size_t size);
  ::std::string* mutable_vini();
  ::std::string* release_vini();
  void set_allocated_vini(::std::string* vini);

  // optional bytes vini_hmac = 3;
  bool has_vini_hmac() const;
  void clear_vini_hmac();
  static const int kViniHmacFieldNumber = 3;
  const ::std::string& vini_hmac() const;
  void set_vini_hmac(const ::std::string& value);
  #if LANG_CXX11
  void set_vini_hmac(::std::string&& value);
  #endif
  void set_vini_hmac(const char* value);
  void set_vini_hmac(const void* value, size_t size);
  ::std::string* mutable_vini_hmac();
  ::std::string* release_vini_hmac();
  void set_allocated_vini_hmac(::std::string* vini_hmac);

  // optional bytes pseudo_out = 4;
  bool has_pseudo_out() const;
  void clear_pseudo_out();
  static const int kPseudoOutFieldNumber = 4;
  const ::std::string& pseudo_out() const;
  void set_pseudo_out(const ::std::string& value);
  #if LANG_CXX11
  void set_pseudo_out(::std::string&& value);
  #endif
  void set_pseudo_out(const char* value);
  void set_pseudo_out(const void* value, size_t size);
  ::std::string* mutable_pseudo_out();
  ::std::string* release_pseudo_out();
  void set_allocated_pseudo_out(::std::string* pseudo_out);

  // optional bytes pseudo_out_hmac = 5;
  bool has_pseudo_out_hmac() const;
  void clear_pseudo_out_hmac();
  static const int kPseudoOutHmacFieldNumber = 5;
  const ::std::string& pseudo_out_hmac() const;
  void set_pseudo_out_hmac(const ::std::string& value);
  #if LANG_CXX11
  void set_pseudo_out_hmac(::std::string&& value);
  #endif
  void set_pseudo_out_hmac(const char* value);
  void set_pseudo_out_hmac(const void* value, size_t size);
  ::std::string* mutable_pseudo_out_hmac();
  ::std::string* release_pseudo_out_hmac();
  void set_allocated_pseudo_out_hmac(::std::string* pseudo_out_hmac);

  // optional .hw.trezor.messages.monero.MoneroTransactionSourceEntry src_entr = 1;
  bool has_src_entr() const;
  void clear_src_entr();
  static const int kSrcEntrFieldNumber = 1;
  const ::hw::trezor::messages::monero::MoneroTransactionSourceEntry& src_entr() const;
  ::hw::trezor::messages::monero::MoneroTransactionSourceEntry* release_src_entr();
  ::hw::trezor::messages::monero::MoneroTransactionSourceEntry* mutable_src_entr();
  void set_allocated_src_entr(::hw::trezor::messages::monero::MoneroTransactionSourceEntry* src_entr);

  // @@protoc_insertion_point(class_scope:hw.trezor.messages.monero.MoneroTransactionInputViniRequest)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr vini_;
  ::google::protobuf::internal::ArenaStringPtr vini_hmac_;
  ::google::protobuf::internal::ArenaStringPtr pseudo_out_;
  ::google::protobuf::internal::ArenaStringPtr pseudo_out_hmac_;
  ::hw::trezor::messages::monero::MoneroTransactionSourceEntry* src_entr_;
  friend struct ::TableStruct_messages_2dmonero_2eproto;
};
// -------------------------------------------------------------------

class MoneroTransactionInputViniAck final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:hw.trezor.messages.monero.MoneroTransactionInputViniAck) */ {
 public:
  MoneroTransactionInputViniAck();
  virtual ~MoneroTransactionInputViniAck();

  MoneroTransactionInputViniAck(const MoneroTransactionInputViniAck& from);

  inline MoneroTransactionInputViniAck& operator=(const MoneroTransactionInputViniAck& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  MoneroTransactionInputViniAck(MoneroTransactionInputViniAck&& from) noexcept
    : MoneroTransactionInputViniAck() {
    *this = ::std::move(from);
  }

  inline MoneroTransactionInputViniAck& operator=(MoneroTransactionInputViniAck&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const MoneroTransactionInputViniAck& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const MoneroTransactionInputViniAck* internal_default_instance() {
    return reinterpret_cast<const MoneroTransactionInputViniAck*>(
               &_MoneroTransactionInputViniAck_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    19;

  void Swap(MoneroTransactionInputViniAck* other);
  friend void swap(MoneroTransactionInputViniAck& a, MoneroTransactionInputViniAck& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline MoneroTransactionInputViniAck* New() const final {
    return CreateMaybeMessage<MoneroTransactionInputViniAck>(nullptr);
  }

  MoneroTransactionInputViniAck* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<MoneroTransactionInputViniAck>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const MoneroTransactionInputViniAck& from);
  void MergeFrom(const MoneroTransactionInputViniAck& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MoneroTransactionInputViniAck* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:hw.trezor.messages.monero.MoneroTransactionInputViniAck)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_messages_2dmonero_2eproto;
};
// -------------------------------------------------------------------

class MoneroTransactionAllInputsSetRequest final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:hw.trezor.messages.monero.MoneroTransactionAllInputsSetRequest) */ {
 public:
  MoneroTransactionAllInputsSetRequest();
  virtual ~MoneroTransactionAllInputsSetRequest();

  MoneroTransactionAllInputsSetRequest(const MoneroTransactionAllInputsSetRequest& from);

  inline MoneroTransactionAllInputsSetRequest& operator=(const MoneroTransactionAllInputsSetRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  MoneroTransactionAllInputsSetRequest(MoneroTransactionAllInputsSetRequest&& from) noexcept
    : MoneroTransactionAllInputsSetRequest() {
    *this = ::std::move(from);
  }

  inline MoneroTransactionAllInputsSetRequest& operator=(MoneroTransactionAllInputsSetRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const MoneroTransactionAllInputsSetRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const MoneroTransactionAllInputsSetRequest* internal_default_instance() {
    return reinterpret_cast<const MoneroTransactionAllInputsSetRequest*>(
               &_MoneroTransactionAllInputsSetRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    20;

  void Swap(MoneroTransactionAllInputsSetRequest* other);
  friend void swap(MoneroTransactionAllInputsSetRequest& a, MoneroTransactionAllInputsSetRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline MoneroTransactionAllInputsSetRequest* New() const final {
    return CreateMaybeMessage<MoneroTransactionAllInputsSetRequest>(nullptr);
  }

  MoneroTransactionAllInputsSetRequest* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<MoneroTransactionAllInputsSetRequest>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const MoneroTransactionAllInputsSetRequest& from);
  void MergeFrom(const MoneroTransactionAllInputsSetRequest& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MoneroTransactionAllInputsSetRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:hw.trezor.messages.monero.MoneroTransactionAllInputsSetRequest)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_messages_2dmonero_2eproto;
};
// -------------------------------------------------------------------

class MoneroTransactionAllInputsSetAck final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:hw.trezor.messages.monero.MoneroTransactionAllInputsSetAck) */ {
 public:
  MoneroTransactionAllInputsSetAck();
  virtual ~MoneroTransactionAllInputsSetAck();

  MoneroTransactionAllInputsSetAck(const MoneroTransactionAllInputsSetAck& from);

  inline MoneroTransactionAllInputsSetAck& operator=(const MoneroTransactionAllInputsSetAck& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  MoneroTransactionAllInputsSetAck(MoneroTransactionAllInputsSetAck&& from) noexcept
    : MoneroTransactionAllInputsSetAck() {
    *this = ::std::move(from);
  }

  inline MoneroTransactionAllInputsSetAck& operator=(MoneroTransactionAllInputsSetAck&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const MoneroTransactionAllInputsSetAck& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const MoneroTransactionAllInputsSetAck* internal_default_instance() {
    return reinterpret_cast<const MoneroTransactionAllInputsSetAck*>(
               &_MoneroTransactionAllInputsSetAck_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    21;

  void Swap(MoneroTransactionAllInputsSetAck* other);
  friend void swap(MoneroTransactionAllInputsSetAck& a, MoneroTransactionAllInputsSetAck& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline MoneroTransactionAllInputsSetAck* New() const final {
    return CreateMaybeMessage<MoneroTransactionAllInputsSetAck>(nullptr);
  }

  MoneroTransactionAllInputsSetAck* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<MoneroTransactionAllInputsSetAck>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const MoneroTransactionAllInputsSetAck& from);
  void MergeFrom(const MoneroTransactionAllInputsSetAck& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MoneroTransactionAllInputsSetAck* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .hw.trezor.messages.monero.MoneroTransactionRsigData rsig_data = 1;
  bool has_rsig_data() const;
  void clear_rsig_data();
  static const int kRsigDataFieldNumber = 1;
  const ::hw::trezor::messages::monero::MoneroTransactionRsigData& rsig_data() const;
  ::hw::trezor::messages::monero::MoneroTransactionRsigData* release_rsig_data();
  ::hw::trezor::messages::monero::MoneroTransactionRsigData* mutable_rsig_data();
  void set_allocated_rsig_data(::hw::trezor::messages::monero::MoneroTransactionRsigData* rsig_data);

  // @@protoc_insertion_point(class_scope:hw.trezor.messages.monero.MoneroTransactionAllInputsSetAck)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::hw::trezor::messages::monero::MoneroTransactionRsigData* rsig_data_;
  friend struct ::TableStruct_messages_2dmonero_2eproto;
};
// -------------------------------------------------------------------

class MoneroTransactionSetOutputRequest final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:hw.trezor.messages.monero.MoneroTransactionSetOutputRequest) */ {
 public:
  MoneroTransactionSetOutputRequest();
  virtual ~MoneroTransactionSetOutputRequest();

  MoneroTransactionSetOutputRequest(const MoneroTransactionSetOutputRequest& from);

  inline MoneroTransactionSetOutputRequest& operator=(const MoneroTransactionSetOutputRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  MoneroTransactionSetOutputRequest(MoneroTransactionSetOutputRequest&& from) noexcept
    : MoneroTransactionSetOutputRequest() {
    *this = ::std::move(from);
  }

  inline MoneroTransactionSetOutputRequest& operator=(MoneroTransactionSetOutputRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const MoneroTransactionSetOutputRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const MoneroTransactionSetOutputRequest* internal_default_instance() {
    return reinterpret_cast<const MoneroTransactionSetOutputRequest*>(
               &_MoneroTransactionSetOutputRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    22;

  void Swap(MoneroTransactionSetOutputRequest* other);
  friend void swap(MoneroTransactionSetOutputRequest& a, MoneroTransactionSetOutputRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline MoneroTransactionSetOutputRequest* New() const final {
    return CreateMaybeMessage<MoneroTransactionSetOutputRequest>(nullptr);
  }

  MoneroTransactionSetOutputRequest* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<MoneroTransactionSetOutputRequest>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const MoneroTransactionSetOutputRequest& from);
  void MergeFrom(const MoneroTransactionSetOutputRequest& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MoneroTransactionSetOutputRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bytes dst_entr_hmac = 2;
  bool has_dst_entr_hmac() const;
  void clear_dst_entr_hmac();
  static const int kDstEntrHmacFieldNumber = 2;
  const ::std::string& dst_entr_hmac() const;
  void set_dst_entr_hmac(const ::std::string& value);
  #if LANG_CXX11
  void set_dst_entr_hmac(::std::string&& value);
  #endif
  void set_dst_entr_hmac(const char* value);
  void set_dst_entr_hmac(const void* value, size_t size);
  ::std::string* mutable_dst_entr_hmac();
  ::std::string* release_dst_entr_hmac();
  void set_allocated_dst_entr_hmac(::std::string* dst_entr_hmac);

  // optional .hw.trezor.messages.monero.MoneroTransactionDestinationEntry dst_entr = 1;
  bool has_dst_entr() const;
  void clear_dst_entr();
  static const int kDstEntrFieldNumber = 1;
  const ::hw::trezor::messages::monero::MoneroTransactionDestinationEntry& dst_entr() const;
  ::hw::trezor::messages::monero::MoneroTransactionDestinationEntry* release_dst_entr();
  ::hw::trezor::messages::monero::MoneroTransactionDestinationEntry* mutable_dst_entr();
  void set_allocated_dst_entr(::hw::trezor::messages::monero::MoneroTransactionDestinationEntry* dst_entr);

  // optional .hw.trezor.messages.monero.MoneroTransactionRsigData rsig_data = 3;
  bool has_rsig_data() const;
  void clear_rsig_data();
  static const int kRsigDataFieldNumber = 3;
  const ::hw::trezor::messages::monero::MoneroTransactionRsigData& rsig_data() const;
  ::hw::trezor::messages::monero::MoneroTransactionRsigData* release_rsig_data();
  ::hw::trezor::messages::monero::MoneroTransactionRsigData* mutable_rsig_data();
  void set_allocated_rsig_data(::hw::trezor::messages::monero::MoneroTransactionRsigData* rsig_data);

  // @@protoc_insertion_point(class_scope:hw.trezor.messages.monero.MoneroTransactionSetOutputRequest)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr dst_entr_hmac_;
  ::hw::trezor::messages::monero::MoneroTransactionDestinationEntry* dst_entr_;
  ::hw::trezor::messages::monero::MoneroTransactionRsigData* rsig_data_;
  friend struct ::TableStruct_messages_2dmonero_2eproto;
};
// -------------------------------------------------------------------

class MoneroTransactionSetOutputAck final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:hw.trezor.messages.monero.MoneroTransactionSetOutputAck) */ {
 public:
  MoneroTransactionSetOutputAck();
  virtual ~MoneroTransactionSetOutputAck();

  MoneroTransactionSetOutputAck(const MoneroTransactionSetOutputAck& from);

  inline MoneroTransactionSetOutputAck& operator=(const MoneroTransactionSetOutputAck& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  MoneroTransactionSetOutputAck(MoneroTransactionSetOutputAck&& from) noexcept
    : MoneroTransactionSetOutputAck() {
    *this = ::std::move(from);
  }

  inline MoneroTransactionSetOutputAck& operator=(MoneroTransactionSetOutputAck&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const MoneroTransactionSetOutputAck& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const MoneroTransactionSetOutputAck* internal_default_instance() {
    return reinterpret_cast<const MoneroTransactionSetOutputAck*>(
               &_MoneroTransactionSetOutputAck_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    23;

  void Swap(MoneroTransactionSetOutputAck* other);
  friend void swap(MoneroTransactionSetOutputAck& a, MoneroTransactionSetOutputAck& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline MoneroTransactionSetOutputAck* New() const final {
    return CreateMaybeMessage<MoneroTransactionSetOutputAck>(nullptr);
  }

  MoneroTransactionSetOutputAck* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<MoneroTransactionSetOutputAck>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const MoneroTransactionSetOutputAck& from);
  void MergeFrom(const MoneroTransactionSetOutputAck& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MoneroTransactionSetOutputAck* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bytes tx_out = 1;
  bool has_tx_out() const;
  void clear_tx_out();
  static const int kTxOutFieldNumber = 1;
  const ::std::string& tx_out() const;
  void set_tx_out(const ::std::string& value);
  #if LANG_CXX11
  void set_tx_out(::std::string&& value);
  #endif
  void set_tx_out(const char* value);
  void set_tx_out(const void* value, size_t size);
  ::std::string* mutable_tx_out();
  ::std::string* release_tx_out();
  void set_allocated_tx_out(::std::string* tx_out);

  // optional bytes vouti_hmac = 2;
  bool has_vouti_hmac() const;
  void clear_vouti_hmac();
  static const int kVoutiHmacFieldNumber = 2;
  const ::std::string& vouti_hmac() const;
  void set_vouti_hmac(const ::std::string& value);
  #if LANG_CXX11
  void set_vouti_hmac(::std::string&& value);
  #endif
  void set_vouti_hmac(const char* value);
  void set_vouti_hmac(const void* value, size_t size);
  ::std::string* mutable_vouti_hmac();
  ::std::string* release_vouti_hmac();
  void set_allocated_vouti_hmac(::std::string* vouti_hmac);

  // optional bytes out_pk = 4;
  bool has_out_pk() const;
  void clear_out_pk();
  static const int kOutPkFieldNumber = 4;
  const ::std::string& out_pk() const;
  void set_out_pk(const ::std::string& value);
  #if LANG_CXX11
  void set_out_pk(::std::string&& value);
  #endif
  void set_out_pk(const char* value);
  void set_out_pk(const void* value, size_t size);
  ::std::string* mutable_out_pk();
  ::std::string* release_out_pk();
  void set_allocated_out_pk(::std::string* out_pk);

  // optional bytes ecdh_info = 5;
  bool has_ecdh_info() const;
  void clear_ecdh_info();
  static const int kEcdhInfoFieldNumber = 5;
  const ::std::string& ecdh_info() const;
  void set_ecdh_info(const ::std::string& value);
  #if LANG_CXX11
  void set_ecdh_info(::std::string&& value);
  #endif
  void set_ecdh_info(const char* value);
  void set_ecdh_info(const void* value, size_t size);
  ::std::string* mutable_ecdh_info();
  ::std::string* release_ecdh_info();
  void set_allocated_ecdh_info(::std::string* ecdh_info);

  // optional .hw.trezor.messages.monero.MoneroTransactionRsigData rsig_data = 3;
  bool has_rsig_data() const;
  void clear_rsig_data();
  static const int kRsigDataFieldNumber = 3;
  const ::hw::trezor::messages::monero::MoneroTransactionRsigData& rsig_data() const;
  ::hw::trezor::messages::monero::MoneroTransactionRsigData* release_rsig_data();
  ::hw::trezor::messages::monero::MoneroTransactionRsigData* mutable_rsig_data();
  void set_allocated_rsig_data(::hw::trezor::messages::monero::MoneroTransactionRsigData* rsig_data);

  // @@protoc_insertion_point(class_scope:hw.trezor.messages.monero.MoneroTransactionSetOutputAck)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr tx_out_;
  ::google::protobuf::internal::ArenaStringPtr vouti_hmac_;
  ::google::protobuf::internal::ArenaStringPtr out_pk_;
  ::google::protobuf::internal::ArenaStringPtr ecdh_info_;
  ::hw::trezor::messages::monero::MoneroTransactionRsigData* rsig_data_;
  friend struct ::TableStruct_messages_2dmonero_2eproto;
};
// -------------------------------------------------------------------

class MoneroTransactionAllOutSetRequest final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:hw.trezor.messages.monero.MoneroTransactionAllOutSetRequest) */ {
 public:
  MoneroTransactionAllOutSetRequest();
  virtual ~MoneroTransactionAllOutSetRequest();

  MoneroTransactionAllOutSetRequest(const MoneroTransactionAllOutSetRequest& from);

  inline MoneroTransactionAllOutSetRequest& operator=(const MoneroTransactionAllOutSetRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  MoneroTransactionAllOutSetRequest(MoneroTransactionAllOutSetRequest&& from) noexcept
    : MoneroTransactionAllOutSetRequest() {
    *this = ::std::move(from);
  }

  inline MoneroTransactionAllOutSetRequest& operator=(MoneroTransactionAllOutSetRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const MoneroTransactionAllOutSetRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const MoneroTransactionAllOutSetRequest* internal_default_instance() {
    return reinterpret_cast<const MoneroTransactionAllOutSetRequest*>(
               &_MoneroTransactionAllOutSetRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    24;

  void Swap(MoneroTransactionAllOutSetRequest* other);
  friend void swap(MoneroTransactionAllOutSetRequest& a, MoneroTransactionAllOutSetRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline MoneroTransactionAllOutSetRequest* New() const final {
    return CreateMaybeMessage<MoneroTransactionAllOutSetRequest>(nullptr);
  }

  MoneroTransactionAllOutSetRequest* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<MoneroTransactionAllOutSetRequest>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const MoneroTransactionAllOutSetRequest& from);
  void MergeFrom(const MoneroTransactionAllOutSetRequest& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MoneroTransactionAllOutSetRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .hw.trezor.messages.monero.MoneroTransactionRsigData rsig_data = 1;
  bool has_rsig_data() const;
  void clear_rsig_data();
  static const int kRsigDataFieldNumber = 1;
  const ::hw::trezor::messages::monero::MoneroTransactionRsigData& rsig_data() const;
  ::hw::trezor::messages::monero::MoneroTransactionRsigData* release_rsig_data();
  ::hw::trezor::messages::monero::MoneroTransactionRsigData* mutable_rsig_data();
  void set_allocated_rsig_data(::hw::trezor::messages::monero::MoneroTransactionRsigData* rsig_data);

  // @@protoc_insertion_point(class_scope:hw.trezor.messages.monero.MoneroTransactionAllOutSetRequest)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::hw::trezor::messages::monero::MoneroTransactionRsigData* rsig_data_;
  friend struct ::TableStruct_messages_2dmonero_2eproto;
};
// -------------------------------------------------------------------

class MoneroTransactionAllOutSetAck_MoneroRingCtSig final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:hw.trezor.messages.monero.MoneroTransactionAllOutSetAck.MoneroRingCtSig) */ {
 public:
  MoneroTransactionAllOutSetAck_MoneroRingCtSig();
  virtual ~MoneroTransactionAllOutSetAck_MoneroRingCtSig();

  MoneroTransactionAllOutSetAck_MoneroRingCtSig(const MoneroTransactionAllOutSetAck_MoneroRingCtSig& from);

  inline MoneroTransactionAllOutSetAck_MoneroRingCtSig& operator=(const MoneroTransactionAllOutSetAck_MoneroRingCtSig& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  MoneroTransactionAllOutSetAck_MoneroRingCtSig(MoneroTransactionAllOutSetAck_MoneroRingCtSig&& from) noexcept
    : MoneroTransactionAllOutSetAck_MoneroRingCtSig() {
    *this = ::std::move(from);
  }

  inline MoneroTransactionAllOutSetAck_MoneroRingCtSig& operator=(MoneroTransactionAllOutSetAck_MoneroRingCtSig&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const MoneroTransactionAllOutSetAck_MoneroRingCtSig& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const MoneroTransactionAllOutSetAck_MoneroRingCtSig* internal_default_instance() {
    return reinterpret_cast<const MoneroTransactionAllOutSetAck_MoneroRingCtSig*>(
               &_MoneroTransactionAllOutSetAck_MoneroRingCtSig_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    25;

  void Swap(MoneroTransactionAllOutSetAck_MoneroRingCtSig* other);
  friend void swap(MoneroTransactionAllOutSetAck_MoneroRingCtSig& a, MoneroTransactionAllOutSetAck_MoneroRingCtSig& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline MoneroTransactionAllOutSetAck_MoneroRingCtSig* New() const final {
    return CreateMaybeMessage<MoneroTransactionAllOutSetAck_MoneroRingCtSig>(nullptr);
  }

  MoneroTransactionAllOutSetAck_MoneroRingCtSig* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<MoneroTransactionAllOutSetAck_MoneroRingCtSig>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const MoneroTransactionAllOutSetAck_MoneroRingCtSig& from);
  void MergeFrom(const MoneroTransactionAllOutSetAck_MoneroRingCtSig& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MoneroTransactionAllOutSetAck_MoneroRingCtSig* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bytes message = 2;
  bool has_message() const;
  void clear_message();
  static const int kMessageFieldNumber = 2;
  const ::std::string& message() const;
  void set_message(const ::std::string& value);
  #if LANG_CXX11
  void set_message(::std::string&& value);
  #endif
  void set_message(const char* value);
  void set_message(const void* value, size_t size);
  ::std::string* mutable_message();
  ::std::string* release_message();
  void set_allocated_message(::std::string* message);

  // optional uint64 txn_fee = 1;
  bool has_txn_fee() const;
  void clear_txn_fee();
  static const int kTxnFeeFieldNumber = 1;
  ::google::protobuf::uint64 txn_fee() const;
  void set_txn_fee(::google::protobuf::uint64 value);

  // optional uint32 rv_type = 3;
  bool has_rv_type() const;
  void clear_rv_type();
  static const int kRvTypeFieldNumber = 3;
  ::google::protobuf::uint32 rv_type() const;
  void set_rv_type(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:hw.trezor.messages.monero.MoneroTransactionAllOutSetAck.MoneroRingCtSig)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr message_;
  ::google::protobuf::uint64 txn_fee_;
  ::google::protobuf::uint32 rv_type_;
  friend struct ::TableStruct_messages_2dmonero_2eproto;
};
// -------------------------------------------------------------------

class MoneroTransactionAllOutSetAck final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:hw.trezor.messages.monero.MoneroTransactionAllOutSetAck) */ {
 public:
  MoneroTransactionAllOutSetAck();
  virtual ~MoneroTransactionAllOutSetAck();

  MoneroTransactionAllOutSetAck(const MoneroTransactionAllOutSetAck& from);

  inline MoneroTransactionAllOutSetAck& operator=(const MoneroTransactionAllOutSetAck& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  MoneroTransactionAllOutSetAck(MoneroTransactionAllOutSetAck&& from) noexcept
    : MoneroTransactionAllOutSetAck() {
    *this = ::std::move(from);
  }

  inline MoneroTransactionAllOutSetAck& operator=(MoneroTransactionAllOutSetAck&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const MoneroTransactionAllOutSetAck& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const MoneroTransactionAllOutSetAck* internal_default_instance() {
    return reinterpret_cast<const MoneroTransactionAllOutSetAck*>(
               &_MoneroTransactionAllOutSetAck_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    26;

  void Swap(MoneroTransactionAllOutSetAck* other);
  friend void swap(MoneroTransactionAllOutSetAck& a, MoneroTransactionAllOutSetAck& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline MoneroTransactionAllOutSetAck* New() const final {
    return CreateMaybeMessage<MoneroTransactionAllOutSetAck>(nullptr);
  }

  MoneroTransactionAllOutSetAck* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<MoneroTransactionAllOutSetAck>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const MoneroTransactionAllOutSetAck& from);
  void MergeFrom(const MoneroTransactionAllOutSetAck& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MoneroTransactionAllOutSetAck* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef MoneroTransactionAllOutSetAck_MoneroRingCtSig MoneroRingCtSig;

  // accessors -------------------------------------------------------

  // optional bytes extra = 1;
  bool has_extra() const;
  void clear_extra();
  static const int kExtraFieldNumber = 1;
  const ::std::string& extra() const;
  void set_extra(const ::std::string& value);
  #if LANG_CXX11
  void set_extra(::std::string&& value);
  #endif
  void set_extra(const char* value);
  void set_extra(const void* value, size_t size);
  ::std::string* mutable_extra();
  ::std::string* release_extra();
  void set_allocated_extra(::std::string* extra);

  // optional bytes tx_prefix_hash = 2;
  bool has_tx_prefix_hash() const;
  void clear_tx_prefix_hash();
  static const int kTxPrefixHashFieldNumber = 2;
  const ::std::string& tx_prefix_hash() const;
  void set_tx_prefix_hash(const ::std::string& value);
  #if LANG_CXX11
  void set_tx_prefix_hash(::std::string&& value);
  #endif
  void set_tx_prefix_hash(const char* value);
  void set_tx_prefix_hash(const void* value, size_t size);
  ::std::string* mutable_tx_prefix_hash();
  ::std::string* release_tx_prefix_hash();
  void set_allocated_tx_prefix_hash(::std::string* tx_prefix_hash);

  // optional bytes full_message_hash = 5;
  bool has_full_message_hash() const;
  void clear_full_message_hash();
  static const int kFullMessageHashFieldNumber = 5;
  const ::std::string& full_message_hash() const;
  void set_full_message_hash(const ::std::string& value);
  #if LANG_CXX11
  void set_full_message_hash(::std::string&& value);
  #endif
  void set_full_message_hash(const char* value);
  void set_full_message_hash(const void* value, size_t size);
  ::std::string* mutable_full_message_hash();
  ::std::string* release_full_message_hash();
  void set_allocated_full_message_hash(::std::string* full_message_hash);

  // optional .hw.trezor.messages.monero.MoneroTransactionAllOutSetAck.MoneroRingCtSig rv = 4;
  bool has_rv() const;
  void clear_rv();
  static const int kRvFieldNumber = 4;
  const ::hw::trezor::messages::monero::MoneroTransactionAllOutSetAck_MoneroRingCtSig& rv() const;
  ::hw::trezor::messages::monero::MoneroTransactionAllOutSetAck_MoneroRingCtSig* release_rv();
  ::hw::trezor::messages::monero::MoneroTransactionAllOutSetAck_MoneroRingCtSig* mutable_rv();
  void set_allocated_rv(::hw::trezor::messages::monero::MoneroTransactionAllOutSetAck_MoneroRingCtSig* rv);

  // @@protoc_insertion_point(class_scope:hw.trezor.messages.monero.MoneroTransactionAllOutSetAck)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr extra_;
  ::google::protobuf::internal::ArenaStringPtr tx_prefix_hash_;
  ::google::protobuf::internal::ArenaStringPtr full_message_hash_;
  ::hw::trezor::messages::monero::MoneroTransactionAllOutSetAck_MoneroRingCtSig* rv_;
  friend struct ::TableStruct_messages_2dmonero_2eproto;
};
// -------------------------------------------------------------------

class MoneroTransactionSignInputRequest final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:hw.trezor.messages.monero.MoneroTransactionSignInputRequest) */ {
 public:
  MoneroTransactionSignInputRequest();
  virtual ~MoneroTransactionSignInputRequest();

  MoneroTransactionSignInputRequest(const MoneroTransactionSignInputRequest& from);

  inline MoneroTransactionSignInputRequest& operator=(const MoneroTransactionSignInputRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  MoneroTransactionSignInputRequest(MoneroTransactionSignInputRequest&& from) noexcept
    : MoneroTransactionSignInputRequest() {
    *this = ::std::move(from);
  }

  inline MoneroTransactionSignInputRequest& operator=(MoneroTransactionSignInputRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const MoneroTransactionSignInputRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const MoneroTransactionSignInputRequest* internal_default_instance() {
    return reinterpret_cast<const MoneroTransactionSignInputRequest*>(
               &_MoneroTransactionSignInputRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    27;

  void Swap(MoneroTransactionSignInputRequest* other);
  friend void swap(MoneroTransactionSignInputRequest& a, MoneroTransactionSignInputRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline MoneroTransactionSignInputRequest* New() const final {
    return CreateMaybeMessage<MoneroTransactionSignInputRequest>(nullptr);
  }

  MoneroTransactionSignInputRequest* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<MoneroTransactionSignInputRequest>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const MoneroTransactionSignInputRequest& from);
  void MergeFrom(const MoneroTransactionSignInputRequest& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MoneroTransactionSignInputRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bytes vini = 2;
  bool has_vini() const;
  void clear_vini();
  static const int kViniFieldNumber = 2;
  const ::std::string& vini() const;
  void set_vini(const ::std::string& value);
  #if LANG_CXX11
  void set_vini(::std::string&& value);
  #endif
  void set_vini(const char* value);
  void set_vini(const void* value, size_t size);
  ::std::string* mutable_vini();
  ::std::string* release_vini();
  void set_allocated_vini(::std::string* vini);

  // optional bytes vini_hmac = 3;
  bool has_vini_hmac() const;
  void clear_vini_hmac();
  static const int kViniHmacFieldNumber = 3;
  const ::std::string& vini_hmac() const;
  void set_vini_hmac(const ::std::string& value);
  #if LANG_CXX11
  void set_vini_hmac(::std::string&& value);
  #endif
  void set_vini_hmac(const char* value);
  void set_vini_hmac(const void* value, size_t size);
  ::std::string* mutable_vini_hmac();
  ::std::string* release_vini_hmac();
  void set_allocated_vini_hmac(::std::string* vini_hmac);

  // optional bytes pseudo_out = 4;
  bool has_pseudo_out() const;
  void clear_pseudo_out();
  static const int kPseudoOutFieldNumber = 4;
  const ::std::string& pseudo_out() const;
  void set_pseudo_out(const ::std::string& value);
  #if LANG_CXX11
  void set_pseudo_out(::std::string&& value);
  #endif
  void set_pseudo_out(const char* value);
  void set_pseudo_out(const void* value, size_t size);
  ::std::string* mutable_pseudo_out();
  ::std::string* release_pseudo_out();
  void set_allocated_pseudo_out(::std::string* pseudo_out);

  // optional bytes pseudo_out_hmac = 5;
  bool has_pseudo_out_hmac() const;
  void clear_pseudo_out_hmac();
  static const int kPseudoOutHmacFieldNumber = 5;
  const ::std::string& pseudo_out_hmac() const;
  void set_pseudo_out_hmac(const ::std::string& value);
  #if LANG_CXX11
  void set_pseudo_out_hmac(::std::string&& value);
  #endif
  void set_pseudo_out_hmac(const char* value);
  void set_pseudo_out_hmac(const void* value, size_t size);
  ::std::string* mutable_pseudo_out_hmac();
  ::std::string* release_pseudo_out_hmac();
  void set_allocated_pseudo_out_hmac(::std::string* pseudo_out_hmac);

  // optional bytes pseudo_out_alpha = 6;
  bool has_pseudo_out_alpha() const;
  void clear_pseudo_out_alpha();
  static const int kPseudoOutAlphaFieldNumber = 6;
  const ::std::string& pseudo_out_alpha() const;
  void set_pseudo_out_alpha(const ::std::string& value);
  #if LANG_CXX11
  void set_pseudo_out_alpha(::std::string&& value);
  #endif
  void set_pseudo_out_alpha(const char* value);
  void set_pseudo_out_alpha(const void* value, size_t size);
  ::std::string* mutable_pseudo_out_alpha();
  ::std::string* release_pseudo_out_alpha();
  void set_allocated_pseudo_out_alpha(::std::string* pseudo_out_alpha);

  // optional bytes spend_key = 7;
  bool has_spend_key() const;
  void clear_spend_key();
  static const int kSpendKeyFieldNumber = 7;
  const ::std::string& spend_key() const;
  void set_spend_key(const ::std::string& value);
  #if LANG_CXX11
  void set_spend_key(::std::string&& value);
  #endif
  void set_spend_key(const char* value);
  void set_spend_key(const void* value, size_t size);
  ::std::string* mutable_spend_key();
  ::std::string* release_spend_key();
  void set_allocated_spend_key(::std::string* spend_key);

  // optional .hw.trezor.messages.monero.MoneroTransactionSourceEntry src_entr = 1;
  bool has_src_entr() const;
  void clear_src_entr();
  static const int kSrcEntrFieldNumber = 1;
  const ::hw::trezor::messages::monero::MoneroTransactionSourceEntry& src_entr() const;
  ::hw::trezor::messages::monero::MoneroTransactionSourceEntry* release_src_entr();
  ::hw::trezor::messages::monero::MoneroTransactionSourceEntry* mutable_src_entr();
  void set_allocated_src_entr(::hw::trezor::messages::monero::MoneroTransactionSourceEntry* src_entr);

  // @@protoc_insertion_point(class_scope:hw.trezor.messages.monero.MoneroTransactionSignInputRequest)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr vini_;
  ::google::protobuf::internal::ArenaStringPtr vini_hmac_;
  ::google::protobuf::internal::ArenaStringPtr pseudo_out_;
  ::google::protobuf::internal::ArenaStringPtr pseudo_out_hmac_;
  ::google::protobuf::internal::ArenaStringPtr pseudo_out_alpha_;
  ::google::protobuf::internal::ArenaStringPtr spend_key_;
  ::hw::trezor::messages::monero::MoneroTransactionSourceEntry* src_entr_;
  friend struct ::TableStruct_messages_2dmonero_2eproto;
};
// -------------------------------------------------------------------

class MoneroTransactionSignInputAck final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:hw.trezor.messages.monero.MoneroTransactionSignInputAck) */ {
 public:
  MoneroTransactionSignInputAck();
  virtual ~MoneroTransactionSignInputAck();

  MoneroTransactionSignInputAck(const MoneroTransactionSignInputAck& from);

  inline MoneroTransactionSignInputAck& operator=(const MoneroTransactionSignInputAck& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  MoneroTransactionSignInputAck(MoneroTransactionSignInputAck&& from) noexcept
    : MoneroTransactionSignInputAck() {
    *this = ::std::move(from);
  }

  inline MoneroTransactionSignInputAck& operator=(MoneroTransactionSignInputAck&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const MoneroTransactionSignInputAck& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const MoneroTransactionSignInputAck* internal_default_instance() {
    return reinterpret_cast<const MoneroTransactionSignInputAck*>(
               &_MoneroTransactionSignInputAck_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    28;

  void Swap(MoneroTransactionSignInputAck* other);
  friend void swap(MoneroTransactionSignInputAck& a, MoneroTransactionSignInputAck& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline MoneroTransactionSignInputAck* New() const final {
    return CreateMaybeMessage<MoneroTransactionSignInputAck>(nullptr);
  }

  MoneroTransactionSignInputAck* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<MoneroTransactionSignInputAck>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const MoneroTransactionSignInputAck& from);
  void MergeFrom(const MoneroTransactionSignInputAck& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MoneroTransactionSignInputAck* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bytes signature = 1;
  bool has_signature() const;
  void clear_signature();
  static const int kSignatureFieldNumber = 1;
  const ::std::string& signature() const;
  void set_signature(const ::std::string& value);
  #if LANG_CXX11
  void set_signature(::std::string&& value);
  #endif
  void set_signature(const char* value);
  void set_signature(const void* value, size_t size);
  ::std::string* mutable_signature();
  ::std::string* release_signature();
  void set_allocated_signature(::std::string* signature);

  // @@protoc_insertion_point(class_scope:hw.trezor.messages.monero.MoneroTransactionSignInputAck)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr signature_;
  friend struct ::TableStruct_messages_2dmonero_2eproto;
};
// -------------------------------------------------------------------

class MoneroTransactionFinalRequest final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:hw.trezor.messages.monero.MoneroTransactionFinalRequest) */ {
 public:
  MoneroTransactionFinalRequest();
  virtual ~MoneroTransactionFinalRequest();

  MoneroTransactionFinalRequest(const MoneroTransactionFinalRequest& from);

  inline MoneroTransactionFinalRequest& operator=(const MoneroTransactionFinalRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  MoneroTransactionFinalRequest(MoneroTransactionFinalRequest&& from) noexcept
    : MoneroTransactionFinalRequest() {
    *this = ::std::move(from);
  }

  inline MoneroTransactionFinalRequest& operator=(MoneroTransactionFinalRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const MoneroTransactionFinalRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const MoneroTransactionFinalRequest* internal_default_instance() {
    return reinterpret_cast<const MoneroTransactionFinalRequest*>(
               &_MoneroTransactionFinalRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    29;

  void Swap(MoneroTransactionFinalRequest* other);
  friend void swap(MoneroTransactionFinalRequest& a, MoneroTransactionFinalRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline MoneroTransactionFinalRequest* New() const final {
    return CreateMaybeMessage<MoneroTransactionFinalRequest>(nullptr);
  }

  MoneroTransactionFinalRequest* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<MoneroTransactionFinalRequest>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const MoneroTransactionFinalRequest& from);
  void MergeFrom(const MoneroTransactionFinalRequest& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MoneroTransactionFinalRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:hw.trezor.messages.monero.MoneroTransactionFinalRequest)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_messages_2dmonero_2eproto;
};
// -------------------------------------------------------------------

class MoneroTransactionFinalAck final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:hw.trezor.messages.monero.MoneroTransactionFinalAck) */ {
 public:
  MoneroTransactionFinalAck();
  virtual ~MoneroTransactionFinalAck();

  MoneroTransactionFinalAck(const MoneroTransactionFinalAck& from);

  inline MoneroTransactionFinalAck& operator=(const MoneroTransactionFinalAck& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  MoneroTransactionFinalAck(MoneroTransactionFinalAck&& from) noexcept
    : MoneroTransactionFinalAck() {
    *this = ::std::move(from);
  }

  inline MoneroTransactionFinalAck& operator=(MoneroTransactionFinalAck&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const MoneroTransactionFinalAck& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const MoneroTransactionFinalAck* internal_default_instance() {
    return reinterpret_cast<const MoneroTransactionFinalAck*>(
               &_MoneroTransactionFinalAck_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    30;

  void Swap(MoneroTransactionFinalAck* other);
  friend void swap(MoneroTransactionFinalAck& a, MoneroTransactionFinalAck& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline MoneroTransactionFinalAck* New() const final {
    return CreateMaybeMessage<MoneroTransactionFinalAck>(nullptr);
  }

  MoneroTransactionFinalAck* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<MoneroTransactionFinalAck>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const MoneroTransactionFinalAck& from);
  void MergeFrom(const MoneroTransactionFinalAck& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MoneroTransactionFinalAck* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bytes cout_key = 1;
  bool has_cout_key() const;
  void clear_cout_key();
  static const int kCoutKeyFieldNumber = 1;
  const ::std::string& cout_key() const;
  void set_cout_key(const ::std::string& value);
  #if LANG_CXX11
  void set_cout_key(::std::string&& value);
  #endif
  void set_cout_key(const char* value);
  void set_cout_key(const void* value, size_t size);
  ::std::string* mutable_cout_key();
  ::std::string* release_cout_key();
  void set_allocated_cout_key(::std::string* cout_key);

  // optional bytes salt = 2;
  bool has_salt() const;
  void clear_salt();
  static const int kSaltFieldNumber = 2;
  const ::std::string& salt() const;
  void set_salt(const ::std::string& value);
  #if LANG_CXX11
  void set_salt(::std::string&& value);
  #endif
  void set_salt(const char* value);
  void set_salt(const void* value, size_t size);
  ::std::string* mutable_salt();
  ::std::string* release_salt();
  void set_allocated_salt(::std::string* salt);

  // optional bytes rand_mult = 3;
  bool has_rand_mult() const;
  void clear_rand_mult();
  static const int kRandMultFieldNumber = 3;
  const ::std::string& rand_mult() const;
  void set_rand_mult(const ::std::string& value);
  #if LANG_CXX11
  void set_rand_mult(::std::string&& value);
  #endif
  void set_rand_mult(const char* value);
  void set_rand_mult(const void* value, size_t size);
  ::std::string* mutable_rand_mult();
  ::std::string* release_rand_mult();
  void set_allocated_rand_mult(::std::string* rand_mult);

  // optional bytes tx_enc_keys = 4;
  bool has_tx_enc_keys() const;
  void clear_tx_enc_keys();
  static const int kTxEncKeysFieldNumber = 4;
  const ::std::string& tx_enc_keys() const;
  void set_tx_enc_keys(const ::std::string& value);
  #if LANG_CXX11
  void set_tx_enc_keys(::std::string&& value);
  #endif
  void set_tx_enc_keys(const char* value);
  void set_tx_enc_keys(const void* value, size_t size);
  ::std::string* mutable_tx_enc_keys();
  ::std::string* release_tx_enc_keys();
  void set_allocated_tx_enc_keys(::std::string* tx_enc_keys);

  // @@protoc_insertion_point(class_scope:hw.trezor.messages.monero.MoneroTransactionFinalAck)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr cout_key_;
  ::google::protobuf::internal::ArenaStringPtr salt_;
  ::google::protobuf::internal::ArenaStringPtr rand_mult_;
  ::google::protobuf::internal::ArenaStringPtr tx_enc_keys_;
  friend struct ::TableStruct_messages_2dmonero_2eproto;
};
// -------------------------------------------------------------------

class MoneroKeyImageExportInitRequest_MoneroSubAddressIndicesList final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:hw.trezor.messages.monero.MoneroKeyImageExportInitRequest.MoneroSubAddressIndicesList) */ {
 public:
  MoneroKeyImageExportInitRequest_MoneroSubAddressIndicesList();
  virtual ~MoneroKeyImageExportInitRequest_MoneroSubAddressIndicesList();

  MoneroKeyImageExportInitRequest_MoneroSubAddressIndicesList(const MoneroKeyImageExportInitRequest_MoneroSubAddressIndicesList& from);

  inline MoneroKeyImageExportInitRequest_MoneroSubAddressIndicesList& operator=(const MoneroKeyImageExportInitRequest_MoneroSubAddressIndicesList& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  MoneroKeyImageExportInitRequest_MoneroSubAddressIndicesList(MoneroKeyImageExportInitRequest_MoneroSubAddressIndicesList&& from) noexcept
    : MoneroKeyImageExportInitRequest_MoneroSubAddressIndicesList() {
    *this = ::std::move(from);
  }

  inline MoneroKeyImageExportInitRequest_MoneroSubAddressIndicesList& operator=(MoneroKeyImageExportInitRequest_MoneroSubAddressIndicesList&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const MoneroKeyImageExportInitRequest_MoneroSubAddressIndicesList& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const MoneroKeyImageExportInitRequest_MoneroSubAddressIndicesList* internal_default_instance() {
    return reinterpret_cast<const MoneroKeyImageExportInitRequest_MoneroSubAddressIndicesList*>(
               &_MoneroKeyImageExportInitRequest_MoneroSubAddressIndicesList_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    31;

  void Swap(MoneroKeyImageExportInitRequest_MoneroSubAddressIndicesList* other);
  friend void swap(MoneroKeyImageExportInitRequest_MoneroSubAddressIndicesList& a, MoneroKeyImageExportInitRequest_MoneroSubAddressIndicesList& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline MoneroKeyImageExportInitRequest_MoneroSubAddressIndicesList* New() const final {
    return CreateMaybeMessage<MoneroKeyImageExportInitRequest_MoneroSubAddressIndicesList>(nullptr);
  }

  MoneroKeyImageExportInitRequest_MoneroSubAddressIndicesList* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<MoneroKeyImageExportInitRequest_MoneroSubAddressIndicesList>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const MoneroKeyImageExportInitRequest_MoneroSubAddressIndicesList& from);
  void MergeFrom(const MoneroKeyImageExportInitRequest_MoneroSubAddressIndicesList& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MoneroKeyImageExportInitRequest_MoneroSubAddressIndicesList* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated uint32 minor_indices = 2;
  int minor_indices_size() const;
  void clear_minor_indices();
  static const int kMinorIndicesFieldNumber = 2;
  ::google::protobuf::uint32 minor_indices(int index) const;
  void set_minor_indices(int index, ::google::protobuf::uint32 value);
  void add_minor_indices(::google::protobuf::uint32 value);
  const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      minor_indices() const;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable_minor_indices();

  // optional uint32 account = 1;
  bool has_account() const;
  void clear_account();
  static const int kAccountFieldNumber = 1;
  ::google::protobuf::uint32 account() const;
  void set_account(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:hw.trezor.messages.monero.MoneroKeyImageExportInitRequest.MoneroSubAddressIndicesList)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > minor_indices_;
  ::google::protobuf::uint32 account_;
  friend struct ::TableStruct_messages_2dmonero_2eproto;
};
// -------------------------------------------------------------------

class MoneroKeyImageExportInitRequest final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:hw.trezor.messages.monero.MoneroKeyImageExportInitRequest) */ {
 public:
  MoneroKeyImageExportInitRequest();
  virtual ~MoneroKeyImageExportInitRequest();

  MoneroKeyImageExportInitRequest(const MoneroKeyImageExportInitRequest& from);

  inline MoneroKeyImageExportInitRequest& operator=(const MoneroKeyImageExportInitRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  MoneroKeyImageExportInitRequest(MoneroKeyImageExportInitRequest&& from) noexcept
    : MoneroKeyImageExportInitRequest() {
    *this = ::std::move(from);
  }

  inline MoneroKeyImageExportInitRequest& operator=(MoneroKeyImageExportInitRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const MoneroKeyImageExportInitRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const MoneroKeyImageExportInitRequest* internal_default_instance() {
    return reinterpret_cast<const MoneroKeyImageExportInitRequest*>(
               &_MoneroKeyImageExportInitRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    32;

  void Swap(MoneroKeyImageExportInitRequest* other);
  friend void swap(MoneroKeyImageExportInitRequest& a, MoneroKeyImageExportInitRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline MoneroKeyImageExportInitRequest* New() const final {
    return CreateMaybeMessage<MoneroKeyImageExportInitRequest>(nullptr);
  }

  MoneroKeyImageExportInitRequest* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<MoneroKeyImageExportInitRequest>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const MoneroKeyImageExportInitRequest& from);
  void MergeFrom(const MoneroKeyImageExportInitRequest& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MoneroKeyImageExportInitRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef MoneroKeyImageExportInitRequest_MoneroSubAddressIndicesList MoneroSubAddressIndicesList;

  // accessors -------------------------------------------------------

  // repeated uint32 address_n = 3;
  int address_n_size() const;
  void clear_address_n();
  static const int kAddressNFieldNumber = 3;
  ::google::protobuf::uint32 address_n(int index) const;
  void set_address_n(int index, ::google::protobuf::uint32 value);
  void add_address_n(::google::protobuf::uint32 value);
  const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      address_n() const;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable_address_n();

  // repeated .hw.trezor.messages.monero.MoneroKeyImageExportInitRequest.MoneroSubAddressIndicesList subs = 5;
  int subs_size() const;
  void clear_subs();
  static const int kSubsFieldNumber = 5;
  ::hw::trezor::messages::monero::MoneroKeyImageExportInitRequest_MoneroSubAddressIndicesList* mutable_subs(int index);
  ::google::protobuf::RepeatedPtrField< ::hw::trezor::messages::monero::MoneroKeyImageExportInitRequest_MoneroSubAddressIndicesList >*
      mutable_subs();
  const ::hw::trezor::messages::monero::MoneroKeyImageExportInitRequest_MoneroSubAddressIndicesList& subs(int index) const;
  ::hw::trezor::messages::monero::MoneroKeyImageExportInitRequest_MoneroSubAddressIndicesList* add_subs();
  const ::google::protobuf::RepeatedPtrField< ::hw::trezor::messages::monero::MoneroKeyImageExportInitRequest_MoneroSubAddressIndicesList >&
      subs() const;

  // optional bytes hash = 2;
  bool has_hash() const;
  void clear_hash();
  static const int kHashFieldNumber = 2;
  const ::std::string& hash() const;
  void set_hash(const ::std::string& value);
  #if LANG_CXX11
  void set_hash(::std::string&& value);
  #endif
  void set_hash(const char* value);
  void set_hash(const void* value, size_t size);
  ::std::string* mutable_hash();
  ::std::string* release_hash();
  void set_allocated_hash(::std::string* hash);

  // optional uint64 num = 1;
  bool has_num() const;
  void clear_num();
  static const int kNumFieldNumber = 1;
  ::google::protobuf::uint64 num() const;
  void set_num(::google::protobuf::uint64 value);

  // optional uint32 network_type = 4;
  bool has_network_type() const;
  void clear_network_type();
  static const int kNetworkTypeFieldNumber = 4;
  ::google::protobuf::uint32 network_type() const;
  void set_network_type(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:hw.trezor.messages.monero.MoneroKeyImageExportInitRequest)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > address_n_;
  ::google::protobuf::RepeatedPtrField< ::hw::trezor::messages::monero::MoneroKeyImageExportInitRequest_MoneroSubAddressIndicesList > subs_;
  ::google::protobuf::internal::ArenaStringPtr hash_;
  ::google::protobuf::uint64 num_;
  ::google::protobuf::uint32 network_type_;
  friend struct ::TableStruct_messages_2dmonero_2eproto;
};
// -------------------------------------------------------------------

class MoneroKeyImageExportInitAck final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:hw.trezor.messages.monero.MoneroKeyImageExportInitAck) */ {
 public:
  MoneroKeyImageExportInitAck();
  virtual ~MoneroKeyImageExportInitAck();

  MoneroKeyImageExportInitAck(const MoneroKeyImageExportInitAck& from);

  inline MoneroKeyImageExportInitAck& operator=(const MoneroKeyImageExportInitAck& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  MoneroKeyImageExportInitAck(MoneroKeyImageExportInitAck&& from) noexcept
    : MoneroKeyImageExportInitAck() {
    *this = ::std::move(from);
  }

  inline MoneroKeyImageExportInitAck& operator=(MoneroKeyImageExportInitAck&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const MoneroKeyImageExportInitAck& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const MoneroKeyImageExportInitAck* internal_default_instance() {
    return reinterpret_cast<const MoneroKeyImageExportInitAck*>(
               &_MoneroKeyImageExportInitAck_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    33;

  void Swap(MoneroKeyImageExportInitAck* other);
  friend void swap(MoneroKeyImageExportInitAck& a, MoneroKeyImageExportInitAck& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline MoneroKeyImageExportInitAck* New() const final {
    return CreateMaybeMessage<MoneroKeyImageExportInitAck>(nullptr);
  }

  MoneroKeyImageExportInitAck* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<MoneroKeyImageExportInitAck>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const MoneroKeyImageExportInitAck& from);
  void MergeFrom(const MoneroKeyImageExportInitAck& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MoneroKeyImageExportInitAck* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:hw.trezor.messages.monero.MoneroKeyImageExportInitAck)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_messages_2dmonero_2eproto;
};
// -------------------------------------------------------------------

class MoneroKeyImageSyncStepRequest_MoneroTransferDetails final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:hw.trezor.messages.monero.MoneroKeyImageSyncStepRequest.MoneroTransferDetails) */ {
 public:
  MoneroKeyImageSyncStepRequest_MoneroTransferDetails();
  virtual ~MoneroKeyImageSyncStepRequest_MoneroTransferDetails();

  MoneroKeyImageSyncStepRequest_MoneroTransferDetails(const MoneroKeyImageSyncStepRequest_MoneroTransferDetails& from);

  inline MoneroKeyImageSyncStepRequest_MoneroTransferDetails& operator=(const MoneroKeyImageSyncStepRequest_MoneroTransferDetails& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  MoneroKeyImageSyncStepRequest_MoneroTransferDetails(MoneroKeyImageSyncStepRequest_MoneroTransferDetails&& from) noexcept
    : MoneroKeyImageSyncStepRequest_MoneroTransferDetails() {
    *this = ::std::move(from);
  }

  inline MoneroKeyImageSyncStepRequest_MoneroTransferDetails& operator=(MoneroKeyImageSyncStepRequest_MoneroTransferDetails&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const MoneroKeyImageSyncStepRequest_MoneroTransferDetails& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const MoneroKeyImageSyncStepRequest_MoneroTransferDetails* internal_default_instance() {
    return reinterpret_cast<const MoneroKeyImageSyncStepRequest_MoneroTransferDetails*>(
               &_MoneroKeyImageSyncStepRequest_MoneroTransferDetails_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    34;

  void Swap(MoneroKeyImageSyncStepRequest_MoneroTransferDetails* other);
  friend void swap(MoneroKeyImageSyncStepRequest_MoneroTransferDetails& a, MoneroKeyImageSyncStepRequest_MoneroTransferDetails& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline MoneroKeyImageSyncStepRequest_MoneroTransferDetails* New() const final {
    return CreateMaybeMessage<MoneroKeyImageSyncStepRequest_MoneroTransferDetails>(nullptr);
  }

  MoneroKeyImageSyncStepRequest_MoneroTransferDetails* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<MoneroKeyImageSyncStepRequest_MoneroTransferDetails>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const MoneroKeyImageSyncStepRequest_MoneroTransferDetails& from);
  void MergeFrom(const MoneroKeyImageSyncStepRequest_MoneroTransferDetails& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MoneroKeyImageSyncStepRequest_MoneroTransferDetails* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated bytes additional_tx_pub_keys = 3;
  int additional_tx_pub_keys_size() const;
  void clear_additional_tx_pub_keys();
  static const int kAdditionalTxPubKeysFieldNumber = 3;
  const ::std::string& additional_tx_pub_keys(int index) const;
  ::std::string* mutable_additional_tx_pub_keys(int index);
  void set_additional_tx_pub_keys(int index, const ::std::string& value);
  #if LANG_CXX11
  void set_additional_tx_pub_keys(int index, ::std::string&& value);
  #endif
  void set_additional_tx_pub_keys(int index, const char* value);
  void set_additional_tx_pub_keys(int index, const void* value, size_t size);
  ::std::string* add_additional_tx_pub_keys();
  void add_additional_tx_pub_keys(const ::std::string& value);
  #if LANG_CXX11
  void add_additional_tx_pub_keys(::std::string&& value);
  #endif
  void add_additional_tx_pub_keys(const char* value);
  void add_additional_tx_pub_keys(const void* value, size_t size);
  const ::google::protobuf::RepeatedPtrField<::std::string>& additional_tx_pub_keys() const;
  ::google::protobuf::RepeatedPtrField<::std::string>* mutable_additional_tx_pub_keys();

  // optional bytes out_key = 1;
  bool has_out_key() const;
  void clear_out_key();
  static const int kOutKeyFieldNumber = 1;
  const ::std::string& out_key() const;
  void set_out_key(const ::std::string& value);
  #if LANG_CXX11
  void set_out_key(::std::string&& value);
  #endif
  void set_out_key(const char* value);
  void set_out_key(const void* value, size_t size);
  ::std::string* mutable_out_key();
  ::std::string* release_out_key();
  void set_allocated_out_key(::std::string* out_key);

  // optional bytes tx_pub_key = 2;
  bool has_tx_pub_key() const;
  void clear_tx_pub_key();
  static const int kTxPubKeyFieldNumber = 2;
  const ::std::string& tx_pub_key() const;
  void set_tx_pub_key(const ::std::string& value);
  #if LANG_CXX11
  void set_tx_pub_key(::std::string&& value);
  #endif
  void set_tx_pub_key(const char* value);
  void set_tx_pub_key(const void* value, size_t size);
  ::std::string* mutable_tx_pub_key();
  ::std::string* release_tx_pub_key();
  void set_allocated_tx_pub_key(::std::string* tx_pub_key);

  // optional uint64 internal_output_index = 4;
  bool has_internal_output_index() const;
  void clear_internal_output_index();
  static const int kInternalOutputIndexFieldNumber = 4;
  ::google::protobuf::uint64 internal_output_index() const;
  void set_internal_output_index(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:hw.trezor.messages.monero.MoneroKeyImageSyncStepRequest.MoneroTransferDetails)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedPtrField<::std::string> additional_tx_pub_keys_;
  ::google::protobuf::internal::ArenaStringPtr out_key_;
  ::google::protobuf::internal::ArenaStringPtr tx_pub_key_;
  ::google::protobuf::uint64 internal_output_index_;
  friend struct ::TableStruct_messages_2dmonero_2eproto;
};
// -------------------------------------------------------------------

class MoneroKeyImageSyncStepRequest final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:hw.trezor.messages.monero.MoneroKeyImageSyncStepRequest) */ {
 public:
  MoneroKeyImageSyncStepRequest();
  virtual ~MoneroKeyImageSyncStepRequest();

  MoneroKeyImageSyncStepRequest(const MoneroKeyImageSyncStepRequest& from);

  inline MoneroKeyImageSyncStepRequest& operator=(const MoneroKeyImageSyncStepRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  MoneroKeyImageSyncStepRequest(MoneroKeyImageSyncStepRequest&& from) noexcept
    : MoneroKeyImageSyncStepRequest() {
    *this = ::std::move(from);
  }

  inline MoneroKeyImageSyncStepRequest& operator=(MoneroKeyImageSyncStepRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const MoneroKeyImageSyncStepRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const MoneroKeyImageSyncStepRequest* internal_default_instance() {
    return reinterpret_cast<const MoneroKeyImageSyncStepRequest*>(
               &_MoneroKeyImageSyncStepRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    35;

  void Swap(MoneroKeyImageSyncStepRequest* other);
  friend void swap(MoneroKeyImageSyncStepRequest& a, MoneroKeyImageSyncStepRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline MoneroKeyImageSyncStepRequest* New() const final {
    return CreateMaybeMessage<MoneroKeyImageSyncStepRequest>(nullptr);
  }

  MoneroKeyImageSyncStepRequest* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<MoneroKeyImageSyncStepRequest>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const MoneroKeyImageSyncStepRequest& from);
  void MergeFrom(const MoneroKeyImageSyncStepRequest& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MoneroKeyImageSyncStepRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef MoneroKeyImageSyncStepRequest_MoneroTransferDetails MoneroTransferDetails;

  // accessors -------------------------------------------------------

  // repeated .hw.trezor.messages.monero.MoneroKeyImageSyncStepRequest.MoneroTransferDetails tdis = 1;
  int tdis_size() const;
  void clear_tdis();
  static const int kTdisFieldNumber = 1;
  ::hw::trezor::messages::monero::MoneroKeyImageSyncStepRequest_MoneroTransferDetails* mutable_tdis(int index);
  ::google::protobuf::RepeatedPtrField< ::hw::trezor::messages::monero::MoneroKeyImageSyncStepRequest_MoneroTransferDetails >*
      mutable_tdis();
  const ::hw::trezor::messages::monero::MoneroKeyImageSyncStepRequest_MoneroTransferDetails& tdis(int index) const;
  ::hw::trezor::messages::monero::MoneroKeyImageSyncStepRequest_MoneroTransferDetails* add_tdis();
  const ::google::protobuf::RepeatedPtrField< ::hw::trezor::messages::monero::MoneroKeyImageSyncStepRequest_MoneroTransferDetails >&
      tdis() const;

  // @@protoc_insertion_point(class_scope:hw.trezor.messages.monero.MoneroKeyImageSyncStepRequest)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::hw::trezor::messages::monero::MoneroKeyImageSyncStepRequest_MoneroTransferDetails > tdis_;
  friend struct ::TableStruct_messages_2dmonero_2eproto;
};
// -------------------------------------------------------------------

class MoneroKeyImageSyncStepAck_MoneroExportedKeyImage final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:hw.trezor.messages.monero.MoneroKeyImageSyncStepAck.MoneroExportedKeyImage) */ {
 public:
  MoneroKeyImageSyncStepAck_MoneroExportedKeyImage();
  virtual ~MoneroKeyImageSyncStepAck_MoneroExportedKeyImage();

  MoneroKeyImageSyncStepAck_MoneroExportedKeyImage(const MoneroKeyImageSyncStepAck_MoneroExportedKeyImage& from);

  inline MoneroKeyImageSyncStepAck_MoneroExportedKeyImage& operator=(const MoneroKeyImageSyncStepAck_MoneroExportedKeyImage& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  MoneroKeyImageSyncStepAck_MoneroExportedKeyImage(MoneroKeyImageSyncStepAck_MoneroExportedKeyImage&& from) noexcept
    : MoneroKeyImageSyncStepAck_MoneroExportedKeyImage() {
    *this = ::std::move(from);
  }

  inline MoneroKeyImageSyncStepAck_MoneroExportedKeyImage& operator=(MoneroKeyImageSyncStepAck_MoneroExportedKeyImage&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const MoneroKeyImageSyncStepAck_MoneroExportedKeyImage& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const MoneroKeyImageSyncStepAck_MoneroExportedKeyImage* internal_default_instance() {
    return reinterpret_cast<const MoneroKeyImageSyncStepAck_MoneroExportedKeyImage*>(
               &_MoneroKeyImageSyncStepAck_MoneroExportedKeyImage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    36;

  void Swap(MoneroKeyImageSyncStepAck_MoneroExportedKeyImage* other);
  friend void swap(MoneroKeyImageSyncStepAck_MoneroExportedKeyImage& a, MoneroKeyImageSyncStepAck_MoneroExportedKeyImage& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline MoneroKeyImageSyncStepAck_MoneroExportedKeyImage* New() const final {
    return CreateMaybeMessage<MoneroKeyImageSyncStepAck_MoneroExportedKeyImage>(nullptr);
  }

  MoneroKeyImageSyncStepAck_MoneroExportedKeyImage* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<MoneroKeyImageSyncStepAck_MoneroExportedKeyImage>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const MoneroKeyImageSyncStepAck_MoneroExportedKeyImage& from);
  void MergeFrom(const MoneroKeyImageSyncStepAck_MoneroExportedKeyImage& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MoneroKeyImageSyncStepAck_MoneroExportedKeyImage* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bytes iv = 1;
  bool has_iv() const;
  void clear_iv();
  static const int kIvFieldNumber = 1;
  const ::std::string& iv() const;
  void set_iv(const ::std::string& value);
  #if LANG_CXX11
  void set_iv(::std::string&& value);
  #endif
  void set_iv(const char* value);
  void set_iv(const void* value, size_t size);
  ::std::string* mutable_iv();
  ::std::string* release_iv();
  void set_allocated_iv(::std::string* iv);

  // optional bytes blob = 3;
  bool has_blob() const;
  void clear_blob();
  static const int kBlobFieldNumber = 3;
  const ::std::string& blob() const;
  void set_blob(const ::std::string& value);
  #if LANG_CXX11
  void set_blob(::std::string&& value);
  #endif
  void set_blob(const char* value);
  void set_blob(const void* value, size_t size);
  ::std::string* mutable_blob();
  ::std::string* release_blob();
  void set_allocated_blob(::std::string* blob);

  // @@protoc_insertion_point(class_scope:hw.trezor.messages.monero.MoneroKeyImageSyncStepAck.MoneroExportedKeyImage)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr iv_;
  ::google::protobuf::internal::ArenaStringPtr blob_;
  friend struct ::TableStruct_messages_2dmonero_2eproto;
};
// -------------------------------------------------------------------

class MoneroKeyImageSyncStepAck final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:hw.trezor.messages.monero.MoneroKeyImageSyncStepAck) */ {
 public:
  MoneroKeyImageSyncStepAck();
  virtual ~MoneroKeyImageSyncStepAck();

  MoneroKeyImageSyncStepAck(const MoneroKeyImageSyncStepAck& from);

  inline MoneroKeyImageSyncStepAck& operator=(const MoneroKeyImageSyncStepAck& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  MoneroKeyImageSyncStepAck(MoneroKeyImageSyncStepAck&& from) noexcept
    : MoneroKeyImageSyncStepAck() {
    *this = ::std::move(from);
  }

  inline MoneroKeyImageSyncStepAck& operator=(MoneroKeyImageSyncStepAck&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const MoneroKeyImageSyncStepAck& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const MoneroKeyImageSyncStepAck* internal_default_instance() {
    return reinterpret_cast<const MoneroKeyImageSyncStepAck*>(
               &_MoneroKeyImageSyncStepAck_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    37;

  void Swap(MoneroKeyImageSyncStepAck* other);
  friend void swap(MoneroKeyImageSyncStepAck& a, MoneroKeyImageSyncStepAck& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline MoneroKeyImageSyncStepAck* New() const final {
    return CreateMaybeMessage<MoneroKeyImageSyncStepAck>(nullptr);
  }

  MoneroKeyImageSyncStepAck* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<MoneroKeyImageSyncStepAck>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const MoneroKeyImageSyncStepAck& from);
  void MergeFrom(const MoneroKeyImageSyncStepAck& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MoneroKeyImageSyncStepAck* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef MoneroKeyImageSyncStepAck_MoneroExportedKeyImage MoneroExportedKeyImage;

  // accessors -------------------------------------------------------

  // repeated .hw.trezor.messages.monero.MoneroKeyImageSyncStepAck.MoneroExportedKeyImage kis = 1;
  int kis_size() const;
  void clear_kis();
  static const int kKisFieldNumber = 1;
  ::hw::trezor::messages::monero::MoneroKeyImageSyncStepAck_MoneroExportedKeyImage* mutable_kis(int index);
  ::google::protobuf::RepeatedPtrField< ::hw::trezor::messages::monero::MoneroKeyImageSyncStepAck_MoneroExportedKeyImage >*
      mutable_kis();
  const ::hw::trezor::messages::monero::MoneroKeyImageSyncStepAck_MoneroExportedKeyImage& kis(int index) const;
  ::hw::trezor::messages::monero::MoneroKeyImageSyncStepAck_MoneroExportedKeyImage* add_kis();
  const ::google::protobuf::RepeatedPtrField< ::hw::trezor::messages::monero::MoneroKeyImageSyncStepAck_MoneroExportedKeyImage >&
      kis() const;

  // @@protoc_insertion_point(class_scope:hw.trezor.messages.monero.MoneroKeyImageSyncStepAck)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::hw::trezor::messages::monero::MoneroKeyImageSyncStepAck_MoneroExportedKeyImage > kis_;
  friend struct ::TableStruct_messages_2dmonero_2eproto;
};
// -------------------------------------------------------------------

class MoneroKeyImageSyncFinalRequest final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:hw.trezor.messages.monero.MoneroKeyImageSyncFinalRequest) */ {
 public:
  MoneroKeyImageSyncFinalRequest();
  virtual ~MoneroKeyImageSyncFinalRequest();

  MoneroKeyImageSyncFinalRequest(const MoneroKeyImageSyncFinalRequest& from);

  inline MoneroKeyImageSyncFinalRequest& operator=(const MoneroKeyImageSyncFinalRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  MoneroKeyImageSyncFinalRequest(MoneroKeyImageSyncFinalRequest&& from) noexcept
    : MoneroKeyImageSyncFinalRequest() {
    *this = ::std::move(from);
  }

  inline MoneroKeyImageSyncFinalRequest& operator=(MoneroKeyImageSyncFinalRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const MoneroKeyImageSyncFinalRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const MoneroKeyImageSyncFinalRequest* internal_default_instance() {
    return reinterpret_cast<const MoneroKeyImageSyncFinalRequest*>(
               &_MoneroKeyImageSyncFinalRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    38;

  void Swap(MoneroKeyImageSyncFinalRequest* other);
  friend void swap(MoneroKeyImageSyncFinalRequest& a, MoneroKeyImageSyncFinalRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline MoneroKeyImageSyncFinalRequest* New() const final {
    return CreateMaybeMessage<MoneroKeyImageSyncFinalRequest>(nullptr);
  }

  MoneroKeyImageSyncFinalRequest* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<MoneroKeyImageSyncFinalRequest>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const MoneroKeyImageSyncFinalRequest& from);
  void MergeFrom(const MoneroKeyImageSyncFinalRequest& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MoneroKeyImageSyncFinalRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:hw.trezor.messages.monero.MoneroKeyImageSyncFinalRequest)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_messages_2dmonero_2eproto;
};
// -------------------------------------------------------------------

class MoneroKeyImageSyncFinalAck final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:hw.trezor.messages.monero.MoneroKeyImageSyncFinalAck) */ {
 public:
  MoneroKeyImageSyncFinalAck();
  virtual ~MoneroKeyImageSyncFinalAck();

  MoneroKeyImageSyncFinalAck(const MoneroKeyImageSyncFinalAck& from);

  inline MoneroKeyImageSyncFinalAck& operator=(const MoneroKeyImageSyncFinalAck& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  MoneroKeyImageSyncFinalAck(MoneroKeyImageSyncFinalAck&& from) noexcept
    : MoneroKeyImageSyncFinalAck() {
    *this = ::std::move(from);
  }

  inline MoneroKeyImageSyncFinalAck& operator=(MoneroKeyImageSyncFinalAck&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const MoneroKeyImageSyncFinalAck& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const MoneroKeyImageSyncFinalAck* internal_default_instance() {
    return reinterpret_cast<const MoneroKeyImageSyncFinalAck*>(
               &_MoneroKeyImageSyncFinalAck_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    39;

  void Swap(MoneroKeyImageSyncFinalAck* other);
  friend void swap(MoneroKeyImageSyncFinalAck& a, MoneroKeyImageSyncFinalAck& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline MoneroKeyImageSyncFinalAck* New() const final {
    return CreateMaybeMessage<MoneroKeyImageSyncFinalAck>(nullptr);
  }

  MoneroKeyImageSyncFinalAck* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<MoneroKeyImageSyncFinalAck>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const MoneroKeyImageSyncFinalAck& from);
  void MergeFrom(const MoneroKeyImageSyncFinalAck& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MoneroKeyImageSyncFinalAck* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bytes enc_key = 1;
  bool has_enc_key() const;
  void clear_enc_key();
  static const int kEncKeyFieldNumber = 1;
  const ::std::string& enc_key() const;
  void set_enc_key(const ::std::string& value);
  #if LANG_CXX11
  void set_enc_key(::std::string&& value);
  #endif
  void set_enc_key(const char* value);
  void set_enc_key(const void* value, size_t size);
  ::std::string* mutable_enc_key();
  ::std::string* release_enc_key();
  void set_allocated_enc_key(::std::string* enc_key);

  // @@protoc_insertion_point(class_scope:hw.trezor.messages.monero.MoneroKeyImageSyncFinalAck)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr enc_key_;
  friend struct ::TableStruct_messages_2dmonero_2eproto;
};
// -------------------------------------------------------------------

class MoneroGetTxKeyRequest final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:hw.trezor.messages.monero.MoneroGetTxKeyRequest) */ {
 public:
  MoneroGetTxKeyRequest();
  virtual ~MoneroGetTxKeyRequest();

  MoneroGetTxKeyRequest(const MoneroGetTxKeyRequest& from);

  inline MoneroGetTxKeyRequest& operator=(const MoneroGetTxKeyRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  MoneroGetTxKeyRequest(MoneroGetTxKeyRequest&& from) noexcept
    : MoneroGetTxKeyRequest() {
    *this = ::std::move(from);
  }

  inline MoneroGetTxKeyRequest& operator=(MoneroGetTxKeyRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const MoneroGetTxKeyRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const MoneroGetTxKeyRequest* internal_default_instance() {
    return reinterpret_cast<const MoneroGetTxKeyRequest*>(
               &_MoneroGetTxKeyRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    40;

  void Swap(MoneroGetTxKeyRequest* other);
  friend void swap(MoneroGetTxKeyRequest& a, MoneroGetTxKeyRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline MoneroGetTxKeyRequest* New() const final {
    return CreateMaybeMessage<MoneroGetTxKeyRequest>(nullptr);
  }

  MoneroGetTxKeyRequest* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<MoneroGetTxKeyRequest>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const MoneroGetTxKeyRequest& from);
  void MergeFrom(const MoneroGetTxKeyRequest& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MoneroGetTxKeyRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated uint32 address_n = 1;
  int address_n_size() const;
  void clear_address_n();
  static const int kAddressNFieldNumber = 1;
  ::google::protobuf::uint32 address_n(int index) const;
  void set_address_n(int index, ::google::protobuf::uint32 value);
  void add_address_n(::google::protobuf::uint32 value);
  const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      address_n() const;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable_address_n();

  // optional bytes salt1 = 3;
  bool has_salt1() const;
  void clear_salt1();
  static const int kSalt1FieldNumber = 3;
  const ::std::string& salt1() const;
  void set_salt1(const ::std::string& value);
  #if LANG_CXX11
  void set_salt1(::std::string&& value);
  #endif
  void set_salt1(const char* value);
  void set_salt1(const void* value, size_t size);
  ::std::string* mutable_salt1();
  ::std::string* release_salt1();
  void set_allocated_salt1(::std::string* salt1);

  // optional bytes salt2 = 4;
  bool has_salt2() const;
  void clear_salt2();
  static const int kSalt2FieldNumber = 4;
  const ::std::string& salt2() const;
  void set_salt2(const ::std::string& value);
  #if LANG_CXX11
  void set_salt2(::std::string&& value);
  #endif
  void set_salt2(const char* value);
  void set_salt2(const void* value, size_t size);
  ::std::string* mutable_salt2();
  ::std::string* release_salt2();
  void set_allocated_salt2(::std::string* salt2);

  // optional bytes tx_enc_keys = 5;
  bool has_tx_enc_keys() const;
  void clear_tx_enc_keys();
  static const int kTxEncKeysFieldNumber = 5;
  const ::std::string& tx_enc_keys() const;
  void set_tx_enc_keys(const ::std::string& value);
  #if LANG_CXX11
  void set_tx_enc_keys(::std::string&& value);
  #endif
  void set_tx_enc_keys(const char* value);
  void set_tx_enc_keys(const void* value, size_t size);
  ::std::string* mutable_tx_enc_keys();
  ::std::string* release_tx_enc_keys();
  void set_allocated_tx_enc_keys(::std::string* tx_enc_keys);

  // optional bytes tx_prefix_hash = 6;
  bool has_tx_prefix_hash() const;
  void clear_tx_prefix_hash();
  static const int kTxPrefixHashFieldNumber = 6;
  const ::std::string& tx_prefix_hash() const;
  void set_tx_prefix_hash(const ::std::string& value);
  #if LANG_CXX11
  void set_tx_prefix_hash(::std::string&& value);
  #endif
  void set_tx_prefix_hash(const char* value);
  void set_tx_prefix_hash(const void* value, size_t size);
  ::std::string* mutable_tx_prefix_hash();
  ::std::string* release_tx_prefix_hash();
  void set_allocated_tx_prefix_hash(::std::string* tx_prefix_hash);

  // optional bytes view_public_key = 8;
  bool has_view_public_key() const;
  void clear_view_public_key();
  static const int kViewPublicKeyFieldNumber = 8;
  const ::std::string& view_public_key() const;
  void set_view_public_key(const ::std::string& value);
  #if LANG_CXX11
  void set_view_public_key(::std::string&& value);
  #endif
  void set_view_public_key(const char* value);
  void set_view_public_key(const void* value, size_t size);
  ::std::string* mutable_view_public_key();
  ::std::string* release_view_public_key();
  void set_allocated_view_public_key(::std::string* view_public_key);

  // optional uint32 network_type = 2;
  bool has_network_type() const;
  void clear_network_type();
  static const int kNetworkTypeFieldNumber = 2;
  ::google::protobuf::uint32 network_type() const;
  void set_network_type(::google::protobuf::uint32 value);

  // optional uint32 reason = 7;
  bool has_reason() const;
  void clear_reason();
  static const int kReasonFieldNumber = 7;
  ::google::protobuf::uint32 reason() const;
  void set_reason(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:hw.trezor.messages.monero.MoneroGetTxKeyRequest)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > address_n_;
  ::google::protobuf::internal::ArenaStringPtr salt1_;
  ::google::protobuf::internal::ArenaStringPtr salt2_;
  ::google::protobuf::internal::ArenaStringPtr tx_enc_keys_;
  ::google::protobuf::internal::ArenaStringPtr tx_prefix_hash_;
  ::google::protobuf::internal::ArenaStringPtr view_public_key_;
  ::google::protobuf::uint32 network_type_;
  ::google::protobuf::uint32 reason_;
  friend struct ::TableStruct_messages_2dmonero_2eproto;
};
// -------------------------------------------------------------------

class MoneroGetTxKeyAck final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:hw.trezor.messages.monero.MoneroGetTxKeyAck) */ {
 public:
  MoneroGetTxKeyAck();
  virtual ~MoneroGetTxKeyAck();

  MoneroGetTxKeyAck(const MoneroGetTxKeyAck& from);

  inline MoneroGetTxKeyAck& operator=(const MoneroGetTxKeyAck& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  MoneroGetTxKeyAck(MoneroGetTxKeyAck&& from) noexcept
    : MoneroGetTxKeyAck() {
    *this = ::std::move(from);
  }

  inline MoneroGetTxKeyAck& operator=(MoneroGetTxKeyAck&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const MoneroGetTxKeyAck& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const MoneroGetTxKeyAck* internal_default_instance() {
    return reinterpret_cast<const MoneroGetTxKeyAck*>(
               &_MoneroGetTxKeyAck_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    41;

  void Swap(MoneroGetTxKeyAck* other);
  friend void swap(MoneroGetTxKeyAck& a, MoneroGetTxKeyAck& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline MoneroGetTxKeyAck* New() const final {
    return CreateMaybeMessage<MoneroGetTxKeyAck>(nullptr);
  }

  MoneroGetTxKeyAck* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<MoneroGetTxKeyAck>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const MoneroGetTxKeyAck& from);
  void MergeFrom(const MoneroGetTxKeyAck& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MoneroGetTxKeyAck* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bytes salt = 1;
  bool has_salt() const;
  void clear_salt();
  static const int kSaltFieldNumber = 1;
  const ::std::string& salt() const;
  void set_salt(const ::std::string& value);
  #if LANG_CXX11
  void set_salt(::std::string&& value);
  #endif
  void set_salt(const char* value);
  void set_salt(const void* value, size_t size);
  ::std::string* mutable_salt();
  ::std::string* release_salt();
  void set_allocated_salt(::std::string* salt);

  // optional bytes tx_keys = 2;
  bool has_tx_keys() const;
  void clear_tx_keys();
  static const int kTxKeysFieldNumber = 2;
  const ::std::string& tx_keys() const;
  void set_tx_keys(const ::std::string& value);
  #if LANG_CXX11
  void set_tx_keys(::std::string&& value);
  #endif
  void set_tx_keys(const char* value);
  void set_tx_keys(const void* value, size_t size);
  ::std::string* mutable_tx_keys();
  ::std::string* release_tx_keys();
  void set_allocated_tx_keys(::std::string* tx_keys);

  // optional bytes tx_derivations = 3;
  bool has_tx_derivations() const;
  void clear_tx_derivations();
  static const int kTxDerivationsFieldNumber = 3;
  const ::std::string& tx_derivations() const;
  void set_tx_derivations(const ::std::string& value);
  #if LANG_CXX11
  void set_tx_derivations(::std::string&& value);
  #endif
  void set_tx_derivations(const char* value);
  void set_tx_derivations(const void* value, size_t size);
  ::std::string* mutable_tx_derivations();
  ::std::string* release_tx_derivations();
  void set_allocated_tx_derivations(::std::string* tx_derivations);

  // @@protoc_insertion_point(class_scope:hw.trezor.messages.monero.MoneroGetTxKeyAck)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr salt_;
  ::google::protobuf::internal::ArenaStringPtr tx_keys_;
  ::google::protobuf::internal::ArenaStringPtr tx_derivations_;
  friend struct ::TableStruct_messages_2dmonero_2eproto;
};
// -------------------------------------------------------------------

class MoneroLiveRefreshStartRequest final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:hw.trezor.messages.monero.MoneroLiveRefreshStartRequest) */ {
 public:
  MoneroLiveRefreshStartRequest();
  virtual ~MoneroLiveRefreshStartRequest();

  MoneroLiveRefreshStartRequest(const MoneroLiveRefreshStartRequest& from);

  inline MoneroLiveRefreshStartRequest& operator=(const MoneroLiveRefreshStartRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  MoneroLiveRefreshStartRequest(MoneroLiveRefreshStartRequest&& from) noexcept
    : MoneroLiveRefreshStartRequest() {
    *this = ::std::move(from);
  }

  inline MoneroLiveRefreshStartRequest& operator=(MoneroLiveRefreshStartRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const MoneroLiveRefreshStartRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const MoneroLiveRefreshStartRequest* internal_default_instance() {
    return reinterpret_cast<const MoneroLiveRefreshStartRequest*>(
               &_MoneroLiveRefreshStartRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    42;

  void Swap(MoneroLiveRefreshStartRequest* other);
  friend void swap(MoneroLiveRefreshStartRequest& a, MoneroLiveRefreshStartRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline MoneroLiveRefreshStartRequest* New() const final {
    return CreateMaybeMessage<MoneroLiveRefreshStartRequest>(nullptr);
  }

  MoneroLiveRefreshStartRequest* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<MoneroLiveRefreshStartRequest>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const MoneroLiveRefreshStartRequest& from);
  void MergeFrom(const MoneroLiveRefreshStartRequest& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MoneroLiveRefreshStartRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated uint32 address_n = 1;
  int address_n_size() const;
  void clear_address_n();
  static const int kAddressNFieldNumber = 1;
  ::google::protobuf::uint32 address_n(int index) const;
  void set_address_n(int index, ::google::protobuf::uint32 value);
  void add_address_n(::google::protobuf::uint32 value);
  const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      address_n() const;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable_address_n();

  // optional uint32 network_type = 2;
  bool has_network_type() const;
  void clear_network_type();
  static const int kNetworkTypeFieldNumber = 2;
  ::google::protobuf::uint32 network_type() const;
  void set_network_type(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:hw.trezor.messages.monero.MoneroLiveRefreshStartRequest)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > address_n_;
  ::google::protobuf::uint32 network_type_;
  friend struct ::TableStruct_messages_2dmonero_2eproto;
};
// -------------------------------------------------------------------

class MoneroLiveRefreshStartAck final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:hw.trezor.messages.monero.MoneroLiveRefreshStartAck) */ {
 public:
  MoneroLiveRefreshStartAck();
  virtual ~MoneroLiveRefreshStartAck();

  MoneroLiveRefreshStartAck(const MoneroLiveRefreshStartAck& from);

  inline MoneroLiveRefreshStartAck& operator=(const MoneroLiveRefreshStartAck& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  MoneroLiveRefreshStartAck(MoneroLiveRefreshStartAck&& from) noexcept
    : MoneroLiveRefreshStartAck() {
    *this = ::std::move(from);
  }

  inline MoneroLiveRefreshStartAck& operator=(MoneroLiveRefreshStartAck&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const MoneroLiveRefreshStartAck& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const MoneroLiveRefreshStartAck* internal_default_instance() {
    return reinterpret_cast<const MoneroLiveRefreshStartAck*>(
               &_MoneroLiveRefreshStartAck_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    43;

  void Swap(MoneroLiveRefreshStartAck* other);
  friend void swap(MoneroLiveRefreshStartAck& a, MoneroLiveRefreshStartAck& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline MoneroLiveRefreshStartAck* New() const final {
    return CreateMaybeMessage<MoneroLiveRefreshStartAck>(nullptr);
  }

  MoneroLiveRefreshStartAck* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<MoneroLiveRefreshStartAck>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const MoneroLiveRefreshStartAck& from);
  void MergeFrom(const MoneroLiveRefreshStartAck& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MoneroLiveRefreshStartAck* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:hw.trezor.messages.monero.MoneroLiveRefreshStartAck)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_messages_2dmonero_2eproto;
};
// -------------------------------------------------------------------

class MoneroLiveRefreshStepRequest final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:hw.trezor.messages.monero.MoneroLiveRefreshStepRequest) */ {
 public:
  MoneroLiveRefreshStepRequest();
  virtual ~MoneroLiveRefreshStepRequest();

  MoneroLiveRefreshStepRequest(const MoneroLiveRefreshStepRequest& from);

  inline MoneroLiveRefreshStepRequest& operator=(const MoneroLiveRefreshStepRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  MoneroLiveRefreshStepRequest(MoneroLiveRefreshStepRequest&& from) noexcept
    : MoneroLiveRefreshStepRequest() {
    *this = ::std::move(from);
  }

  inline MoneroLiveRefreshStepRequest& operator=(MoneroLiveRefreshStepRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const MoneroLiveRefreshStepRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const MoneroLiveRefreshStepRequest* internal_default_instance() {
    return reinterpret_cast<const MoneroLiveRefreshStepRequest*>(
               &_MoneroLiveRefreshStepRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    44;

  void Swap(MoneroLiveRefreshStepRequest* other);
  friend void swap(MoneroLiveRefreshStepRequest& a, MoneroLiveRefreshStepRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline MoneroLiveRefreshStepRequest* New() const final {
    return CreateMaybeMessage<MoneroLiveRefreshStepRequest>(nullptr);
  }

  MoneroLiveRefreshStepRequest* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<MoneroLiveRefreshStepRequest>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const MoneroLiveRefreshStepRequest& from);
  void MergeFrom(const MoneroLiveRefreshStepRequest& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MoneroLiveRefreshStepRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bytes out_key = 1;
  bool has_out_key() const;
  void clear_out_key();
  static const int kOutKeyFieldNumber = 1;
  const ::std::string& out_key() const;
  void set_out_key(const ::std::string& value);
  #if LANG_CXX11
  void set_out_key(::std::string&& value);
  #endif
  void set_out_key(const char* value);
  void set_out_key(const void* value, size_t size);
  ::std::string* mutable_out_key();
  ::std::string* release_out_key();
  void set_allocated_out_key(::std::string* out_key);

  // optional bytes recv_deriv = 2;
  bool has_recv_deriv() const;
  void clear_recv_deriv();
  static const int kRecvDerivFieldNumber = 2;
  const ::std::string& recv_deriv() const;
  void set_recv_deriv(const ::std::string& value);
  #if LANG_CXX11
  void set_recv_deriv(::std::string&& value);
  #endif
  void set_recv_deriv(const char* value);
  void set_recv_deriv(const void* value, size_t size);
  ::std::string* mutable_recv_deriv();
  ::std::string* release_recv_deriv();
  void set_allocated_recv_deriv(::std::string* recv_deriv);

  // optional uint64 real_out_idx = 3;
  bool has_real_out_idx() const;
  void clear_real_out_idx();
  static const int kRealOutIdxFieldNumber = 3;
  ::google::protobuf::uint64 real_out_idx() const;
  void set_real_out_idx(::google::protobuf::uint64 value);

  // optional uint32 sub_addr_major = 4;
  bool has_sub_addr_major() const;
  void clear_sub_addr_major();
  static const int kSubAddrMajorFieldNumber = 4;
  ::google::protobuf::uint32 sub_addr_major() const;
  void set_sub_addr_major(::google::protobuf::uint32 value);

  // optional uint32 sub_addr_minor = 5;
  bool has_sub_addr_minor() const;
  void clear_sub_addr_minor();
  static const int kSubAddrMinorFieldNumber = 5;
  ::google::protobuf::uint32 sub_addr_minor() const;
  void set_sub_addr_minor(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:hw.trezor.messages.monero.MoneroLiveRefreshStepRequest)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr out_key_;
  ::google::protobuf::internal::ArenaStringPtr recv_deriv_;
  ::google::protobuf::uint64 real_out_idx_;
  ::google::protobuf::uint32 sub_addr_major_;
  ::google::protobuf::uint32 sub_addr_minor_;
  friend struct ::TableStruct_messages_2dmonero_2eproto;
};
// -------------------------------------------------------------------

class MoneroLiveRefreshStepAck final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:hw.trezor.messages.monero.MoneroLiveRefreshStepAck) */ {
 public:
  MoneroLiveRefreshStepAck();
  virtual ~MoneroLiveRefreshStepAck();

  MoneroLiveRefreshStepAck(const MoneroLiveRefreshStepAck& from);

  inline MoneroLiveRefreshStepAck& operator=(const MoneroLiveRefreshStepAck& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  MoneroLiveRefreshStepAck(MoneroLiveRefreshStepAck&& from) noexcept
    : MoneroLiveRefreshStepAck() {
    *this = ::std::move(from);
  }

  inline MoneroLiveRefreshStepAck& operator=(MoneroLiveRefreshStepAck&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const MoneroLiveRefreshStepAck& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const MoneroLiveRefreshStepAck* internal_default_instance() {
    return reinterpret_cast<const MoneroLiveRefreshStepAck*>(
               &_MoneroLiveRefreshStepAck_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    45;

  void Swap(MoneroLiveRefreshStepAck* other);
  friend void swap(MoneroLiveRefreshStepAck& a, MoneroLiveRefreshStepAck& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline MoneroLiveRefreshStepAck* New() const final {
    return CreateMaybeMessage<MoneroLiveRefreshStepAck>(nullptr);
  }

  MoneroLiveRefreshStepAck* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<MoneroLiveRefreshStepAck>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const MoneroLiveRefreshStepAck& from);
  void MergeFrom(const MoneroLiveRefreshStepAck& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MoneroLiveRefreshStepAck* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bytes salt = 1;
  bool has_salt() const;
  void clear_salt();
  static const int kSaltFieldNumber = 1;
  const ::std::string& salt() const;
  void set_salt(const ::std::string& value);
  #if LANG_CXX11
  void set_salt(::std::string&& value);
  #endif
  void set_salt(const char* value);
  void set_salt(const void* value, size_t size);
  ::std::string* mutable_salt();
  ::std::string* release_salt();
  void set_allocated_salt(::std::string* salt);

  // optional bytes key_image = 2;
  bool has_key_image() const;
  void clear_key_image();
  static const int kKeyImageFieldNumber = 2;
  const ::std::string& key_image() const;
  void set_key_image(const ::std::string& value);
  #if LANG_CXX11
  void set_key_image(::std::string&& value);
  #endif
  void set_key_image(const char* value);
  void set_key_image(const void* value, size_t size);
  ::std::string* mutable_key_image();
  ::std::string* release_key_image();
  void set_allocated_key_image(::std::string* key_image);

  // @@protoc_insertion_point(class_scope:hw.trezor.messages.monero.MoneroLiveRefreshStepAck)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr salt_;
  ::google::protobuf::internal::ArenaStringPtr key_image_;
  friend struct ::TableStruct_messages_2dmonero_2eproto;
};
// -------------------------------------------------------------------

class MoneroLiveRefreshFinalRequest final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:hw.trezor.messages.monero.MoneroLiveRefreshFinalRequest) */ {
 public:
  MoneroLiveRefreshFinalRequest();
  virtual ~MoneroLiveRefreshFinalRequest();

  MoneroLiveRefreshFinalRequest(const MoneroLiveRefreshFinalRequest& from);

  inline MoneroLiveRefreshFinalRequest& operator=(const MoneroLiveRefreshFinalRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  MoneroLiveRefreshFinalRequest(MoneroLiveRefreshFinalRequest&& from) noexcept
    : MoneroLiveRefreshFinalRequest() {
    *this = ::std::move(from);
  }

  inline MoneroLiveRefreshFinalRequest& operator=(MoneroLiveRefreshFinalRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const MoneroLiveRefreshFinalRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const MoneroLiveRefreshFinalRequest* internal_default_instance() {
    return reinterpret_cast<const MoneroLiveRefreshFinalRequest*>(
               &_MoneroLiveRefreshFinalRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    46;

  void Swap(MoneroLiveRefreshFinalRequest* other);
  friend void swap(MoneroLiveRefreshFinalRequest& a, MoneroLiveRefreshFinalRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline MoneroLiveRefreshFinalRequest* New() const final {
    return CreateMaybeMessage<MoneroLiveRefreshFinalRequest>(nullptr);
  }

  MoneroLiveRefreshFinalRequest* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<MoneroLiveRefreshFinalRequest>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const MoneroLiveRefreshFinalRequest& from);
  void MergeFrom(const MoneroLiveRefreshFinalRequest& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MoneroLiveRefreshFinalRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:hw.trezor.messages.monero.MoneroLiveRefreshFinalRequest)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_messages_2dmonero_2eproto;
};
// -------------------------------------------------------------------

class MoneroLiveRefreshFinalAck final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:hw.trezor.messages.monero.MoneroLiveRefreshFinalAck) */ {
 public:
  MoneroLiveRefreshFinalAck();
  virtual ~MoneroLiveRefreshFinalAck();

  MoneroLiveRefreshFinalAck(const MoneroLiveRefreshFinalAck& from);

  inline MoneroLiveRefreshFinalAck& operator=(const MoneroLiveRefreshFinalAck& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  MoneroLiveRefreshFinalAck(MoneroLiveRefreshFinalAck&& from) noexcept
    : MoneroLiveRefreshFinalAck() {
    *this = ::std::move(from);
  }

  inline MoneroLiveRefreshFinalAck& operator=(MoneroLiveRefreshFinalAck&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const MoneroLiveRefreshFinalAck& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const MoneroLiveRefreshFinalAck* internal_default_instance() {
    return reinterpret_cast<const MoneroLiveRefreshFinalAck*>(
               &_MoneroLiveRefreshFinalAck_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    47;

  void Swap(MoneroLiveRefreshFinalAck* other);
  friend void swap(MoneroLiveRefreshFinalAck& a, MoneroLiveRefreshFinalAck& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline MoneroLiveRefreshFinalAck* New() const final {
    return CreateMaybeMessage<MoneroLiveRefreshFinalAck>(nullptr);
  }

  MoneroLiveRefreshFinalAck* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<MoneroLiveRefreshFinalAck>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const MoneroLiveRefreshFinalAck& from);
  void MergeFrom(const MoneroLiveRefreshFinalAck& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MoneroLiveRefreshFinalAck* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:hw.trezor.messages.monero.MoneroLiveRefreshFinalAck)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_messages_2dmonero_2eproto;
};
// -------------------------------------------------------------------

class DebugMoneroDiagRequest final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:hw.trezor.messages.monero.DebugMoneroDiagRequest) */ {
 public:
  DebugMoneroDiagRequest();
  virtual ~DebugMoneroDiagRequest();

  DebugMoneroDiagRequest(const DebugMoneroDiagRequest& from);

  inline DebugMoneroDiagRequest& operator=(const DebugMoneroDiagRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  DebugMoneroDiagRequest(DebugMoneroDiagRequest&& from) noexcept
    : DebugMoneroDiagRequest() {
    *this = ::std::move(from);
  }

  inline DebugMoneroDiagRequest& operator=(DebugMoneroDiagRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const DebugMoneroDiagRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const DebugMoneroDiagRequest* internal_default_instance() {
    return reinterpret_cast<const DebugMoneroDiagRequest*>(
               &_DebugMoneroDiagRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    48;

  void Swap(DebugMoneroDiagRequest* other);
  friend void swap(DebugMoneroDiagRequest& a, DebugMoneroDiagRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline DebugMoneroDiagRequest* New() const final {
    return CreateMaybeMessage<DebugMoneroDiagRequest>(nullptr);
  }

  DebugMoneroDiagRequest* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<DebugMoneroDiagRequest>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const DebugMoneroDiagRequest& from);
  void MergeFrom(const DebugMoneroDiagRequest& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DebugMoneroDiagRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated uint64 pd = 4;
  int pd_size() const;
  void clear_pd();
  static const int kPdFieldNumber = 4;
  ::google::protobuf::uint64 pd(int index) const;
  void set_pd(int index, ::google::protobuf::uint64 value);
  void add_pd(::google::protobuf::uint64 value);
  const ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >&
      pd() const;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >*
      mutable_pd();

  // optional bytes data1 = 5;
  bool has_data1() const;
  void clear_data1();
  static const int kData1FieldNumber = 5;
  const ::std::string& data1() const;
  void set_data1(const ::std::string& value);
  #if LANG_CXX11
  void set_data1(::std::string&& value);
  #endif
  void set_data1(const char* value);
  void set_data1(const void* value, size_t size);
  ::std::string* mutable_data1();
  ::std::string* release_data1();
  void set_allocated_data1(::std::string* data1);

  // optional bytes data2 = 6;
  bool has_data2() const;
  void clear_data2();
  static const int kData2FieldNumber = 6;
  const ::std::string& data2() const;
  void set_data2(const ::std::string& value);
  #if LANG_CXX11
  void set_data2(::std::string&& value);
  #endif
  void set_data2(const char* value);
  void set_data2(const void* value, size_t size);
  ::std::string* mutable_data2();
  ::std::string* release_data2();
  void set_allocated_data2(::std::string* data2);

  // optional uint64 ins = 1;
  bool has_ins() const;
  void clear_ins();
  static const int kInsFieldNumber = 1;
  ::google::protobuf::uint64 ins() const;
  void set_ins(::google::protobuf::uint64 value);

  // optional uint64 p1 = 2;
  bool has_p1() const;
  void clear_p1();
  static const int kP1FieldNumber = 2;
  ::google::protobuf::uint64 p1() const;
  void set_p1(::google::protobuf::uint64 value);

  // optional uint64 p2 = 3;
  bool has_p2() const;
  void clear_p2();
  static const int kP2FieldNumber = 3;
  ::google::protobuf::uint64 p2() const;
  void set_p2(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:hw.trezor.messages.monero.DebugMoneroDiagRequest)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint64 > pd_;
  ::google::protobuf::internal::ArenaStringPtr data1_;
  ::google::protobuf::internal::ArenaStringPtr data2_;
  ::google::protobuf::uint64 ins_;
  ::google::protobuf::uint64 p1_;
  ::google::protobuf::uint64 p2_;
  friend struct ::TableStruct_messages_2dmonero_2eproto;
};
// -------------------------------------------------------------------

class DebugMoneroDiagAck final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:hw.trezor.messages.monero.DebugMoneroDiagAck) */ {
 public:
  DebugMoneroDiagAck();
  virtual ~DebugMoneroDiagAck();

  DebugMoneroDiagAck(const DebugMoneroDiagAck& from);

  inline DebugMoneroDiagAck& operator=(const DebugMoneroDiagAck& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  DebugMoneroDiagAck(DebugMoneroDiagAck&& from) noexcept
    : DebugMoneroDiagAck() {
    *this = ::std::move(from);
  }

  inline DebugMoneroDiagAck& operator=(DebugMoneroDiagAck&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const DebugMoneroDiagAck& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const DebugMoneroDiagAck* internal_default_instance() {
    return reinterpret_cast<const DebugMoneroDiagAck*>(
               &_DebugMoneroDiagAck_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    49;

  void Swap(DebugMoneroDiagAck* other);
  friend void swap(DebugMoneroDiagAck& a, DebugMoneroDiagAck& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline DebugMoneroDiagAck* New() const final {
    return CreateMaybeMessage<DebugMoneroDiagAck>(nullptr);
  }

  DebugMoneroDiagAck* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<DebugMoneroDiagAck>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const DebugMoneroDiagAck& from);
  void MergeFrom(const DebugMoneroDiagAck& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DebugMoneroDiagAck* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated uint64 pd = 4;
  int pd_size() const;
  void clear_pd();
  static const int kPdFieldNumber = 4;
  ::google::protobuf::uint64 pd(int index) const;
  void set_pd(int index, ::google::protobuf::uint64 value);
  void add_pd(::google::protobuf::uint64 value);
  const ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >&
      pd() const;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >*
      mutable_pd();

  // optional bytes data1 = 5;
  bool has_data1() const;
  void clear_data1();
  static const int kData1FieldNumber = 5;
  const ::std::string& data1() const;
  void set_data1(const ::std::string& value);
  #if LANG_CXX11
  void set_data1(::std::string&& value);
  #endif
  void set_data1(const char* value);
  void set_data1(const void* value, size_t size);
  ::std::string* mutable_data1();
  ::std::string* release_data1();
  void set_allocated_data1(::std::string* data1);

  // optional bytes data2 = 6;
  bool has_data2() const;
  void clear_data2();
  static const int kData2FieldNumber = 6;
  const ::std::string& data2() const;
  void set_data2(const ::std::string& value);
  #if LANG_CXX11
  void set_data2(::std::string&& value);
  #endif
  void set_data2(const char* value);
  void set_data2(const void* value, size_t size);
  ::std::string* mutable_data2();
  ::std::string* release_data2();
  void set_allocated_data2(::std::string* data2);

  // optional uint64 ins = 1;
  bool has_ins() const;
  void clear_ins();
  static const int kInsFieldNumber = 1;
  ::google::protobuf::uint64 ins() const;
  void set_ins(::google::protobuf::uint64 value);

  // optional uint64 p1 = 2;
  bool has_p1() const;
  void clear_p1();
  static const int kP1FieldNumber = 2;
  ::google::protobuf::uint64 p1() const;
  void set_p1(::google::protobuf::uint64 value);

  // optional uint64 p2 = 3;
  bool has_p2() const;
  void clear_p2();
  static const int kP2FieldNumber = 3;
  ::google::protobuf::uint64 p2() const;
  void set_p2(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:hw.trezor.messages.monero.DebugMoneroDiagAck)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint64 > pd_;
  ::google::protobuf::internal::ArenaStringPtr data1_;
  ::google::protobuf::internal::ArenaStringPtr data2_;
  ::google::protobuf::uint64 ins_;
  ::google::protobuf::uint64 p1_;
  ::google::protobuf::uint64 p2_;
  friend struct ::TableStruct_messages_2dmonero_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// MoneroTransactionSourceEntry_MoneroOutputEntry_MoneroRctKeyPublic

// optional bytes dest = 1;
inline bool MoneroTransactionSourceEntry_MoneroOutputEntry_MoneroRctKeyPublic::has_dest() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MoneroTransactionSourceEntry_MoneroOutputEntry_MoneroRctKeyPublic::clear_dest() {
  dest_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::std::string& MoneroTransactionSourceEntry_MoneroOutputEntry_MoneroRctKeyPublic::dest() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.monero.MoneroTransactionSourceEntry.MoneroOutputEntry.MoneroRctKeyPublic.dest)
  return dest_.GetNoArena();
}
inline void MoneroTransactionSourceEntry_MoneroOutputEntry_MoneroRctKeyPublic::set_dest(const ::std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  dest_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:hw.trezor.messages.monero.MoneroTransactionSourceEntry.MoneroOutputEntry.MoneroRctKeyPublic.dest)
}
#if LANG_CXX11
inline void MoneroTransactionSourceEntry_MoneroOutputEntry_MoneroRctKeyPublic::set_dest(::std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  dest_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:hw.trezor.messages.monero.MoneroTransactionSourceEntry.MoneroOutputEntry.MoneroRctKeyPublic.dest)
}
#endif
inline void MoneroTransactionSourceEntry_MoneroOutputEntry_MoneroRctKeyPublic::set_dest(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  dest_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:hw.trezor.messages.monero.MoneroTransactionSourceEntry.MoneroOutputEntry.MoneroRctKeyPublic.dest)
}
inline void MoneroTransactionSourceEntry_MoneroOutputEntry_MoneroRctKeyPublic::set_dest(const void* value, size_t size) {
  _has_bits_[0] |= 0x00000001u;
  dest_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:hw.trezor.messages.monero.MoneroTransactionSourceEntry.MoneroOutputEntry.MoneroRctKeyPublic.dest)
}
inline ::std::string* MoneroTransactionSourceEntry_MoneroOutputEntry_MoneroRctKeyPublic::mutable_dest() {
  _has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_mutable:hw.trezor.messages.monero.MoneroTransactionSourceEntry.MoneroOutputEntry.MoneroRctKeyPublic.dest)
  return dest_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* MoneroTransactionSourceEntry_MoneroOutputEntry_MoneroRctKeyPublic::release_dest() {
  // @@protoc_insertion_point(field_release:hw.trezor.messages.monero.MoneroTransactionSourceEntry.MoneroOutputEntry.MoneroRctKeyPublic.dest)
  if (!has_dest()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return dest_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void MoneroTransactionSourceEntry_MoneroOutputEntry_MoneroRctKeyPublic::set_allocated_dest(::std::string* dest) {
  if (dest != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  dest_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), dest);
  // @@protoc_insertion_point(field_set_allocated:hw.trezor.messages.monero.MoneroTransactionSourceEntry.MoneroOutputEntry.MoneroRctKeyPublic.dest)
}

// optional bytes commitment = 2;
inline bool MoneroTransactionSourceEntry_MoneroOutputEntry_MoneroRctKeyPublic::has_commitment() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void MoneroTransactionSourceEntry_MoneroOutputEntry_MoneroRctKeyPublic::clear_commitment() {
  commitment_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000002u;
}
inline const ::std::string& MoneroTransactionSourceEntry_MoneroOutputEntry_MoneroRctKeyPublic::commitment() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.monero.MoneroTransactionSourceEntry.MoneroOutputEntry.MoneroRctKeyPublic.commitment)
  return commitment_.GetNoArena();
}
inline void MoneroTransactionSourceEntry_MoneroOutputEntry_MoneroRctKeyPublic::set_commitment(const ::std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  commitment_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:hw.trezor.messages.monero.MoneroTransactionSourceEntry.MoneroOutputEntry.MoneroRctKeyPublic.commitment)
}
#if LANG_CXX11
inline void MoneroTransactionSourceEntry_MoneroOutputEntry_MoneroRctKeyPublic::set_commitment(::std::string&& value) {
  _has_bits_[0] |= 0x00000002u;
  commitment_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:hw.trezor.messages.monero.MoneroTransactionSourceEntry.MoneroOutputEntry.MoneroRctKeyPublic.commitment)
}
#endif
inline void MoneroTransactionSourceEntry_MoneroOutputEntry_MoneroRctKeyPublic::set_commitment(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000002u;
  commitment_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:hw.trezor.messages.monero.MoneroTransactionSourceEntry.MoneroOutputEntry.MoneroRctKeyPublic.commitment)
}
inline void MoneroTransactionSourceEntry_MoneroOutputEntry_MoneroRctKeyPublic::set_commitment(const void* value, size_t size) {
  _has_bits_[0] |= 0x00000002u;
  commitment_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:hw.trezor.messages.monero.MoneroTransactionSourceEntry.MoneroOutputEntry.MoneroRctKeyPublic.commitment)
}
inline ::std::string* MoneroTransactionSourceEntry_MoneroOutputEntry_MoneroRctKeyPublic::mutable_commitment() {
  _has_bits_[0] |= 0x00000002u;
  // @@protoc_insertion_point(field_mutable:hw.trezor.messages.monero.MoneroTransactionSourceEntry.MoneroOutputEntry.MoneroRctKeyPublic.commitment)
  return commitment_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* MoneroTransactionSourceEntry_MoneroOutputEntry_MoneroRctKeyPublic::release_commitment() {
  // @@protoc_insertion_point(field_release:hw.trezor.messages.monero.MoneroTransactionSourceEntry.MoneroOutputEntry.MoneroRctKeyPublic.commitment)
  if (!has_commitment()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  return commitment_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void MoneroTransactionSourceEntry_MoneroOutputEntry_MoneroRctKeyPublic::set_allocated_commitment(::std::string* commitment) {
  if (commitment != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  commitment_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), commitment);
  // @@protoc_insertion_point(field_set_allocated:hw.trezor.messages.monero.MoneroTransactionSourceEntry.MoneroOutputEntry.MoneroRctKeyPublic.commitment)
}

// -------------------------------------------------------------------

// MoneroTransactionSourceEntry_MoneroOutputEntry

// optional uint64 idx = 1;
inline bool MoneroTransactionSourceEntry_MoneroOutputEntry::has_idx() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void MoneroTransactionSourceEntry_MoneroOutputEntry::clear_idx() {
  idx_ = PROTOBUF_ULONGLONG(0);
  _has_bits_[0] &= ~0x00000002u;
}
inline ::google::protobuf::uint64 MoneroTransactionSourceEntry_MoneroOutputEntry::idx() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.monero.MoneroTransactionSourceEntry.MoneroOutputEntry.idx)
  return idx_;
}
inline void MoneroTransactionSourceEntry_MoneroOutputEntry::set_idx(::google::protobuf::uint64 value) {
  _has_bits_[0] |= 0x00000002u;
  idx_ = value;
  // @@protoc_insertion_point(field_set:hw.trezor.messages.monero.MoneroTransactionSourceEntry.MoneroOutputEntry.idx)
}

// optional .hw.trezor.messages.monero.MoneroTransactionSourceEntry.MoneroOutputEntry.MoneroRctKeyPublic key = 2;
inline bool MoneroTransactionSourceEntry_MoneroOutputEntry::has_key() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MoneroTransactionSourceEntry_MoneroOutputEntry::clear_key() {
  if (key_ != nullptr) key_->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::hw::trezor::messages::monero::MoneroTransactionSourceEntry_MoneroOutputEntry_MoneroRctKeyPublic& MoneroTransactionSourceEntry_MoneroOutputEntry::key() const {
  const ::hw::trezor::messages::monero::MoneroTransactionSourceEntry_MoneroOutputEntry_MoneroRctKeyPublic* p = key_;
  // @@protoc_insertion_point(field_get:hw.trezor.messages.monero.MoneroTransactionSourceEntry.MoneroOutputEntry.key)
  return p != nullptr ? *p : *reinterpret_cast<const ::hw::trezor::messages::monero::MoneroTransactionSourceEntry_MoneroOutputEntry_MoneroRctKeyPublic*>(
      &::hw::trezor::messages::monero::_MoneroTransactionSourceEntry_MoneroOutputEntry_MoneroRctKeyPublic_default_instance_);
}
inline ::hw::trezor::messages::monero::MoneroTransactionSourceEntry_MoneroOutputEntry_MoneroRctKeyPublic* MoneroTransactionSourceEntry_MoneroOutputEntry::release_key() {
  // @@protoc_insertion_point(field_release:hw.trezor.messages.monero.MoneroTransactionSourceEntry.MoneroOutputEntry.key)
  _has_bits_[0] &= ~0x00000001u;
  ::hw::trezor::messages::monero::MoneroTransactionSourceEntry_MoneroOutputEntry_MoneroRctKeyPublic* temp = key_;
  key_ = nullptr;
  return temp;
}
inline ::hw::trezor::messages::monero::MoneroTransactionSourceEntry_MoneroOutputEntry_MoneroRctKeyPublic* MoneroTransactionSourceEntry_MoneroOutputEntry::mutable_key() {
  _has_bits_[0] |= 0x00000001u;
  if (key_ == nullptr) {
    auto* p = CreateMaybeMessage<::hw::trezor::messages::monero::MoneroTransactionSourceEntry_MoneroOutputEntry_MoneroRctKeyPublic>(GetArenaNoVirtual());
    key_ = p;
  }
  // @@protoc_insertion_point(field_mutable:hw.trezor.messages.monero.MoneroTransactionSourceEntry.MoneroOutputEntry.key)
  return key_;
}
inline void MoneroTransactionSourceEntry_MoneroOutputEntry::set_allocated_key(::hw::trezor::messages::monero::MoneroTransactionSourceEntry_MoneroOutputEntry_MoneroRctKeyPublic* key) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete key_;
  }
  if (key) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      key = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, key, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  key_ = key;
  // @@protoc_insertion_point(field_set_allocated:hw.trezor.messages.monero.MoneroTransactionSourceEntry.MoneroOutputEntry.key)
}

// -------------------------------------------------------------------

// MoneroTransactionSourceEntry_MoneroMultisigKLRki

// optional bytes K = 1;
inline bool MoneroTransactionSourceEntry_MoneroMultisigKLRki::has_k() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MoneroTransactionSourceEntry_MoneroMultisigKLRki::clear_k() {
  k_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::std::string& MoneroTransactionSourceEntry_MoneroMultisigKLRki::k() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.monero.MoneroTransactionSourceEntry.MoneroMultisigKLRki.K)
  return k_.GetNoArena();
}
inline void MoneroTransactionSourceEntry_MoneroMultisigKLRki::set_k(const ::std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  k_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:hw.trezor.messages.monero.MoneroTransactionSourceEntry.MoneroMultisigKLRki.K)
}
#if LANG_CXX11
inline void MoneroTransactionSourceEntry_MoneroMultisigKLRki::set_k(::std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  k_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:hw.trezor.messages.monero.MoneroTransactionSourceEntry.MoneroMultisigKLRki.K)
}
#endif
inline void MoneroTransactionSourceEntry_MoneroMultisigKLRki::set_k(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  k_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:hw.trezor.messages.monero.MoneroTransactionSourceEntry.MoneroMultisigKLRki.K)
}
inline void MoneroTransactionSourceEntry_MoneroMultisigKLRki::set_k(const void* value, size_t size) {
  _has_bits_[0] |= 0x00000001u;
  k_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:hw.trezor.messages.monero.MoneroTransactionSourceEntry.MoneroMultisigKLRki.K)
}
inline ::std::string* MoneroTransactionSourceEntry_MoneroMultisigKLRki::mutable_k() {
  _has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_mutable:hw.trezor.messages.monero.MoneroTransactionSourceEntry.MoneroMultisigKLRki.K)
  return k_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* MoneroTransactionSourceEntry_MoneroMultisigKLRki::release_k() {
  // @@protoc_insertion_point(field_release:hw.trezor.messages.monero.MoneroTransactionSourceEntry.MoneroMultisigKLRki.K)
  if (!has_k()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return k_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void MoneroTransactionSourceEntry_MoneroMultisigKLRki::set_allocated_k(::std::string* k) {
  if (k != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  k_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), k);
  // @@protoc_insertion_point(field_set_allocated:hw.trezor.messages.monero.MoneroTransactionSourceEntry.MoneroMultisigKLRki.K)
}

// optional bytes L = 2;
inline bool MoneroTransactionSourceEntry_MoneroMultisigKLRki::has_l() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void MoneroTransactionSourceEntry_MoneroMultisigKLRki::clear_l() {
  l_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000002u;
}
inline const ::std::string& MoneroTransactionSourceEntry_MoneroMultisigKLRki::l() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.monero.MoneroTransactionSourceEntry.MoneroMultisigKLRki.L)
  return l_.GetNoArena();
}
inline void MoneroTransactionSourceEntry_MoneroMultisigKLRki::set_l(const ::std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  l_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:hw.trezor.messages.monero.MoneroTransactionSourceEntry.MoneroMultisigKLRki.L)
}
#if LANG_CXX11
inline void MoneroTransactionSourceEntry_MoneroMultisigKLRki::set_l(::std::string&& value) {
  _has_bits_[0] |= 0x00000002u;
  l_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:hw.trezor.messages.monero.MoneroTransactionSourceEntry.MoneroMultisigKLRki.L)
}
#endif
inline void MoneroTransactionSourceEntry_MoneroMultisigKLRki::set_l(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000002u;
  l_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:hw.trezor.messages.monero.MoneroTransactionSourceEntry.MoneroMultisigKLRki.L)
}
inline void MoneroTransactionSourceEntry_MoneroMultisigKLRki::set_l(const void* value, size_t size) {
  _has_bits_[0] |= 0x00000002u;
  l_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:hw.trezor.messages.monero.MoneroTransactionSourceEntry.MoneroMultisigKLRki.L)
}
inline ::std::string* MoneroTransactionSourceEntry_MoneroMultisigKLRki::mutable_l() {
  _has_bits_[0] |= 0x00000002u;
  // @@protoc_insertion_point(field_mutable:hw.trezor.messages.monero.MoneroTransactionSourceEntry.MoneroMultisigKLRki.L)
  return l_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* MoneroTransactionSourceEntry_MoneroMultisigKLRki::release_l() {
  // @@protoc_insertion_point(field_release:hw.trezor.messages.monero.MoneroTransactionSourceEntry.MoneroMultisigKLRki.L)
  if (!has_l()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  return l_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void MoneroTransactionSourceEntry_MoneroMultisigKLRki::set_allocated_l(::std::string* l) {
  if (l != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  l_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), l);
  // @@protoc_insertion_point(field_set_allocated:hw.trezor.messages.monero.MoneroTransactionSourceEntry.MoneroMultisigKLRki.L)
}

// optional bytes R = 3;
inline bool MoneroTransactionSourceEntry_MoneroMultisigKLRki::has_r() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void MoneroTransactionSourceEntry_MoneroMultisigKLRki::clear_r() {
  r_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000004u;
}
inline const ::std::string& MoneroTransactionSourceEntry_MoneroMultisigKLRki::r() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.monero.MoneroTransactionSourceEntry.MoneroMultisigKLRki.R)
  return r_.GetNoArena();
}
inline void MoneroTransactionSourceEntry_MoneroMultisigKLRki::set_r(const ::std::string& value) {
  _has_bits_[0] |= 0x00000004u;
  r_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:hw.trezor.messages.monero.MoneroTransactionSourceEntry.MoneroMultisigKLRki.R)
}
#if LANG_CXX11
inline void MoneroTransactionSourceEntry_MoneroMultisigKLRki::set_r(::std::string&& value) {
  _has_bits_[0] |= 0x00000004u;
  r_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:hw.trezor.messages.monero.MoneroTransactionSourceEntry.MoneroMultisigKLRki.R)
}
#endif
inline void MoneroTransactionSourceEntry_MoneroMultisigKLRki::set_r(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000004u;
  r_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:hw.trezor.messages.monero.MoneroTransactionSourceEntry.MoneroMultisigKLRki.R)
}
inline void MoneroTransactionSourceEntry_MoneroMultisigKLRki::set_r(const void* value, size_t size) {
  _has_bits_[0] |= 0x00000004u;
  r_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:hw.trezor.messages.monero.MoneroTransactionSourceEntry.MoneroMultisigKLRki.R)
}
inline ::std::string* MoneroTransactionSourceEntry_MoneroMultisigKLRki::mutable_r() {
  _has_bits_[0] |= 0x00000004u;
  // @@protoc_insertion_point(field_mutable:hw.trezor.messages.monero.MoneroTransactionSourceEntry.MoneroMultisigKLRki.R)
  return r_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* MoneroTransactionSourceEntry_MoneroMultisigKLRki::release_r() {
  // @@protoc_insertion_point(field_release:hw.trezor.messages.monero.MoneroTransactionSourceEntry.MoneroMultisigKLRki.R)
  if (!has_r()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000004u;
  return r_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void MoneroTransactionSourceEntry_MoneroMultisigKLRki::set_allocated_r(::std::string* r) {
  if (r != nullptr) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  r_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), r);
  // @@protoc_insertion_point(field_set_allocated:hw.trezor.messages.monero.MoneroTransactionSourceEntry.MoneroMultisigKLRki.R)
}

// optional bytes ki = 4;
inline bool MoneroTransactionSourceEntry_MoneroMultisigKLRki::has_ki() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void MoneroTransactionSourceEntry_MoneroMultisigKLRki::clear_ki() {
  ki_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000008u;
}
inline const ::std::string& MoneroTransactionSourceEntry_MoneroMultisigKLRki::ki() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.monero.MoneroTransactionSourceEntry.MoneroMultisigKLRki.ki)
  return ki_.GetNoArena();
}
inline void MoneroTransactionSourceEntry_MoneroMultisigKLRki::set_ki(const ::std::string& value) {
  _has_bits_[0] |= 0x00000008u;
  ki_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:hw.trezor.messages.monero.MoneroTransactionSourceEntry.MoneroMultisigKLRki.ki)
}
#if LANG_CXX11
inline void MoneroTransactionSourceEntry_MoneroMultisigKLRki::set_ki(::std::string&& value) {
  _has_bits_[0] |= 0x00000008u;
  ki_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:hw.trezor.messages.monero.MoneroTransactionSourceEntry.MoneroMultisigKLRki.ki)
}
#endif
inline void MoneroTransactionSourceEntry_MoneroMultisigKLRki::set_ki(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000008u;
  ki_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:hw.trezor.messages.monero.MoneroTransactionSourceEntry.MoneroMultisigKLRki.ki)
}
inline void MoneroTransactionSourceEntry_MoneroMultisigKLRki::set_ki(const void* value, size_t size) {
  _has_bits_[0] |= 0x00000008u;
  ki_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:hw.trezor.messages.monero.MoneroTransactionSourceEntry.MoneroMultisigKLRki.ki)
}
inline ::std::string* MoneroTransactionSourceEntry_MoneroMultisigKLRki::mutable_ki() {
  _has_bits_[0] |= 0x00000008u;
  // @@protoc_insertion_point(field_mutable:hw.trezor.messages.monero.MoneroTransactionSourceEntry.MoneroMultisigKLRki.ki)
  return ki_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* MoneroTransactionSourceEntry_MoneroMultisigKLRki::release_ki() {
  // @@protoc_insertion_point(field_release:hw.trezor.messages.monero.MoneroTransactionSourceEntry.MoneroMultisigKLRki.ki)
  if (!has_ki()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000008u;
  return ki_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void MoneroTransactionSourceEntry_MoneroMultisigKLRki::set_allocated_ki(::std::string* ki) {
  if (ki != nullptr) {
    _has_bits_[0] |= 0x00000008u;
  } else {
    _has_bits_[0] &= ~0x00000008u;
  }
  ki_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ki);
  // @@protoc_insertion_point(field_set_allocated:hw.trezor.messages.monero.MoneroTransactionSourceEntry.MoneroMultisigKLRki.ki)
}

// -------------------------------------------------------------------

// MoneroTransactionSourceEntry

// repeated .hw.trezor.messages.monero.MoneroTransactionSourceEntry.MoneroOutputEntry outputs = 1;
inline int MoneroTransactionSourceEntry::outputs_size() const {
  return outputs_.size();
}
inline void MoneroTransactionSourceEntry::clear_outputs() {
  outputs_.Clear();
}
inline ::hw::trezor::messages::monero::MoneroTransactionSourceEntry_MoneroOutputEntry* MoneroTransactionSourceEntry::mutable_outputs(int index) {
  // @@protoc_insertion_point(field_mutable:hw.trezor.messages.monero.MoneroTransactionSourceEntry.outputs)
  return outputs_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::hw::trezor::messages::monero::MoneroTransactionSourceEntry_MoneroOutputEntry >*
MoneroTransactionSourceEntry::mutable_outputs() {
  // @@protoc_insertion_point(field_mutable_list:hw.trezor.messages.monero.MoneroTransactionSourceEntry.outputs)
  return &outputs_;
}
inline const ::hw::trezor::messages::monero::MoneroTransactionSourceEntry_MoneroOutputEntry& MoneroTransactionSourceEntry::outputs(int index) const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.monero.MoneroTransactionSourceEntry.outputs)
  return outputs_.Get(index);
}
inline ::hw::trezor::messages::monero::MoneroTransactionSourceEntry_MoneroOutputEntry* MoneroTransactionSourceEntry::add_outputs() {
  // @@protoc_insertion_point(field_add:hw.trezor.messages.monero.MoneroTransactionSourceEntry.outputs)
  return outputs_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::hw::trezor::messages::monero::MoneroTransactionSourceEntry_MoneroOutputEntry >&
MoneroTransactionSourceEntry::outputs() const {
  // @@protoc_insertion_point(field_list:hw.trezor.messages.monero.MoneroTransactionSourceEntry.outputs)
  return outputs_;
}

// optional uint64 real_output = 2;
inline bool MoneroTransactionSourceEntry::has_real_output() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void MoneroTransactionSourceEntry::clear_real_output() {
  real_output_ = PROTOBUF_ULONGLONG(0);
  _has_bits_[0] &= ~0x00000008u;
}
inline ::google::protobuf::uint64 MoneroTransactionSourceEntry::real_output() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.monero.MoneroTransactionSourceEntry.real_output)
  return real_output_;
}
inline void MoneroTransactionSourceEntry::set_real_output(::google::protobuf::uint64 value) {
  _has_bits_[0] |= 0x00000008u;
  real_output_ = value;
  // @@protoc_insertion_point(field_set:hw.trezor.messages.monero.MoneroTransactionSourceEntry.real_output)
}

// optional bytes real_out_tx_key = 3;
inline bool MoneroTransactionSourceEntry::has_real_out_tx_key() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MoneroTransactionSourceEntry::clear_real_out_tx_key() {
  real_out_tx_key_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::std::string& MoneroTransactionSourceEntry::real_out_tx_key() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.monero.MoneroTransactionSourceEntry.real_out_tx_key)
  return real_out_tx_key_.GetNoArena();
}
inline void MoneroTransactionSourceEntry::set_real_out_tx_key(const ::std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  real_out_tx_key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:hw.trezor.messages.monero.MoneroTransactionSourceEntry.real_out_tx_key)
}
#if LANG_CXX11
inline void MoneroTransactionSourceEntry::set_real_out_tx_key(::std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  real_out_tx_key_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:hw.trezor.messages.monero.MoneroTransactionSourceEntry.real_out_tx_key)
}
#endif
inline void MoneroTransactionSourceEntry::set_real_out_tx_key(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  real_out_tx_key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:hw.trezor.messages.monero.MoneroTransactionSourceEntry.real_out_tx_key)
}
inline void MoneroTransactionSourceEntry::set_real_out_tx_key(const void* value, size_t size) {
  _has_bits_[0] |= 0x00000001u;
  real_out_tx_key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:hw.trezor.messages.monero.MoneroTransactionSourceEntry.real_out_tx_key)
}
inline ::std::string* MoneroTransactionSourceEntry::mutable_real_out_tx_key() {
  _has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_mutable:hw.trezor.messages.monero.MoneroTransactionSourceEntry.real_out_tx_key)
  return real_out_tx_key_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* MoneroTransactionSourceEntry::release_real_out_tx_key() {
  // @@protoc_insertion_point(field_release:hw.trezor.messages.monero.MoneroTransactionSourceEntry.real_out_tx_key)
  if (!has_real_out_tx_key()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return real_out_tx_key_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void MoneroTransactionSourceEntry::set_allocated_real_out_tx_key(::std::string* real_out_tx_key) {
  if (real_out_tx_key != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  real_out_tx_key_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), real_out_tx_key);
  // @@protoc_insertion_point(field_set_allocated:hw.trezor.messages.monero.MoneroTransactionSourceEntry.real_out_tx_key)
}

// repeated bytes real_out_additional_tx_keys = 4;
inline int MoneroTransactionSourceEntry::real_out_additional_tx_keys_size() const {
  return real_out_additional_tx_keys_.size();
}
inline void MoneroTransactionSourceEntry::clear_real_out_additional_tx_keys() {
  real_out_additional_tx_keys_.Clear();
}
inline const ::std::string& MoneroTransactionSourceEntry::real_out_additional_tx_keys(int index) const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.monero.MoneroTransactionSourceEntry.real_out_additional_tx_keys)
  return real_out_additional_tx_keys_.Get(index);
}
inline ::std::string* MoneroTransactionSourceEntry::mutable_real_out_additional_tx_keys(int index) {
  // @@protoc_insertion_point(field_mutable:hw.trezor.messages.monero.MoneroTransactionSourceEntry.real_out_additional_tx_keys)
  return real_out_additional_tx_keys_.Mutable(index);
}
inline void MoneroTransactionSourceEntry::set_real_out_additional_tx_keys(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:hw.trezor.messages.monero.MoneroTransactionSourceEntry.real_out_additional_tx_keys)
  real_out_additional_tx_keys_.Mutable(index)->assign(value);
}
#if LANG_CXX11
inline void MoneroTransactionSourceEntry::set_real_out_additional_tx_keys(int index, ::std::string&& value) {
  // @@protoc_insertion_point(field_set:hw.trezor.messages.monero.MoneroTransactionSourceEntry.real_out_additional_tx_keys)
  real_out_additional_tx_keys_.Mutable(index)->assign(std::move(value));
}
#endif
inline void MoneroTransactionSourceEntry::set_real_out_additional_tx_keys(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  real_out_additional_tx_keys_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:hw.trezor.messages.monero.MoneroTransactionSourceEntry.real_out_additional_tx_keys)
}
inline void MoneroTransactionSourceEntry::set_real_out_additional_tx_keys(int index, const void* value, size_t size) {
  real_out_additional_tx_keys_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:hw.trezor.messages.monero.MoneroTransactionSourceEntry.real_out_additional_tx_keys)
}
inline ::std::string* MoneroTransactionSourceEntry::add_real_out_additional_tx_keys() {
  // @@protoc_insertion_point(field_add_mutable:hw.trezor.messages.monero.MoneroTransactionSourceEntry.real_out_additional_tx_keys)
  return real_out_additional_tx_keys_.Add();
}
inline void MoneroTransactionSourceEntry::add_real_out_additional_tx_keys(const ::std::string& value) {
  real_out_additional_tx_keys_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:hw.trezor.messages.monero.MoneroTransactionSourceEntry.real_out_additional_tx_keys)
}
#if LANG_CXX11
inline void MoneroTransactionSourceEntry::add_real_out_additional_tx_keys(::std::string&& value) {
  real_out_additional_tx_keys_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:hw.trezor.messages.monero.MoneroTransactionSourceEntry.real_out_additional_tx_keys)
}
#endif
inline void MoneroTransactionSourceEntry::add_real_out_additional_tx_keys(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  real_out_additional_tx_keys_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:hw.trezor.messages.monero.MoneroTransactionSourceEntry.real_out_additional_tx_keys)
}
inline void MoneroTransactionSourceEntry::add_real_out_additional_tx_keys(const void* value, size_t size) {
  real_out_additional_tx_keys_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:hw.trezor.messages.monero.MoneroTransactionSourceEntry.real_out_additional_tx_keys)
}
inline const ::google::protobuf::RepeatedPtrField<::std::string>&
MoneroTransactionSourceEntry::real_out_additional_tx_keys() const {
  // @@protoc_insertion_point(field_list:hw.trezor.messages.monero.MoneroTransactionSourceEntry.real_out_additional_tx_keys)
  return real_out_additional_tx_keys_;
}
inline ::google::protobuf::RepeatedPtrField<::std::string>*
MoneroTransactionSourceEntry::mutable_real_out_additional_tx_keys() {
  // @@protoc_insertion_point(field_mutable_list:hw.trezor.messages.monero.MoneroTransactionSourceEntry.real_out_additional_tx_keys)
  return &real_out_additional_tx_keys_;
}

// optional uint64 real_output_in_tx_index = 5;
inline bool MoneroTransactionSourceEntry::has_real_output_in_tx_index() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void MoneroTransactionSourceEntry::clear_real_output_in_tx_index() {
  real_output_in_tx_index_ = PROTOBUF_ULONGLONG(0);
  _has_bits_[0] &= ~0x00000010u;
}
inline ::google::protobuf::uint64 MoneroTransactionSourceEntry::real_output_in_tx_index() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.monero.MoneroTransactionSourceEntry.real_output_in_tx_index)
  return real_output_in_tx_index_;
}
inline void MoneroTransactionSourceEntry::set_real_output_in_tx_index(::google::protobuf::uint64 value) {
  _has_bits_[0] |= 0x00000010u;
  real_output_in_tx_index_ = value;
  // @@protoc_insertion_point(field_set:hw.trezor.messages.monero.MoneroTransactionSourceEntry.real_output_in_tx_index)
}

// optional uint64 amount = 6;
inline bool MoneroTransactionSourceEntry::has_amount() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void MoneroTransactionSourceEntry::clear_amount() {
  amount_ = PROTOBUF_ULONGLONG(0);
  _has_bits_[0] &= ~0x00000020u;
}
inline ::google::protobuf::uint64 MoneroTransactionSourceEntry::amount() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.monero.MoneroTransactionSourceEntry.amount)
  return amount_;
}
inline void MoneroTransactionSourceEntry::set_amount(::google::protobuf::uint64 value) {
  _has_bits_[0] |= 0x00000020u;
  amount_ = value;
  // @@protoc_insertion_point(field_set:hw.trezor.messages.monero.MoneroTransactionSourceEntry.amount)
}

// optional bool rct = 7;
inline bool MoneroTransactionSourceEntry::has_rct() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void MoneroTransactionSourceEntry::clear_rct() {
  rct_ = false;
  _has_bits_[0] &= ~0x00000040u;
}
inline bool MoneroTransactionSourceEntry::rct() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.monero.MoneroTransactionSourceEntry.rct)
  return rct_;
}
inline void MoneroTransactionSourceEntry::set_rct(bool value) {
  _has_bits_[0] |= 0x00000040u;
  rct_ = value;
  // @@protoc_insertion_point(field_set:hw.trezor.messages.monero.MoneroTransactionSourceEntry.rct)
}

// optional bytes mask = 8;
inline bool MoneroTransactionSourceEntry::has_mask() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void MoneroTransactionSourceEntry::clear_mask() {
  mask_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000002u;
}
inline const ::std::string& MoneroTransactionSourceEntry::mask() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.monero.MoneroTransactionSourceEntry.mask)
  return mask_.GetNoArena();
}
inline void MoneroTransactionSourceEntry::set_mask(const ::std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  mask_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:hw.trezor.messages.monero.MoneroTransactionSourceEntry.mask)
}
#if LANG_CXX11
inline void MoneroTransactionSourceEntry::set_mask(::std::string&& value) {
  _has_bits_[0] |= 0x00000002u;
  mask_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:hw.trezor.messages.monero.MoneroTransactionSourceEntry.mask)
}
#endif
inline void MoneroTransactionSourceEntry::set_mask(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000002u;
  mask_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:hw.trezor.messages.monero.MoneroTransactionSourceEntry.mask)
}
inline void MoneroTransactionSourceEntry::set_mask(const void* value, size_t size) {
  _has_bits_[0] |= 0x00000002u;
  mask_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:hw.trezor.messages.monero.MoneroTransactionSourceEntry.mask)
}
inline ::std::string* MoneroTransactionSourceEntry::mutable_mask() {
  _has_bits_[0] |= 0x00000002u;
  // @@protoc_insertion_point(field_mutable:hw.trezor.messages.monero.MoneroTransactionSourceEntry.mask)
  return mask_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* MoneroTransactionSourceEntry::release_mask() {
  // @@protoc_insertion_point(field_release:hw.trezor.messages.monero.MoneroTransactionSourceEntry.mask)
  if (!has_mask()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  return mask_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void MoneroTransactionSourceEntry::set_allocated_mask(::std::string* mask) {
  if (mask != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  mask_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), mask);
  // @@protoc_insertion_point(field_set_allocated:hw.trezor.messages.monero.MoneroTransactionSourceEntry.mask)
}

// optional .hw.trezor.messages.monero.MoneroTransactionSourceEntry.MoneroMultisigKLRki multisig_kLRki = 9;
inline bool MoneroTransactionSourceEntry::has_multisig_klrki() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void MoneroTransactionSourceEntry::clear_multisig_klrki() {
  if (multisig_klrki_ != nullptr) multisig_klrki_->Clear();
  _has_bits_[0] &= ~0x00000004u;
}
inline const ::hw::trezor::messages::monero::MoneroTransactionSourceEntry_MoneroMultisigKLRki& MoneroTransactionSourceEntry::multisig_klrki() const {
  const ::hw::trezor::messages::monero::MoneroTransactionSourceEntry_MoneroMultisigKLRki* p = multisig_klrki_;
  // @@protoc_insertion_point(field_get:hw.trezor.messages.monero.MoneroTransactionSourceEntry.multisig_kLRki)
  return p != nullptr ? *p : *reinterpret_cast<const ::hw::trezor::messages::monero::MoneroTransactionSourceEntry_MoneroMultisigKLRki*>(
      &::hw::trezor::messages::monero::_MoneroTransactionSourceEntry_MoneroMultisigKLRki_default_instance_);
}
inline ::hw::trezor::messages::monero::MoneroTransactionSourceEntry_MoneroMultisigKLRki* MoneroTransactionSourceEntry::release_multisig_klrki() {
  // @@protoc_insertion_point(field_release:hw.trezor.messages.monero.MoneroTransactionSourceEntry.multisig_kLRki)
  _has_bits_[0] &= ~0x00000004u;
  ::hw::trezor::messages::monero::MoneroTransactionSourceEntry_MoneroMultisigKLRki* temp = multisig_klrki_;
  multisig_klrki_ = nullptr;
  return temp;
}
inline ::hw::trezor::messages::monero::MoneroTransactionSourceEntry_MoneroMultisigKLRki* MoneroTransactionSourceEntry::mutable_multisig_klrki() {
  _has_bits_[0] |= 0x00000004u;
  if (multisig_klrki_ == nullptr) {
    auto* p = CreateMaybeMessage<::hw::trezor::messages::monero::MoneroTransactionSourceEntry_MoneroMultisigKLRki>(GetArenaNoVirtual());
    multisig_klrki_ = p;
  }
  // @@protoc_insertion_point(field_mutable:hw.trezor.messages.monero.MoneroTransactionSourceEntry.multisig_kLRki)
  return multisig_klrki_;
}
inline void MoneroTransactionSourceEntry::set_allocated_multisig_klrki(::hw::trezor::messages::monero::MoneroTransactionSourceEntry_MoneroMultisigKLRki* multisig_klrki) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete multisig_klrki_;
  }
  if (multisig_klrki) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      multisig_klrki = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, multisig_klrki, submessage_arena);
    }
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  multisig_klrki_ = multisig_klrki;
  // @@protoc_insertion_point(field_set_allocated:hw.trezor.messages.monero.MoneroTransactionSourceEntry.multisig_kLRki)
}

// -------------------------------------------------------------------

// MoneroTransactionDestinationEntry_MoneroAccountPublicAddress

// optional bytes spend_public_key = 1;
inline bool MoneroTransactionDestinationEntry_MoneroAccountPublicAddress::has_spend_public_key() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MoneroTransactionDestinationEntry_MoneroAccountPublicAddress::clear_spend_public_key() {
  spend_public_key_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::std::string& MoneroTransactionDestinationEntry_MoneroAccountPublicAddress::spend_public_key() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.monero.MoneroTransactionDestinationEntry.MoneroAccountPublicAddress.spend_public_key)
  return spend_public_key_.GetNoArena();
}
inline void MoneroTransactionDestinationEntry_MoneroAccountPublicAddress::set_spend_public_key(const ::std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  spend_public_key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:hw.trezor.messages.monero.MoneroTransactionDestinationEntry.MoneroAccountPublicAddress.spend_public_key)
}
#if LANG_CXX11
inline void MoneroTransactionDestinationEntry_MoneroAccountPublicAddress::set_spend_public_key(::std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  spend_public_key_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:hw.trezor.messages.monero.MoneroTransactionDestinationEntry.MoneroAccountPublicAddress.spend_public_key)
}
#endif
inline void MoneroTransactionDestinationEntry_MoneroAccountPublicAddress::set_spend_public_key(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  spend_public_key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:hw.trezor.messages.monero.MoneroTransactionDestinationEntry.MoneroAccountPublicAddress.spend_public_key)
}
inline void MoneroTransactionDestinationEntry_MoneroAccountPublicAddress::set_spend_public_key(const void* value, size_t size) {
  _has_bits_[0] |= 0x00000001u;
  spend_public_key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:hw.trezor.messages.monero.MoneroTransactionDestinationEntry.MoneroAccountPublicAddress.spend_public_key)
}
inline ::std::string* MoneroTransactionDestinationEntry_MoneroAccountPublicAddress::mutable_spend_public_key() {
  _has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_mutable:hw.trezor.messages.monero.MoneroTransactionDestinationEntry.MoneroAccountPublicAddress.spend_public_key)
  return spend_public_key_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* MoneroTransactionDestinationEntry_MoneroAccountPublicAddress::release_spend_public_key() {
  // @@protoc_insertion_point(field_release:hw.trezor.messages.monero.MoneroTransactionDestinationEntry.MoneroAccountPublicAddress.spend_public_key)
  if (!has_spend_public_key()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return spend_public_key_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void MoneroTransactionDestinationEntry_MoneroAccountPublicAddress::set_allocated_spend_public_key(::std::string* spend_public_key) {
  if (spend_public_key != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  spend_public_key_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), spend_public_key);
  // @@protoc_insertion_point(field_set_allocated:hw.trezor.messages.monero.MoneroTransactionDestinationEntry.MoneroAccountPublicAddress.spend_public_key)
}

// optional bytes view_public_key = 2;
inline bool MoneroTransactionDestinationEntry_MoneroAccountPublicAddress::has_view_public_key() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void MoneroTransactionDestinationEntry_MoneroAccountPublicAddress::clear_view_public_key() {
  view_public_key_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000002u;
}
inline const ::std::string& MoneroTransactionDestinationEntry_MoneroAccountPublicAddress::view_public_key() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.monero.MoneroTransactionDestinationEntry.MoneroAccountPublicAddress.view_public_key)
  return view_public_key_.GetNoArena();
}
inline void MoneroTransactionDestinationEntry_MoneroAccountPublicAddress::set_view_public_key(const ::std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  view_public_key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:hw.trezor.messages.monero.MoneroTransactionDestinationEntry.MoneroAccountPublicAddress.view_public_key)
}
#if LANG_CXX11
inline void MoneroTransactionDestinationEntry_MoneroAccountPublicAddress::set_view_public_key(::std::string&& value) {
  _has_bits_[0] |= 0x00000002u;
  view_public_key_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:hw.trezor.messages.monero.MoneroTransactionDestinationEntry.MoneroAccountPublicAddress.view_public_key)
}
#endif
inline void MoneroTransactionDestinationEntry_MoneroAccountPublicAddress::set_view_public_key(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000002u;
  view_public_key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:hw.trezor.messages.monero.MoneroTransactionDestinationEntry.MoneroAccountPublicAddress.view_public_key)
}
inline void MoneroTransactionDestinationEntry_MoneroAccountPublicAddress::set_view_public_key(const void* value, size_t size) {
  _has_bits_[0] |= 0x00000002u;
  view_public_key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:hw.trezor.messages.monero.MoneroTransactionDestinationEntry.MoneroAccountPublicAddress.view_public_key)
}
inline ::std::string* MoneroTransactionDestinationEntry_MoneroAccountPublicAddress::mutable_view_public_key() {
  _has_bits_[0] |= 0x00000002u;
  // @@protoc_insertion_point(field_mutable:hw.trezor.messages.monero.MoneroTransactionDestinationEntry.MoneroAccountPublicAddress.view_public_key)
  return view_public_key_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* MoneroTransactionDestinationEntry_MoneroAccountPublicAddress::release_view_public_key() {
  // @@protoc_insertion_point(field_release:hw.trezor.messages.monero.MoneroTransactionDestinationEntry.MoneroAccountPublicAddress.view_public_key)
  if (!has_view_public_key()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  return view_public_key_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void MoneroTransactionDestinationEntry_MoneroAccountPublicAddress::set_allocated_view_public_key(::std::string* view_public_key) {
  if (view_public_key != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  view_public_key_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), view_public_key);
  // @@protoc_insertion_point(field_set_allocated:hw.trezor.messages.monero.MoneroTransactionDestinationEntry.MoneroAccountPublicAddress.view_public_key)
}

// -------------------------------------------------------------------

// MoneroTransactionDestinationEntry

// optional uint64 amount = 1;
inline bool MoneroTransactionDestinationEntry::has_amount() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void MoneroTransactionDestinationEntry::clear_amount() {
  amount_ = PROTOBUF_ULONGLONG(0);
  _has_bits_[0] &= ~0x00000002u;
}
inline ::google::protobuf::uint64 MoneroTransactionDestinationEntry::amount() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.monero.MoneroTransactionDestinationEntry.amount)
  return amount_;
}
inline void MoneroTransactionDestinationEntry::set_amount(::google::protobuf::uint64 value) {
  _has_bits_[0] |= 0x00000002u;
  amount_ = value;
  // @@protoc_insertion_point(field_set:hw.trezor.messages.monero.MoneroTransactionDestinationEntry.amount)
}

// optional .hw.trezor.messages.monero.MoneroTransactionDestinationEntry.MoneroAccountPublicAddress addr = 2;
inline bool MoneroTransactionDestinationEntry::has_addr() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MoneroTransactionDestinationEntry::clear_addr() {
  if (addr_ != nullptr) addr_->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::hw::trezor::messages::monero::MoneroTransactionDestinationEntry_MoneroAccountPublicAddress& MoneroTransactionDestinationEntry::addr() const {
  const ::hw::trezor::messages::monero::MoneroTransactionDestinationEntry_MoneroAccountPublicAddress* p = addr_;
  // @@protoc_insertion_point(field_get:hw.trezor.messages.monero.MoneroTransactionDestinationEntry.addr)
  return p != nullptr ? *p : *reinterpret_cast<const ::hw::trezor::messages::monero::MoneroTransactionDestinationEntry_MoneroAccountPublicAddress*>(
      &::hw::trezor::messages::monero::_MoneroTransactionDestinationEntry_MoneroAccountPublicAddress_default_instance_);
}
inline ::hw::trezor::messages::monero::MoneroTransactionDestinationEntry_MoneroAccountPublicAddress* MoneroTransactionDestinationEntry::release_addr() {
  // @@protoc_insertion_point(field_release:hw.trezor.messages.monero.MoneroTransactionDestinationEntry.addr)
  _has_bits_[0] &= ~0x00000001u;
  ::hw::trezor::messages::monero::MoneroTransactionDestinationEntry_MoneroAccountPublicAddress* temp = addr_;
  addr_ = nullptr;
  return temp;
}
inline ::hw::trezor::messages::monero::MoneroTransactionDestinationEntry_MoneroAccountPublicAddress* MoneroTransactionDestinationEntry::mutable_addr() {
  _has_bits_[0] |= 0x00000001u;
  if (addr_ == nullptr) {
    auto* p = CreateMaybeMessage<::hw::trezor::messages::monero::MoneroTransactionDestinationEntry_MoneroAccountPublicAddress>(GetArenaNoVirtual());
    addr_ = p;
  }
  // @@protoc_insertion_point(field_mutable:hw.trezor.messages.monero.MoneroTransactionDestinationEntry.addr)
  return addr_;
}
inline void MoneroTransactionDestinationEntry::set_allocated_addr(::hw::trezor::messages::monero::MoneroTransactionDestinationEntry_MoneroAccountPublicAddress* addr) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete addr_;
  }
  if (addr) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      addr = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, addr, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  addr_ = addr;
  // @@protoc_insertion_point(field_set_allocated:hw.trezor.messages.monero.MoneroTransactionDestinationEntry.addr)
}

// optional bool is_subaddress = 3;
inline bool MoneroTransactionDestinationEntry::has_is_subaddress() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void MoneroTransactionDestinationEntry::clear_is_subaddress() {
  is_subaddress_ = false;
  _has_bits_[0] &= ~0x00000004u;
}
inline bool MoneroTransactionDestinationEntry::is_subaddress() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.monero.MoneroTransactionDestinationEntry.is_subaddress)
  return is_subaddress_;
}
inline void MoneroTransactionDestinationEntry::set_is_subaddress(bool value) {
  _has_bits_[0] |= 0x00000004u;
  is_subaddress_ = value;
  // @@protoc_insertion_point(field_set:hw.trezor.messages.monero.MoneroTransactionDestinationEntry.is_subaddress)
}

// -------------------------------------------------------------------

// MoneroTransactionRsigData

// optional uint32 rsig_type = 1;
inline bool MoneroTransactionRsigData::has_rsig_type() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void MoneroTransactionRsigData::clear_rsig_type() {
  rsig_type_ = 0u;
  _has_bits_[0] &= ~0x00000004u;
}
inline ::google::protobuf::uint32 MoneroTransactionRsigData::rsig_type() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.monero.MoneroTransactionRsigData.rsig_type)
  return rsig_type_;
}
inline void MoneroTransactionRsigData::set_rsig_type(::google::protobuf::uint32 value) {
  _has_bits_[0] |= 0x00000004u;
  rsig_type_ = value;
  // @@protoc_insertion_point(field_set:hw.trezor.messages.monero.MoneroTransactionRsigData.rsig_type)
}

// optional uint32 offload_type = 2;
inline bool MoneroTransactionRsigData::has_offload_type() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void MoneroTransactionRsigData::clear_offload_type() {
  offload_type_ = 0u;
  _has_bits_[0] &= ~0x00000008u;
}
inline ::google::protobuf::uint32 MoneroTransactionRsigData::offload_type() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.monero.MoneroTransactionRsigData.offload_type)
  return offload_type_;
}
inline void MoneroTransactionRsigData::set_offload_type(::google::protobuf::uint32 value) {
  _has_bits_[0] |= 0x00000008u;
  offload_type_ = value;
  // @@protoc_insertion_point(field_set:hw.trezor.messages.monero.MoneroTransactionRsigData.offload_type)
}

// repeated uint64 grouping = 3;
inline int MoneroTransactionRsigData::grouping_size() const {
  return grouping_.size();
}
inline void MoneroTransactionRsigData::clear_grouping() {
  grouping_.Clear();
}
inline ::google::protobuf::uint64 MoneroTransactionRsigData::grouping(int index) const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.monero.MoneroTransactionRsigData.grouping)
  return grouping_.Get(index);
}
inline void MoneroTransactionRsigData::set_grouping(int index, ::google::protobuf::uint64 value) {
  grouping_.Set(index, value);
  // @@protoc_insertion_point(field_set:hw.trezor.messages.monero.MoneroTransactionRsigData.grouping)
}
inline void MoneroTransactionRsigData::add_grouping(::google::protobuf::uint64 value) {
  grouping_.Add(value);
  // @@protoc_insertion_point(field_add:hw.trezor.messages.monero.MoneroTransactionRsigData.grouping)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >&
MoneroTransactionRsigData::grouping() const {
  // @@protoc_insertion_point(field_list:hw.trezor.messages.monero.MoneroTransactionRsigData.grouping)
  return grouping_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >*
MoneroTransactionRsigData::mutable_grouping() {
  // @@protoc_insertion_point(field_mutable_list:hw.trezor.messages.monero.MoneroTransactionRsigData.grouping)
  return &grouping_;
}

// optional bytes mask = 4;
inline bool MoneroTransactionRsigData::has_mask() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MoneroTransactionRsigData::clear_mask() {
  mask_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::std::string& MoneroTransactionRsigData::mask() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.monero.MoneroTransactionRsigData.mask)
  return mask_.GetNoArena();
}
inline void MoneroTransactionRsigData::set_mask(const ::std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  mask_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:hw.trezor.messages.monero.MoneroTransactionRsigData.mask)
}
#if LANG_CXX11
inline void MoneroTransactionRsigData::set_mask(::std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  mask_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:hw.trezor.messages.monero.MoneroTransactionRsigData.mask)
}
#endif
inline void MoneroTransactionRsigData::set_mask(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  mask_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:hw.trezor.messages.monero.MoneroTransactionRsigData.mask)
}
inline void MoneroTransactionRsigData::set_mask(const void* value, size_t size) {
  _has_bits_[0] |= 0x00000001u;
  mask_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:hw.trezor.messages.monero.MoneroTransactionRsigData.mask)
}
inline ::std::string* MoneroTransactionRsigData::mutable_mask() {
  _has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_mutable:hw.trezor.messages.monero.MoneroTransactionRsigData.mask)
  return mask_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* MoneroTransactionRsigData::release_mask() {
  // @@protoc_insertion_point(field_release:hw.trezor.messages.monero.MoneroTransactionRsigData.mask)
  if (!has_mask()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return mask_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void MoneroTransactionRsigData::set_allocated_mask(::std::string* mask) {
  if (mask != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  mask_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), mask);
  // @@protoc_insertion_point(field_set_allocated:hw.trezor.messages.monero.MoneroTransactionRsigData.mask)
}

// optional bytes rsig = 5;
inline bool MoneroTransactionRsigData::has_rsig() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void MoneroTransactionRsigData::clear_rsig() {
  rsig_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000002u;
}
inline const ::std::string& MoneroTransactionRsigData::rsig() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.monero.MoneroTransactionRsigData.rsig)
  return rsig_.GetNoArena();
}
inline void MoneroTransactionRsigData::set_rsig(const ::std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  rsig_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:hw.trezor.messages.monero.MoneroTransactionRsigData.rsig)
}
#if LANG_CXX11
inline void MoneroTransactionRsigData::set_rsig(::std::string&& value) {
  _has_bits_[0] |= 0x00000002u;
  rsig_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:hw.trezor.messages.monero.MoneroTransactionRsigData.rsig)
}
#endif
inline void MoneroTransactionRsigData::set_rsig(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000002u;
  rsig_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:hw.trezor.messages.monero.MoneroTransactionRsigData.rsig)
}
inline void MoneroTransactionRsigData::set_rsig(const void* value, size_t size) {
  _has_bits_[0] |= 0x00000002u;
  rsig_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:hw.trezor.messages.monero.MoneroTransactionRsigData.rsig)
}
inline ::std::string* MoneroTransactionRsigData::mutable_rsig() {
  _has_bits_[0] |= 0x00000002u;
  // @@protoc_insertion_point(field_mutable:hw.trezor.messages.monero.MoneroTransactionRsigData.rsig)
  return rsig_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* MoneroTransactionRsigData::release_rsig() {
  // @@protoc_insertion_point(field_release:hw.trezor.messages.monero.MoneroTransactionRsigData.rsig)
  if (!has_rsig()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  return rsig_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void MoneroTransactionRsigData::set_allocated_rsig(::std::string* rsig) {
  if (rsig != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  rsig_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), rsig);
  // @@protoc_insertion_point(field_set_allocated:hw.trezor.messages.monero.MoneroTransactionRsigData.rsig)
}

// repeated bytes rsig_parts = 6;
inline int MoneroTransactionRsigData::rsig_parts_size() const {
  return rsig_parts_.size();
}
inline void MoneroTransactionRsigData::clear_rsig_parts() {
  rsig_parts_.Clear();
}
inline const ::std::string& MoneroTransactionRsigData::rsig_parts(int index) const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.monero.MoneroTransactionRsigData.rsig_parts)
  return rsig_parts_.Get(index);
}
inline ::std::string* MoneroTransactionRsigData::mutable_rsig_parts(int index) {
  // @@protoc_insertion_point(field_mutable:hw.trezor.messages.monero.MoneroTransactionRsigData.rsig_parts)
  return rsig_parts_.Mutable(index);
}
inline void MoneroTransactionRsigData::set_rsig_parts(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:hw.trezor.messages.monero.MoneroTransactionRsigData.rsig_parts)
  rsig_parts_.Mutable(index)->assign(value);
}
#if LANG_CXX11
inline void MoneroTransactionRsigData::set_rsig_parts(int index, ::std::string&& value) {
  // @@protoc_insertion_point(field_set:hw.trezor.messages.monero.MoneroTransactionRsigData.rsig_parts)
  rsig_parts_.Mutable(index)->assign(std::move(value));
}
#endif
inline void MoneroTransactionRsigData::set_rsig_parts(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  rsig_parts_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:hw.trezor.messages.monero.MoneroTransactionRsigData.rsig_parts)
}
inline void MoneroTransactionRsigData::set_rsig_parts(int index, const void* value, size_t size) {
  rsig_parts_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:hw.trezor.messages.monero.MoneroTransactionRsigData.rsig_parts)
}
inline ::std::string* MoneroTransactionRsigData::add_rsig_parts() {
  // @@protoc_insertion_point(field_add_mutable:hw.trezor.messages.monero.MoneroTransactionRsigData.rsig_parts)
  return rsig_parts_.Add();
}
inline void MoneroTransactionRsigData::add_rsig_parts(const ::std::string& value) {
  rsig_parts_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:hw.trezor.messages.monero.MoneroTransactionRsigData.rsig_parts)
}
#if LANG_CXX11
inline void MoneroTransactionRsigData::add_rsig_parts(::std::string&& value) {
  rsig_parts_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:hw.trezor.messages.monero.MoneroTransactionRsigData.rsig_parts)
}
#endif
inline void MoneroTransactionRsigData::add_rsig_parts(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  rsig_parts_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:hw.trezor.messages.monero.MoneroTransactionRsigData.rsig_parts)
}
inline void MoneroTransactionRsigData::add_rsig_parts(const void* value, size_t size) {
  rsig_parts_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:hw.trezor.messages.monero.MoneroTransactionRsigData.rsig_parts)
}
inline const ::google::protobuf::RepeatedPtrField<::std::string>&
MoneroTransactionRsigData::rsig_parts() const {
  // @@protoc_insertion_point(field_list:hw.trezor.messages.monero.MoneroTransactionRsigData.rsig_parts)
  return rsig_parts_;
}
inline ::google::protobuf::RepeatedPtrField<::std::string>*
MoneroTransactionRsigData::mutable_rsig_parts() {
  // @@protoc_insertion_point(field_mutable_list:hw.trezor.messages.monero.MoneroTransactionRsigData.rsig_parts)
  return &rsig_parts_;
}

// -------------------------------------------------------------------

// MoneroGetAddress

// repeated uint32 address_n = 1;
inline int MoneroGetAddress::address_n_size() const {
  return address_n_.size();
}
inline void MoneroGetAddress::clear_address_n() {
  address_n_.Clear();
}
inline ::google::protobuf::uint32 MoneroGetAddress::address_n(int index) const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.monero.MoneroGetAddress.address_n)
  return address_n_.Get(index);
}
inline void MoneroGetAddress::set_address_n(int index, ::google::protobuf::uint32 value) {
  address_n_.Set(index, value);
  // @@protoc_insertion_point(field_set:hw.trezor.messages.monero.MoneroGetAddress.address_n)
}
inline void MoneroGetAddress::add_address_n(::google::protobuf::uint32 value) {
  address_n_.Add(value);
  // @@protoc_insertion_point(field_add:hw.trezor.messages.monero.MoneroGetAddress.address_n)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
MoneroGetAddress::address_n() const {
  // @@protoc_insertion_point(field_list:hw.trezor.messages.monero.MoneroGetAddress.address_n)
  return address_n_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
MoneroGetAddress::mutable_address_n() {
  // @@protoc_insertion_point(field_mutable_list:hw.trezor.messages.monero.MoneroGetAddress.address_n)
  return &address_n_;
}

// optional bool show_display = 2;
inline bool MoneroGetAddress::has_show_display() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MoneroGetAddress::clear_show_display() {
  show_display_ = false;
  _has_bits_[0] &= ~0x00000001u;
}
inline bool MoneroGetAddress::show_display() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.monero.MoneroGetAddress.show_display)
  return show_display_;
}
inline void MoneroGetAddress::set_show_display(bool value) {
  _has_bits_[0] |= 0x00000001u;
  show_display_ = value;
  // @@protoc_insertion_point(field_set:hw.trezor.messages.monero.MoneroGetAddress.show_display)
}

// optional uint32 network_type = 3;
inline bool MoneroGetAddress::has_network_type() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void MoneroGetAddress::clear_network_type() {
  network_type_ = 0u;
  _has_bits_[0] &= ~0x00000002u;
}
inline ::google::protobuf::uint32 MoneroGetAddress::network_type() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.monero.MoneroGetAddress.network_type)
  return network_type_;
}
inline void MoneroGetAddress::set_network_type(::google::protobuf::uint32 value) {
  _has_bits_[0] |= 0x00000002u;
  network_type_ = value;
  // @@protoc_insertion_point(field_set:hw.trezor.messages.monero.MoneroGetAddress.network_type)
}

// optional uint32 account = 4;
inline bool MoneroGetAddress::has_account() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void MoneroGetAddress::clear_account() {
  account_ = 0u;
  _has_bits_[0] &= ~0x00000004u;
}
inline ::google::protobuf::uint32 MoneroGetAddress::account() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.monero.MoneroGetAddress.account)
  return account_;
}
inline void MoneroGetAddress::set_account(::google::protobuf::uint32 value) {
  _has_bits_[0] |= 0x00000004u;
  account_ = value;
  // @@protoc_insertion_point(field_set:hw.trezor.messages.monero.MoneroGetAddress.account)
}

// optional uint32 minor = 5;
inline bool MoneroGetAddress::has_minor() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void MoneroGetAddress::clear_minor() {
  minor_ = 0u;
  _has_bits_[0] &= ~0x00000008u;
}
inline ::google::protobuf::uint32 MoneroGetAddress::minor() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.monero.MoneroGetAddress.minor)
  return minor_;
}
inline void MoneroGetAddress::set_minor(::google::protobuf::uint32 value) {
  _has_bits_[0] |= 0x00000008u;
  minor_ = value;
  // @@protoc_insertion_point(field_set:hw.trezor.messages.monero.MoneroGetAddress.minor)
}

// -------------------------------------------------------------------

// MoneroAddress

// optional bytes address = 1;
inline bool MoneroAddress::has_address() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MoneroAddress::clear_address() {
  address_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::std::string& MoneroAddress::address() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.monero.MoneroAddress.address)
  return address_.GetNoArena();
}
inline void MoneroAddress::set_address(const ::std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  address_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:hw.trezor.messages.monero.MoneroAddress.address)
}
#if LANG_CXX11
inline void MoneroAddress::set_address(::std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  address_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:hw.trezor.messages.monero.MoneroAddress.address)
}
#endif
inline void MoneroAddress::set_address(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  address_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:hw.trezor.messages.monero.MoneroAddress.address)
}
inline void MoneroAddress::set_address(const void* value, size_t size) {
  _has_bits_[0] |= 0x00000001u;
  address_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:hw.trezor.messages.monero.MoneroAddress.address)
}
inline ::std::string* MoneroAddress::mutable_address() {
  _has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_mutable:hw.trezor.messages.monero.MoneroAddress.address)
  return address_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* MoneroAddress::release_address() {
  // @@protoc_insertion_point(field_release:hw.trezor.messages.monero.MoneroAddress.address)
  if (!has_address()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return address_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void MoneroAddress::set_allocated_address(::std::string* address) {
  if (address != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  address_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), address);
  // @@protoc_insertion_point(field_set_allocated:hw.trezor.messages.monero.MoneroAddress.address)
}

// -------------------------------------------------------------------

// MoneroGetWatchKey

// repeated uint32 address_n = 1;
inline int MoneroGetWatchKey::address_n_size() const {
  return address_n_.size();
}
inline void MoneroGetWatchKey::clear_address_n() {
  address_n_.Clear();
}
inline ::google::protobuf::uint32 MoneroGetWatchKey::address_n(int index) const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.monero.MoneroGetWatchKey.address_n)
  return address_n_.Get(index);
}
inline void MoneroGetWatchKey::set_address_n(int index, ::google::protobuf::uint32 value) {
  address_n_.Set(index, value);
  // @@protoc_insertion_point(field_set:hw.trezor.messages.monero.MoneroGetWatchKey.address_n)
}
inline void MoneroGetWatchKey::add_address_n(::google::protobuf::uint32 value) {
  address_n_.Add(value);
  // @@protoc_insertion_point(field_add:hw.trezor.messages.monero.MoneroGetWatchKey.address_n)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
MoneroGetWatchKey::address_n() const {
  // @@protoc_insertion_point(field_list:hw.trezor.messages.monero.MoneroGetWatchKey.address_n)
  return address_n_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
MoneroGetWatchKey::mutable_address_n() {
  // @@protoc_insertion_point(field_mutable_list:hw.trezor.messages.monero.MoneroGetWatchKey.address_n)
  return &address_n_;
}

// optional uint32 network_type = 2;
inline bool MoneroGetWatchKey::has_network_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MoneroGetWatchKey::clear_network_type() {
  network_type_ = 0u;
  _has_bits_[0] &= ~0x00000001u;
}
inline ::google::protobuf::uint32 MoneroGetWatchKey::network_type() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.monero.MoneroGetWatchKey.network_type)
  return network_type_;
}
inline void MoneroGetWatchKey::set_network_type(::google::protobuf::uint32 value) {
  _has_bits_[0] |= 0x00000001u;
  network_type_ = value;
  // @@protoc_insertion_point(field_set:hw.trezor.messages.monero.MoneroGetWatchKey.network_type)
}

// -------------------------------------------------------------------

// MoneroWatchKey

// optional bytes watch_key = 1;
inline bool MoneroWatchKey::has_watch_key() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MoneroWatchKey::clear_watch_key() {
  watch_key_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::std::string& MoneroWatchKey::watch_key() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.monero.MoneroWatchKey.watch_key)
  return watch_key_.GetNoArena();
}
inline void MoneroWatchKey::set_watch_key(const ::std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  watch_key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:hw.trezor.messages.monero.MoneroWatchKey.watch_key)
}
#if LANG_CXX11
inline void MoneroWatchKey::set_watch_key(::std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  watch_key_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:hw.trezor.messages.monero.MoneroWatchKey.watch_key)
}
#endif
inline void MoneroWatchKey::set_watch_key(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  watch_key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:hw.trezor.messages.monero.MoneroWatchKey.watch_key)
}
inline void MoneroWatchKey::set_watch_key(const void* value, size_t size) {
  _has_bits_[0] |= 0x00000001u;
  watch_key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:hw.trezor.messages.monero.MoneroWatchKey.watch_key)
}
inline ::std::string* MoneroWatchKey::mutable_watch_key() {
  _has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_mutable:hw.trezor.messages.monero.MoneroWatchKey.watch_key)
  return watch_key_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* MoneroWatchKey::release_watch_key() {
  // @@protoc_insertion_point(field_release:hw.trezor.messages.monero.MoneroWatchKey.watch_key)
  if (!has_watch_key()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return watch_key_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void MoneroWatchKey::set_allocated_watch_key(::std::string* watch_key) {
  if (watch_key != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  watch_key_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), watch_key);
  // @@protoc_insertion_point(field_set_allocated:hw.trezor.messages.monero.MoneroWatchKey.watch_key)
}

// optional bytes address = 2;
inline bool MoneroWatchKey::has_address() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void MoneroWatchKey::clear_address() {
  address_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000002u;
}
inline const ::std::string& MoneroWatchKey::address() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.monero.MoneroWatchKey.address)
  return address_.GetNoArena();
}
inline void MoneroWatchKey::set_address(const ::std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  address_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:hw.trezor.messages.monero.MoneroWatchKey.address)
}
#if LANG_CXX11
inline void MoneroWatchKey::set_address(::std::string&& value) {
  _has_bits_[0] |= 0x00000002u;
  address_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:hw.trezor.messages.monero.MoneroWatchKey.address)
}
#endif
inline void MoneroWatchKey::set_address(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000002u;
  address_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:hw.trezor.messages.monero.MoneroWatchKey.address)
}
inline void MoneroWatchKey::set_address(const void* value, size_t size) {
  _has_bits_[0] |= 0x00000002u;
  address_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:hw.trezor.messages.monero.MoneroWatchKey.address)
}
inline ::std::string* MoneroWatchKey::mutable_address() {
  _has_bits_[0] |= 0x00000002u;
  // @@protoc_insertion_point(field_mutable:hw.trezor.messages.monero.MoneroWatchKey.address)
  return address_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* MoneroWatchKey::release_address() {
  // @@protoc_insertion_point(field_release:hw.trezor.messages.monero.MoneroWatchKey.address)
  if (!has_address()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  return address_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void MoneroWatchKey::set_allocated_address(::std::string* address) {
  if (address != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  address_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), address);
  // @@protoc_insertion_point(field_set_allocated:hw.trezor.messages.monero.MoneroWatchKey.address)
}

// -------------------------------------------------------------------

// MoneroTransactionInitRequest_MoneroTransactionData

// optional uint32 version = 1;
inline bool MoneroTransactionInitRequest_MoneroTransactionData::has_version() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void MoneroTransactionInitRequest_MoneroTransactionData::clear_version() {
  version_ = 0u;
  _has_bits_[0] &= ~0x00000010u;
}
inline ::google::protobuf::uint32 MoneroTransactionInitRequest_MoneroTransactionData::version() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.monero.MoneroTransactionInitRequest.MoneroTransactionData.version)
  return version_;
}
inline void MoneroTransactionInitRequest_MoneroTransactionData::set_version(::google::protobuf::uint32 value) {
  _has_bits_[0] |= 0x00000010u;
  version_ = value;
  // @@protoc_insertion_point(field_set:hw.trezor.messages.monero.MoneroTransactionInitRequest.MoneroTransactionData.version)
}

// optional bytes payment_id = 2;
inline bool MoneroTransactionInitRequest_MoneroTransactionData::has_payment_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MoneroTransactionInitRequest_MoneroTransactionData::clear_payment_id() {
  payment_id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::std::string& MoneroTransactionInitRequest_MoneroTransactionData::payment_id() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.monero.MoneroTransactionInitRequest.MoneroTransactionData.payment_id)
  return payment_id_.GetNoArena();
}
inline void MoneroTransactionInitRequest_MoneroTransactionData::set_payment_id(const ::std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  payment_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:hw.trezor.messages.monero.MoneroTransactionInitRequest.MoneroTransactionData.payment_id)
}
#if LANG_CXX11
inline void MoneroTransactionInitRequest_MoneroTransactionData::set_payment_id(::std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  payment_id_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:hw.trezor.messages.monero.MoneroTransactionInitRequest.MoneroTransactionData.payment_id)
}
#endif
inline void MoneroTransactionInitRequest_MoneroTransactionData::set_payment_id(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  payment_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:hw.trezor.messages.monero.MoneroTransactionInitRequest.MoneroTransactionData.payment_id)
}
inline void MoneroTransactionInitRequest_MoneroTransactionData::set_payment_id(const void* value, size_t size) {
  _has_bits_[0] |= 0x00000001u;
  payment_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:hw.trezor.messages.monero.MoneroTransactionInitRequest.MoneroTransactionData.payment_id)
}
inline ::std::string* MoneroTransactionInitRequest_MoneroTransactionData::mutable_payment_id() {
  _has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_mutable:hw.trezor.messages.monero.MoneroTransactionInitRequest.MoneroTransactionData.payment_id)
  return payment_id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* MoneroTransactionInitRequest_MoneroTransactionData::release_payment_id() {
  // @@protoc_insertion_point(field_release:hw.trezor.messages.monero.MoneroTransactionInitRequest.MoneroTransactionData.payment_id)
  if (!has_payment_id()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return payment_id_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void MoneroTransactionInitRequest_MoneroTransactionData::set_allocated_payment_id(::std::string* payment_id) {
  if (payment_id != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  payment_id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), payment_id);
  // @@protoc_insertion_point(field_set_allocated:hw.trezor.messages.monero.MoneroTransactionInitRequest.MoneroTransactionData.payment_id)
}

// optional uint64 unlock_time = 3;
inline bool MoneroTransactionInitRequest_MoneroTransactionData::has_unlock_time() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void MoneroTransactionInitRequest_MoneroTransactionData::clear_unlock_time() {
  unlock_time_ = PROTOBUF_ULONGLONG(0);
  _has_bits_[0] &= ~0x00000008u;
}
inline ::google::protobuf::uint64 MoneroTransactionInitRequest_MoneroTransactionData::unlock_time() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.monero.MoneroTransactionInitRequest.MoneroTransactionData.unlock_time)
  return unlock_time_;
}
inline void MoneroTransactionInitRequest_MoneroTransactionData::set_unlock_time(::google::protobuf::uint64 value) {
  _has_bits_[0] |= 0x00000008u;
  unlock_time_ = value;
  // @@protoc_insertion_point(field_set:hw.trezor.messages.monero.MoneroTransactionInitRequest.MoneroTransactionData.unlock_time)
}

// repeated .hw.trezor.messages.monero.MoneroTransactionDestinationEntry outputs = 4;
inline int MoneroTransactionInitRequest_MoneroTransactionData::outputs_size() const {
  return outputs_.size();
}
inline void MoneroTransactionInitRequest_MoneroTransactionData::clear_outputs() {
  outputs_.Clear();
}
inline ::hw::trezor::messages::monero::MoneroTransactionDestinationEntry* MoneroTransactionInitRequest_MoneroTransactionData::mutable_outputs(int index) {
  // @@protoc_insertion_point(field_mutable:hw.trezor.messages.monero.MoneroTransactionInitRequest.MoneroTransactionData.outputs)
  return outputs_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::hw::trezor::messages::monero::MoneroTransactionDestinationEntry >*
MoneroTransactionInitRequest_MoneroTransactionData::mutable_outputs() {
  // @@protoc_insertion_point(field_mutable_list:hw.trezor.messages.monero.MoneroTransactionInitRequest.MoneroTransactionData.outputs)
  return &outputs_;
}
inline const ::hw::trezor::messages::monero::MoneroTransactionDestinationEntry& MoneroTransactionInitRequest_MoneroTransactionData::outputs(int index) const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.monero.MoneroTransactionInitRequest.MoneroTransactionData.outputs)
  return outputs_.Get(index);
}
inline ::hw::trezor::messages::monero::MoneroTransactionDestinationEntry* MoneroTransactionInitRequest_MoneroTransactionData::add_outputs() {
  // @@protoc_insertion_point(field_add:hw.trezor.messages.monero.MoneroTransactionInitRequest.MoneroTransactionData.outputs)
  return outputs_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::hw::trezor::messages::monero::MoneroTransactionDestinationEntry >&
MoneroTransactionInitRequest_MoneroTransactionData::outputs() const {
  // @@protoc_insertion_point(field_list:hw.trezor.messages.monero.MoneroTransactionInitRequest.MoneroTransactionData.outputs)
  return outputs_;
}

// optional .hw.trezor.messages.monero.MoneroTransactionDestinationEntry change_dts = 5;
inline bool MoneroTransactionInitRequest_MoneroTransactionData::has_change_dts() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void MoneroTransactionInitRequest_MoneroTransactionData::clear_change_dts() {
  if (change_dts_ != nullptr) change_dts_->Clear();
  _has_bits_[0] &= ~0x00000002u;
}
inline const ::hw::trezor::messages::monero::MoneroTransactionDestinationEntry& MoneroTransactionInitRequest_MoneroTransactionData::change_dts() const {
  const ::hw::trezor::messages::monero::MoneroTransactionDestinationEntry* p = change_dts_;
  // @@protoc_insertion_point(field_get:hw.trezor.messages.monero.MoneroTransactionInitRequest.MoneroTransactionData.change_dts)
  return p != nullptr ? *p : *reinterpret_cast<const ::hw::trezor::messages::monero::MoneroTransactionDestinationEntry*>(
      &::hw::trezor::messages::monero::_MoneroTransactionDestinationEntry_default_instance_);
}
inline ::hw::trezor::messages::monero::MoneroTransactionDestinationEntry* MoneroTransactionInitRequest_MoneroTransactionData::release_change_dts() {
  // @@protoc_insertion_point(field_release:hw.trezor.messages.monero.MoneroTransactionInitRequest.MoneroTransactionData.change_dts)
  _has_bits_[0] &= ~0x00000002u;
  ::hw::trezor::messages::monero::MoneroTransactionDestinationEntry* temp = change_dts_;
  change_dts_ = nullptr;
  return temp;
}
inline ::hw::trezor::messages::monero::MoneroTransactionDestinationEntry* MoneroTransactionInitRequest_MoneroTransactionData::mutable_change_dts() {
  _has_bits_[0] |= 0x00000002u;
  if (change_dts_ == nullptr) {
    auto* p = CreateMaybeMessage<::hw::trezor::messages::monero::MoneroTransactionDestinationEntry>(GetArenaNoVirtual());
    change_dts_ = p;
  }
  // @@protoc_insertion_point(field_mutable:hw.trezor.messages.monero.MoneroTransactionInitRequest.MoneroTransactionData.change_dts)
  return change_dts_;
}
inline void MoneroTransactionInitRequest_MoneroTransactionData::set_allocated_change_dts(::hw::trezor::messages::monero::MoneroTransactionDestinationEntry* change_dts) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete change_dts_;
  }
  if (change_dts) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      change_dts = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, change_dts, submessage_arena);
    }
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  change_dts_ = change_dts;
  // @@protoc_insertion_point(field_set_allocated:hw.trezor.messages.monero.MoneroTransactionInitRequest.MoneroTransactionData.change_dts)
}

// optional uint32 num_inputs = 6;
inline bool MoneroTransactionInitRequest_MoneroTransactionData::has_num_inputs() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void MoneroTransactionInitRequest_MoneroTransactionData::clear_num_inputs() {
  num_inputs_ = 0u;
  _has_bits_[0] &= ~0x00000020u;
}
inline ::google::protobuf::uint32 MoneroTransactionInitRequest_MoneroTransactionData::num_inputs() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.monero.MoneroTransactionInitRequest.MoneroTransactionData.num_inputs)
  return num_inputs_;
}
inline void MoneroTransactionInitRequest_MoneroTransactionData::set_num_inputs(::google::protobuf::uint32 value) {
  _has_bits_[0] |= 0x00000020u;
  num_inputs_ = value;
  // @@protoc_insertion_point(field_set:hw.trezor.messages.monero.MoneroTransactionInitRequest.MoneroTransactionData.num_inputs)
}

// optional uint32 mixin = 7;
inline bool MoneroTransactionInitRequest_MoneroTransactionData::has_mixin() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void MoneroTransactionInitRequest_MoneroTransactionData::clear_mixin() {
  mixin_ = 0u;
  _has_bits_[0] &= ~0x00000080u;
}
inline ::google::protobuf::uint32 MoneroTransactionInitRequest_MoneroTransactionData::mixin() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.monero.MoneroTransactionInitRequest.MoneroTransactionData.mixin)
  return mixin_;
}
inline void MoneroTransactionInitRequest_MoneroTransactionData::set_mixin(::google::protobuf::uint32 value) {
  _has_bits_[0] |= 0x00000080u;
  mixin_ = value;
  // @@protoc_insertion_point(field_set:hw.trezor.messages.monero.MoneroTransactionInitRequest.MoneroTransactionData.mixin)
}

// optional uint64 fee = 8;
inline bool MoneroTransactionInitRequest_MoneroTransactionData::has_fee() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void MoneroTransactionInitRequest_MoneroTransactionData::clear_fee() {
  fee_ = PROTOBUF_ULONGLONG(0);
  _has_bits_[0] &= ~0x00000040u;
}
inline ::google::protobuf::uint64 MoneroTransactionInitRequest_MoneroTransactionData::fee() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.monero.MoneroTransactionInitRequest.MoneroTransactionData.fee)
  return fee_;
}
inline void MoneroTransactionInitRequest_MoneroTransactionData::set_fee(::google::protobuf::uint64 value) {
  _has_bits_[0] |= 0x00000040u;
  fee_ = value;
  // @@protoc_insertion_point(field_set:hw.trezor.messages.monero.MoneroTransactionInitRequest.MoneroTransactionData.fee)
}

// optional uint32 account = 9;
inline bool MoneroTransactionInitRequest_MoneroTransactionData::has_account() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void MoneroTransactionInitRequest_MoneroTransactionData::clear_account() {
  account_ = 0u;
  _has_bits_[0] &= ~0x00000100u;
}
inline ::google::protobuf::uint32 MoneroTransactionInitRequest_MoneroTransactionData::account() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.monero.MoneroTransactionInitRequest.MoneroTransactionData.account)
  return account_;
}
inline void MoneroTransactionInitRequest_MoneroTransactionData::set_account(::google::protobuf::uint32 value) {
  _has_bits_[0] |= 0x00000100u;
  account_ = value;
  // @@protoc_insertion_point(field_set:hw.trezor.messages.monero.MoneroTransactionInitRequest.MoneroTransactionData.account)
}

// repeated uint32 minor_indices = 10;
inline int MoneroTransactionInitRequest_MoneroTransactionData::minor_indices_size() const {
  return minor_indices_.size();
}
inline void MoneroTransactionInitRequest_MoneroTransactionData::clear_minor_indices() {
  minor_indices_.Clear();
}
inline ::google::protobuf::uint32 MoneroTransactionInitRequest_MoneroTransactionData::minor_indices(int index) const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.monero.MoneroTransactionInitRequest.MoneroTransactionData.minor_indices)
  return minor_indices_.Get(index);
}
inline void MoneroTransactionInitRequest_MoneroTransactionData::set_minor_indices(int index, ::google::protobuf::uint32 value) {
  minor_indices_.Set(index, value);
  // @@protoc_insertion_point(field_set:hw.trezor.messages.monero.MoneroTransactionInitRequest.MoneroTransactionData.minor_indices)
}
inline void MoneroTransactionInitRequest_MoneroTransactionData::add_minor_indices(::google::protobuf::uint32 value) {
  minor_indices_.Add(value);
  // @@protoc_insertion_point(field_add:hw.trezor.messages.monero.MoneroTransactionInitRequest.MoneroTransactionData.minor_indices)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
MoneroTransactionInitRequest_MoneroTransactionData::minor_indices() const {
  // @@protoc_insertion_point(field_list:hw.trezor.messages.monero.MoneroTransactionInitRequest.MoneroTransactionData.minor_indices)
  return minor_indices_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
MoneroTransactionInitRequest_MoneroTransactionData::mutable_minor_indices() {
  // @@protoc_insertion_point(field_mutable_list:hw.trezor.messages.monero.MoneroTransactionInitRequest.MoneroTransactionData.minor_indices)
  return &minor_indices_;
}

// optional .hw.trezor.messages.monero.MoneroTransactionRsigData rsig_data = 11;
inline bool MoneroTransactionInitRequest_MoneroTransactionData::has_rsig_data() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void MoneroTransactionInitRequest_MoneroTransactionData::clear_rsig_data() {
  if (rsig_data_ != nullptr) rsig_data_->Clear();
  _has_bits_[0] &= ~0x00000004u;
}
inline const ::hw::trezor::messages::monero::MoneroTransactionRsigData& MoneroTransactionInitRequest_MoneroTransactionData::rsig_data() const {
  const ::hw::trezor::messages::monero::MoneroTransactionRsigData* p = rsig_data_;
  // @@protoc_insertion_point(field_get:hw.trezor.messages.monero.MoneroTransactionInitRequest.MoneroTransactionData.rsig_data)
  return p != nullptr ? *p : *reinterpret_cast<const ::hw::trezor::messages::monero::MoneroTransactionRsigData*>(
      &::hw::trezor::messages::monero::_MoneroTransactionRsigData_default_instance_);
}
inline ::hw::trezor::messages::monero::MoneroTransactionRsigData* MoneroTransactionInitRequest_MoneroTransactionData::release_rsig_data() {
  // @@protoc_insertion_point(field_release:hw.trezor.messages.monero.MoneroTransactionInitRequest.MoneroTransactionData.rsig_data)
  _has_bits_[0] &= ~0x00000004u;
  ::hw::trezor::messages::monero::MoneroTransactionRsigData* temp = rsig_data_;
  rsig_data_ = nullptr;
  return temp;
}
inline ::hw::trezor::messages::monero::MoneroTransactionRsigData* MoneroTransactionInitRequest_MoneroTransactionData::mutable_rsig_data() {
  _has_bits_[0] |= 0x00000004u;
  if (rsig_data_ == nullptr) {
    auto* p = CreateMaybeMessage<::hw::trezor::messages::monero::MoneroTransactionRsigData>(GetArenaNoVirtual());
    rsig_data_ = p;
  }
  // @@protoc_insertion_point(field_mutable:hw.trezor.messages.monero.MoneroTransactionInitRequest.MoneroTransactionData.rsig_data)
  return rsig_data_;
}
inline void MoneroTransactionInitRequest_MoneroTransactionData::set_allocated_rsig_data(::hw::trezor::messages::monero::MoneroTransactionRsigData* rsig_data) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete rsig_data_;
  }
  if (rsig_data) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      rsig_data = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, rsig_data, submessage_arena);
    }
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  rsig_data_ = rsig_data;
  // @@protoc_insertion_point(field_set_allocated:hw.trezor.messages.monero.MoneroTransactionInitRequest.MoneroTransactionData.rsig_data)
}

// repeated uint32 integrated_indices = 12;
inline int MoneroTransactionInitRequest_MoneroTransactionData::integrated_indices_size() const {
  return integrated_indices_.size();
}
inline void MoneroTransactionInitRequest_MoneroTransactionData::clear_integrated_indices() {
  integrated_indices_.Clear();
}
inline ::google::protobuf::uint32 MoneroTransactionInitRequest_MoneroTransactionData::integrated_indices(int index) const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.monero.MoneroTransactionInitRequest.MoneroTransactionData.integrated_indices)
  return integrated_indices_.Get(index);
}
inline void MoneroTransactionInitRequest_MoneroTransactionData::set_integrated_indices(int index, ::google::protobuf::uint32 value) {
  integrated_indices_.Set(index, value);
  // @@protoc_insertion_point(field_set:hw.trezor.messages.monero.MoneroTransactionInitRequest.MoneroTransactionData.integrated_indices)
}
inline void MoneroTransactionInitRequest_MoneroTransactionData::add_integrated_indices(::google::protobuf::uint32 value) {
  integrated_indices_.Add(value);
  // @@protoc_insertion_point(field_add:hw.trezor.messages.monero.MoneroTransactionInitRequest.MoneroTransactionData.integrated_indices)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
MoneroTransactionInitRequest_MoneroTransactionData::integrated_indices() const {
  // @@protoc_insertion_point(field_list:hw.trezor.messages.monero.MoneroTransactionInitRequest.MoneroTransactionData.integrated_indices)
  return integrated_indices_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
MoneroTransactionInitRequest_MoneroTransactionData::mutable_integrated_indices() {
  // @@protoc_insertion_point(field_mutable_list:hw.trezor.messages.monero.MoneroTransactionInitRequest.MoneroTransactionData.integrated_indices)
  return &integrated_indices_;
}

// -------------------------------------------------------------------

// MoneroTransactionInitRequest

// optional uint32 version = 1;
inline bool MoneroTransactionInitRequest::has_version() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void MoneroTransactionInitRequest::clear_version() {
  version_ = 0u;
  _has_bits_[0] &= ~0x00000002u;
}
inline ::google::protobuf::uint32 MoneroTransactionInitRequest::version() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.monero.MoneroTransactionInitRequest.version)
  return version_;
}
inline void MoneroTransactionInitRequest::set_version(::google::protobuf::uint32 value) {
  _has_bits_[0] |= 0x00000002u;
  version_ = value;
  // @@protoc_insertion_point(field_set:hw.trezor.messages.monero.MoneroTransactionInitRequest.version)
}

// repeated uint32 address_n = 2;
inline int MoneroTransactionInitRequest::address_n_size() const {
  return address_n_.size();
}
inline void MoneroTransactionInitRequest::clear_address_n() {
  address_n_.Clear();
}
inline ::google::protobuf::uint32 MoneroTransactionInitRequest::address_n(int index) const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.monero.MoneroTransactionInitRequest.address_n)
  return address_n_.Get(index);
}
inline void MoneroTransactionInitRequest::set_address_n(int index, ::google::protobuf::uint32 value) {
  address_n_.Set(index, value);
  // @@protoc_insertion_point(field_set:hw.trezor.messages.monero.MoneroTransactionInitRequest.address_n)
}
inline void MoneroTransactionInitRequest::add_address_n(::google::protobuf::uint32 value) {
  address_n_.Add(value);
  // @@protoc_insertion_point(field_add:hw.trezor.messages.monero.MoneroTransactionInitRequest.address_n)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
MoneroTransactionInitRequest::address_n() const {
  // @@protoc_insertion_point(field_list:hw.trezor.messages.monero.MoneroTransactionInitRequest.address_n)
  return address_n_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
MoneroTransactionInitRequest::mutable_address_n() {
  // @@protoc_insertion_point(field_mutable_list:hw.trezor.messages.monero.MoneroTransactionInitRequest.address_n)
  return &address_n_;
}

// optional uint32 network_type = 3;
inline bool MoneroTransactionInitRequest::has_network_type() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void MoneroTransactionInitRequest::clear_network_type() {
  network_type_ = 0u;
  _has_bits_[0] &= ~0x00000004u;
}
inline ::google::protobuf::uint32 MoneroTransactionInitRequest::network_type() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.monero.MoneroTransactionInitRequest.network_type)
  return network_type_;
}
inline void MoneroTransactionInitRequest::set_network_type(::google::protobuf::uint32 value) {
  _has_bits_[0] |= 0x00000004u;
  network_type_ = value;
  // @@protoc_insertion_point(field_set:hw.trezor.messages.monero.MoneroTransactionInitRequest.network_type)
}

// optional .hw.trezor.messages.monero.MoneroTransactionInitRequest.MoneroTransactionData tsx_data = 4;
inline bool MoneroTransactionInitRequest::has_tsx_data() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MoneroTransactionInitRequest::clear_tsx_data() {
  if (tsx_data_ != nullptr) tsx_data_->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::hw::trezor::messages::monero::MoneroTransactionInitRequest_MoneroTransactionData& MoneroTransactionInitRequest::tsx_data() const {
  const ::hw::trezor::messages::monero::MoneroTransactionInitRequest_MoneroTransactionData* p = tsx_data_;
  // @@protoc_insertion_point(field_get:hw.trezor.messages.monero.MoneroTransactionInitRequest.tsx_data)
  return p != nullptr ? *p : *reinterpret_cast<const ::hw::trezor::messages::monero::MoneroTransactionInitRequest_MoneroTransactionData*>(
      &::hw::trezor::messages::monero::_MoneroTransactionInitRequest_MoneroTransactionData_default_instance_);
}
inline ::hw::trezor::messages::monero::MoneroTransactionInitRequest_MoneroTransactionData* MoneroTransactionInitRequest::release_tsx_data() {
  // @@protoc_insertion_point(field_release:hw.trezor.messages.monero.MoneroTransactionInitRequest.tsx_data)
  _has_bits_[0] &= ~0x00000001u;
  ::hw::trezor::messages::monero::MoneroTransactionInitRequest_MoneroTransactionData* temp = tsx_data_;
  tsx_data_ = nullptr;
  return temp;
}
inline ::hw::trezor::messages::monero::MoneroTransactionInitRequest_MoneroTransactionData* MoneroTransactionInitRequest::mutable_tsx_data() {
  _has_bits_[0] |= 0x00000001u;
  if (tsx_data_ == nullptr) {
    auto* p = CreateMaybeMessage<::hw::trezor::messages::monero::MoneroTransactionInitRequest_MoneroTransactionData>(GetArenaNoVirtual());
    tsx_data_ = p;
  }
  // @@protoc_insertion_point(field_mutable:hw.trezor.messages.monero.MoneroTransactionInitRequest.tsx_data)
  return tsx_data_;
}
inline void MoneroTransactionInitRequest::set_allocated_tsx_data(::hw::trezor::messages::monero::MoneroTransactionInitRequest_MoneroTransactionData* tsx_data) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete tsx_data_;
  }
  if (tsx_data) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      tsx_data = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, tsx_data, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  tsx_data_ = tsx_data;
  // @@protoc_insertion_point(field_set_allocated:hw.trezor.messages.monero.MoneroTransactionInitRequest.tsx_data)
}

// -------------------------------------------------------------------

// MoneroTransactionInitAck

// repeated bytes hmacs = 1;
inline int MoneroTransactionInitAck::hmacs_size() const {
  return hmacs_.size();
}
inline void MoneroTransactionInitAck::clear_hmacs() {
  hmacs_.Clear();
}
inline const ::std::string& MoneroTransactionInitAck::hmacs(int index) const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.monero.MoneroTransactionInitAck.hmacs)
  return hmacs_.Get(index);
}
inline ::std::string* MoneroTransactionInitAck::mutable_hmacs(int index) {
  // @@protoc_insertion_point(field_mutable:hw.trezor.messages.monero.MoneroTransactionInitAck.hmacs)
  return hmacs_.Mutable(index);
}
inline void MoneroTransactionInitAck::set_hmacs(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:hw.trezor.messages.monero.MoneroTransactionInitAck.hmacs)
  hmacs_.Mutable(index)->assign(value);
}
#if LANG_CXX11
inline void MoneroTransactionInitAck::set_hmacs(int index, ::std::string&& value) {
  // @@protoc_insertion_point(field_set:hw.trezor.messages.monero.MoneroTransactionInitAck.hmacs)
  hmacs_.Mutable(index)->assign(std::move(value));
}
#endif
inline void MoneroTransactionInitAck::set_hmacs(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  hmacs_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:hw.trezor.messages.monero.MoneroTransactionInitAck.hmacs)
}
inline void MoneroTransactionInitAck::set_hmacs(int index, const void* value, size_t size) {
  hmacs_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:hw.trezor.messages.monero.MoneroTransactionInitAck.hmacs)
}
inline ::std::string* MoneroTransactionInitAck::add_hmacs() {
  // @@protoc_insertion_point(field_add_mutable:hw.trezor.messages.monero.MoneroTransactionInitAck.hmacs)
  return hmacs_.Add();
}
inline void MoneroTransactionInitAck::add_hmacs(const ::std::string& value) {
  hmacs_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:hw.trezor.messages.monero.MoneroTransactionInitAck.hmacs)
}
#if LANG_CXX11
inline void MoneroTransactionInitAck::add_hmacs(::std::string&& value) {
  hmacs_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:hw.trezor.messages.monero.MoneroTransactionInitAck.hmacs)
}
#endif
inline void MoneroTransactionInitAck::add_hmacs(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  hmacs_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:hw.trezor.messages.monero.MoneroTransactionInitAck.hmacs)
}
inline void MoneroTransactionInitAck::add_hmacs(const void* value, size_t size) {
  hmacs_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:hw.trezor.messages.monero.MoneroTransactionInitAck.hmacs)
}
inline const ::google::protobuf::RepeatedPtrField<::std::string>&
MoneroTransactionInitAck::hmacs() const {
  // @@protoc_insertion_point(field_list:hw.trezor.messages.monero.MoneroTransactionInitAck.hmacs)
  return hmacs_;
}
inline ::google::protobuf::RepeatedPtrField<::std::string>*
MoneroTransactionInitAck::mutable_hmacs() {
  // @@protoc_insertion_point(field_mutable_list:hw.trezor.messages.monero.MoneroTransactionInitAck.hmacs)
  return &hmacs_;
}

// optional .hw.trezor.messages.monero.MoneroTransactionRsigData rsig_data = 2;
inline bool MoneroTransactionInitAck::has_rsig_data() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MoneroTransactionInitAck::clear_rsig_data() {
  if (rsig_data_ != nullptr) rsig_data_->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::hw::trezor::messages::monero::MoneroTransactionRsigData& MoneroTransactionInitAck::rsig_data() const {
  const ::hw::trezor::messages::monero::MoneroTransactionRsigData* p = rsig_data_;
  // @@protoc_insertion_point(field_get:hw.trezor.messages.monero.MoneroTransactionInitAck.rsig_data)
  return p != nullptr ? *p : *reinterpret_cast<const ::hw::trezor::messages::monero::MoneroTransactionRsigData*>(
      &::hw::trezor::messages::monero::_MoneroTransactionRsigData_default_instance_);
}
inline ::hw::trezor::messages::monero::MoneroTransactionRsigData* MoneroTransactionInitAck::release_rsig_data() {
  // @@protoc_insertion_point(field_release:hw.trezor.messages.monero.MoneroTransactionInitAck.rsig_data)
  _has_bits_[0] &= ~0x00000001u;
  ::hw::trezor::messages::monero::MoneroTransactionRsigData* temp = rsig_data_;
  rsig_data_ = nullptr;
  return temp;
}
inline ::hw::trezor::messages::monero::MoneroTransactionRsigData* MoneroTransactionInitAck::mutable_rsig_data() {
  _has_bits_[0] |= 0x00000001u;
  if (rsig_data_ == nullptr) {
    auto* p = CreateMaybeMessage<::hw::trezor::messages::monero::MoneroTransactionRsigData>(GetArenaNoVirtual());
    rsig_data_ = p;
  }
  // @@protoc_insertion_point(field_mutable:hw.trezor.messages.monero.MoneroTransactionInitAck.rsig_data)
  return rsig_data_;
}
inline void MoneroTransactionInitAck::set_allocated_rsig_data(::hw::trezor::messages::monero::MoneroTransactionRsigData* rsig_data) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete rsig_data_;
  }
  if (rsig_data) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      rsig_data = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, rsig_data, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  rsig_data_ = rsig_data;
  // @@protoc_insertion_point(field_set_allocated:hw.trezor.messages.monero.MoneroTransactionInitAck.rsig_data)
}

// -------------------------------------------------------------------

// MoneroTransactionSetInputRequest

// optional .hw.trezor.messages.monero.MoneroTransactionSourceEntry src_entr = 1;
inline bool MoneroTransactionSetInputRequest::has_src_entr() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MoneroTransactionSetInputRequest::clear_src_entr() {
  if (src_entr_ != nullptr) src_entr_->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::hw::trezor::messages::monero::MoneroTransactionSourceEntry& MoneroTransactionSetInputRequest::src_entr() const {
  const ::hw::trezor::messages::monero::MoneroTransactionSourceEntry* p = src_entr_;
  // @@protoc_insertion_point(field_get:hw.trezor.messages.monero.MoneroTransactionSetInputRequest.src_entr)
  return p != nullptr ? *p : *reinterpret_cast<const ::hw::trezor::messages::monero::MoneroTransactionSourceEntry*>(
      &::hw::trezor::messages::monero::_MoneroTransactionSourceEntry_default_instance_);
}
inline ::hw::trezor::messages::monero::MoneroTransactionSourceEntry* MoneroTransactionSetInputRequest::release_src_entr() {
  // @@protoc_insertion_point(field_release:hw.trezor.messages.monero.MoneroTransactionSetInputRequest.src_entr)
  _has_bits_[0] &= ~0x00000001u;
  ::hw::trezor::messages::monero::MoneroTransactionSourceEntry* temp = src_entr_;
  src_entr_ = nullptr;
  return temp;
}
inline ::hw::trezor::messages::monero::MoneroTransactionSourceEntry* MoneroTransactionSetInputRequest::mutable_src_entr() {
  _has_bits_[0] |= 0x00000001u;
  if (src_entr_ == nullptr) {
    auto* p = CreateMaybeMessage<::hw::trezor::messages::monero::MoneroTransactionSourceEntry>(GetArenaNoVirtual());
    src_entr_ = p;
  }
  // @@protoc_insertion_point(field_mutable:hw.trezor.messages.monero.MoneroTransactionSetInputRequest.src_entr)
  return src_entr_;
}
inline void MoneroTransactionSetInputRequest::set_allocated_src_entr(::hw::trezor::messages::monero::MoneroTransactionSourceEntry* src_entr) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete src_entr_;
  }
  if (src_entr) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      src_entr = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, src_entr, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  src_entr_ = src_entr;
  // @@protoc_insertion_point(field_set_allocated:hw.trezor.messages.monero.MoneroTransactionSetInputRequest.src_entr)
}

// -------------------------------------------------------------------

// MoneroTransactionSetInputAck

// optional bytes vini = 1;
inline bool MoneroTransactionSetInputAck::has_vini() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MoneroTransactionSetInputAck::clear_vini() {
  vini_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::std::string& MoneroTransactionSetInputAck::vini() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.monero.MoneroTransactionSetInputAck.vini)
  return vini_.GetNoArena();
}
inline void MoneroTransactionSetInputAck::set_vini(const ::std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  vini_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:hw.trezor.messages.monero.MoneroTransactionSetInputAck.vini)
}
#if LANG_CXX11
inline void MoneroTransactionSetInputAck::set_vini(::std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  vini_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:hw.trezor.messages.monero.MoneroTransactionSetInputAck.vini)
}
#endif
inline void MoneroTransactionSetInputAck::set_vini(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  vini_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:hw.trezor.messages.monero.MoneroTransactionSetInputAck.vini)
}
inline void MoneroTransactionSetInputAck::set_vini(const void* value, size_t size) {
  _has_bits_[0] |= 0x00000001u;
  vini_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:hw.trezor.messages.monero.MoneroTransactionSetInputAck.vini)
}
inline ::std::string* MoneroTransactionSetInputAck::mutable_vini() {
  _has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_mutable:hw.trezor.messages.monero.MoneroTransactionSetInputAck.vini)
  return vini_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* MoneroTransactionSetInputAck::release_vini() {
  // @@protoc_insertion_point(field_release:hw.trezor.messages.monero.MoneroTransactionSetInputAck.vini)
  if (!has_vini()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return vini_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void MoneroTransactionSetInputAck::set_allocated_vini(::std::string* vini) {
  if (vini != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  vini_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), vini);
  // @@protoc_insertion_point(field_set_allocated:hw.trezor.messages.monero.MoneroTransactionSetInputAck.vini)
}

// optional bytes vini_hmac = 2;
inline bool MoneroTransactionSetInputAck::has_vini_hmac() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void MoneroTransactionSetInputAck::clear_vini_hmac() {
  vini_hmac_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000002u;
}
inline const ::std::string& MoneroTransactionSetInputAck::vini_hmac() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.monero.MoneroTransactionSetInputAck.vini_hmac)
  return vini_hmac_.GetNoArena();
}
inline void MoneroTransactionSetInputAck::set_vini_hmac(const ::std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  vini_hmac_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:hw.trezor.messages.monero.MoneroTransactionSetInputAck.vini_hmac)
}
#if LANG_CXX11
inline void MoneroTransactionSetInputAck::set_vini_hmac(::std::string&& value) {
  _has_bits_[0] |= 0x00000002u;
  vini_hmac_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:hw.trezor.messages.monero.MoneroTransactionSetInputAck.vini_hmac)
}
#endif
inline void MoneroTransactionSetInputAck::set_vini_hmac(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000002u;
  vini_hmac_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:hw.trezor.messages.monero.MoneroTransactionSetInputAck.vini_hmac)
}
inline void MoneroTransactionSetInputAck::set_vini_hmac(const void* value, size_t size) {
  _has_bits_[0] |= 0x00000002u;
  vini_hmac_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:hw.trezor.messages.monero.MoneroTransactionSetInputAck.vini_hmac)
}
inline ::std::string* MoneroTransactionSetInputAck::mutable_vini_hmac() {
  _has_bits_[0] |= 0x00000002u;
  // @@protoc_insertion_point(field_mutable:hw.trezor.messages.monero.MoneroTransactionSetInputAck.vini_hmac)
  return vini_hmac_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* MoneroTransactionSetInputAck::release_vini_hmac() {
  // @@protoc_insertion_point(field_release:hw.trezor.messages.monero.MoneroTransactionSetInputAck.vini_hmac)
  if (!has_vini_hmac()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  return vini_hmac_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void MoneroTransactionSetInputAck::set_allocated_vini_hmac(::std::string* vini_hmac) {
  if (vini_hmac != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  vini_hmac_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), vini_hmac);
  // @@protoc_insertion_point(field_set_allocated:hw.trezor.messages.monero.MoneroTransactionSetInputAck.vini_hmac)
}

// optional bytes pseudo_out = 3;
inline bool MoneroTransactionSetInputAck::has_pseudo_out() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void MoneroTransactionSetInputAck::clear_pseudo_out() {
  pseudo_out_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000004u;
}
inline const ::std::string& MoneroTransactionSetInputAck::pseudo_out() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.monero.MoneroTransactionSetInputAck.pseudo_out)
  return pseudo_out_.GetNoArena();
}
inline void MoneroTransactionSetInputAck::set_pseudo_out(const ::std::string& value) {
  _has_bits_[0] |= 0x00000004u;
  pseudo_out_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:hw.trezor.messages.monero.MoneroTransactionSetInputAck.pseudo_out)
}
#if LANG_CXX11
inline void MoneroTransactionSetInputAck::set_pseudo_out(::std::string&& value) {
  _has_bits_[0] |= 0x00000004u;
  pseudo_out_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:hw.trezor.messages.monero.MoneroTransactionSetInputAck.pseudo_out)
}
#endif
inline void MoneroTransactionSetInputAck::set_pseudo_out(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000004u;
  pseudo_out_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:hw.trezor.messages.monero.MoneroTransactionSetInputAck.pseudo_out)
}
inline void MoneroTransactionSetInputAck::set_pseudo_out(const void* value, size_t size) {
  _has_bits_[0] |= 0x00000004u;
  pseudo_out_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:hw.trezor.messages.monero.MoneroTransactionSetInputAck.pseudo_out)
}
inline ::std::string* MoneroTransactionSetInputAck::mutable_pseudo_out() {
  _has_bits_[0] |= 0x00000004u;
  // @@protoc_insertion_point(field_mutable:hw.trezor.messages.monero.MoneroTransactionSetInputAck.pseudo_out)
  return pseudo_out_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* MoneroTransactionSetInputAck::release_pseudo_out() {
  // @@protoc_insertion_point(field_release:hw.trezor.messages.monero.MoneroTransactionSetInputAck.pseudo_out)
  if (!has_pseudo_out()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000004u;
  return pseudo_out_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void MoneroTransactionSetInputAck::set_allocated_pseudo_out(::std::string* pseudo_out) {
  if (pseudo_out != nullptr) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  pseudo_out_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), pseudo_out);
  // @@protoc_insertion_point(field_set_allocated:hw.trezor.messages.monero.MoneroTransactionSetInputAck.pseudo_out)
}

// optional bytes pseudo_out_hmac = 4;
inline bool MoneroTransactionSetInputAck::has_pseudo_out_hmac() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void MoneroTransactionSetInputAck::clear_pseudo_out_hmac() {
  pseudo_out_hmac_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000008u;
}
inline const ::std::string& MoneroTransactionSetInputAck::pseudo_out_hmac() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.monero.MoneroTransactionSetInputAck.pseudo_out_hmac)
  return pseudo_out_hmac_.GetNoArena();
}
inline void MoneroTransactionSetInputAck::set_pseudo_out_hmac(const ::std::string& value) {
  _has_bits_[0] |= 0x00000008u;
  pseudo_out_hmac_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:hw.trezor.messages.monero.MoneroTransactionSetInputAck.pseudo_out_hmac)
}
#if LANG_CXX11
inline void MoneroTransactionSetInputAck::set_pseudo_out_hmac(::std::string&& value) {
  _has_bits_[0] |= 0x00000008u;
  pseudo_out_hmac_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:hw.trezor.messages.monero.MoneroTransactionSetInputAck.pseudo_out_hmac)
}
#endif
inline void MoneroTransactionSetInputAck::set_pseudo_out_hmac(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000008u;
  pseudo_out_hmac_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:hw.trezor.messages.monero.MoneroTransactionSetInputAck.pseudo_out_hmac)
}
inline void MoneroTransactionSetInputAck::set_pseudo_out_hmac(const void* value, size_t size) {
  _has_bits_[0] |= 0x00000008u;
  pseudo_out_hmac_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:hw.trezor.messages.monero.MoneroTransactionSetInputAck.pseudo_out_hmac)
}
inline ::std::string* MoneroTransactionSetInputAck::mutable_pseudo_out_hmac() {
  _has_bits_[0] |= 0x00000008u;
  // @@protoc_insertion_point(field_mutable:hw.trezor.messages.monero.MoneroTransactionSetInputAck.pseudo_out_hmac)
  return pseudo_out_hmac_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* MoneroTransactionSetInputAck::release_pseudo_out_hmac() {
  // @@protoc_insertion_point(field_release:hw.trezor.messages.monero.MoneroTransactionSetInputAck.pseudo_out_hmac)
  if (!has_pseudo_out_hmac()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000008u;
  return pseudo_out_hmac_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void MoneroTransactionSetInputAck::set_allocated_pseudo_out_hmac(::std::string* pseudo_out_hmac) {
  if (pseudo_out_hmac != nullptr) {
    _has_bits_[0] |= 0x00000008u;
  } else {
    _has_bits_[0] &= ~0x00000008u;
  }
  pseudo_out_hmac_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), pseudo_out_hmac);
  // @@protoc_insertion_point(field_set_allocated:hw.trezor.messages.monero.MoneroTransactionSetInputAck.pseudo_out_hmac)
}

// optional bytes pseudo_out_alpha = 5;
inline bool MoneroTransactionSetInputAck::has_pseudo_out_alpha() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void MoneroTransactionSetInputAck::clear_pseudo_out_alpha() {
  pseudo_out_alpha_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000010u;
}
inline const ::std::string& MoneroTransactionSetInputAck::pseudo_out_alpha() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.monero.MoneroTransactionSetInputAck.pseudo_out_alpha)
  return pseudo_out_alpha_.GetNoArena();
}
inline void MoneroTransactionSetInputAck::set_pseudo_out_alpha(const ::std::string& value) {
  _has_bits_[0] |= 0x00000010u;
  pseudo_out_alpha_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:hw.trezor.messages.monero.MoneroTransactionSetInputAck.pseudo_out_alpha)
}
#if LANG_CXX11
inline void MoneroTransactionSetInputAck::set_pseudo_out_alpha(::std::string&& value) {
  _has_bits_[0] |= 0x00000010u;
  pseudo_out_alpha_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:hw.trezor.messages.monero.MoneroTransactionSetInputAck.pseudo_out_alpha)
}
#endif
inline void MoneroTransactionSetInputAck::set_pseudo_out_alpha(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000010u;
  pseudo_out_alpha_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:hw.trezor.messages.monero.MoneroTransactionSetInputAck.pseudo_out_alpha)
}
inline void MoneroTransactionSetInputAck::set_pseudo_out_alpha(const void* value, size_t size) {
  _has_bits_[0] |= 0x00000010u;
  pseudo_out_alpha_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:hw.trezor.messages.monero.MoneroTransactionSetInputAck.pseudo_out_alpha)
}
inline ::std::string* MoneroTransactionSetInputAck::mutable_pseudo_out_alpha() {
  _has_bits_[0] |= 0x00000010u;
  // @@protoc_insertion_point(field_mutable:hw.trezor.messages.monero.MoneroTransactionSetInputAck.pseudo_out_alpha)
  return pseudo_out_alpha_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* MoneroTransactionSetInputAck::release_pseudo_out_alpha() {
  // @@protoc_insertion_point(field_release:hw.trezor.messages.monero.MoneroTransactionSetInputAck.pseudo_out_alpha)
  if (!has_pseudo_out_alpha()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000010u;
  return pseudo_out_alpha_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void MoneroTransactionSetInputAck::set_allocated_pseudo_out_alpha(::std::string* pseudo_out_alpha) {
  if (pseudo_out_alpha != nullptr) {
    _has_bits_[0] |= 0x00000010u;
  } else {
    _has_bits_[0] &= ~0x00000010u;
  }
  pseudo_out_alpha_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), pseudo_out_alpha);
  // @@protoc_insertion_point(field_set_allocated:hw.trezor.messages.monero.MoneroTransactionSetInputAck.pseudo_out_alpha)
}

// optional bytes spend_key = 6;
inline bool MoneroTransactionSetInputAck::has_spend_key() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void MoneroTransactionSetInputAck::clear_spend_key() {
  spend_key_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000020u;
}
inline const ::std::string& MoneroTransactionSetInputAck::spend_key() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.monero.MoneroTransactionSetInputAck.spend_key)
  return spend_key_.GetNoArena();
}
inline void MoneroTransactionSetInputAck::set_spend_key(const ::std::string& value) {
  _has_bits_[0] |= 0x00000020u;
  spend_key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:hw.trezor.messages.monero.MoneroTransactionSetInputAck.spend_key)
}
#if LANG_CXX11
inline void MoneroTransactionSetInputAck::set_spend_key(::std::string&& value) {
  _has_bits_[0] |= 0x00000020u;
  spend_key_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:hw.trezor.messages.monero.MoneroTransactionSetInputAck.spend_key)
}
#endif
inline void MoneroTransactionSetInputAck::set_spend_key(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000020u;
  spend_key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:hw.trezor.messages.monero.MoneroTransactionSetInputAck.spend_key)
}
inline void MoneroTransactionSetInputAck::set_spend_key(const void* value, size_t size) {
  _has_bits_[0] |= 0x00000020u;
  spend_key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:hw.trezor.messages.monero.MoneroTransactionSetInputAck.spend_key)
}
inline ::std::string* MoneroTransactionSetInputAck::mutable_spend_key() {
  _has_bits_[0] |= 0x00000020u;
  // @@protoc_insertion_point(field_mutable:hw.trezor.messages.monero.MoneroTransactionSetInputAck.spend_key)
  return spend_key_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* MoneroTransactionSetInputAck::release_spend_key() {
  // @@protoc_insertion_point(field_release:hw.trezor.messages.monero.MoneroTransactionSetInputAck.spend_key)
  if (!has_spend_key()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000020u;
  return spend_key_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void MoneroTransactionSetInputAck::set_allocated_spend_key(::std::string* spend_key) {
  if (spend_key != nullptr) {
    _has_bits_[0] |= 0x00000020u;
  } else {
    _has_bits_[0] &= ~0x00000020u;
  }
  spend_key_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), spend_key);
  // @@protoc_insertion_point(field_set_allocated:hw.trezor.messages.monero.MoneroTransactionSetInputAck.spend_key)
}

// -------------------------------------------------------------------

// MoneroTransactionInputsPermutationRequest

// repeated uint32 perm = 1;
inline int MoneroTransactionInputsPermutationRequest::perm_size() const {
  return perm_.size();
}
inline void MoneroTransactionInputsPermutationRequest::clear_perm() {
  perm_.Clear();
}
inline ::google::protobuf::uint32 MoneroTransactionInputsPermutationRequest::perm(int index) const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.monero.MoneroTransactionInputsPermutationRequest.perm)
  return perm_.Get(index);
}
inline void MoneroTransactionInputsPermutationRequest::set_perm(int index, ::google::protobuf::uint32 value) {
  perm_.Set(index, value);
  // @@protoc_insertion_point(field_set:hw.trezor.messages.monero.MoneroTransactionInputsPermutationRequest.perm)
}
inline void MoneroTransactionInputsPermutationRequest::add_perm(::google::protobuf::uint32 value) {
  perm_.Add(value);
  // @@protoc_insertion_point(field_add:hw.trezor.messages.monero.MoneroTransactionInputsPermutationRequest.perm)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
MoneroTransactionInputsPermutationRequest::perm() const {
  // @@protoc_insertion_point(field_list:hw.trezor.messages.monero.MoneroTransactionInputsPermutationRequest.perm)
  return perm_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
MoneroTransactionInputsPermutationRequest::mutable_perm() {
  // @@protoc_insertion_point(field_mutable_list:hw.trezor.messages.monero.MoneroTransactionInputsPermutationRequest.perm)
  return &perm_;
}

// -------------------------------------------------------------------

// MoneroTransactionInputsPermutationAck

// -------------------------------------------------------------------

// MoneroTransactionInputViniRequest

// optional .hw.trezor.messages.monero.MoneroTransactionSourceEntry src_entr = 1;
inline bool MoneroTransactionInputViniRequest::has_src_entr() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void MoneroTransactionInputViniRequest::clear_src_entr() {
  if (src_entr_ != nullptr) src_entr_->Clear();
  _has_bits_[0] &= ~0x00000010u;
}
inline const ::hw::trezor::messages::monero::MoneroTransactionSourceEntry& MoneroTransactionInputViniRequest::src_entr() const {
  const ::hw::trezor::messages::monero::MoneroTransactionSourceEntry* p = src_entr_;
  // @@protoc_insertion_point(field_get:hw.trezor.messages.monero.MoneroTransactionInputViniRequest.src_entr)
  return p != nullptr ? *p : *reinterpret_cast<const ::hw::trezor::messages::monero::MoneroTransactionSourceEntry*>(
      &::hw::trezor::messages::monero::_MoneroTransactionSourceEntry_default_instance_);
}
inline ::hw::trezor::messages::monero::MoneroTransactionSourceEntry* MoneroTransactionInputViniRequest::release_src_entr() {
  // @@protoc_insertion_point(field_release:hw.trezor.messages.monero.MoneroTransactionInputViniRequest.src_entr)
  _has_bits_[0] &= ~0x00000010u;
  ::hw::trezor::messages::monero::MoneroTransactionSourceEntry* temp = src_entr_;
  src_entr_ = nullptr;
  return temp;
}
inline ::hw::trezor::messages::monero::MoneroTransactionSourceEntry* MoneroTransactionInputViniRequest::mutable_src_entr() {
  _has_bits_[0] |= 0x00000010u;
  if (src_entr_ == nullptr) {
    auto* p = CreateMaybeMessage<::hw::trezor::messages::monero::MoneroTransactionSourceEntry>(GetArenaNoVirtual());
    src_entr_ = p;
  }
  // @@protoc_insertion_point(field_mutable:hw.trezor.messages.monero.MoneroTransactionInputViniRequest.src_entr)
  return src_entr_;
}
inline void MoneroTransactionInputViniRequest::set_allocated_src_entr(::hw::trezor::messages::monero::MoneroTransactionSourceEntry* src_entr) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete src_entr_;
  }
  if (src_entr) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      src_entr = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, src_entr, submessage_arena);
    }
    _has_bits_[0] |= 0x00000010u;
  } else {
    _has_bits_[0] &= ~0x00000010u;
  }
  src_entr_ = src_entr;
  // @@protoc_insertion_point(field_set_allocated:hw.trezor.messages.monero.MoneroTransactionInputViniRequest.src_entr)
}

// optional bytes vini = 2;
inline bool MoneroTransactionInputViniRequest::has_vini() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MoneroTransactionInputViniRequest::clear_vini() {
  vini_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::std::string& MoneroTransactionInputViniRequest::vini() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.monero.MoneroTransactionInputViniRequest.vini)
  return vini_.GetNoArena();
}
inline void MoneroTransactionInputViniRequest::set_vini(const ::std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  vini_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:hw.trezor.messages.monero.MoneroTransactionInputViniRequest.vini)
}
#if LANG_CXX11
inline void MoneroTransactionInputViniRequest::set_vini(::std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  vini_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:hw.trezor.messages.monero.MoneroTransactionInputViniRequest.vini)
}
#endif
inline void MoneroTransactionInputViniRequest::set_vini(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  vini_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:hw.trezor.messages.monero.MoneroTransactionInputViniRequest.vini)
}
inline void MoneroTransactionInputViniRequest::set_vini(const void* value, size_t size) {
  _has_bits_[0] |= 0x00000001u;
  vini_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:hw.trezor.messages.monero.MoneroTransactionInputViniRequest.vini)
}
inline ::std::string* MoneroTransactionInputViniRequest::mutable_vini() {
  _has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_mutable:hw.trezor.messages.monero.MoneroTransactionInputViniRequest.vini)
  return vini_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* MoneroTransactionInputViniRequest::release_vini() {
  // @@protoc_insertion_point(field_release:hw.trezor.messages.monero.MoneroTransactionInputViniRequest.vini)
  if (!has_vini()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return vini_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void MoneroTransactionInputViniRequest::set_allocated_vini(::std::string* vini) {
  if (vini != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  vini_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), vini);
  // @@protoc_insertion_point(field_set_allocated:hw.trezor.messages.monero.MoneroTransactionInputViniRequest.vini)
}

// optional bytes vini_hmac = 3;
inline bool MoneroTransactionInputViniRequest::has_vini_hmac() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void MoneroTransactionInputViniRequest::clear_vini_hmac() {
  vini_hmac_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000002u;
}
inline const ::std::string& MoneroTransactionInputViniRequest::vini_hmac() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.monero.MoneroTransactionInputViniRequest.vini_hmac)
  return vini_hmac_.GetNoArena();
}
inline void MoneroTransactionInputViniRequest::set_vini_hmac(const ::std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  vini_hmac_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:hw.trezor.messages.monero.MoneroTransactionInputViniRequest.vini_hmac)
}
#if LANG_CXX11
inline void MoneroTransactionInputViniRequest::set_vini_hmac(::std::string&& value) {
  _has_bits_[0] |= 0x00000002u;
  vini_hmac_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:hw.trezor.messages.monero.MoneroTransactionInputViniRequest.vini_hmac)
}
#endif
inline void MoneroTransactionInputViniRequest::set_vini_hmac(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000002u;
  vini_hmac_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:hw.trezor.messages.monero.MoneroTransactionInputViniRequest.vini_hmac)
}
inline void MoneroTransactionInputViniRequest::set_vini_hmac(const void* value, size_t size) {
  _has_bits_[0] |= 0x00000002u;
  vini_hmac_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:hw.trezor.messages.monero.MoneroTransactionInputViniRequest.vini_hmac)
}
inline ::std::string* MoneroTransactionInputViniRequest::mutable_vini_hmac() {
  _has_bits_[0] |= 0x00000002u;
  // @@protoc_insertion_point(field_mutable:hw.trezor.messages.monero.MoneroTransactionInputViniRequest.vini_hmac)
  return vini_hmac_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* MoneroTransactionInputViniRequest::release_vini_hmac() {
  // @@protoc_insertion_point(field_release:hw.trezor.messages.monero.MoneroTransactionInputViniRequest.vini_hmac)
  if (!has_vini_hmac()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  return vini_hmac_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void MoneroTransactionInputViniRequest::set_allocated_vini_hmac(::std::string* vini_hmac) {
  if (vini_hmac != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  vini_hmac_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), vini_hmac);
  // @@protoc_insertion_point(field_set_allocated:hw.trezor.messages.monero.MoneroTransactionInputViniRequest.vini_hmac)
}

// optional bytes pseudo_out = 4;
inline bool MoneroTransactionInputViniRequest::has_pseudo_out() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void MoneroTransactionInputViniRequest::clear_pseudo_out() {
  pseudo_out_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000004u;
}
inline const ::std::string& MoneroTransactionInputViniRequest::pseudo_out() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.monero.MoneroTransactionInputViniRequest.pseudo_out)
  return pseudo_out_.GetNoArena();
}
inline void MoneroTransactionInputViniRequest::set_pseudo_out(const ::std::string& value) {
  _has_bits_[0] |= 0x00000004u;
  pseudo_out_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:hw.trezor.messages.monero.MoneroTransactionInputViniRequest.pseudo_out)
}
#if LANG_CXX11
inline void MoneroTransactionInputViniRequest::set_pseudo_out(::std::string&& value) {
  _has_bits_[0] |= 0x00000004u;
  pseudo_out_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:hw.trezor.messages.monero.MoneroTransactionInputViniRequest.pseudo_out)
}
#endif
inline void MoneroTransactionInputViniRequest::set_pseudo_out(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000004u;
  pseudo_out_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:hw.trezor.messages.monero.MoneroTransactionInputViniRequest.pseudo_out)
}
inline void MoneroTransactionInputViniRequest::set_pseudo_out(const void* value, size_t size) {
  _has_bits_[0] |= 0x00000004u;
  pseudo_out_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:hw.trezor.messages.monero.MoneroTransactionInputViniRequest.pseudo_out)
}
inline ::std::string* MoneroTransactionInputViniRequest::mutable_pseudo_out() {
  _has_bits_[0] |= 0x00000004u;
  // @@protoc_insertion_point(field_mutable:hw.trezor.messages.monero.MoneroTransactionInputViniRequest.pseudo_out)
  return pseudo_out_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* MoneroTransactionInputViniRequest::release_pseudo_out() {
  // @@protoc_insertion_point(field_release:hw.trezor.messages.monero.MoneroTransactionInputViniRequest.pseudo_out)
  if (!has_pseudo_out()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000004u;
  return pseudo_out_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void MoneroTransactionInputViniRequest::set_allocated_pseudo_out(::std::string* pseudo_out) {
  if (pseudo_out != nullptr) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  pseudo_out_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), pseudo_out);
  // @@protoc_insertion_point(field_set_allocated:hw.trezor.messages.monero.MoneroTransactionInputViniRequest.pseudo_out)
}

// optional bytes pseudo_out_hmac = 5;
inline bool MoneroTransactionInputViniRequest::has_pseudo_out_hmac() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void MoneroTransactionInputViniRequest::clear_pseudo_out_hmac() {
  pseudo_out_hmac_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000008u;
}
inline const ::std::string& MoneroTransactionInputViniRequest::pseudo_out_hmac() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.monero.MoneroTransactionInputViniRequest.pseudo_out_hmac)
  return pseudo_out_hmac_.GetNoArena();
}
inline void MoneroTransactionInputViniRequest::set_pseudo_out_hmac(const ::std::string& value) {
  _has_bits_[0] |= 0x00000008u;
  pseudo_out_hmac_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:hw.trezor.messages.monero.MoneroTransactionInputViniRequest.pseudo_out_hmac)
}
#if LANG_CXX11
inline void MoneroTransactionInputViniRequest::set_pseudo_out_hmac(::std::string&& value) {
  _has_bits_[0] |= 0x00000008u;
  pseudo_out_hmac_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:hw.trezor.messages.monero.MoneroTransactionInputViniRequest.pseudo_out_hmac)
}
#endif
inline void MoneroTransactionInputViniRequest::set_pseudo_out_hmac(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000008u;
  pseudo_out_hmac_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:hw.trezor.messages.monero.MoneroTransactionInputViniRequest.pseudo_out_hmac)
}
inline void MoneroTransactionInputViniRequest::set_pseudo_out_hmac(const void* value, size_t size) {
  _has_bits_[0] |= 0x00000008u;
  pseudo_out_hmac_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:hw.trezor.messages.monero.MoneroTransactionInputViniRequest.pseudo_out_hmac)
}
inline ::std::string* MoneroTransactionInputViniRequest::mutable_pseudo_out_hmac() {
  _has_bits_[0] |= 0x00000008u;
  // @@protoc_insertion_point(field_mutable:hw.trezor.messages.monero.MoneroTransactionInputViniRequest.pseudo_out_hmac)
  return pseudo_out_hmac_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* MoneroTransactionInputViniRequest::release_pseudo_out_hmac() {
  // @@protoc_insertion_point(field_release:hw.trezor.messages.monero.MoneroTransactionInputViniRequest.pseudo_out_hmac)
  if (!has_pseudo_out_hmac()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000008u;
  return pseudo_out_hmac_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void MoneroTransactionInputViniRequest::set_allocated_pseudo_out_hmac(::std::string* pseudo_out_hmac) {
  if (pseudo_out_hmac != nullptr) {
    _has_bits_[0] |= 0x00000008u;
  } else {
    _has_bits_[0] &= ~0x00000008u;
  }
  pseudo_out_hmac_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), pseudo_out_hmac);
  // @@protoc_insertion_point(field_set_allocated:hw.trezor.messages.monero.MoneroTransactionInputViniRequest.pseudo_out_hmac)
}

// -------------------------------------------------------------------

// MoneroTransactionInputViniAck

// -------------------------------------------------------------------

// MoneroTransactionAllInputsSetRequest

// -------------------------------------------------------------------

// MoneroTransactionAllInputsSetAck

// optional .hw.trezor.messages.monero.MoneroTransactionRsigData rsig_data = 1;
inline bool MoneroTransactionAllInputsSetAck::has_rsig_data() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MoneroTransactionAllInputsSetAck::clear_rsig_data() {
  if (rsig_data_ != nullptr) rsig_data_->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::hw::trezor::messages::monero::MoneroTransactionRsigData& MoneroTransactionAllInputsSetAck::rsig_data() const {
  const ::hw::trezor::messages::monero::MoneroTransactionRsigData* p = rsig_data_;
  // @@protoc_insertion_point(field_get:hw.trezor.messages.monero.MoneroTransactionAllInputsSetAck.rsig_data)
  return p != nullptr ? *p : *reinterpret_cast<const ::hw::trezor::messages::monero::MoneroTransactionRsigData*>(
      &::hw::trezor::messages::monero::_MoneroTransactionRsigData_default_instance_);
}
inline ::hw::trezor::messages::monero::MoneroTransactionRsigData* MoneroTransactionAllInputsSetAck::release_rsig_data() {
  // @@protoc_insertion_point(field_release:hw.trezor.messages.monero.MoneroTransactionAllInputsSetAck.rsig_data)
  _has_bits_[0] &= ~0x00000001u;
  ::hw::trezor::messages::monero::MoneroTransactionRsigData* temp = rsig_data_;
  rsig_data_ = nullptr;
  return temp;
}
inline ::hw::trezor::messages::monero::MoneroTransactionRsigData* MoneroTransactionAllInputsSetAck::mutable_rsig_data() {
  _has_bits_[0] |= 0x00000001u;
  if (rsig_data_ == nullptr) {
    auto* p = CreateMaybeMessage<::hw::trezor::messages::monero::MoneroTransactionRsigData>(GetArenaNoVirtual());
    rsig_data_ = p;
  }
  // @@protoc_insertion_point(field_mutable:hw.trezor.messages.monero.MoneroTransactionAllInputsSetAck.rsig_data)
  return rsig_data_;
}
inline void MoneroTransactionAllInputsSetAck::set_allocated_rsig_data(::hw::trezor::messages::monero::MoneroTransactionRsigData* rsig_data) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete rsig_data_;
  }
  if (rsig_data) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      rsig_data = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, rsig_data, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  rsig_data_ = rsig_data;
  // @@protoc_insertion_point(field_set_allocated:hw.trezor.messages.monero.MoneroTransactionAllInputsSetAck.rsig_data)
}

// -------------------------------------------------------------------

// MoneroTransactionSetOutputRequest

// optional .hw.trezor.messages.monero.MoneroTransactionDestinationEntry dst_entr = 1;
inline bool MoneroTransactionSetOutputRequest::has_dst_entr() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void MoneroTransactionSetOutputRequest::clear_dst_entr() {
  if (dst_entr_ != nullptr) dst_entr_->Clear();
  _has_bits_[0] &= ~0x00000002u;
}
inline const ::hw::trezor::messages::monero::MoneroTransactionDestinationEntry& MoneroTransactionSetOutputRequest::dst_entr() const {
  const ::hw::trezor::messages::monero::MoneroTransactionDestinationEntry* p = dst_entr_;
  // @@protoc_insertion_point(field_get:hw.trezor.messages.monero.MoneroTransactionSetOutputRequest.dst_entr)
  return p != nullptr ? *p : *reinterpret_cast<const ::hw::trezor::messages::monero::MoneroTransactionDestinationEntry*>(
      &::hw::trezor::messages::monero::_MoneroTransactionDestinationEntry_default_instance_);
}
inline ::hw::trezor::messages::monero::MoneroTransactionDestinationEntry* MoneroTransactionSetOutputRequest::release_dst_entr() {
  // @@protoc_insertion_point(field_release:hw.trezor.messages.monero.MoneroTransactionSetOutputRequest.dst_entr)
  _has_bits_[0] &= ~0x00000002u;
  ::hw::trezor::messages::monero::MoneroTransactionDestinationEntry* temp = dst_entr_;
  dst_entr_ = nullptr;
  return temp;
}
inline ::hw::trezor::messages::monero::MoneroTransactionDestinationEntry* MoneroTransactionSetOutputRequest::mutable_dst_entr() {
  _has_bits_[0] |= 0x00000002u;
  if (dst_entr_ == nullptr) {
    auto* p = CreateMaybeMessage<::hw::trezor::messages::monero::MoneroTransactionDestinationEntry>(GetArenaNoVirtual());
    dst_entr_ = p;
  }
  // @@protoc_insertion_point(field_mutable:hw.trezor.messages.monero.MoneroTransactionSetOutputRequest.dst_entr)
  return dst_entr_;
}
inline void MoneroTransactionSetOutputRequest::set_allocated_dst_entr(::hw::trezor::messages::monero::MoneroTransactionDestinationEntry* dst_entr) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete dst_entr_;
  }
  if (dst_entr) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      dst_entr = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, dst_entr, submessage_arena);
    }
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  dst_entr_ = dst_entr;
  // @@protoc_insertion_point(field_set_allocated:hw.trezor.messages.monero.MoneroTransactionSetOutputRequest.dst_entr)
}

// optional bytes dst_entr_hmac = 2;
inline bool MoneroTransactionSetOutputRequest::has_dst_entr_hmac() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MoneroTransactionSetOutputRequest::clear_dst_entr_hmac() {
  dst_entr_hmac_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::std::string& MoneroTransactionSetOutputRequest::dst_entr_hmac() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.monero.MoneroTransactionSetOutputRequest.dst_entr_hmac)
  return dst_entr_hmac_.GetNoArena();
}
inline void MoneroTransactionSetOutputRequest::set_dst_entr_hmac(const ::std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  dst_entr_hmac_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:hw.trezor.messages.monero.MoneroTransactionSetOutputRequest.dst_entr_hmac)
}
#if LANG_CXX11
inline void MoneroTransactionSetOutputRequest::set_dst_entr_hmac(::std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  dst_entr_hmac_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:hw.trezor.messages.monero.MoneroTransactionSetOutputRequest.dst_entr_hmac)
}
#endif
inline void MoneroTransactionSetOutputRequest::set_dst_entr_hmac(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  dst_entr_hmac_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:hw.trezor.messages.monero.MoneroTransactionSetOutputRequest.dst_entr_hmac)
}
inline void MoneroTransactionSetOutputRequest::set_dst_entr_hmac(const void* value, size_t size) {
  _has_bits_[0] |= 0x00000001u;
  dst_entr_hmac_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:hw.trezor.messages.monero.MoneroTransactionSetOutputRequest.dst_entr_hmac)
}
inline ::std::string* MoneroTransactionSetOutputRequest::mutable_dst_entr_hmac() {
  _has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_mutable:hw.trezor.messages.monero.MoneroTransactionSetOutputRequest.dst_entr_hmac)
  return dst_entr_hmac_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* MoneroTransactionSetOutputRequest::release_dst_entr_hmac() {
  // @@protoc_insertion_point(field_release:hw.trezor.messages.monero.MoneroTransactionSetOutputRequest.dst_entr_hmac)
  if (!has_dst_entr_hmac()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return dst_entr_hmac_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void MoneroTransactionSetOutputRequest::set_allocated_dst_entr_hmac(::std::string* dst_entr_hmac) {
  if (dst_entr_hmac != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  dst_entr_hmac_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), dst_entr_hmac);
  // @@protoc_insertion_point(field_set_allocated:hw.trezor.messages.monero.MoneroTransactionSetOutputRequest.dst_entr_hmac)
}

// optional .hw.trezor.messages.monero.MoneroTransactionRsigData rsig_data = 3;
inline bool MoneroTransactionSetOutputRequest::has_rsig_data() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void MoneroTransactionSetOutputRequest::clear_rsig_data() {
  if (rsig_data_ != nullptr) rsig_data_->Clear();
  _has_bits_[0] &= ~0x00000004u;
}
inline const ::hw::trezor::messages::monero::MoneroTransactionRsigData& MoneroTransactionSetOutputRequest::rsig_data() const {
  const ::hw::trezor::messages::monero::MoneroTransactionRsigData* p = rsig_data_;
  // @@protoc_insertion_point(field_get:hw.trezor.messages.monero.MoneroTransactionSetOutputRequest.rsig_data)
  return p != nullptr ? *p : *reinterpret_cast<const ::hw::trezor::messages::monero::MoneroTransactionRsigData*>(
      &::hw::trezor::messages::monero::_MoneroTransactionRsigData_default_instance_);
}
inline ::hw::trezor::messages::monero::MoneroTransactionRsigData* MoneroTransactionSetOutputRequest::release_rsig_data() {
  // @@protoc_insertion_point(field_release:hw.trezor.messages.monero.MoneroTransactionSetOutputRequest.rsig_data)
  _has_bits_[0] &= ~0x00000004u;
  ::hw::trezor::messages::monero::MoneroTransactionRsigData* temp = rsig_data_;
  rsig_data_ = nullptr;
  return temp;
}
inline ::hw::trezor::messages::monero::MoneroTransactionRsigData* MoneroTransactionSetOutputRequest::mutable_rsig_data() {
  _has_bits_[0] |= 0x00000004u;
  if (rsig_data_ == nullptr) {
    auto* p = CreateMaybeMessage<::hw::trezor::messages::monero::MoneroTransactionRsigData>(GetArenaNoVirtual());
    rsig_data_ = p;
  }
  // @@protoc_insertion_point(field_mutable:hw.trezor.messages.monero.MoneroTransactionSetOutputRequest.rsig_data)
  return rsig_data_;
}
inline void MoneroTransactionSetOutputRequest::set_allocated_rsig_data(::hw::trezor::messages::monero::MoneroTransactionRsigData* rsig_data) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete rsig_data_;
  }
  if (rsig_data) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      rsig_data = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, rsig_data, submessage_arena);
    }
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  rsig_data_ = rsig_data;
  // @@protoc_insertion_point(field_set_allocated:hw.trezor.messages.monero.MoneroTransactionSetOutputRequest.rsig_data)
}

// -------------------------------------------------------------------

// MoneroTransactionSetOutputAck

// optional bytes tx_out = 1;
inline bool MoneroTransactionSetOutputAck::has_tx_out() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MoneroTransactionSetOutputAck::clear_tx_out() {
  tx_out_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::std::string& MoneroTransactionSetOutputAck::tx_out() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.monero.MoneroTransactionSetOutputAck.tx_out)
  return tx_out_.GetNoArena();
}
inline void MoneroTransactionSetOutputAck::set_tx_out(const ::std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  tx_out_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:hw.trezor.messages.monero.MoneroTransactionSetOutputAck.tx_out)
}
#if LANG_CXX11
inline void MoneroTransactionSetOutputAck::set_tx_out(::std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  tx_out_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:hw.trezor.messages.monero.MoneroTransactionSetOutputAck.tx_out)
}
#endif
inline void MoneroTransactionSetOutputAck::set_tx_out(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  tx_out_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:hw.trezor.messages.monero.MoneroTransactionSetOutputAck.tx_out)
}
inline void MoneroTransactionSetOutputAck::set_tx_out(const void* value, size_t size) {
  _has_bits_[0] |= 0x00000001u;
  tx_out_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:hw.trezor.messages.monero.MoneroTransactionSetOutputAck.tx_out)
}
inline ::std::string* MoneroTransactionSetOutputAck::mutable_tx_out() {
  _has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_mutable:hw.trezor.messages.monero.MoneroTransactionSetOutputAck.tx_out)
  return tx_out_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* MoneroTransactionSetOutputAck::release_tx_out() {
  // @@protoc_insertion_point(field_release:hw.trezor.messages.monero.MoneroTransactionSetOutputAck.tx_out)
  if (!has_tx_out()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return tx_out_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void MoneroTransactionSetOutputAck::set_allocated_tx_out(::std::string* tx_out) {
  if (tx_out != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  tx_out_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), tx_out);
  // @@protoc_insertion_point(field_set_allocated:hw.trezor.messages.monero.MoneroTransactionSetOutputAck.tx_out)
}

// optional bytes vouti_hmac = 2;
inline bool MoneroTransactionSetOutputAck::has_vouti_hmac() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void MoneroTransactionSetOutputAck::clear_vouti_hmac() {
  vouti_hmac_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000002u;
}
inline const ::std::string& MoneroTransactionSetOutputAck::vouti_hmac() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.monero.MoneroTransactionSetOutputAck.vouti_hmac)
  return vouti_hmac_.GetNoArena();
}
inline void MoneroTransactionSetOutputAck::set_vouti_hmac(const ::std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  vouti_hmac_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:hw.trezor.messages.monero.MoneroTransactionSetOutputAck.vouti_hmac)
}
#if LANG_CXX11
inline void MoneroTransactionSetOutputAck::set_vouti_hmac(::std::string&& value) {
  _has_bits_[0] |= 0x00000002u;
  vouti_hmac_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:hw.trezor.messages.monero.MoneroTransactionSetOutputAck.vouti_hmac)
}
#endif
inline void MoneroTransactionSetOutputAck::set_vouti_hmac(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000002u;
  vouti_hmac_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:hw.trezor.messages.monero.MoneroTransactionSetOutputAck.vouti_hmac)
}
inline void MoneroTransactionSetOutputAck::set_vouti_hmac(const void* value, size_t size) {
  _has_bits_[0] |= 0x00000002u;
  vouti_hmac_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:hw.trezor.messages.monero.MoneroTransactionSetOutputAck.vouti_hmac)
}
inline ::std::string* MoneroTransactionSetOutputAck::mutable_vouti_hmac() {
  _has_bits_[0] |= 0x00000002u;
  // @@protoc_insertion_point(field_mutable:hw.trezor.messages.monero.MoneroTransactionSetOutputAck.vouti_hmac)
  return vouti_hmac_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* MoneroTransactionSetOutputAck::release_vouti_hmac() {
  // @@protoc_insertion_point(field_release:hw.trezor.messages.monero.MoneroTransactionSetOutputAck.vouti_hmac)
  if (!has_vouti_hmac()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  return vouti_hmac_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void MoneroTransactionSetOutputAck::set_allocated_vouti_hmac(::std::string* vouti_hmac) {
  if (vouti_hmac != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  vouti_hmac_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), vouti_hmac);
  // @@protoc_insertion_point(field_set_allocated:hw.trezor.messages.monero.MoneroTransactionSetOutputAck.vouti_hmac)
}

// optional .hw.trezor.messages.monero.MoneroTransactionRsigData rsig_data = 3;
inline bool MoneroTransactionSetOutputAck::has_rsig_data() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void MoneroTransactionSetOutputAck::clear_rsig_data() {
  if (rsig_data_ != nullptr) rsig_data_->Clear();
  _has_bits_[0] &= ~0x00000010u;
}
inline const ::hw::trezor::messages::monero::MoneroTransactionRsigData& MoneroTransactionSetOutputAck::rsig_data() const {
  const ::hw::trezor::messages::monero::MoneroTransactionRsigData* p = rsig_data_;
  // @@protoc_insertion_point(field_get:hw.trezor.messages.monero.MoneroTransactionSetOutputAck.rsig_data)
  return p != nullptr ? *p : *reinterpret_cast<const ::hw::trezor::messages::monero::MoneroTransactionRsigData*>(
      &::hw::trezor::messages::monero::_MoneroTransactionRsigData_default_instance_);
}
inline ::hw::trezor::messages::monero::MoneroTransactionRsigData* MoneroTransactionSetOutputAck::release_rsig_data() {
  // @@protoc_insertion_point(field_release:hw.trezor.messages.monero.MoneroTransactionSetOutputAck.rsig_data)
  _has_bits_[0] &= ~0x00000010u;
  ::hw::trezor::messages::monero::MoneroTransactionRsigData* temp = rsig_data_;
  rsig_data_ = nullptr;
  return temp;
}
inline ::hw::trezor::messages::monero::MoneroTransactionRsigData* MoneroTransactionSetOutputAck::mutable_rsig_data() {
  _has_bits_[0] |= 0x00000010u;
  if (rsig_data_ == nullptr) {
    auto* p = CreateMaybeMessage<::hw::trezor::messages::monero::MoneroTransactionRsigData>(GetArenaNoVirtual());
    rsig_data_ = p;
  }
  // @@protoc_insertion_point(field_mutable:hw.trezor.messages.monero.MoneroTransactionSetOutputAck.rsig_data)
  return rsig_data_;
}
inline void MoneroTransactionSetOutputAck::set_allocated_rsig_data(::hw::trezor::messages::monero::MoneroTransactionRsigData* rsig_data) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete rsig_data_;
  }
  if (rsig_data) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      rsig_data = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, rsig_data, submessage_arena);
    }
    _has_bits_[0] |= 0x00000010u;
  } else {
    _has_bits_[0] &= ~0x00000010u;
  }
  rsig_data_ = rsig_data;
  // @@protoc_insertion_point(field_set_allocated:hw.trezor.messages.monero.MoneroTransactionSetOutputAck.rsig_data)
}

// optional bytes out_pk = 4;
inline bool MoneroTransactionSetOutputAck::has_out_pk() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void MoneroTransactionSetOutputAck::clear_out_pk() {
  out_pk_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000004u;
}
inline const ::std::string& MoneroTransactionSetOutputAck::out_pk() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.monero.MoneroTransactionSetOutputAck.out_pk)
  return out_pk_.GetNoArena();
}
inline void MoneroTransactionSetOutputAck::set_out_pk(const ::std::string& value) {
  _has_bits_[0] |= 0x00000004u;
  out_pk_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:hw.trezor.messages.monero.MoneroTransactionSetOutputAck.out_pk)
}
#if LANG_CXX11
inline void MoneroTransactionSetOutputAck::set_out_pk(::std::string&& value) {
  _has_bits_[0] |= 0x00000004u;
  out_pk_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:hw.trezor.messages.monero.MoneroTransactionSetOutputAck.out_pk)
}
#endif
inline void MoneroTransactionSetOutputAck::set_out_pk(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000004u;
  out_pk_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:hw.trezor.messages.monero.MoneroTransactionSetOutputAck.out_pk)
}
inline void MoneroTransactionSetOutputAck::set_out_pk(const void* value, size_t size) {
  _has_bits_[0] |= 0x00000004u;
  out_pk_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:hw.trezor.messages.monero.MoneroTransactionSetOutputAck.out_pk)
}
inline ::std::string* MoneroTransactionSetOutputAck::mutable_out_pk() {
  _has_bits_[0] |= 0x00000004u;
  // @@protoc_insertion_point(field_mutable:hw.trezor.messages.monero.MoneroTransactionSetOutputAck.out_pk)
  return out_pk_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* MoneroTransactionSetOutputAck::release_out_pk() {
  // @@protoc_insertion_point(field_release:hw.trezor.messages.monero.MoneroTransactionSetOutputAck.out_pk)
  if (!has_out_pk()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000004u;
  return out_pk_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void MoneroTransactionSetOutputAck::set_allocated_out_pk(::std::string* out_pk) {
  if (out_pk != nullptr) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  out_pk_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), out_pk);
  // @@protoc_insertion_point(field_set_allocated:hw.trezor.messages.monero.MoneroTransactionSetOutputAck.out_pk)
}

// optional bytes ecdh_info = 5;
inline bool MoneroTransactionSetOutputAck::has_ecdh_info() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void MoneroTransactionSetOutputAck::clear_ecdh_info() {
  ecdh_info_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000008u;
}
inline const ::std::string& MoneroTransactionSetOutputAck::ecdh_info() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.monero.MoneroTransactionSetOutputAck.ecdh_info)
  return ecdh_info_.GetNoArena();
}
inline void MoneroTransactionSetOutputAck::set_ecdh_info(const ::std::string& value) {
  _has_bits_[0] |= 0x00000008u;
  ecdh_info_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:hw.trezor.messages.monero.MoneroTransactionSetOutputAck.ecdh_info)
}
#if LANG_CXX11
inline void MoneroTransactionSetOutputAck::set_ecdh_info(::std::string&& value) {
  _has_bits_[0] |= 0x00000008u;
  ecdh_info_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:hw.trezor.messages.monero.MoneroTransactionSetOutputAck.ecdh_info)
}
#endif
inline void MoneroTransactionSetOutputAck::set_ecdh_info(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000008u;
  ecdh_info_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:hw.trezor.messages.monero.MoneroTransactionSetOutputAck.ecdh_info)
}
inline void MoneroTransactionSetOutputAck::set_ecdh_info(const void* value, size_t size) {
  _has_bits_[0] |= 0x00000008u;
  ecdh_info_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:hw.trezor.messages.monero.MoneroTransactionSetOutputAck.ecdh_info)
}
inline ::std::string* MoneroTransactionSetOutputAck::mutable_ecdh_info() {
  _has_bits_[0] |= 0x00000008u;
  // @@protoc_insertion_point(field_mutable:hw.trezor.messages.monero.MoneroTransactionSetOutputAck.ecdh_info)
  return ecdh_info_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* MoneroTransactionSetOutputAck::release_ecdh_info() {
  // @@protoc_insertion_point(field_release:hw.trezor.messages.monero.MoneroTransactionSetOutputAck.ecdh_info)
  if (!has_ecdh_info()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000008u;
  return ecdh_info_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void MoneroTransactionSetOutputAck::set_allocated_ecdh_info(::std::string* ecdh_info) {
  if (ecdh_info != nullptr) {
    _has_bits_[0] |= 0x00000008u;
  } else {
    _has_bits_[0] &= ~0x00000008u;
  }
  ecdh_info_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ecdh_info);
  // @@protoc_insertion_point(field_set_allocated:hw.trezor.messages.monero.MoneroTransactionSetOutputAck.ecdh_info)
}

// -------------------------------------------------------------------

// MoneroTransactionAllOutSetRequest

// optional .hw.trezor.messages.monero.MoneroTransactionRsigData rsig_data = 1;
inline bool MoneroTransactionAllOutSetRequest::has_rsig_data() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MoneroTransactionAllOutSetRequest::clear_rsig_data() {
  if (rsig_data_ != nullptr) rsig_data_->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::hw::trezor::messages::monero::MoneroTransactionRsigData& MoneroTransactionAllOutSetRequest::rsig_data() const {
  const ::hw::trezor::messages::monero::MoneroTransactionRsigData* p = rsig_data_;
  // @@protoc_insertion_point(field_get:hw.trezor.messages.monero.MoneroTransactionAllOutSetRequest.rsig_data)
  return p != nullptr ? *p : *reinterpret_cast<const ::hw::trezor::messages::monero::MoneroTransactionRsigData*>(
      &::hw::trezor::messages::monero::_MoneroTransactionRsigData_default_instance_);
}
inline ::hw::trezor::messages::monero::MoneroTransactionRsigData* MoneroTransactionAllOutSetRequest::release_rsig_data() {
  // @@protoc_insertion_point(field_release:hw.trezor.messages.monero.MoneroTransactionAllOutSetRequest.rsig_data)
  _has_bits_[0] &= ~0x00000001u;
  ::hw::trezor::messages::monero::MoneroTransactionRsigData* temp = rsig_data_;
  rsig_data_ = nullptr;
  return temp;
}
inline ::hw::trezor::messages::monero::MoneroTransactionRsigData* MoneroTransactionAllOutSetRequest::mutable_rsig_data() {
  _has_bits_[0] |= 0x00000001u;
  if (rsig_data_ == nullptr) {
    auto* p = CreateMaybeMessage<::hw::trezor::messages::monero::MoneroTransactionRsigData>(GetArenaNoVirtual());
    rsig_data_ = p;
  }
  // @@protoc_insertion_point(field_mutable:hw.trezor.messages.monero.MoneroTransactionAllOutSetRequest.rsig_data)
  return rsig_data_;
}
inline void MoneroTransactionAllOutSetRequest::set_allocated_rsig_data(::hw::trezor::messages::monero::MoneroTransactionRsigData* rsig_data) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete rsig_data_;
  }
  if (rsig_data) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      rsig_data = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, rsig_data, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  rsig_data_ = rsig_data;
  // @@protoc_insertion_point(field_set_allocated:hw.trezor.messages.monero.MoneroTransactionAllOutSetRequest.rsig_data)
}

// -------------------------------------------------------------------

// MoneroTransactionAllOutSetAck_MoneroRingCtSig

// optional uint64 txn_fee = 1;
inline bool MoneroTransactionAllOutSetAck_MoneroRingCtSig::has_txn_fee() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void MoneroTransactionAllOutSetAck_MoneroRingCtSig::clear_txn_fee() {
  txn_fee_ = PROTOBUF_ULONGLONG(0);
  _has_bits_[0] &= ~0x00000002u;
}
inline ::google::protobuf::uint64 MoneroTransactionAllOutSetAck_MoneroRingCtSig::txn_fee() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.monero.MoneroTransactionAllOutSetAck.MoneroRingCtSig.txn_fee)
  return txn_fee_;
}
inline void MoneroTransactionAllOutSetAck_MoneroRingCtSig::set_txn_fee(::google::protobuf::uint64 value) {
  _has_bits_[0] |= 0x00000002u;
  txn_fee_ = value;
  // @@protoc_insertion_point(field_set:hw.trezor.messages.monero.MoneroTransactionAllOutSetAck.MoneroRingCtSig.txn_fee)
}

// optional bytes message = 2;
inline bool MoneroTransactionAllOutSetAck_MoneroRingCtSig::has_message() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MoneroTransactionAllOutSetAck_MoneroRingCtSig::clear_message() {
  message_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::std::string& MoneroTransactionAllOutSetAck_MoneroRingCtSig::message() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.monero.MoneroTransactionAllOutSetAck.MoneroRingCtSig.message)
  return message_.GetNoArena();
}
inline void MoneroTransactionAllOutSetAck_MoneroRingCtSig::set_message(const ::std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  message_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:hw.trezor.messages.monero.MoneroTransactionAllOutSetAck.MoneroRingCtSig.message)
}
#if LANG_CXX11
inline void MoneroTransactionAllOutSetAck_MoneroRingCtSig::set_message(::std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  message_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:hw.trezor.messages.monero.MoneroTransactionAllOutSetAck.MoneroRingCtSig.message)
}
#endif
inline void MoneroTransactionAllOutSetAck_MoneroRingCtSig::set_message(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  message_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:hw.trezor.messages.monero.MoneroTransactionAllOutSetAck.MoneroRingCtSig.message)
}
inline void MoneroTransactionAllOutSetAck_MoneroRingCtSig::set_message(const void* value, size_t size) {
  _has_bits_[0] |= 0x00000001u;
  message_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:hw.trezor.messages.monero.MoneroTransactionAllOutSetAck.MoneroRingCtSig.message)
}
inline ::std::string* MoneroTransactionAllOutSetAck_MoneroRingCtSig::mutable_message() {
  _has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_mutable:hw.trezor.messages.monero.MoneroTransactionAllOutSetAck.MoneroRingCtSig.message)
  return message_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* MoneroTransactionAllOutSetAck_MoneroRingCtSig::release_message() {
  // @@protoc_insertion_point(field_release:hw.trezor.messages.monero.MoneroTransactionAllOutSetAck.MoneroRingCtSig.message)
  if (!has_message()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return message_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void MoneroTransactionAllOutSetAck_MoneroRingCtSig::set_allocated_message(::std::string* message) {
  if (message != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  message_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), message);
  // @@protoc_insertion_point(field_set_allocated:hw.trezor.messages.monero.MoneroTransactionAllOutSetAck.MoneroRingCtSig.message)
}

// optional uint32 rv_type = 3;
inline bool MoneroTransactionAllOutSetAck_MoneroRingCtSig::has_rv_type() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void MoneroTransactionAllOutSetAck_MoneroRingCtSig::clear_rv_type() {
  rv_type_ = 0u;
  _has_bits_[0] &= ~0x00000004u;
}
inline ::google::protobuf::uint32 MoneroTransactionAllOutSetAck_MoneroRingCtSig::rv_type() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.monero.MoneroTransactionAllOutSetAck.MoneroRingCtSig.rv_type)
  return rv_type_;
}
inline void MoneroTransactionAllOutSetAck_MoneroRingCtSig::set_rv_type(::google::protobuf::uint32 value) {
  _has_bits_[0] |= 0x00000004u;
  rv_type_ = value;
  // @@protoc_insertion_point(field_set:hw.trezor.messages.monero.MoneroTransactionAllOutSetAck.MoneroRingCtSig.rv_type)
}

// -------------------------------------------------------------------

// MoneroTransactionAllOutSetAck

// optional bytes extra = 1;
inline bool MoneroTransactionAllOutSetAck::has_extra() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MoneroTransactionAllOutSetAck::clear_extra() {
  extra_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::std::string& MoneroTransactionAllOutSetAck::extra() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.monero.MoneroTransactionAllOutSetAck.extra)
  return extra_.GetNoArena();
}
inline void MoneroTransactionAllOutSetAck::set_extra(const ::std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  extra_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:hw.trezor.messages.monero.MoneroTransactionAllOutSetAck.extra)
}
#if LANG_CXX11
inline void MoneroTransactionAllOutSetAck::set_extra(::std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  extra_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:hw.trezor.messages.monero.MoneroTransactionAllOutSetAck.extra)
}
#endif
inline void MoneroTransactionAllOutSetAck::set_extra(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  extra_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:hw.trezor.messages.monero.MoneroTransactionAllOutSetAck.extra)
}
inline void MoneroTransactionAllOutSetAck::set_extra(const void* value, size_t size) {
  _has_bits_[0] |= 0x00000001u;
  extra_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:hw.trezor.messages.monero.MoneroTransactionAllOutSetAck.extra)
}
inline ::std::string* MoneroTransactionAllOutSetAck::mutable_extra() {
  _has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_mutable:hw.trezor.messages.monero.MoneroTransactionAllOutSetAck.extra)
  return extra_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* MoneroTransactionAllOutSetAck::release_extra() {
  // @@protoc_insertion_point(field_release:hw.trezor.messages.monero.MoneroTransactionAllOutSetAck.extra)
  if (!has_extra()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return extra_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void MoneroTransactionAllOutSetAck::set_allocated_extra(::std::string* extra) {
  if (extra != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  extra_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), extra);
  // @@protoc_insertion_point(field_set_allocated:hw.trezor.messages.monero.MoneroTransactionAllOutSetAck.extra)
}

// optional bytes tx_prefix_hash = 2;
inline bool MoneroTransactionAllOutSetAck::has_tx_prefix_hash() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void MoneroTransactionAllOutSetAck::clear_tx_prefix_hash() {
  tx_prefix_hash_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000002u;
}
inline const ::std::string& MoneroTransactionAllOutSetAck::tx_prefix_hash() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.monero.MoneroTransactionAllOutSetAck.tx_prefix_hash)
  return tx_prefix_hash_.GetNoArena();
}
inline void MoneroTransactionAllOutSetAck::set_tx_prefix_hash(const ::std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  tx_prefix_hash_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:hw.trezor.messages.monero.MoneroTransactionAllOutSetAck.tx_prefix_hash)
}
#if LANG_CXX11
inline void MoneroTransactionAllOutSetAck::set_tx_prefix_hash(::std::string&& value) {
  _has_bits_[0] |= 0x00000002u;
  tx_prefix_hash_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:hw.trezor.messages.monero.MoneroTransactionAllOutSetAck.tx_prefix_hash)
}
#endif
inline void MoneroTransactionAllOutSetAck::set_tx_prefix_hash(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000002u;
  tx_prefix_hash_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:hw.trezor.messages.monero.MoneroTransactionAllOutSetAck.tx_prefix_hash)
}
inline void MoneroTransactionAllOutSetAck::set_tx_prefix_hash(const void* value, size_t size) {
  _has_bits_[0] |= 0x00000002u;
  tx_prefix_hash_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:hw.trezor.messages.monero.MoneroTransactionAllOutSetAck.tx_prefix_hash)
}
inline ::std::string* MoneroTransactionAllOutSetAck::mutable_tx_prefix_hash() {
  _has_bits_[0] |= 0x00000002u;
  // @@protoc_insertion_point(field_mutable:hw.trezor.messages.monero.MoneroTransactionAllOutSetAck.tx_prefix_hash)
  return tx_prefix_hash_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* MoneroTransactionAllOutSetAck::release_tx_prefix_hash() {
  // @@protoc_insertion_point(field_release:hw.trezor.messages.monero.MoneroTransactionAllOutSetAck.tx_prefix_hash)
  if (!has_tx_prefix_hash()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  return tx_prefix_hash_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void MoneroTransactionAllOutSetAck::set_allocated_tx_prefix_hash(::std::string* tx_prefix_hash) {
  if (tx_prefix_hash != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  tx_prefix_hash_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), tx_prefix_hash);
  // @@protoc_insertion_point(field_set_allocated:hw.trezor.messages.monero.MoneroTransactionAllOutSetAck.tx_prefix_hash)
}

// optional .hw.trezor.messages.monero.MoneroTransactionAllOutSetAck.MoneroRingCtSig rv = 4;
inline bool MoneroTransactionAllOutSetAck::has_rv() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void MoneroTransactionAllOutSetAck::clear_rv() {
  if (rv_ != nullptr) rv_->Clear();
  _has_bits_[0] &= ~0x00000008u;
}
inline const ::hw::trezor::messages::monero::MoneroTransactionAllOutSetAck_MoneroRingCtSig& MoneroTransactionAllOutSetAck::rv() const {
  const ::hw::trezor::messages::monero::MoneroTransactionAllOutSetAck_MoneroRingCtSig* p = rv_;
  // @@protoc_insertion_point(field_get:hw.trezor.messages.monero.MoneroTransactionAllOutSetAck.rv)
  return p != nullptr ? *p : *reinterpret_cast<const ::hw::trezor::messages::monero::MoneroTransactionAllOutSetAck_MoneroRingCtSig*>(
      &::hw::trezor::messages::monero::_MoneroTransactionAllOutSetAck_MoneroRingCtSig_default_instance_);
}
inline ::hw::trezor::messages::monero::MoneroTransactionAllOutSetAck_MoneroRingCtSig* MoneroTransactionAllOutSetAck::release_rv() {
  // @@protoc_insertion_point(field_release:hw.trezor.messages.monero.MoneroTransactionAllOutSetAck.rv)
  _has_bits_[0] &= ~0x00000008u;
  ::hw::trezor::messages::monero::MoneroTransactionAllOutSetAck_MoneroRingCtSig* temp = rv_;
  rv_ = nullptr;
  return temp;
}
inline ::hw::trezor::messages::monero::MoneroTransactionAllOutSetAck_MoneroRingCtSig* MoneroTransactionAllOutSetAck::mutable_rv() {
  _has_bits_[0] |= 0x00000008u;
  if (rv_ == nullptr) {
    auto* p = CreateMaybeMessage<::hw::trezor::messages::monero::MoneroTransactionAllOutSetAck_MoneroRingCtSig>(GetArenaNoVirtual());
    rv_ = p;
  }
  // @@protoc_insertion_point(field_mutable:hw.trezor.messages.monero.MoneroTransactionAllOutSetAck.rv)
  return rv_;
}
inline void MoneroTransactionAllOutSetAck::set_allocated_rv(::hw::trezor::messages::monero::MoneroTransactionAllOutSetAck_MoneroRingCtSig* rv) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete rv_;
  }
  if (rv) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      rv = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, rv, submessage_arena);
    }
    _has_bits_[0] |= 0x00000008u;
  } else {
    _has_bits_[0] &= ~0x00000008u;
  }
  rv_ = rv;
  // @@protoc_insertion_point(field_set_allocated:hw.trezor.messages.monero.MoneroTransactionAllOutSetAck.rv)
}

// optional bytes full_message_hash = 5;
inline bool MoneroTransactionAllOutSetAck::has_full_message_hash() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void MoneroTransactionAllOutSetAck::clear_full_message_hash() {
  full_message_hash_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000004u;
}
inline const ::std::string& MoneroTransactionAllOutSetAck::full_message_hash() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.monero.MoneroTransactionAllOutSetAck.full_message_hash)
  return full_message_hash_.GetNoArena();
}
inline void MoneroTransactionAllOutSetAck::set_full_message_hash(const ::std::string& value) {
  _has_bits_[0] |= 0x00000004u;
  full_message_hash_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:hw.trezor.messages.monero.MoneroTransactionAllOutSetAck.full_message_hash)
}
#if LANG_CXX11
inline void MoneroTransactionAllOutSetAck::set_full_message_hash(::std::string&& value) {
  _has_bits_[0] |= 0x00000004u;
  full_message_hash_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:hw.trezor.messages.monero.MoneroTransactionAllOutSetAck.full_message_hash)
}
#endif
inline void MoneroTransactionAllOutSetAck::set_full_message_hash(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000004u;
  full_message_hash_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:hw.trezor.messages.monero.MoneroTransactionAllOutSetAck.full_message_hash)
}
inline void MoneroTransactionAllOutSetAck::set_full_message_hash(const void* value, size_t size) {
  _has_bits_[0] |= 0x00000004u;
  full_message_hash_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:hw.trezor.messages.monero.MoneroTransactionAllOutSetAck.full_message_hash)
}
inline ::std::string* MoneroTransactionAllOutSetAck::mutable_full_message_hash() {
  _has_bits_[0] |= 0x00000004u;
  // @@protoc_insertion_point(field_mutable:hw.trezor.messages.monero.MoneroTransactionAllOutSetAck.full_message_hash)
  return full_message_hash_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* MoneroTransactionAllOutSetAck::release_full_message_hash() {
  // @@protoc_insertion_point(field_release:hw.trezor.messages.monero.MoneroTransactionAllOutSetAck.full_message_hash)
  if (!has_full_message_hash()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000004u;
  return full_message_hash_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void MoneroTransactionAllOutSetAck::set_allocated_full_message_hash(::std::string* full_message_hash) {
  if (full_message_hash != nullptr) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  full_message_hash_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), full_message_hash);
  // @@protoc_insertion_point(field_set_allocated:hw.trezor.messages.monero.MoneroTransactionAllOutSetAck.full_message_hash)
}

// -------------------------------------------------------------------

// MoneroTransactionSignInputRequest

// optional .hw.trezor.messages.monero.MoneroTransactionSourceEntry src_entr = 1;
inline bool MoneroTransactionSignInputRequest::has_src_entr() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void MoneroTransactionSignInputRequest::clear_src_entr() {
  if (src_entr_ != nullptr) src_entr_->Clear();
  _has_bits_[0] &= ~0x00000040u;
}
inline const ::hw::trezor::messages::monero::MoneroTransactionSourceEntry& MoneroTransactionSignInputRequest::src_entr() const {
  const ::hw::trezor::messages::monero::MoneroTransactionSourceEntry* p = src_entr_;
  // @@protoc_insertion_point(field_get:hw.trezor.messages.monero.MoneroTransactionSignInputRequest.src_entr)
  return p != nullptr ? *p : *reinterpret_cast<const ::hw::trezor::messages::monero::MoneroTransactionSourceEntry*>(
      &::hw::trezor::messages::monero::_MoneroTransactionSourceEntry_default_instance_);
}
inline ::hw::trezor::messages::monero::MoneroTransactionSourceEntry* MoneroTransactionSignInputRequest::release_src_entr() {
  // @@protoc_insertion_point(field_release:hw.trezor.messages.monero.MoneroTransactionSignInputRequest.src_entr)
  _has_bits_[0] &= ~0x00000040u;
  ::hw::trezor::messages::monero::MoneroTransactionSourceEntry* temp = src_entr_;
  src_entr_ = nullptr;
  return temp;
}
inline ::hw::trezor::messages::monero::MoneroTransactionSourceEntry* MoneroTransactionSignInputRequest::mutable_src_entr() {
  _has_bits_[0] |= 0x00000040u;
  if (src_entr_ == nullptr) {
    auto* p = CreateMaybeMessage<::hw::trezor::messages::monero::MoneroTransactionSourceEntry>(GetArenaNoVirtual());
    src_entr_ = p;
  }
  // @@protoc_insertion_point(field_mutable:hw.trezor.messages.monero.MoneroTransactionSignInputRequest.src_entr)
  return src_entr_;
}
inline void MoneroTransactionSignInputRequest::set_allocated_src_entr(::hw::trezor::messages::monero::MoneroTransactionSourceEntry* src_entr) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete src_entr_;
  }
  if (src_entr) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      src_entr = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, src_entr, submessage_arena);
    }
    _has_bits_[0] |= 0x00000040u;
  } else {
    _has_bits_[0] &= ~0x00000040u;
  }
  src_entr_ = src_entr;
  // @@protoc_insertion_point(field_set_allocated:hw.trezor.messages.monero.MoneroTransactionSignInputRequest.src_entr)
}

// optional bytes vini = 2;
inline bool MoneroTransactionSignInputRequest::has_vini() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MoneroTransactionSignInputRequest::clear_vini() {
  vini_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::std::string& MoneroTransactionSignInputRequest::vini() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.monero.MoneroTransactionSignInputRequest.vini)
  return vini_.GetNoArena();
}
inline void MoneroTransactionSignInputRequest::set_vini(const ::std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  vini_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:hw.trezor.messages.monero.MoneroTransactionSignInputRequest.vini)
}
#if LANG_CXX11
inline void MoneroTransactionSignInputRequest::set_vini(::std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  vini_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:hw.trezor.messages.monero.MoneroTransactionSignInputRequest.vini)
}
#endif
inline void MoneroTransactionSignInputRequest::set_vini(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  vini_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:hw.trezor.messages.monero.MoneroTransactionSignInputRequest.vini)
}
inline void MoneroTransactionSignInputRequest::set_vini(const void* value, size_t size) {
  _has_bits_[0] |= 0x00000001u;
  vini_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:hw.trezor.messages.monero.MoneroTransactionSignInputRequest.vini)
}
inline ::std::string* MoneroTransactionSignInputRequest::mutable_vini() {
  _has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_mutable:hw.trezor.messages.monero.MoneroTransactionSignInputRequest.vini)
  return vini_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* MoneroTransactionSignInputRequest::release_vini() {
  // @@protoc_insertion_point(field_release:hw.trezor.messages.monero.MoneroTransactionSignInputRequest.vini)
  if (!has_vini()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return vini_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void MoneroTransactionSignInputRequest::set_allocated_vini(::std::string* vini) {
  if (vini != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  vini_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), vini);
  // @@protoc_insertion_point(field_set_allocated:hw.trezor.messages.monero.MoneroTransactionSignInputRequest.vini)
}

// optional bytes vini_hmac = 3;
inline bool MoneroTransactionSignInputRequest::has_vini_hmac() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void MoneroTransactionSignInputRequest::clear_vini_hmac() {
  vini_hmac_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000002u;
}
inline const ::std::string& MoneroTransactionSignInputRequest::vini_hmac() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.monero.MoneroTransactionSignInputRequest.vini_hmac)
  return vini_hmac_.GetNoArena();
}
inline void MoneroTransactionSignInputRequest::set_vini_hmac(const ::std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  vini_hmac_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:hw.trezor.messages.monero.MoneroTransactionSignInputRequest.vini_hmac)
}
#if LANG_CXX11
inline void MoneroTransactionSignInputRequest::set_vini_hmac(::std::string&& value) {
  _has_bits_[0] |= 0x00000002u;
  vini_hmac_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:hw.trezor.messages.monero.MoneroTransactionSignInputRequest.vini_hmac)
}
#endif
inline void MoneroTransactionSignInputRequest::set_vini_hmac(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000002u;
  vini_hmac_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:hw.trezor.messages.monero.MoneroTransactionSignInputRequest.vini_hmac)
}
inline void MoneroTransactionSignInputRequest::set_vini_hmac(const void* value, size_t size) {
  _has_bits_[0] |= 0x00000002u;
  vini_hmac_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:hw.trezor.messages.monero.MoneroTransactionSignInputRequest.vini_hmac)
}
inline ::std::string* MoneroTransactionSignInputRequest::mutable_vini_hmac() {
  _has_bits_[0] |= 0x00000002u;
  // @@protoc_insertion_point(field_mutable:hw.trezor.messages.monero.MoneroTransactionSignInputRequest.vini_hmac)
  return vini_hmac_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* MoneroTransactionSignInputRequest::release_vini_hmac() {
  // @@protoc_insertion_point(field_release:hw.trezor.messages.monero.MoneroTransactionSignInputRequest.vini_hmac)
  if (!has_vini_hmac()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  return vini_hmac_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void MoneroTransactionSignInputRequest::set_allocated_vini_hmac(::std::string* vini_hmac) {
  if (vini_hmac != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  vini_hmac_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), vini_hmac);
  // @@protoc_insertion_point(field_set_allocated:hw.trezor.messages.monero.MoneroTransactionSignInputRequest.vini_hmac)
}

// optional bytes pseudo_out = 4;
inline bool MoneroTransactionSignInputRequest::has_pseudo_out() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void MoneroTransactionSignInputRequest::clear_pseudo_out() {
  pseudo_out_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000004u;
}
inline const ::std::string& MoneroTransactionSignInputRequest::pseudo_out() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.monero.MoneroTransactionSignInputRequest.pseudo_out)
  return pseudo_out_.GetNoArena();
}
inline void MoneroTransactionSignInputRequest::set_pseudo_out(const ::std::string& value) {
  _has_bits_[0] |= 0x00000004u;
  pseudo_out_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:hw.trezor.messages.monero.MoneroTransactionSignInputRequest.pseudo_out)
}
#if LANG_CXX11
inline void MoneroTransactionSignInputRequest::set_pseudo_out(::std::string&& value) {
  _has_bits_[0] |= 0x00000004u;
  pseudo_out_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:hw.trezor.messages.monero.MoneroTransactionSignInputRequest.pseudo_out)
}
#endif
inline void MoneroTransactionSignInputRequest::set_pseudo_out(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000004u;
  pseudo_out_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:hw.trezor.messages.monero.MoneroTransactionSignInputRequest.pseudo_out)
}
inline void MoneroTransactionSignInputRequest::set_pseudo_out(const void* value, size_t size) {
  _has_bits_[0] |= 0x00000004u;
  pseudo_out_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:hw.trezor.messages.monero.MoneroTransactionSignInputRequest.pseudo_out)
}
inline ::std::string* MoneroTransactionSignInputRequest::mutable_pseudo_out() {
  _has_bits_[0] |= 0x00000004u;
  // @@protoc_insertion_point(field_mutable:hw.trezor.messages.monero.MoneroTransactionSignInputRequest.pseudo_out)
  return pseudo_out_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* MoneroTransactionSignInputRequest::release_pseudo_out() {
  // @@protoc_insertion_point(field_release:hw.trezor.messages.monero.MoneroTransactionSignInputRequest.pseudo_out)
  if (!has_pseudo_out()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000004u;
  return pseudo_out_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void MoneroTransactionSignInputRequest::set_allocated_pseudo_out(::std::string* pseudo_out) {
  if (pseudo_out != nullptr) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  pseudo_out_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), pseudo_out);
  // @@protoc_insertion_point(field_set_allocated:hw.trezor.messages.monero.MoneroTransactionSignInputRequest.pseudo_out)
}

// optional bytes pseudo_out_hmac = 5;
inline bool MoneroTransactionSignInputRequest::has_pseudo_out_hmac() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void MoneroTransactionSignInputRequest::clear_pseudo_out_hmac() {
  pseudo_out_hmac_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000008u;
}
inline const ::std::string& MoneroTransactionSignInputRequest::pseudo_out_hmac() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.monero.MoneroTransactionSignInputRequest.pseudo_out_hmac)
  return pseudo_out_hmac_.GetNoArena();
}
inline void MoneroTransactionSignInputRequest::set_pseudo_out_hmac(const ::std::string& value) {
  _has_bits_[0] |= 0x00000008u;
  pseudo_out_hmac_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:hw.trezor.messages.monero.MoneroTransactionSignInputRequest.pseudo_out_hmac)
}
#if LANG_CXX11
inline void MoneroTransactionSignInputRequest::set_pseudo_out_hmac(::std::string&& value) {
  _has_bits_[0] |= 0x00000008u;
  pseudo_out_hmac_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:hw.trezor.messages.monero.MoneroTransactionSignInputRequest.pseudo_out_hmac)
}
#endif
inline void MoneroTransactionSignInputRequest::set_pseudo_out_hmac(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000008u;
  pseudo_out_hmac_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:hw.trezor.messages.monero.MoneroTransactionSignInputRequest.pseudo_out_hmac)
}
inline void MoneroTransactionSignInputRequest::set_pseudo_out_hmac(const void* value, size_t size) {
  _has_bits_[0] |= 0x00000008u;
  pseudo_out_hmac_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:hw.trezor.messages.monero.MoneroTransactionSignInputRequest.pseudo_out_hmac)
}
inline ::std::string* MoneroTransactionSignInputRequest::mutable_pseudo_out_hmac() {
  _has_bits_[0] |= 0x00000008u;
  // @@protoc_insertion_point(field_mutable:hw.trezor.messages.monero.MoneroTransactionSignInputRequest.pseudo_out_hmac)
  return pseudo_out_hmac_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* MoneroTransactionSignInputRequest::release_pseudo_out_hmac() {
  // @@protoc_insertion_point(field_release:hw.trezor.messages.monero.MoneroTransactionSignInputRequest.pseudo_out_hmac)
  if (!has_pseudo_out_hmac()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000008u;
  return pseudo_out_hmac_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void MoneroTransactionSignInputRequest::set_allocated_pseudo_out_hmac(::std::string* pseudo_out_hmac) {
  if (pseudo_out_hmac != nullptr) {
    _has_bits_[0] |= 0x00000008u;
  } else {
    _has_bits_[0] &= ~0x00000008u;
  }
  pseudo_out_hmac_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), pseudo_out_hmac);
  // @@protoc_insertion_point(field_set_allocated:hw.trezor.messages.monero.MoneroTransactionSignInputRequest.pseudo_out_hmac)
}

// optional bytes pseudo_out_alpha = 6;
inline bool MoneroTransactionSignInputRequest::has_pseudo_out_alpha() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void MoneroTransactionSignInputRequest::clear_pseudo_out_alpha() {
  pseudo_out_alpha_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000010u;
}
inline const ::std::string& MoneroTransactionSignInputRequest::pseudo_out_alpha() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.monero.MoneroTransactionSignInputRequest.pseudo_out_alpha)
  return pseudo_out_alpha_.GetNoArena();
}
inline void MoneroTransactionSignInputRequest::set_pseudo_out_alpha(const ::std::string& value) {
  _has_bits_[0] |= 0x00000010u;
  pseudo_out_alpha_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:hw.trezor.messages.monero.MoneroTransactionSignInputRequest.pseudo_out_alpha)
}
#if LANG_CXX11
inline void MoneroTransactionSignInputRequest::set_pseudo_out_alpha(::std::string&& value) {
  _has_bits_[0] |= 0x00000010u;
  pseudo_out_alpha_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:hw.trezor.messages.monero.MoneroTransactionSignInputRequest.pseudo_out_alpha)
}
#endif
inline void MoneroTransactionSignInputRequest::set_pseudo_out_alpha(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000010u;
  pseudo_out_alpha_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:hw.trezor.messages.monero.MoneroTransactionSignInputRequest.pseudo_out_alpha)
}
inline void MoneroTransactionSignInputRequest::set_pseudo_out_alpha(const void* value, size_t size) {
  _has_bits_[0] |= 0x00000010u;
  pseudo_out_alpha_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:hw.trezor.messages.monero.MoneroTransactionSignInputRequest.pseudo_out_alpha)
}
inline ::std::string* MoneroTransactionSignInputRequest::mutable_pseudo_out_alpha() {
  _has_bits_[0] |= 0x00000010u;
  // @@protoc_insertion_point(field_mutable:hw.trezor.messages.monero.MoneroTransactionSignInputRequest.pseudo_out_alpha)
  return pseudo_out_alpha_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* MoneroTransactionSignInputRequest::release_pseudo_out_alpha() {
  // @@protoc_insertion_point(field_release:hw.trezor.messages.monero.MoneroTransactionSignInputRequest.pseudo_out_alpha)
  if (!has_pseudo_out_alpha()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000010u;
  return pseudo_out_alpha_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void MoneroTransactionSignInputRequest::set_allocated_pseudo_out_alpha(::std::string* pseudo_out_alpha) {
  if (pseudo_out_alpha != nullptr) {
    _has_bits_[0] |= 0x00000010u;
  } else {
    _has_bits_[0] &= ~0x00000010u;
  }
  pseudo_out_alpha_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), pseudo_out_alpha);
  // @@protoc_insertion_point(field_set_allocated:hw.trezor.messages.monero.MoneroTransactionSignInputRequest.pseudo_out_alpha)
}

// optional bytes spend_key = 7;
inline bool MoneroTransactionSignInputRequest::has_spend_key() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void MoneroTransactionSignInputRequest::clear_spend_key() {
  spend_key_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000020u;
}
inline const ::std::string& MoneroTransactionSignInputRequest::spend_key() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.monero.MoneroTransactionSignInputRequest.spend_key)
  return spend_key_.GetNoArena();
}
inline void MoneroTransactionSignInputRequest::set_spend_key(const ::std::string& value) {
  _has_bits_[0] |= 0x00000020u;
  spend_key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:hw.trezor.messages.monero.MoneroTransactionSignInputRequest.spend_key)
}
#if LANG_CXX11
inline void MoneroTransactionSignInputRequest::set_spend_key(::std::string&& value) {
  _has_bits_[0] |= 0x00000020u;
  spend_key_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:hw.trezor.messages.monero.MoneroTransactionSignInputRequest.spend_key)
}
#endif
inline void MoneroTransactionSignInputRequest::set_spend_key(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000020u;
  spend_key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:hw.trezor.messages.monero.MoneroTransactionSignInputRequest.spend_key)
}
inline void MoneroTransactionSignInputRequest::set_spend_key(const void* value, size_t size) {
  _has_bits_[0] |= 0x00000020u;
  spend_key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:hw.trezor.messages.monero.MoneroTransactionSignInputRequest.spend_key)
}
inline ::std::string* MoneroTransactionSignInputRequest::mutable_spend_key() {
  _has_bits_[0] |= 0x00000020u;
  // @@protoc_insertion_point(field_mutable:hw.trezor.messages.monero.MoneroTransactionSignInputRequest.spend_key)
  return spend_key_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* MoneroTransactionSignInputRequest::release_spend_key() {
  // @@protoc_insertion_point(field_release:hw.trezor.messages.monero.MoneroTransactionSignInputRequest.spend_key)
  if (!has_spend_key()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000020u;
  return spend_key_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void MoneroTransactionSignInputRequest::set_allocated_spend_key(::std::string* spend_key) {
  if (spend_key != nullptr) {
    _has_bits_[0] |= 0x00000020u;
  } else {
    _has_bits_[0] &= ~0x00000020u;
  }
  spend_key_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), spend_key);
  // @@protoc_insertion_point(field_set_allocated:hw.trezor.messages.monero.MoneroTransactionSignInputRequest.spend_key)
}

// -------------------------------------------------------------------

// MoneroTransactionSignInputAck

// optional bytes signature = 1;
inline bool MoneroTransactionSignInputAck::has_signature() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MoneroTransactionSignInputAck::clear_signature() {
  signature_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::std::string& MoneroTransactionSignInputAck::signature() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.monero.MoneroTransactionSignInputAck.signature)
  return signature_.GetNoArena();
}
inline void MoneroTransactionSignInputAck::set_signature(const ::std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  signature_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:hw.trezor.messages.monero.MoneroTransactionSignInputAck.signature)
}
#if LANG_CXX11
inline void MoneroTransactionSignInputAck::set_signature(::std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  signature_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:hw.trezor.messages.monero.MoneroTransactionSignInputAck.signature)
}
#endif
inline void MoneroTransactionSignInputAck::set_signature(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  signature_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:hw.trezor.messages.monero.MoneroTransactionSignInputAck.signature)
}
inline void MoneroTransactionSignInputAck::set_signature(const void* value, size_t size) {
  _has_bits_[0] |= 0x00000001u;
  signature_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:hw.trezor.messages.monero.MoneroTransactionSignInputAck.signature)
}
inline ::std::string* MoneroTransactionSignInputAck::mutable_signature() {
  _has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_mutable:hw.trezor.messages.monero.MoneroTransactionSignInputAck.signature)
  return signature_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* MoneroTransactionSignInputAck::release_signature() {
  // @@protoc_insertion_point(field_release:hw.trezor.messages.monero.MoneroTransactionSignInputAck.signature)
  if (!has_signature()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return signature_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void MoneroTransactionSignInputAck::set_allocated_signature(::std::string* signature) {
  if (signature != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  signature_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), signature);
  // @@protoc_insertion_point(field_set_allocated:hw.trezor.messages.monero.MoneroTransactionSignInputAck.signature)
}

// -------------------------------------------------------------------

// MoneroTransactionFinalRequest

// -------------------------------------------------------------------

// MoneroTransactionFinalAck

// optional bytes cout_key = 1;
inline bool MoneroTransactionFinalAck::has_cout_key() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MoneroTransactionFinalAck::clear_cout_key() {
  cout_key_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::std::string& MoneroTransactionFinalAck::cout_key() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.monero.MoneroTransactionFinalAck.cout_key)
  return cout_key_.GetNoArena();
}
inline void MoneroTransactionFinalAck::set_cout_key(const ::std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  cout_key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:hw.trezor.messages.monero.MoneroTransactionFinalAck.cout_key)
}
#if LANG_CXX11
inline void MoneroTransactionFinalAck::set_cout_key(::std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  cout_key_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:hw.trezor.messages.monero.MoneroTransactionFinalAck.cout_key)
}
#endif
inline void MoneroTransactionFinalAck::set_cout_key(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  cout_key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:hw.trezor.messages.monero.MoneroTransactionFinalAck.cout_key)
}
inline void MoneroTransactionFinalAck::set_cout_key(const void* value, size_t size) {
  _has_bits_[0] |= 0x00000001u;
  cout_key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:hw.trezor.messages.monero.MoneroTransactionFinalAck.cout_key)
}
inline ::std::string* MoneroTransactionFinalAck::mutable_cout_key() {
  _has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_mutable:hw.trezor.messages.monero.MoneroTransactionFinalAck.cout_key)
  return cout_key_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* MoneroTransactionFinalAck::release_cout_key() {
  // @@protoc_insertion_point(field_release:hw.trezor.messages.monero.MoneroTransactionFinalAck.cout_key)
  if (!has_cout_key()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return cout_key_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void MoneroTransactionFinalAck::set_allocated_cout_key(::std::string* cout_key) {
  if (cout_key != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  cout_key_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), cout_key);
  // @@protoc_insertion_point(field_set_allocated:hw.trezor.messages.monero.MoneroTransactionFinalAck.cout_key)
}

// optional bytes salt = 2;
inline bool MoneroTransactionFinalAck::has_salt() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void MoneroTransactionFinalAck::clear_salt() {
  salt_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000002u;
}
inline const ::std::string& MoneroTransactionFinalAck::salt() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.monero.MoneroTransactionFinalAck.salt)
  return salt_.GetNoArena();
}
inline void MoneroTransactionFinalAck::set_salt(const ::std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  salt_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:hw.trezor.messages.monero.MoneroTransactionFinalAck.salt)
}
#if LANG_CXX11
inline void MoneroTransactionFinalAck::set_salt(::std::string&& value) {
  _has_bits_[0] |= 0x00000002u;
  salt_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:hw.trezor.messages.monero.MoneroTransactionFinalAck.salt)
}
#endif
inline void MoneroTransactionFinalAck::set_salt(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000002u;
  salt_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:hw.trezor.messages.monero.MoneroTransactionFinalAck.salt)
}
inline void MoneroTransactionFinalAck::set_salt(const void* value, size_t size) {
  _has_bits_[0] |= 0x00000002u;
  salt_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:hw.trezor.messages.monero.MoneroTransactionFinalAck.salt)
}
inline ::std::string* MoneroTransactionFinalAck::mutable_salt() {
  _has_bits_[0] |= 0x00000002u;
  // @@protoc_insertion_point(field_mutable:hw.trezor.messages.monero.MoneroTransactionFinalAck.salt)
  return salt_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* MoneroTransactionFinalAck::release_salt() {
  // @@protoc_insertion_point(field_release:hw.trezor.messages.monero.MoneroTransactionFinalAck.salt)
  if (!has_salt()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  return salt_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void MoneroTransactionFinalAck::set_allocated_salt(::std::string* salt) {
  if (salt != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  salt_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), salt);
  // @@protoc_insertion_point(field_set_allocated:hw.trezor.messages.monero.MoneroTransactionFinalAck.salt)
}

// optional bytes rand_mult = 3;
inline bool MoneroTransactionFinalAck::has_rand_mult() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void MoneroTransactionFinalAck::clear_rand_mult() {
  rand_mult_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000004u;
}
inline const ::std::string& MoneroTransactionFinalAck::rand_mult() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.monero.MoneroTransactionFinalAck.rand_mult)
  return rand_mult_.GetNoArena();
}
inline void MoneroTransactionFinalAck::set_rand_mult(const ::std::string& value) {
  _has_bits_[0] |= 0x00000004u;
  rand_mult_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:hw.trezor.messages.monero.MoneroTransactionFinalAck.rand_mult)
}
#if LANG_CXX11
inline void MoneroTransactionFinalAck::set_rand_mult(::std::string&& value) {
  _has_bits_[0] |= 0x00000004u;
  rand_mult_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:hw.trezor.messages.monero.MoneroTransactionFinalAck.rand_mult)
}
#endif
inline void MoneroTransactionFinalAck::set_rand_mult(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000004u;
  rand_mult_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:hw.trezor.messages.monero.MoneroTransactionFinalAck.rand_mult)
}
inline void MoneroTransactionFinalAck::set_rand_mult(const void* value, size_t size) {
  _has_bits_[0] |= 0x00000004u;
  rand_mult_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:hw.trezor.messages.monero.MoneroTransactionFinalAck.rand_mult)
}
inline ::std::string* MoneroTransactionFinalAck::mutable_rand_mult() {
  _has_bits_[0] |= 0x00000004u;
  // @@protoc_insertion_point(field_mutable:hw.trezor.messages.monero.MoneroTransactionFinalAck.rand_mult)
  return rand_mult_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* MoneroTransactionFinalAck::release_rand_mult() {
  // @@protoc_insertion_point(field_release:hw.trezor.messages.monero.MoneroTransactionFinalAck.rand_mult)
  if (!has_rand_mult()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000004u;
  return rand_mult_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void MoneroTransactionFinalAck::set_allocated_rand_mult(::std::string* rand_mult) {
  if (rand_mult != nullptr) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  rand_mult_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), rand_mult);
  // @@protoc_insertion_point(field_set_allocated:hw.trezor.messages.monero.MoneroTransactionFinalAck.rand_mult)
}

// optional bytes tx_enc_keys = 4;
inline bool MoneroTransactionFinalAck::has_tx_enc_keys() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void MoneroTransactionFinalAck::clear_tx_enc_keys() {
  tx_enc_keys_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000008u;
}
inline const ::std::string& MoneroTransactionFinalAck::tx_enc_keys() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.monero.MoneroTransactionFinalAck.tx_enc_keys)
  return tx_enc_keys_.GetNoArena();
}
inline void MoneroTransactionFinalAck::set_tx_enc_keys(const ::std::string& value) {
  _has_bits_[0] |= 0x00000008u;
  tx_enc_keys_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:hw.trezor.messages.monero.MoneroTransactionFinalAck.tx_enc_keys)
}
#if LANG_CXX11
inline void MoneroTransactionFinalAck::set_tx_enc_keys(::std::string&& value) {
  _has_bits_[0] |= 0x00000008u;
  tx_enc_keys_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:hw.trezor.messages.monero.MoneroTransactionFinalAck.tx_enc_keys)
}
#endif
inline void MoneroTransactionFinalAck::set_tx_enc_keys(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000008u;
  tx_enc_keys_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:hw.trezor.messages.monero.MoneroTransactionFinalAck.tx_enc_keys)
}
inline void MoneroTransactionFinalAck::set_tx_enc_keys(const void* value, size_t size) {
  _has_bits_[0] |= 0x00000008u;
  tx_enc_keys_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:hw.trezor.messages.monero.MoneroTransactionFinalAck.tx_enc_keys)
}
inline ::std::string* MoneroTransactionFinalAck::mutable_tx_enc_keys() {
  _has_bits_[0] |= 0x00000008u;
  // @@protoc_insertion_point(field_mutable:hw.trezor.messages.monero.MoneroTransactionFinalAck.tx_enc_keys)
  return tx_enc_keys_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* MoneroTransactionFinalAck::release_tx_enc_keys() {
  // @@protoc_insertion_point(field_release:hw.trezor.messages.monero.MoneroTransactionFinalAck.tx_enc_keys)
  if (!has_tx_enc_keys()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000008u;
  return tx_enc_keys_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void MoneroTransactionFinalAck::set_allocated_tx_enc_keys(::std::string* tx_enc_keys) {
  if (tx_enc_keys != nullptr) {
    _has_bits_[0] |= 0x00000008u;
  } else {
    _has_bits_[0] &= ~0x00000008u;
  }
  tx_enc_keys_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), tx_enc_keys);
  // @@protoc_insertion_point(field_set_allocated:hw.trezor.messages.monero.MoneroTransactionFinalAck.tx_enc_keys)
}

// -------------------------------------------------------------------

// MoneroKeyImageExportInitRequest_MoneroSubAddressIndicesList

// optional uint32 account = 1;
inline bool MoneroKeyImageExportInitRequest_MoneroSubAddressIndicesList::has_account() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MoneroKeyImageExportInitRequest_MoneroSubAddressIndicesList::clear_account() {
  account_ = 0u;
  _has_bits_[0] &= ~0x00000001u;
}
inline ::google::protobuf::uint32 MoneroKeyImageExportInitRequest_MoneroSubAddressIndicesList::account() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.monero.MoneroKeyImageExportInitRequest.MoneroSubAddressIndicesList.account)
  return account_;
}
inline void MoneroKeyImageExportInitRequest_MoneroSubAddressIndicesList::set_account(::google::protobuf::uint32 value) {
  _has_bits_[0] |= 0x00000001u;
  account_ = value;
  // @@protoc_insertion_point(field_set:hw.trezor.messages.monero.MoneroKeyImageExportInitRequest.MoneroSubAddressIndicesList.account)
}

// repeated uint32 minor_indices = 2;
inline int MoneroKeyImageExportInitRequest_MoneroSubAddressIndicesList::minor_indices_size() const {
  return minor_indices_.size();
}
inline void MoneroKeyImageExportInitRequest_MoneroSubAddressIndicesList::clear_minor_indices() {
  minor_indices_.Clear();
}
inline ::google::protobuf::uint32 MoneroKeyImageExportInitRequest_MoneroSubAddressIndicesList::minor_indices(int index) const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.monero.MoneroKeyImageExportInitRequest.MoneroSubAddressIndicesList.minor_indices)
  return minor_indices_.Get(index);
}
inline void MoneroKeyImageExportInitRequest_MoneroSubAddressIndicesList::set_minor_indices(int index, ::google::protobuf::uint32 value) {
  minor_indices_.Set(index, value);
  // @@protoc_insertion_point(field_set:hw.trezor.messages.monero.MoneroKeyImageExportInitRequest.MoneroSubAddressIndicesList.minor_indices)
}
inline void MoneroKeyImageExportInitRequest_MoneroSubAddressIndicesList::add_minor_indices(::google::protobuf::uint32 value) {
  minor_indices_.Add(value);
  // @@protoc_insertion_point(field_add:hw.trezor.messages.monero.MoneroKeyImageExportInitRequest.MoneroSubAddressIndicesList.minor_indices)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
MoneroKeyImageExportInitRequest_MoneroSubAddressIndicesList::minor_indices() const {
  // @@protoc_insertion_point(field_list:hw.trezor.messages.monero.MoneroKeyImageExportInitRequest.MoneroSubAddressIndicesList.minor_indices)
  return minor_indices_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
MoneroKeyImageExportInitRequest_MoneroSubAddressIndicesList::mutable_minor_indices() {
  // @@protoc_insertion_point(field_mutable_list:hw.trezor.messages.monero.MoneroKeyImageExportInitRequest.MoneroSubAddressIndicesList.minor_indices)
  return &minor_indices_;
}

// -------------------------------------------------------------------

// MoneroKeyImageExportInitRequest

// optional uint64 num = 1;
inline bool MoneroKeyImageExportInitRequest::has_num() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void MoneroKeyImageExportInitRequest::clear_num() {
  num_ = PROTOBUF_ULONGLONG(0);
  _has_bits_[0] &= ~0x00000002u;
}
inline ::google::protobuf::uint64 MoneroKeyImageExportInitRequest::num() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.monero.MoneroKeyImageExportInitRequest.num)
  return num_;
}
inline void MoneroKeyImageExportInitRequest::set_num(::google::protobuf::uint64 value) {
  _has_bits_[0] |= 0x00000002u;
  num_ = value;
  // @@protoc_insertion_point(field_set:hw.trezor.messages.monero.MoneroKeyImageExportInitRequest.num)
}

// optional bytes hash = 2;
inline bool MoneroKeyImageExportInitRequest::has_hash() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MoneroKeyImageExportInitRequest::clear_hash() {
  hash_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::std::string& MoneroKeyImageExportInitRequest::hash() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.monero.MoneroKeyImageExportInitRequest.hash)
  return hash_.GetNoArena();
}
inline void MoneroKeyImageExportInitRequest::set_hash(const ::std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  hash_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:hw.trezor.messages.monero.MoneroKeyImageExportInitRequest.hash)
}
#if LANG_CXX11
inline void MoneroKeyImageExportInitRequest::set_hash(::std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  hash_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:hw.trezor.messages.monero.MoneroKeyImageExportInitRequest.hash)
}
#endif
inline void MoneroKeyImageExportInitRequest::set_hash(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  hash_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:hw.trezor.messages.monero.MoneroKeyImageExportInitRequest.hash)
}
inline void MoneroKeyImageExportInitRequest::set_hash(const void* value, size_t size) {
  _has_bits_[0] |= 0x00000001u;
  hash_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:hw.trezor.messages.monero.MoneroKeyImageExportInitRequest.hash)
}
inline ::std::string* MoneroKeyImageExportInitRequest::mutable_hash() {
  _has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_mutable:hw.trezor.messages.monero.MoneroKeyImageExportInitRequest.hash)
  return hash_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* MoneroKeyImageExportInitRequest::release_hash() {
  // @@protoc_insertion_point(field_release:hw.trezor.messages.monero.MoneroKeyImageExportInitRequest.hash)
  if (!has_hash()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return hash_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void MoneroKeyImageExportInitRequest::set_allocated_hash(::std::string* hash) {
  if (hash != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  hash_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), hash);
  // @@protoc_insertion_point(field_set_allocated:hw.trezor.messages.monero.MoneroKeyImageExportInitRequest.hash)
}

// repeated uint32 address_n = 3;
inline int MoneroKeyImageExportInitRequest::address_n_size() const {
  return address_n_.size();
}
inline void MoneroKeyImageExportInitRequest::clear_address_n() {
  address_n_.Clear();
}
inline ::google::protobuf::uint32 MoneroKeyImageExportInitRequest::address_n(int index) const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.monero.MoneroKeyImageExportInitRequest.address_n)
  return address_n_.Get(index);
}
inline void MoneroKeyImageExportInitRequest::set_address_n(int index, ::google::protobuf::uint32 value) {
  address_n_.Set(index, value);
  // @@protoc_insertion_point(field_set:hw.trezor.messages.monero.MoneroKeyImageExportInitRequest.address_n)
}
inline void MoneroKeyImageExportInitRequest::add_address_n(::google::protobuf::uint32 value) {
  address_n_.Add(value);
  // @@protoc_insertion_point(field_add:hw.trezor.messages.monero.MoneroKeyImageExportInitRequest.address_n)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
MoneroKeyImageExportInitRequest::address_n() const {
  // @@protoc_insertion_point(field_list:hw.trezor.messages.monero.MoneroKeyImageExportInitRequest.address_n)
  return address_n_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
MoneroKeyImageExportInitRequest::mutable_address_n() {
  // @@protoc_insertion_point(field_mutable_list:hw.trezor.messages.monero.MoneroKeyImageExportInitRequest.address_n)
  return &address_n_;
}

// optional uint32 network_type = 4;
inline bool MoneroKeyImageExportInitRequest::has_network_type() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void MoneroKeyImageExportInitRequest::clear_network_type() {
  network_type_ = 0u;
  _has_bits_[0] &= ~0x00000004u;
}
inline ::google::protobuf::uint32 MoneroKeyImageExportInitRequest::network_type() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.monero.MoneroKeyImageExportInitRequest.network_type)
  return network_type_;
}
inline void MoneroKeyImageExportInitRequest::set_network_type(::google::protobuf::uint32 value) {
  _has_bits_[0] |= 0x00000004u;
  network_type_ = value;
  // @@protoc_insertion_point(field_set:hw.trezor.messages.monero.MoneroKeyImageExportInitRequest.network_type)
}

// repeated .hw.trezor.messages.monero.MoneroKeyImageExportInitRequest.MoneroSubAddressIndicesList subs = 5;
inline int MoneroKeyImageExportInitRequest::subs_size() const {
  return subs_.size();
}
inline void MoneroKeyImageExportInitRequest::clear_subs() {
  subs_.Clear();
}
inline ::hw::trezor::messages::monero::MoneroKeyImageExportInitRequest_MoneroSubAddressIndicesList* MoneroKeyImageExportInitRequest::mutable_subs(int index) {
  // @@protoc_insertion_point(field_mutable:hw.trezor.messages.monero.MoneroKeyImageExportInitRequest.subs)
  return subs_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::hw::trezor::messages::monero::MoneroKeyImageExportInitRequest_MoneroSubAddressIndicesList >*
MoneroKeyImageExportInitRequest::mutable_subs() {
  // @@protoc_insertion_point(field_mutable_list:hw.trezor.messages.monero.MoneroKeyImageExportInitRequest.subs)
  return &subs_;
}
inline const ::hw::trezor::messages::monero::MoneroKeyImageExportInitRequest_MoneroSubAddressIndicesList& MoneroKeyImageExportInitRequest::subs(int index) const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.monero.MoneroKeyImageExportInitRequest.subs)
  return subs_.Get(index);
}
inline ::hw::trezor::messages::monero::MoneroKeyImageExportInitRequest_MoneroSubAddressIndicesList* MoneroKeyImageExportInitRequest::add_subs() {
  // @@protoc_insertion_point(field_add:hw.trezor.messages.monero.MoneroKeyImageExportInitRequest.subs)
  return subs_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::hw::trezor::messages::monero::MoneroKeyImageExportInitRequest_MoneroSubAddressIndicesList >&
MoneroKeyImageExportInitRequest::subs() const {
  // @@protoc_insertion_point(field_list:hw.trezor.messages.monero.MoneroKeyImageExportInitRequest.subs)
  return subs_;
}

// -------------------------------------------------------------------

// MoneroKeyImageExportInitAck

// -------------------------------------------------------------------

// MoneroKeyImageSyncStepRequest_MoneroTransferDetails

// optional bytes out_key = 1;
inline bool MoneroKeyImageSyncStepRequest_MoneroTransferDetails::has_out_key() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MoneroKeyImageSyncStepRequest_MoneroTransferDetails::clear_out_key() {
  out_key_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::std::string& MoneroKeyImageSyncStepRequest_MoneroTransferDetails::out_key() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.monero.MoneroKeyImageSyncStepRequest.MoneroTransferDetails.out_key)
  return out_key_.GetNoArena();
}
inline void MoneroKeyImageSyncStepRequest_MoneroTransferDetails::set_out_key(const ::std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  out_key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:hw.trezor.messages.monero.MoneroKeyImageSyncStepRequest.MoneroTransferDetails.out_key)
}
#if LANG_CXX11
inline void MoneroKeyImageSyncStepRequest_MoneroTransferDetails::set_out_key(::std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  out_key_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:hw.trezor.messages.monero.MoneroKeyImageSyncStepRequest.MoneroTransferDetails.out_key)
}
#endif
inline void MoneroKeyImageSyncStepRequest_MoneroTransferDetails::set_out_key(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  out_key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:hw.trezor.messages.monero.MoneroKeyImageSyncStepRequest.MoneroTransferDetails.out_key)
}
inline void MoneroKeyImageSyncStepRequest_MoneroTransferDetails::set_out_key(const void* value, size_t size) {
  _has_bits_[0] |= 0x00000001u;
  out_key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:hw.trezor.messages.monero.MoneroKeyImageSyncStepRequest.MoneroTransferDetails.out_key)
}
inline ::std::string* MoneroKeyImageSyncStepRequest_MoneroTransferDetails::mutable_out_key() {
  _has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_mutable:hw.trezor.messages.monero.MoneroKeyImageSyncStepRequest.MoneroTransferDetails.out_key)
  return out_key_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* MoneroKeyImageSyncStepRequest_MoneroTransferDetails::release_out_key() {
  // @@protoc_insertion_point(field_release:hw.trezor.messages.monero.MoneroKeyImageSyncStepRequest.MoneroTransferDetails.out_key)
  if (!has_out_key()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return out_key_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void MoneroKeyImageSyncStepRequest_MoneroTransferDetails::set_allocated_out_key(::std::string* out_key) {
  if (out_key != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  out_key_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), out_key);
  // @@protoc_insertion_point(field_set_allocated:hw.trezor.messages.monero.MoneroKeyImageSyncStepRequest.MoneroTransferDetails.out_key)
}

// optional bytes tx_pub_key = 2;
inline bool MoneroKeyImageSyncStepRequest_MoneroTransferDetails::has_tx_pub_key() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void MoneroKeyImageSyncStepRequest_MoneroTransferDetails::clear_tx_pub_key() {
  tx_pub_key_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000002u;
}
inline const ::std::string& MoneroKeyImageSyncStepRequest_MoneroTransferDetails::tx_pub_key() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.monero.MoneroKeyImageSyncStepRequest.MoneroTransferDetails.tx_pub_key)
  return tx_pub_key_.GetNoArena();
}
inline void MoneroKeyImageSyncStepRequest_MoneroTransferDetails::set_tx_pub_key(const ::std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  tx_pub_key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:hw.trezor.messages.monero.MoneroKeyImageSyncStepRequest.MoneroTransferDetails.tx_pub_key)
}
#if LANG_CXX11
inline void MoneroKeyImageSyncStepRequest_MoneroTransferDetails::set_tx_pub_key(::std::string&& value) {
  _has_bits_[0] |= 0x00000002u;
  tx_pub_key_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:hw.trezor.messages.monero.MoneroKeyImageSyncStepRequest.MoneroTransferDetails.tx_pub_key)
}
#endif
inline void MoneroKeyImageSyncStepRequest_MoneroTransferDetails::set_tx_pub_key(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000002u;
  tx_pub_key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:hw.trezor.messages.monero.MoneroKeyImageSyncStepRequest.MoneroTransferDetails.tx_pub_key)
}
inline void MoneroKeyImageSyncStepRequest_MoneroTransferDetails::set_tx_pub_key(const void* value, size_t size) {
  _has_bits_[0] |= 0x00000002u;
  tx_pub_key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:hw.trezor.messages.monero.MoneroKeyImageSyncStepRequest.MoneroTransferDetails.tx_pub_key)
}
inline ::std::string* MoneroKeyImageSyncStepRequest_MoneroTransferDetails::mutable_tx_pub_key() {
  _has_bits_[0] |= 0x00000002u;
  // @@protoc_insertion_point(field_mutable:hw.trezor.messages.monero.MoneroKeyImageSyncStepRequest.MoneroTransferDetails.tx_pub_key)
  return tx_pub_key_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* MoneroKeyImageSyncStepRequest_MoneroTransferDetails::release_tx_pub_key() {
  // @@protoc_insertion_point(field_release:hw.trezor.messages.monero.MoneroKeyImageSyncStepRequest.MoneroTransferDetails.tx_pub_key)
  if (!has_tx_pub_key()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  return tx_pub_key_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void MoneroKeyImageSyncStepRequest_MoneroTransferDetails::set_allocated_tx_pub_key(::std::string* tx_pub_key) {
  if (tx_pub_key != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  tx_pub_key_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), tx_pub_key);
  // @@protoc_insertion_point(field_set_allocated:hw.trezor.messages.monero.MoneroKeyImageSyncStepRequest.MoneroTransferDetails.tx_pub_key)
}

// repeated bytes additional_tx_pub_keys = 3;
inline int MoneroKeyImageSyncStepRequest_MoneroTransferDetails::additional_tx_pub_keys_size() const {
  return additional_tx_pub_keys_.size();
}
inline void MoneroKeyImageSyncStepRequest_MoneroTransferDetails::clear_additional_tx_pub_keys() {
  additional_tx_pub_keys_.Clear();
}
inline const ::std::string& MoneroKeyImageSyncStepRequest_MoneroTransferDetails::additional_tx_pub_keys(int index) const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.monero.MoneroKeyImageSyncStepRequest.MoneroTransferDetails.additional_tx_pub_keys)
  return additional_tx_pub_keys_.Get(index);
}
inline ::std::string* MoneroKeyImageSyncStepRequest_MoneroTransferDetails::mutable_additional_tx_pub_keys(int index) {
  // @@protoc_insertion_point(field_mutable:hw.trezor.messages.monero.MoneroKeyImageSyncStepRequest.MoneroTransferDetails.additional_tx_pub_keys)
  return additional_tx_pub_keys_.Mutable(index);
}
inline void MoneroKeyImageSyncStepRequest_MoneroTransferDetails::set_additional_tx_pub_keys(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:hw.trezor.messages.monero.MoneroKeyImageSyncStepRequest.MoneroTransferDetails.additional_tx_pub_keys)
  additional_tx_pub_keys_.Mutable(index)->assign(value);
}
#if LANG_CXX11
inline void MoneroKeyImageSyncStepRequest_MoneroTransferDetails::set_additional_tx_pub_keys(int index, ::std::string&& value) {
  // @@protoc_insertion_point(field_set:hw.trezor.messages.monero.MoneroKeyImageSyncStepRequest.MoneroTransferDetails.additional_tx_pub_keys)
  additional_tx_pub_keys_.Mutable(index)->assign(std::move(value));
}
#endif
inline void MoneroKeyImageSyncStepRequest_MoneroTransferDetails::set_additional_tx_pub_keys(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  additional_tx_pub_keys_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:hw.trezor.messages.monero.MoneroKeyImageSyncStepRequest.MoneroTransferDetails.additional_tx_pub_keys)
}
inline void MoneroKeyImageSyncStepRequest_MoneroTransferDetails::set_additional_tx_pub_keys(int index, const void* value, size_t size) {
  additional_tx_pub_keys_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:hw.trezor.messages.monero.MoneroKeyImageSyncStepRequest.MoneroTransferDetails.additional_tx_pub_keys)
}
inline ::std::string* MoneroKeyImageSyncStepRequest_MoneroTransferDetails::add_additional_tx_pub_keys() {
  // @@protoc_insertion_point(field_add_mutable:hw.trezor.messages.monero.MoneroKeyImageSyncStepRequest.MoneroTransferDetails.additional_tx_pub_keys)
  return additional_tx_pub_keys_.Add();
}
inline void MoneroKeyImageSyncStepRequest_MoneroTransferDetails::add_additional_tx_pub_keys(const ::std::string& value) {
  additional_tx_pub_keys_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:hw.trezor.messages.monero.MoneroKeyImageSyncStepRequest.MoneroTransferDetails.additional_tx_pub_keys)
}
#if LANG_CXX11
inline void MoneroKeyImageSyncStepRequest_MoneroTransferDetails::add_additional_tx_pub_keys(::std::string&& value) {
  additional_tx_pub_keys_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:hw.trezor.messages.monero.MoneroKeyImageSyncStepRequest.MoneroTransferDetails.additional_tx_pub_keys)
}
#endif
inline void MoneroKeyImageSyncStepRequest_MoneroTransferDetails::add_additional_tx_pub_keys(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  additional_tx_pub_keys_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:hw.trezor.messages.monero.MoneroKeyImageSyncStepRequest.MoneroTransferDetails.additional_tx_pub_keys)
}
inline void MoneroKeyImageSyncStepRequest_MoneroTransferDetails::add_additional_tx_pub_keys(const void* value, size_t size) {
  additional_tx_pub_keys_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:hw.trezor.messages.monero.MoneroKeyImageSyncStepRequest.MoneroTransferDetails.additional_tx_pub_keys)
}
inline const ::google::protobuf::RepeatedPtrField<::std::string>&
MoneroKeyImageSyncStepRequest_MoneroTransferDetails::additional_tx_pub_keys() const {
  // @@protoc_insertion_point(field_list:hw.trezor.messages.monero.MoneroKeyImageSyncStepRequest.MoneroTransferDetails.additional_tx_pub_keys)
  return additional_tx_pub_keys_;
}
inline ::google::protobuf::RepeatedPtrField<::std::string>*
MoneroKeyImageSyncStepRequest_MoneroTransferDetails::mutable_additional_tx_pub_keys() {
  // @@protoc_insertion_point(field_mutable_list:hw.trezor.messages.monero.MoneroKeyImageSyncStepRequest.MoneroTransferDetails.additional_tx_pub_keys)
  return &additional_tx_pub_keys_;
}

// optional uint64 internal_output_index = 4;
inline bool MoneroKeyImageSyncStepRequest_MoneroTransferDetails::has_internal_output_index() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void MoneroKeyImageSyncStepRequest_MoneroTransferDetails::clear_internal_output_index() {
  internal_output_index_ = PROTOBUF_ULONGLONG(0);
  _has_bits_[0] &= ~0x00000004u;
}
inline ::google::protobuf::uint64 MoneroKeyImageSyncStepRequest_MoneroTransferDetails::internal_output_index() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.monero.MoneroKeyImageSyncStepRequest.MoneroTransferDetails.internal_output_index)
  return internal_output_index_;
}
inline void MoneroKeyImageSyncStepRequest_MoneroTransferDetails::set_internal_output_index(::google::protobuf::uint64 value) {
  _has_bits_[0] |= 0x00000004u;
  internal_output_index_ = value;
  // @@protoc_insertion_point(field_set:hw.trezor.messages.monero.MoneroKeyImageSyncStepRequest.MoneroTransferDetails.internal_output_index)
}

// -------------------------------------------------------------------

// MoneroKeyImageSyncStepRequest

// repeated .hw.trezor.messages.monero.MoneroKeyImageSyncStepRequest.MoneroTransferDetails tdis = 1;
inline int MoneroKeyImageSyncStepRequest::tdis_size() const {
  return tdis_.size();
}
inline void MoneroKeyImageSyncStepRequest::clear_tdis() {
  tdis_.Clear();
}
inline ::hw::trezor::messages::monero::MoneroKeyImageSyncStepRequest_MoneroTransferDetails* MoneroKeyImageSyncStepRequest::mutable_tdis(int index) {
  // @@protoc_insertion_point(field_mutable:hw.trezor.messages.monero.MoneroKeyImageSyncStepRequest.tdis)
  return tdis_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::hw::trezor::messages::monero::MoneroKeyImageSyncStepRequest_MoneroTransferDetails >*
MoneroKeyImageSyncStepRequest::mutable_tdis() {
  // @@protoc_insertion_point(field_mutable_list:hw.trezor.messages.monero.MoneroKeyImageSyncStepRequest.tdis)
  return &tdis_;
}
inline const ::hw::trezor::messages::monero::MoneroKeyImageSyncStepRequest_MoneroTransferDetails& MoneroKeyImageSyncStepRequest::tdis(int index) const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.monero.MoneroKeyImageSyncStepRequest.tdis)
  return tdis_.Get(index);
}
inline ::hw::trezor::messages::monero::MoneroKeyImageSyncStepRequest_MoneroTransferDetails* MoneroKeyImageSyncStepRequest::add_tdis() {
  // @@protoc_insertion_point(field_add:hw.trezor.messages.monero.MoneroKeyImageSyncStepRequest.tdis)
  return tdis_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::hw::trezor::messages::monero::MoneroKeyImageSyncStepRequest_MoneroTransferDetails >&
MoneroKeyImageSyncStepRequest::tdis() const {
  // @@protoc_insertion_point(field_list:hw.trezor.messages.monero.MoneroKeyImageSyncStepRequest.tdis)
  return tdis_;
}

// -------------------------------------------------------------------

// MoneroKeyImageSyncStepAck_MoneroExportedKeyImage

// optional bytes iv = 1;
inline bool MoneroKeyImageSyncStepAck_MoneroExportedKeyImage::has_iv() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MoneroKeyImageSyncStepAck_MoneroExportedKeyImage::clear_iv() {
  iv_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::std::string& MoneroKeyImageSyncStepAck_MoneroExportedKeyImage::iv() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.monero.MoneroKeyImageSyncStepAck.MoneroExportedKeyImage.iv)
  return iv_.GetNoArena();
}
inline void MoneroKeyImageSyncStepAck_MoneroExportedKeyImage::set_iv(const ::std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  iv_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:hw.trezor.messages.monero.MoneroKeyImageSyncStepAck.MoneroExportedKeyImage.iv)
}
#if LANG_CXX11
inline void MoneroKeyImageSyncStepAck_MoneroExportedKeyImage::set_iv(::std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  iv_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:hw.trezor.messages.monero.MoneroKeyImageSyncStepAck.MoneroExportedKeyImage.iv)
}
#endif
inline void MoneroKeyImageSyncStepAck_MoneroExportedKeyImage::set_iv(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  iv_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:hw.trezor.messages.monero.MoneroKeyImageSyncStepAck.MoneroExportedKeyImage.iv)
}
inline void MoneroKeyImageSyncStepAck_MoneroExportedKeyImage::set_iv(const void* value, size_t size) {
  _has_bits_[0] |= 0x00000001u;
  iv_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:hw.trezor.messages.monero.MoneroKeyImageSyncStepAck.MoneroExportedKeyImage.iv)
}
inline ::std::string* MoneroKeyImageSyncStepAck_MoneroExportedKeyImage::mutable_iv() {
  _has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_mutable:hw.trezor.messages.monero.MoneroKeyImageSyncStepAck.MoneroExportedKeyImage.iv)
  return iv_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* MoneroKeyImageSyncStepAck_MoneroExportedKeyImage::release_iv() {
  // @@protoc_insertion_point(field_release:hw.trezor.messages.monero.MoneroKeyImageSyncStepAck.MoneroExportedKeyImage.iv)
  if (!has_iv()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return iv_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void MoneroKeyImageSyncStepAck_MoneroExportedKeyImage::set_allocated_iv(::std::string* iv) {
  if (iv != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  iv_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), iv);
  // @@protoc_insertion_point(field_set_allocated:hw.trezor.messages.monero.MoneroKeyImageSyncStepAck.MoneroExportedKeyImage.iv)
}

// optional bytes blob = 3;
inline bool MoneroKeyImageSyncStepAck_MoneroExportedKeyImage::has_blob() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void MoneroKeyImageSyncStepAck_MoneroExportedKeyImage::clear_blob() {
  blob_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000002u;
}
inline const ::std::string& MoneroKeyImageSyncStepAck_MoneroExportedKeyImage::blob() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.monero.MoneroKeyImageSyncStepAck.MoneroExportedKeyImage.blob)
  return blob_.GetNoArena();
}
inline void MoneroKeyImageSyncStepAck_MoneroExportedKeyImage::set_blob(const ::std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  blob_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:hw.trezor.messages.monero.MoneroKeyImageSyncStepAck.MoneroExportedKeyImage.blob)
}
#if LANG_CXX11
inline void MoneroKeyImageSyncStepAck_MoneroExportedKeyImage::set_blob(::std::string&& value) {
  _has_bits_[0] |= 0x00000002u;
  blob_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:hw.trezor.messages.monero.MoneroKeyImageSyncStepAck.MoneroExportedKeyImage.blob)
}
#endif
inline void MoneroKeyImageSyncStepAck_MoneroExportedKeyImage::set_blob(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000002u;
  blob_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:hw.trezor.messages.monero.MoneroKeyImageSyncStepAck.MoneroExportedKeyImage.blob)
}
inline void MoneroKeyImageSyncStepAck_MoneroExportedKeyImage::set_blob(const void* value, size_t size) {
  _has_bits_[0] |= 0x00000002u;
  blob_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:hw.trezor.messages.monero.MoneroKeyImageSyncStepAck.MoneroExportedKeyImage.blob)
}
inline ::std::string* MoneroKeyImageSyncStepAck_MoneroExportedKeyImage::mutable_blob() {
  _has_bits_[0] |= 0x00000002u;
  // @@protoc_insertion_point(field_mutable:hw.trezor.messages.monero.MoneroKeyImageSyncStepAck.MoneroExportedKeyImage.blob)
  return blob_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* MoneroKeyImageSyncStepAck_MoneroExportedKeyImage::release_blob() {
  // @@protoc_insertion_point(field_release:hw.trezor.messages.monero.MoneroKeyImageSyncStepAck.MoneroExportedKeyImage.blob)
  if (!has_blob()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  return blob_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void MoneroKeyImageSyncStepAck_MoneroExportedKeyImage::set_allocated_blob(::std::string* blob) {
  if (blob != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  blob_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), blob);
  // @@protoc_insertion_point(field_set_allocated:hw.trezor.messages.monero.MoneroKeyImageSyncStepAck.MoneroExportedKeyImage.blob)
}

// -------------------------------------------------------------------

// MoneroKeyImageSyncStepAck

// repeated .hw.trezor.messages.monero.MoneroKeyImageSyncStepAck.MoneroExportedKeyImage kis = 1;
inline int MoneroKeyImageSyncStepAck::kis_size() const {
  return kis_.size();
}
inline void MoneroKeyImageSyncStepAck::clear_kis() {
  kis_.Clear();
}
inline ::hw::trezor::messages::monero::MoneroKeyImageSyncStepAck_MoneroExportedKeyImage* MoneroKeyImageSyncStepAck::mutable_kis(int index) {
  // @@protoc_insertion_point(field_mutable:hw.trezor.messages.monero.MoneroKeyImageSyncStepAck.kis)
  return kis_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::hw::trezor::messages::monero::MoneroKeyImageSyncStepAck_MoneroExportedKeyImage >*
MoneroKeyImageSyncStepAck::mutable_kis() {
  // @@protoc_insertion_point(field_mutable_list:hw.trezor.messages.monero.MoneroKeyImageSyncStepAck.kis)
  return &kis_;
}
inline const ::hw::trezor::messages::monero::MoneroKeyImageSyncStepAck_MoneroExportedKeyImage& MoneroKeyImageSyncStepAck::kis(int index) const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.monero.MoneroKeyImageSyncStepAck.kis)
  return kis_.Get(index);
}
inline ::hw::trezor::messages::monero::MoneroKeyImageSyncStepAck_MoneroExportedKeyImage* MoneroKeyImageSyncStepAck::add_kis() {
  // @@protoc_insertion_point(field_add:hw.trezor.messages.monero.MoneroKeyImageSyncStepAck.kis)
  return kis_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::hw::trezor::messages::monero::MoneroKeyImageSyncStepAck_MoneroExportedKeyImage >&
MoneroKeyImageSyncStepAck::kis() const {
  // @@protoc_insertion_point(field_list:hw.trezor.messages.monero.MoneroKeyImageSyncStepAck.kis)
  return kis_;
}

// -------------------------------------------------------------------

// MoneroKeyImageSyncFinalRequest

// -------------------------------------------------------------------

// MoneroKeyImageSyncFinalAck

// optional bytes enc_key = 1;
inline bool MoneroKeyImageSyncFinalAck::has_enc_key() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MoneroKeyImageSyncFinalAck::clear_enc_key() {
  enc_key_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::std::string& MoneroKeyImageSyncFinalAck::enc_key() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.monero.MoneroKeyImageSyncFinalAck.enc_key)
  return enc_key_.GetNoArena();
}
inline void MoneroKeyImageSyncFinalAck::set_enc_key(const ::std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  enc_key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:hw.trezor.messages.monero.MoneroKeyImageSyncFinalAck.enc_key)
}
#if LANG_CXX11
inline void MoneroKeyImageSyncFinalAck::set_enc_key(::std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  enc_key_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:hw.trezor.messages.monero.MoneroKeyImageSyncFinalAck.enc_key)
}
#endif
inline void MoneroKeyImageSyncFinalAck::set_enc_key(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  enc_key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:hw.trezor.messages.monero.MoneroKeyImageSyncFinalAck.enc_key)
}
inline void MoneroKeyImageSyncFinalAck::set_enc_key(const void* value, size_t size) {
  _has_bits_[0] |= 0x00000001u;
  enc_key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:hw.trezor.messages.monero.MoneroKeyImageSyncFinalAck.enc_key)
}
inline ::std::string* MoneroKeyImageSyncFinalAck::mutable_enc_key() {
  _has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_mutable:hw.trezor.messages.monero.MoneroKeyImageSyncFinalAck.enc_key)
  return enc_key_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* MoneroKeyImageSyncFinalAck::release_enc_key() {
  // @@protoc_insertion_point(field_release:hw.trezor.messages.monero.MoneroKeyImageSyncFinalAck.enc_key)
  if (!has_enc_key()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return enc_key_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void MoneroKeyImageSyncFinalAck::set_allocated_enc_key(::std::string* enc_key) {
  if (enc_key != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  enc_key_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), enc_key);
  // @@protoc_insertion_point(field_set_allocated:hw.trezor.messages.monero.MoneroKeyImageSyncFinalAck.enc_key)
}

// -------------------------------------------------------------------

// MoneroGetTxKeyRequest

// repeated uint32 address_n = 1;
inline int MoneroGetTxKeyRequest::address_n_size() const {
  return address_n_.size();
}
inline void MoneroGetTxKeyRequest::clear_address_n() {
  address_n_.Clear();
}
inline ::google::protobuf::uint32 MoneroGetTxKeyRequest::address_n(int index) const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.monero.MoneroGetTxKeyRequest.address_n)
  return address_n_.Get(index);
}
inline void MoneroGetTxKeyRequest::set_address_n(int index, ::google::protobuf::uint32 value) {
  address_n_.Set(index, value);
  // @@protoc_insertion_point(field_set:hw.trezor.messages.monero.MoneroGetTxKeyRequest.address_n)
}
inline void MoneroGetTxKeyRequest::add_address_n(::google::protobuf::uint32 value) {
  address_n_.Add(value);
  // @@protoc_insertion_point(field_add:hw.trezor.messages.monero.MoneroGetTxKeyRequest.address_n)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
MoneroGetTxKeyRequest::address_n() const {
  // @@protoc_insertion_point(field_list:hw.trezor.messages.monero.MoneroGetTxKeyRequest.address_n)
  return address_n_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
MoneroGetTxKeyRequest::mutable_address_n() {
  // @@protoc_insertion_point(field_mutable_list:hw.trezor.messages.monero.MoneroGetTxKeyRequest.address_n)
  return &address_n_;
}

// optional uint32 network_type = 2;
inline bool MoneroGetTxKeyRequest::has_network_type() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void MoneroGetTxKeyRequest::clear_network_type() {
  network_type_ = 0u;
  _has_bits_[0] &= ~0x00000020u;
}
inline ::google::protobuf::uint32 MoneroGetTxKeyRequest::network_type() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.monero.MoneroGetTxKeyRequest.network_type)
  return network_type_;
}
inline void MoneroGetTxKeyRequest::set_network_type(::google::protobuf::uint32 value) {
  _has_bits_[0] |= 0x00000020u;
  network_type_ = value;
  // @@protoc_insertion_point(field_set:hw.trezor.messages.monero.MoneroGetTxKeyRequest.network_type)
}

// optional bytes salt1 = 3;
inline bool MoneroGetTxKeyRequest::has_salt1() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MoneroGetTxKeyRequest::clear_salt1() {
  salt1_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::std::string& MoneroGetTxKeyRequest::salt1() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.monero.MoneroGetTxKeyRequest.salt1)
  return salt1_.GetNoArena();
}
inline void MoneroGetTxKeyRequest::set_salt1(const ::std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  salt1_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:hw.trezor.messages.monero.MoneroGetTxKeyRequest.salt1)
}
#if LANG_CXX11
inline void MoneroGetTxKeyRequest::set_salt1(::std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  salt1_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:hw.trezor.messages.monero.MoneroGetTxKeyRequest.salt1)
}
#endif
inline void MoneroGetTxKeyRequest::set_salt1(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  salt1_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:hw.trezor.messages.monero.MoneroGetTxKeyRequest.salt1)
}
inline void MoneroGetTxKeyRequest::set_salt1(const void* value, size_t size) {
  _has_bits_[0] |= 0x00000001u;
  salt1_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:hw.trezor.messages.monero.MoneroGetTxKeyRequest.salt1)
}
inline ::std::string* MoneroGetTxKeyRequest::mutable_salt1() {
  _has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_mutable:hw.trezor.messages.monero.MoneroGetTxKeyRequest.salt1)
  return salt1_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* MoneroGetTxKeyRequest::release_salt1() {
  // @@protoc_insertion_point(field_release:hw.trezor.messages.monero.MoneroGetTxKeyRequest.salt1)
  if (!has_salt1()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return salt1_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void MoneroGetTxKeyRequest::set_allocated_salt1(::std::string* salt1) {
  if (salt1 != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  salt1_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), salt1);
  // @@protoc_insertion_point(field_set_allocated:hw.trezor.messages.monero.MoneroGetTxKeyRequest.salt1)
}

// optional bytes salt2 = 4;
inline bool MoneroGetTxKeyRequest::has_salt2() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void MoneroGetTxKeyRequest::clear_salt2() {
  salt2_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000002u;
}
inline const ::std::string& MoneroGetTxKeyRequest::salt2() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.monero.MoneroGetTxKeyRequest.salt2)
  return salt2_.GetNoArena();
}
inline void MoneroGetTxKeyRequest::set_salt2(const ::std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  salt2_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:hw.trezor.messages.monero.MoneroGetTxKeyRequest.salt2)
}
#if LANG_CXX11
inline void MoneroGetTxKeyRequest::set_salt2(::std::string&& value) {
  _has_bits_[0] |= 0x00000002u;
  salt2_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:hw.trezor.messages.monero.MoneroGetTxKeyRequest.salt2)
}
#endif
inline void MoneroGetTxKeyRequest::set_salt2(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000002u;
  salt2_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:hw.trezor.messages.monero.MoneroGetTxKeyRequest.salt2)
}
inline void MoneroGetTxKeyRequest::set_salt2(const void* value, size_t size) {
  _has_bits_[0] |= 0x00000002u;
  salt2_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:hw.trezor.messages.monero.MoneroGetTxKeyRequest.salt2)
}
inline ::std::string* MoneroGetTxKeyRequest::mutable_salt2() {
  _has_bits_[0] |= 0x00000002u;
  // @@protoc_insertion_point(field_mutable:hw.trezor.messages.monero.MoneroGetTxKeyRequest.salt2)
  return salt2_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* MoneroGetTxKeyRequest::release_salt2() {
  // @@protoc_insertion_point(field_release:hw.trezor.messages.monero.MoneroGetTxKeyRequest.salt2)
  if (!has_salt2()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  return salt2_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void MoneroGetTxKeyRequest::set_allocated_salt2(::std::string* salt2) {
  if (salt2 != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  salt2_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), salt2);
  // @@protoc_insertion_point(field_set_allocated:hw.trezor.messages.monero.MoneroGetTxKeyRequest.salt2)
}

// optional bytes tx_enc_keys = 5;
inline bool MoneroGetTxKeyRequest::has_tx_enc_keys() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void MoneroGetTxKeyRequest::clear_tx_enc_keys() {
  tx_enc_keys_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000004u;
}
inline const ::std::string& MoneroGetTxKeyRequest::tx_enc_keys() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.monero.MoneroGetTxKeyRequest.tx_enc_keys)
  return tx_enc_keys_.GetNoArena();
}
inline void MoneroGetTxKeyRequest::set_tx_enc_keys(const ::std::string& value) {
  _has_bits_[0] |= 0x00000004u;
  tx_enc_keys_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:hw.trezor.messages.monero.MoneroGetTxKeyRequest.tx_enc_keys)
}
#if LANG_CXX11
inline void MoneroGetTxKeyRequest::set_tx_enc_keys(::std::string&& value) {
  _has_bits_[0] |= 0x00000004u;
  tx_enc_keys_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:hw.trezor.messages.monero.MoneroGetTxKeyRequest.tx_enc_keys)
}
#endif
inline void MoneroGetTxKeyRequest::set_tx_enc_keys(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000004u;
  tx_enc_keys_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:hw.trezor.messages.monero.MoneroGetTxKeyRequest.tx_enc_keys)
}
inline void MoneroGetTxKeyRequest::set_tx_enc_keys(const void* value, size_t size) {
  _has_bits_[0] |= 0x00000004u;
  tx_enc_keys_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:hw.trezor.messages.monero.MoneroGetTxKeyRequest.tx_enc_keys)
}
inline ::std::string* MoneroGetTxKeyRequest::mutable_tx_enc_keys() {
  _has_bits_[0] |= 0x00000004u;
  // @@protoc_insertion_point(field_mutable:hw.trezor.messages.monero.MoneroGetTxKeyRequest.tx_enc_keys)
  return tx_enc_keys_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* MoneroGetTxKeyRequest::release_tx_enc_keys() {
  // @@protoc_insertion_point(field_release:hw.trezor.messages.monero.MoneroGetTxKeyRequest.tx_enc_keys)
  if (!has_tx_enc_keys()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000004u;
  return tx_enc_keys_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void MoneroGetTxKeyRequest::set_allocated_tx_enc_keys(::std::string* tx_enc_keys) {
  if (tx_enc_keys != nullptr) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  tx_enc_keys_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), tx_enc_keys);
  // @@protoc_insertion_point(field_set_allocated:hw.trezor.messages.monero.MoneroGetTxKeyRequest.tx_enc_keys)
}

// optional bytes tx_prefix_hash = 6;
inline bool MoneroGetTxKeyRequest::has_tx_prefix_hash() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void MoneroGetTxKeyRequest::clear_tx_prefix_hash() {
  tx_prefix_hash_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000008u;
}
inline const ::std::string& MoneroGetTxKeyRequest::tx_prefix_hash() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.monero.MoneroGetTxKeyRequest.tx_prefix_hash)
  return tx_prefix_hash_.GetNoArena();
}
inline void MoneroGetTxKeyRequest::set_tx_prefix_hash(const ::std::string& value) {
  _has_bits_[0] |= 0x00000008u;
  tx_prefix_hash_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:hw.trezor.messages.monero.MoneroGetTxKeyRequest.tx_prefix_hash)
}
#if LANG_CXX11
inline void MoneroGetTxKeyRequest::set_tx_prefix_hash(::std::string&& value) {
  _has_bits_[0] |= 0x00000008u;
  tx_prefix_hash_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:hw.trezor.messages.monero.MoneroGetTxKeyRequest.tx_prefix_hash)
}
#endif
inline void MoneroGetTxKeyRequest::set_tx_prefix_hash(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000008u;
  tx_prefix_hash_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:hw.trezor.messages.monero.MoneroGetTxKeyRequest.tx_prefix_hash)
}
inline void MoneroGetTxKeyRequest::set_tx_prefix_hash(const void* value, size_t size) {
  _has_bits_[0] |= 0x00000008u;
  tx_prefix_hash_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:hw.trezor.messages.monero.MoneroGetTxKeyRequest.tx_prefix_hash)
}
inline ::std::string* MoneroGetTxKeyRequest::mutable_tx_prefix_hash() {
  _has_bits_[0] |= 0x00000008u;
  // @@protoc_insertion_point(field_mutable:hw.trezor.messages.monero.MoneroGetTxKeyRequest.tx_prefix_hash)
  return tx_prefix_hash_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* MoneroGetTxKeyRequest::release_tx_prefix_hash() {
  // @@protoc_insertion_point(field_release:hw.trezor.messages.monero.MoneroGetTxKeyRequest.tx_prefix_hash)
  if (!has_tx_prefix_hash()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000008u;
  return tx_prefix_hash_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void MoneroGetTxKeyRequest::set_allocated_tx_prefix_hash(::std::string* tx_prefix_hash) {
  if (tx_prefix_hash != nullptr) {
    _has_bits_[0] |= 0x00000008u;
  } else {
    _has_bits_[0] &= ~0x00000008u;
  }
  tx_prefix_hash_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), tx_prefix_hash);
  // @@protoc_insertion_point(field_set_allocated:hw.trezor.messages.monero.MoneroGetTxKeyRequest.tx_prefix_hash)
}

// optional uint32 reason = 7;
inline bool MoneroGetTxKeyRequest::has_reason() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void MoneroGetTxKeyRequest::clear_reason() {
  reason_ = 0u;
  _has_bits_[0] &= ~0x00000040u;
}
inline ::google::protobuf::uint32 MoneroGetTxKeyRequest::reason() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.monero.MoneroGetTxKeyRequest.reason)
  return reason_;
}
inline void MoneroGetTxKeyRequest::set_reason(::google::protobuf::uint32 value) {
  _has_bits_[0] |= 0x00000040u;
  reason_ = value;
  // @@protoc_insertion_point(field_set:hw.trezor.messages.monero.MoneroGetTxKeyRequest.reason)
}

// optional bytes view_public_key = 8;
inline bool MoneroGetTxKeyRequest::has_view_public_key() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void MoneroGetTxKeyRequest::clear_view_public_key() {
  view_public_key_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000010u;
}
inline const ::std::string& MoneroGetTxKeyRequest::view_public_key() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.monero.MoneroGetTxKeyRequest.view_public_key)
  return view_public_key_.GetNoArena();
}
inline void MoneroGetTxKeyRequest::set_view_public_key(const ::std::string& value) {
  _has_bits_[0] |= 0x00000010u;
  view_public_key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:hw.trezor.messages.monero.MoneroGetTxKeyRequest.view_public_key)
}
#if LANG_CXX11
inline void MoneroGetTxKeyRequest::set_view_public_key(::std::string&& value) {
  _has_bits_[0] |= 0x00000010u;
  view_public_key_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:hw.trezor.messages.monero.MoneroGetTxKeyRequest.view_public_key)
}
#endif
inline void MoneroGetTxKeyRequest::set_view_public_key(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000010u;
  view_public_key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:hw.trezor.messages.monero.MoneroGetTxKeyRequest.view_public_key)
}
inline void MoneroGetTxKeyRequest::set_view_public_key(const void* value, size_t size) {
  _has_bits_[0] |= 0x00000010u;
  view_public_key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:hw.trezor.messages.monero.MoneroGetTxKeyRequest.view_public_key)
}
inline ::std::string* MoneroGetTxKeyRequest::mutable_view_public_key() {
  _has_bits_[0] |= 0x00000010u;
  // @@protoc_insertion_point(field_mutable:hw.trezor.messages.monero.MoneroGetTxKeyRequest.view_public_key)
  return view_public_key_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* MoneroGetTxKeyRequest::release_view_public_key() {
  // @@protoc_insertion_point(field_release:hw.trezor.messages.monero.MoneroGetTxKeyRequest.view_public_key)
  if (!has_view_public_key()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000010u;
  return view_public_key_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void MoneroGetTxKeyRequest::set_allocated_view_public_key(::std::string* view_public_key) {
  if (view_public_key != nullptr) {
    _has_bits_[0] |= 0x00000010u;
  } else {
    _has_bits_[0] &= ~0x00000010u;
  }
  view_public_key_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), view_public_key);
  // @@protoc_insertion_point(field_set_allocated:hw.trezor.messages.monero.MoneroGetTxKeyRequest.view_public_key)
}

// -------------------------------------------------------------------

// MoneroGetTxKeyAck

// optional bytes salt = 1;
inline bool MoneroGetTxKeyAck::has_salt() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MoneroGetTxKeyAck::clear_salt() {
  salt_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::std::string& MoneroGetTxKeyAck::salt() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.monero.MoneroGetTxKeyAck.salt)
  return salt_.GetNoArena();
}
inline void MoneroGetTxKeyAck::set_salt(const ::std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  salt_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:hw.trezor.messages.monero.MoneroGetTxKeyAck.salt)
}
#if LANG_CXX11
inline void MoneroGetTxKeyAck::set_salt(::std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  salt_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:hw.trezor.messages.monero.MoneroGetTxKeyAck.salt)
}
#endif
inline void MoneroGetTxKeyAck::set_salt(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  salt_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:hw.trezor.messages.monero.MoneroGetTxKeyAck.salt)
}
inline void MoneroGetTxKeyAck::set_salt(const void* value, size_t size) {
  _has_bits_[0] |= 0x00000001u;
  salt_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:hw.trezor.messages.monero.MoneroGetTxKeyAck.salt)
}
inline ::std::string* MoneroGetTxKeyAck::mutable_salt() {
  _has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_mutable:hw.trezor.messages.monero.MoneroGetTxKeyAck.salt)
  return salt_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* MoneroGetTxKeyAck::release_salt() {
  // @@protoc_insertion_point(field_release:hw.trezor.messages.monero.MoneroGetTxKeyAck.salt)
  if (!has_salt()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return salt_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void MoneroGetTxKeyAck::set_allocated_salt(::std::string* salt) {
  if (salt != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  salt_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), salt);
  // @@protoc_insertion_point(field_set_allocated:hw.trezor.messages.monero.MoneroGetTxKeyAck.salt)
}

// optional bytes tx_keys = 2;
inline bool MoneroGetTxKeyAck::has_tx_keys() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void MoneroGetTxKeyAck::clear_tx_keys() {
  tx_keys_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000002u;
}
inline const ::std::string& MoneroGetTxKeyAck::tx_keys() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.monero.MoneroGetTxKeyAck.tx_keys)
  return tx_keys_.GetNoArena();
}
inline void MoneroGetTxKeyAck::set_tx_keys(const ::std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  tx_keys_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:hw.trezor.messages.monero.MoneroGetTxKeyAck.tx_keys)
}
#if LANG_CXX11
inline void MoneroGetTxKeyAck::set_tx_keys(::std::string&& value) {
  _has_bits_[0] |= 0x00000002u;
  tx_keys_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:hw.trezor.messages.monero.MoneroGetTxKeyAck.tx_keys)
}
#endif
inline void MoneroGetTxKeyAck::set_tx_keys(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000002u;
  tx_keys_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:hw.trezor.messages.monero.MoneroGetTxKeyAck.tx_keys)
}
inline void MoneroGetTxKeyAck::set_tx_keys(const void* value, size_t size) {
  _has_bits_[0] |= 0x00000002u;
  tx_keys_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:hw.trezor.messages.monero.MoneroGetTxKeyAck.tx_keys)
}
inline ::std::string* MoneroGetTxKeyAck::mutable_tx_keys() {
  _has_bits_[0] |= 0x00000002u;
  // @@protoc_insertion_point(field_mutable:hw.trezor.messages.monero.MoneroGetTxKeyAck.tx_keys)
  return tx_keys_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* MoneroGetTxKeyAck::release_tx_keys() {
  // @@protoc_insertion_point(field_release:hw.trezor.messages.monero.MoneroGetTxKeyAck.tx_keys)
  if (!has_tx_keys()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  return tx_keys_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void MoneroGetTxKeyAck::set_allocated_tx_keys(::std::string* tx_keys) {
  if (tx_keys != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  tx_keys_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), tx_keys);
  // @@protoc_insertion_point(field_set_allocated:hw.trezor.messages.monero.MoneroGetTxKeyAck.tx_keys)
}

// optional bytes tx_derivations = 3;
inline bool MoneroGetTxKeyAck::has_tx_derivations() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void MoneroGetTxKeyAck::clear_tx_derivations() {
  tx_derivations_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000004u;
}
inline const ::std::string& MoneroGetTxKeyAck::tx_derivations() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.monero.MoneroGetTxKeyAck.tx_derivations)
  return tx_derivations_.GetNoArena();
}
inline void MoneroGetTxKeyAck::set_tx_derivations(const ::std::string& value) {
  _has_bits_[0] |= 0x00000004u;
  tx_derivations_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:hw.trezor.messages.monero.MoneroGetTxKeyAck.tx_derivations)
}
#if LANG_CXX11
inline void MoneroGetTxKeyAck::set_tx_derivations(::std::string&& value) {
  _has_bits_[0] |= 0x00000004u;
  tx_derivations_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:hw.trezor.messages.monero.MoneroGetTxKeyAck.tx_derivations)
}
#endif
inline void MoneroGetTxKeyAck::set_tx_derivations(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000004u;
  tx_derivations_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:hw.trezor.messages.monero.MoneroGetTxKeyAck.tx_derivations)
}
inline void MoneroGetTxKeyAck::set_tx_derivations(const void* value, size_t size) {
  _has_bits_[0] |= 0x00000004u;
  tx_derivations_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:hw.trezor.messages.monero.MoneroGetTxKeyAck.tx_derivations)
}
inline ::std::string* MoneroGetTxKeyAck::mutable_tx_derivations() {
  _has_bits_[0] |= 0x00000004u;
  // @@protoc_insertion_point(field_mutable:hw.trezor.messages.monero.MoneroGetTxKeyAck.tx_derivations)
  return tx_derivations_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* MoneroGetTxKeyAck::release_tx_derivations() {
  // @@protoc_insertion_point(field_release:hw.trezor.messages.monero.MoneroGetTxKeyAck.tx_derivations)
  if (!has_tx_derivations()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000004u;
  return tx_derivations_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void MoneroGetTxKeyAck::set_allocated_tx_derivations(::std::string* tx_derivations) {
  if (tx_derivations != nullptr) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  tx_derivations_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), tx_derivations);
  // @@protoc_insertion_point(field_set_allocated:hw.trezor.messages.monero.MoneroGetTxKeyAck.tx_derivations)
}

// -------------------------------------------------------------------

// MoneroLiveRefreshStartRequest

// repeated uint32 address_n = 1;
inline int MoneroLiveRefreshStartRequest::address_n_size() const {
  return address_n_.size();
}
inline void MoneroLiveRefreshStartRequest::clear_address_n() {
  address_n_.Clear();
}
inline ::google::protobuf::uint32 MoneroLiveRefreshStartRequest::address_n(int index) const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.monero.MoneroLiveRefreshStartRequest.address_n)
  return address_n_.Get(index);
}
inline void MoneroLiveRefreshStartRequest::set_address_n(int index, ::google::protobuf::uint32 value) {
  address_n_.Set(index, value);
  // @@protoc_insertion_point(field_set:hw.trezor.messages.monero.MoneroLiveRefreshStartRequest.address_n)
}
inline void MoneroLiveRefreshStartRequest::add_address_n(::google::protobuf::uint32 value) {
  address_n_.Add(value);
  // @@protoc_insertion_point(field_add:hw.trezor.messages.monero.MoneroLiveRefreshStartRequest.address_n)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
MoneroLiveRefreshStartRequest::address_n() const {
  // @@protoc_insertion_point(field_list:hw.trezor.messages.monero.MoneroLiveRefreshStartRequest.address_n)
  return address_n_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
MoneroLiveRefreshStartRequest::mutable_address_n() {
  // @@protoc_insertion_point(field_mutable_list:hw.trezor.messages.monero.MoneroLiveRefreshStartRequest.address_n)
  return &address_n_;
}

// optional uint32 network_type = 2;
inline bool MoneroLiveRefreshStartRequest::has_network_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MoneroLiveRefreshStartRequest::clear_network_type() {
  network_type_ = 0u;
  _has_bits_[0] &= ~0x00000001u;
}
inline ::google::protobuf::uint32 MoneroLiveRefreshStartRequest::network_type() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.monero.MoneroLiveRefreshStartRequest.network_type)
  return network_type_;
}
inline void MoneroLiveRefreshStartRequest::set_network_type(::google::protobuf::uint32 value) {
  _has_bits_[0] |= 0x00000001u;
  network_type_ = value;
  // @@protoc_insertion_point(field_set:hw.trezor.messages.monero.MoneroLiveRefreshStartRequest.network_type)
}

// -------------------------------------------------------------------

// MoneroLiveRefreshStartAck

// -------------------------------------------------------------------

// MoneroLiveRefreshStepRequest

// optional bytes out_key = 1;
inline bool MoneroLiveRefreshStepRequest::has_out_key() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MoneroLiveRefreshStepRequest::clear_out_key() {
  out_key_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::std::string& MoneroLiveRefreshStepRequest::out_key() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.monero.MoneroLiveRefreshStepRequest.out_key)
  return out_key_.GetNoArena();
}
inline void MoneroLiveRefreshStepRequest::set_out_key(const ::std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  out_key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:hw.trezor.messages.monero.MoneroLiveRefreshStepRequest.out_key)
}
#if LANG_CXX11
inline void MoneroLiveRefreshStepRequest::set_out_key(::std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  out_key_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:hw.trezor.messages.monero.MoneroLiveRefreshStepRequest.out_key)
}
#endif
inline void MoneroLiveRefreshStepRequest::set_out_key(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  out_key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:hw.trezor.messages.monero.MoneroLiveRefreshStepRequest.out_key)
}
inline void MoneroLiveRefreshStepRequest::set_out_key(const void* value, size_t size) {
  _has_bits_[0] |= 0x00000001u;
  out_key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:hw.trezor.messages.monero.MoneroLiveRefreshStepRequest.out_key)
}
inline ::std::string* MoneroLiveRefreshStepRequest::mutable_out_key() {
  _has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_mutable:hw.trezor.messages.monero.MoneroLiveRefreshStepRequest.out_key)
  return out_key_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* MoneroLiveRefreshStepRequest::release_out_key() {
  // @@protoc_insertion_point(field_release:hw.trezor.messages.monero.MoneroLiveRefreshStepRequest.out_key)
  if (!has_out_key()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return out_key_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void MoneroLiveRefreshStepRequest::set_allocated_out_key(::std::string* out_key) {
  if (out_key != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  out_key_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), out_key);
  // @@protoc_insertion_point(field_set_allocated:hw.trezor.messages.monero.MoneroLiveRefreshStepRequest.out_key)
}

// optional bytes recv_deriv = 2;
inline bool MoneroLiveRefreshStepRequest::has_recv_deriv() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void MoneroLiveRefreshStepRequest::clear_recv_deriv() {
  recv_deriv_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000002u;
}
inline const ::std::string& MoneroLiveRefreshStepRequest::recv_deriv() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.monero.MoneroLiveRefreshStepRequest.recv_deriv)
  return recv_deriv_.GetNoArena();
}
inline void MoneroLiveRefreshStepRequest::set_recv_deriv(const ::std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  recv_deriv_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:hw.trezor.messages.monero.MoneroLiveRefreshStepRequest.recv_deriv)
}
#if LANG_CXX11
inline void MoneroLiveRefreshStepRequest::set_recv_deriv(::std::string&& value) {
  _has_bits_[0] |= 0x00000002u;
  recv_deriv_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:hw.trezor.messages.monero.MoneroLiveRefreshStepRequest.recv_deriv)
}
#endif
inline void MoneroLiveRefreshStepRequest::set_recv_deriv(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000002u;
  recv_deriv_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:hw.trezor.messages.monero.MoneroLiveRefreshStepRequest.recv_deriv)
}
inline void MoneroLiveRefreshStepRequest::set_recv_deriv(const void* value, size_t size) {
  _has_bits_[0] |= 0x00000002u;
  recv_deriv_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:hw.trezor.messages.monero.MoneroLiveRefreshStepRequest.recv_deriv)
}
inline ::std::string* MoneroLiveRefreshStepRequest::mutable_recv_deriv() {
  _has_bits_[0] |= 0x00000002u;
  // @@protoc_insertion_point(field_mutable:hw.trezor.messages.monero.MoneroLiveRefreshStepRequest.recv_deriv)
  return recv_deriv_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* MoneroLiveRefreshStepRequest::release_recv_deriv() {
  // @@protoc_insertion_point(field_release:hw.trezor.messages.monero.MoneroLiveRefreshStepRequest.recv_deriv)
  if (!has_recv_deriv()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  return recv_deriv_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void MoneroLiveRefreshStepRequest::set_allocated_recv_deriv(::std::string* recv_deriv) {
  if (recv_deriv != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  recv_deriv_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), recv_deriv);
  // @@protoc_insertion_point(field_set_allocated:hw.trezor.messages.monero.MoneroLiveRefreshStepRequest.recv_deriv)
}

// optional uint64 real_out_idx = 3;
inline bool MoneroLiveRefreshStepRequest::has_real_out_idx() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void MoneroLiveRefreshStepRequest::clear_real_out_idx() {
  real_out_idx_ = PROTOBUF_ULONGLONG(0);
  _has_bits_[0] &= ~0x00000004u;
}
inline ::google::protobuf::uint64 MoneroLiveRefreshStepRequest::real_out_idx() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.monero.MoneroLiveRefreshStepRequest.real_out_idx)
  return real_out_idx_;
}
inline void MoneroLiveRefreshStepRequest::set_real_out_idx(::google::protobuf::uint64 value) {
  _has_bits_[0] |= 0x00000004u;
  real_out_idx_ = value;
  // @@protoc_insertion_point(field_set:hw.trezor.messages.monero.MoneroLiveRefreshStepRequest.real_out_idx)
}

// optional uint32 sub_addr_major = 4;
inline bool MoneroLiveRefreshStepRequest::has_sub_addr_major() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void MoneroLiveRefreshStepRequest::clear_sub_addr_major() {
  sub_addr_major_ = 0u;
  _has_bits_[0] &= ~0x00000008u;
}
inline ::google::protobuf::uint32 MoneroLiveRefreshStepRequest::sub_addr_major() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.monero.MoneroLiveRefreshStepRequest.sub_addr_major)
  return sub_addr_major_;
}
inline void MoneroLiveRefreshStepRequest::set_sub_addr_major(::google::protobuf::uint32 value) {
  _has_bits_[0] |= 0x00000008u;
  sub_addr_major_ = value;
  // @@protoc_insertion_point(field_set:hw.trezor.messages.monero.MoneroLiveRefreshStepRequest.sub_addr_major)
}

// optional uint32 sub_addr_minor = 5;
inline bool MoneroLiveRefreshStepRequest::has_sub_addr_minor() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void MoneroLiveRefreshStepRequest::clear_sub_addr_minor() {
  sub_addr_minor_ = 0u;
  _has_bits_[0] &= ~0x00000010u;
}
inline ::google::protobuf::uint32 MoneroLiveRefreshStepRequest::sub_addr_minor() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.monero.MoneroLiveRefreshStepRequest.sub_addr_minor)
  return sub_addr_minor_;
}
inline void MoneroLiveRefreshStepRequest::set_sub_addr_minor(::google::protobuf::uint32 value) {
  _has_bits_[0] |= 0x00000010u;
  sub_addr_minor_ = value;
  // @@protoc_insertion_point(field_set:hw.trezor.messages.monero.MoneroLiveRefreshStepRequest.sub_addr_minor)
}

// -------------------------------------------------------------------

// MoneroLiveRefreshStepAck

// optional bytes salt = 1;
inline bool MoneroLiveRefreshStepAck::has_salt() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MoneroLiveRefreshStepAck::clear_salt() {
  salt_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::std::string& MoneroLiveRefreshStepAck::salt() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.monero.MoneroLiveRefreshStepAck.salt)
  return salt_.GetNoArena();
}
inline void MoneroLiveRefreshStepAck::set_salt(const ::std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  salt_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:hw.trezor.messages.monero.MoneroLiveRefreshStepAck.salt)
}
#if LANG_CXX11
inline void MoneroLiveRefreshStepAck::set_salt(::std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  salt_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:hw.trezor.messages.monero.MoneroLiveRefreshStepAck.salt)
}
#endif
inline void MoneroLiveRefreshStepAck::set_salt(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  salt_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:hw.trezor.messages.monero.MoneroLiveRefreshStepAck.salt)
}
inline void MoneroLiveRefreshStepAck::set_salt(const void* value, size_t size) {
  _has_bits_[0] |= 0x00000001u;
  salt_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:hw.trezor.messages.monero.MoneroLiveRefreshStepAck.salt)
}
inline ::std::string* MoneroLiveRefreshStepAck::mutable_salt() {
  _has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_mutable:hw.trezor.messages.monero.MoneroLiveRefreshStepAck.salt)
  return salt_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* MoneroLiveRefreshStepAck::release_salt() {
  // @@protoc_insertion_point(field_release:hw.trezor.messages.monero.MoneroLiveRefreshStepAck.salt)
  if (!has_salt()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return salt_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void MoneroLiveRefreshStepAck::set_allocated_salt(::std::string* salt) {
  if (salt != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  salt_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), salt);
  // @@protoc_insertion_point(field_set_allocated:hw.trezor.messages.monero.MoneroLiveRefreshStepAck.salt)
}

// optional bytes key_image = 2;
inline bool MoneroLiveRefreshStepAck::has_key_image() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void MoneroLiveRefreshStepAck::clear_key_image() {
  key_image_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000002u;
}
inline const ::std::string& MoneroLiveRefreshStepAck::key_image() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.monero.MoneroLiveRefreshStepAck.key_image)
  return key_image_.GetNoArena();
}
inline void MoneroLiveRefreshStepAck::set_key_image(const ::std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  key_image_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:hw.trezor.messages.monero.MoneroLiveRefreshStepAck.key_image)
}
#if LANG_CXX11
inline void MoneroLiveRefreshStepAck::set_key_image(::std::string&& value) {
  _has_bits_[0] |= 0x00000002u;
  key_image_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:hw.trezor.messages.monero.MoneroLiveRefreshStepAck.key_image)
}
#endif
inline void MoneroLiveRefreshStepAck::set_key_image(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000002u;
  key_image_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:hw.trezor.messages.monero.MoneroLiveRefreshStepAck.key_image)
}
inline void MoneroLiveRefreshStepAck::set_key_image(const void* value, size_t size) {
  _has_bits_[0] |= 0x00000002u;
  key_image_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:hw.trezor.messages.monero.MoneroLiveRefreshStepAck.key_image)
}
inline ::std::string* MoneroLiveRefreshStepAck::mutable_key_image() {
  _has_bits_[0] |= 0x00000002u;
  // @@protoc_insertion_point(field_mutable:hw.trezor.messages.monero.MoneroLiveRefreshStepAck.key_image)
  return key_image_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* MoneroLiveRefreshStepAck::release_key_image() {
  // @@protoc_insertion_point(field_release:hw.trezor.messages.monero.MoneroLiveRefreshStepAck.key_image)
  if (!has_key_image()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  return key_image_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void MoneroLiveRefreshStepAck::set_allocated_key_image(::std::string* key_image) {
  if (key_image != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  key_image_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), key_image);
  // @@protoc_insertion_point(field_set_allocated:hw.trezor.messages.monero.MoneroLiveRefreshStepAck.key_image)
}

// -------------------------------------------------------------------

// MoneroLiveRefreshFinalRequest

// -------------------------------------------------------------------

// MoneroLiveRefreshFinalAck

// -------------------------------------------------------------------

// DebugMoneroDiagRequest

// optional uint64 ins = 1;
inline bool DebugMoneroDiagRequest::has_ins() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void DebugMoneroDiagRequest::clear_ins() {
  ins_ = PROTOBUF_ULONGLONG(0);
  _has_bits_[0] &= ~0x00000004u;
}
inline ::google::protobuf::uint64 DebugMoneroDiagRequest::ins() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.monero.DebugMoneroDiagRequest.ins)
  return ins_;
}
inline void DebugMoneroDiagRequest::set_ins(::google::protobuf::uint64 value) {
  _has_bits_[0] |= 0x00000004u;
  ins_ = value;
  // @@protoc_insertion_point(field_set:hw.trezor.messages.monero.DebugMoneroDiagRequest.ins)
}

// optional uint64 p1 = 2;
inline bool DebugMoneroDiagRequest::has_p1() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void DebugMoneroDiagRequest::clear_p1() {
  p1_ = PROTOBUF_ULONGLONG(0);
  _has_bits_[0] &= ~0x00000008u;
}
inline ::google::protobuf::uint64 DebugMoneroDiagRequest::p1() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.monero.DebugMoneroDiagRequest.p1)
  return p1_;
}
inline void DebugMoneroDiagRequest::set_p1(::google::protobuf::uint64 value) {
  _has_bits_[0] |= 0x00000008u;
  p1_ = value;
  // @@protoc_insertion_point(field_set:hw.trezor.messages.monero.DebugMoneroDiagRequest.p1)
}

// optional uint64 p2 = 3;
inline bool DebugMoneroDiagRequest::has_p2() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void DebugMoneroDiagRequest::clear_p2() {
  p2_ = PROTOBUF_ULONGLONG(0);
  _has_bits_[0] &= ~0x00000010u;
}
inline ::google::protobuf::uint64 DebugMoneroDiagRequest::p2() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.monero.DebugMoneroDiagRequest.p2)
  return p2_;
}
inline void DebugMoneroDiagRequest::set_p2(::google::protobuf::uint64 value) {
  _has_bits_[0] |= 0x00000010u;
  p2_ = value;
  // @@protoc_insertion_point(field_set:hw.trezor.messages.monero.DebugMoneroDiagRequest.p2)
}

// repeated uint64 pd = 4;
inline int DebugMoneroDiagRequest::pd_size() const {
  return pd_.size();
}
inline void DebugMoneroDiagRequest::clear_pd() {
  pd_.Clear();
}
inline ::google::protobuf::uint64 DebugMoneroDiagRequest::pd(int index) const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.monero.DebugMoneroDiagRequest.pd)
  return pd_.Get(index);
}
inline void DebugMoneroDiagRequest::set_pd(int index, ::google::protobuf::uint64 value) {
  pd_.Set(index, value);
  // @@protoc_insertion_point(field_set:hw.trezor.messages.monero.DebugMoneroDiagRequest.pd)
}
inline void DebugMoneroDiagRequest::add_pd(::google::protobuf::uint64 value) {
  pd_.Add(value);
  // @@protoc_insertion_point(field_add:hw.trezor.messages.monero.DebugMoneroDiagRequest.pd)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >&
DebugMoneroDiagRequest::pd() const {
  // @@protoc_insertion_point(field_list:hw.trezor.messages.monero.DebugMoneroDiagRequest.pd)
  return pd_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >*
DebugMoneroDiagRequest::mutable_pd() {
  // @@protoc_insertion_point(field_mutable_list:hw.trezor.messages.monero.DebugMoneroDiagRequest.pd)
  return &pd_;
}

// optional bytes data1 = 5;
inline bool DebugMoneroDiagRequest::has_data1() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void DebugMoneroDiagRequest::clear_data1() {
  data1_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::std::string& DebugMoneroDiagRequest::data1() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.monero.DebugMoneroDiagRequest.data1)
  return data1_.GetNoArena();
}
inline void DebugMoneroDiagRequest::set_data1(const ::std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  data1_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:hw.trezor.messages.monero.DebugMoneroDiagRequest.data1)
}
#if LANG_CXX11
inline void DebugMoneroDiagRequest::set_data1(::std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  data1_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:hw.trezor.messages.monero.DebugMoneroDiagRequest.data1)
}
#endif
inline void DebugMoneroDiagRequest::set_data1(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  data1_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:hw.trezor.messages.monero.DebugMoneroDiagRequest.data1)
}
inline void DebugMoneroDiagRequest::set_data1(const void* value, size_t size) {
  _has_bits_[0] |= 0x00000001u;
  data1_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:hw.trezor.messages.monero.DebugMoneroDiagRequest.data1)
}
inline ::std::string* DebugMoneroDiagRequest::mutable_data1() {
  _has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_mutable:hw.trezor.messages.monero.DebugMoneroDiagRequest.data1)
  return data1_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* DebugMoneroDiagRequest::release_data1() {
  // @@protoc_insertion_point(field_release:hw.trezor.messages.monero.DebugMoneroDiagRequest.data1)
  if (!has_data1()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return data1_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void DebugMoneroDiagRequest::set_allocated_data1(::std::string* data1) {
  if (data1 != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  data1_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), data1);
  // @@protoc_insertion_point(field_set_allocated:hw.trezor.messages.monero.DebugMoneroDiagRequest.data1)
}

// optional bytes data2 = 6;
inline bool DebugMoneroDiagRequest::has_data2() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void DebugMoneroDiagRequest::clear_data2() {
  data2_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000002u;
}
inline const ::std::string& DebugMoneroDiagRequest::data2() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.monero.DebugMoneroDiagRequest.data2)
  return data2_.GetNoArena();
}
inline void DebugMoneroDiagRequest::set_data2(const ::std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  data2_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:hw.trezor.messages.monero.DebugMoneroDiagRequest.data2)
}
#if LANG_CXX11
inline void DebugMoneroDiagRequest::set_data2(::std::string&& value) {
  _has_bits_[0] |= 0x00000002u;
  data2_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:hw.trezor.messages.monero.DebugMoneroDiagRequest.data2)
}
#endif
inline void DebugMoneroDiagRequest::set_data2(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000002u;
  data2_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:hw.trezor.messages.monero.DebugMoneroDiagRequest.data2)
}
inline void DebugMoneroDiagRequest::set_data2(const void* value, size_t size) {
  _has_bits_[0] |= 0x00000002u;
  data2_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:hw.trezor.messages.monero.DebugMoneroDiagRequest.data2)
}
inline ::std::string* DebugMoneroDiagRequest::mutable_data2() {
  _has_bits_[0] |= 0x00000002u;
  // @@protoc_insertion_point(field_mutable:hw.trezor.messages.monero.DebugMoneroDiagRequest.data2)
  return data2_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* DebugMoneroDiagRequest::release_data2() {
  // @@protoc_insertion_point(field_release:hw.trezor.messages.monero.DebugMoneroDiagRequest.data2)
  if (!has_data2()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  return data2_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void DebugMoneroDiagRequest::set_allocated_data2(::std::string* data2) {
  if (data2 != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  data2_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), data2);
  // @@protoc_insertion_point(field_set_allocated:hw.trezor.messages.monero.DebugMoneroDiagRequest.data2)
}

// -------------------------------------------------------------------

// DebugMoneroDiagAck

// optional uint64 ins = 1;
inline bool DebugMoneroDiagAck::has_ins() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void DebugMoneroDiagAck::clear_ins() {
  ins_ = PROTOBUF_ULONGLONG(0);
  _has_bits_[0] &= ~0x00000004u;
}
inline ::google::protobuf::uint64 DebugMoneroDiagAck::ins() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.monero.DebugMoneroDiagAck.ins)
  return ins_;
}
inline void DebugMoneroDiagAck::set_ins(::google::protobuf::uint64 value) {
  _has_bits_[0] |= 0x00000004u;
  ins_ = value;
  // @@protoc_insertion_point(field_set:hw.trezor.messages.monero.DebugMoneroDiagAck.ins)
}

// optional uint64 p1 = 2;
inline bool DebugMoneroDiagAck::has_p1() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void DebugMoneroDiagAck::clear_p1() {
  p1_ = PROTOBUF_ULONGLONG(0);
  _has_bits_[0] &= ~0x00000008u;
}
inline ::google::protobuf::uint64 DebugMoneroDiagAck::p1() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.monero.DebugMoneroDiagAck.p1)
  return p1_;
}
inline void DebugMoneroDiagAck::set_p1(::google::protobuf::uint64 value) {
  _has_bits_[0] |= 0x00000008u;
  p1_ = value;
  // @@protoc_insertion_point(field_set:hw.trezor.messages.monero.DebugMoneroDiagAck.p1)
}

// optional uint64 p2 = 3;
inline bool DebugMoneroDiagAck::has_p2() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void DebugMoneroDiagAck::clear_p2() {
  p2_ = PROTOBUF_ULONGLONG(0);
  _has_bits_[0] &= ~0x00000010u;
}
inline ::google::protobuf::uint64 DebugMoneroDiagAck::p2() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.monero.DebugMoneroDiagAck.p2)
  return p2_;
}
inline void DebugMoneroDiagAck::set_p2(::google::protobuf::uint64 value) {
  _has_bits_[0] |= 0x00000010u;
  p2_ = value;
  // @@protoc_insertion_point(field_set:hw.trezor.messages.monero.DebugMoneroDiagAck.p2)
}

// repeated uint64 pd = 4;
inline int DebugMoneroDiagAck::pd_size() const {
  return pd_.size();
}
inline void DebugMoneroDiagAck::clear_pd() {
  pd_.Clear();
}
inline ::google::protobuf::uint64 DebugMoneroDiagAck::pd(int index) const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.monero.DebugMoneroDiagAck.pd)
  return pd_.Get(index);
}
inline void DebugMoneroDiagAck::set_pd(int index, ::google::protobuf::uint64 value) {
  pd_.Set(index, value);
  // @@protoc_insertion_point(field_set:hw.trezor.messages.monero.DebugMoneroDiagAck.pd)
}
inline void DebugMoneroDiagAck::add_pd(::google::protobuf::uint64 value) {
  pd_.Add(value);
  // @@protoc_insertion_point(field_add:hw.trezor.messages.monero.DebugMoneroDiagAck.pd)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >&
DebugMoneroDiagAck::pd() const {
  // @@protoc_insertion_point(field_list:hw.trezor.messages.monero.DebugMoneroDiagAck.pd)
  return pd_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >*
DebugMoneroDiagAck::mutable_pd() {
  // @@protoc_insertion_point(field_mutable_list:hw.trezor.messages.monero.DebugMoneroDiagAck.pd)
  return &pd_;
}

// optional bytes data1 = 5;
inline bool DebugMoneroDiagAck::has_data1() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void DebugMoneroDiagAck::clear_data1() {
  data1_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::std::string& DebugMoneroDiagAck::data1() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.monero.DebugMoneroDiagAck.data1)
  return data1_.GetNoArena();
}
inline void DebugMoneroDiagAck::set_data1(const ::std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  data1_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:hw.trezor.messages.monero.DebugMoneroDiagAck.data1)
}
#if LANG_CXX11
inline void DebugMoneroDiagAck::set_data1(::std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  data1_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:hw.trezor.messages.monero.DebugMoneroDiagAck.data1)
}
#endif
inline void DebugMoneroDiagAck::set_data1(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  data1_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:hw.trezor.messages.monero.DebugMoneroDiagAck.data1)
}
inline void DebugMoneroDiagAck::set_data1(const void* value, size_t size) {
  _has_bits_[0] |= 0x00000001u;
  data1_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:hw.trezor.messages.monero.DebugMoneroDiagAck.data1)
}
inline ::std::string* DebugMoneroDiagAck::mutable_data1() {
  _has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_mutable:hw.trezor.messages.monero.DebugMoneroDiagAck.data1)
  return data1_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* DebugMoneroDiagAck::release_data1() {
  // @@protoc_insertion_point(field_release:hw.trezor.messages.monero.DebugMoneroDiagAck.data1)
  if (!has_data1()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return data1_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void DebugMoneroDiagAck::set_allocated_data1(::std::string* data1) {
  if (data1 != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  data1_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), data1);
  // @@protoc_insertion_point(field_set_allocated:hw.trezor.messages.monero.DebugMoneroDiagAck.data1)
}

// optional bytes data2 = 6;
inline bool DebugMoneroDiagAck::has_data2() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void DebugMoneroDiagAck::clear_data2() {
  data2_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000002u;
}
inline const ::std::string& DebugMoneroDiagAck::data2() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.monero.DebugMoneroDiagAck.data2)
  return data2_.GetNoArena();
}
inline void DebugMoneroDiagAck::set_data2(const ::std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  data2_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:hw.trezor.messages.monero.DebugMoneroDiagAck.data2)
}
#if LANG_CXX11
inline void DebugMoneroDiagAck::set_data2(::std::string&& value) {
  _has_bits_[0] |= 0x00000002u;
  data2_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:hw.trezor.messages.monero.DebugMoneroDiagAck.data2)
}
#endif
inline void DebugMoneroDiagAck::set_data2(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000002u;
  data2_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:hw.trezor.messages.monero.DebugMoneroDiagAck.data2)
}
inline void DebugMoneroDiagAck::set_data2(const void* value, size_t size) {
  _has_bits_[0] |= 0x00000002u;
  data2_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:hw.trezor.messages.monero.DebugMoneroDiagAck.data2)
}
inline ::std::string* DebugMoneroDiagAck::mutable_data2() {
  _has_bits_[0] |= 0x00000002u;
  // @@protoc_insertion_point(field_mutable:hw.trezor.messages.monero.DebugMoneroDiagAck.data2)
  return data2_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* DebugMoneroDiagAck::release_data2() {
  // @@protoc_insertion_point(field_release:hw.trezor.messages.monero.DebugMoneroDiagAck.data2)
  if (!has_data2()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  return data2_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void DebugMoneroDiagAck::set_allocated_data2(::std::string* data2) {
  if (data2 != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  data2_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), data2);
  // @@protoc_insertion_point(field_set_allocated:hw.trezor.messages.monero.DebugMoneroDiagAck.data2)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace monero
}  // namespace messages
}  // namespace trezor
}  // namespace hw

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // PROTOBUF_INCLUDED_messages_2dmonero_2eproto
