// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: messages-nem.proto

#include "messages-nem.pb.h"

#include <algorithm>

#include <google/protobuf/stubs/common.h>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/wire_format_lite_inl.h>
#include <google/protobuf/descriptor.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/reflection_ops.h>
#include <google/protobuf/wire_format.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>

extern PROTOBUF_INTERNAL_EXPORT_messages_2dnem_2eproto ::google::protobuf::internal::SCCInfo<0> scc_info_NEMSignTx_NEMAggregateModification_NEMCosignatoryModification_messages_2dnem_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_messages_2dnem_2eproto ::google::protobuf::internal::SCCInfo<0> scc_info_NEMSignTx_NEMImportanceTransfer_messages_2dnem_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_messages_2dnem_2eproto ::google::protobuf::internal::SCCInfo<0> scc_info_NEMSignTx_NEMMosaicCreation_NEMMosaicDefinition_messages_2dnem_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_messages_2dnem_2eproto ::google::protobuf::internal::SCCInfo<0> scc_info_NEMSignTx_NEMMosaicSupplyChange_messages_2dnem_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_messages_2dnem_2eproto ::google::protobuf::internal::SCCInfo<0> scc_info_NEMSignTx_NEMProvisionNamespace_messages_2dnem_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_messages_2dnem_2eproto ::google::protobuf::internal::SCCInfo<0> scc_info_NEMSignTx_NEMTransactionCommon_messages_2dnem_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_messages_2dnem_2eproto ::google::protobuf::internal::SCCInfo<0> scc_info_NEMSignTx_NEMTransfer_NEMMosaic_messages_2dnem_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_messages_2dnem_2eproto ::google::protobuf::internal::SCCInfo<1> scc_info_NEMSignTx_NEMAggregateModification_messages_2dnem_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_messages_2dnem_2eproto ::google::protobuf::internal::SCCInfo<1> scc_info_NEMSignTx_NEMMosaicCreation_messages_2dnem_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_messages_2dnem_2eproto ::google::protobuf::internal::SCCInfo<1> scc_info_NEMSignTx_NEMTransfer_messages_2dnem_2eproto;
namespace hw {
namespace trezor {
namespace messages {
namespace nem {
class NEMGetAddressDefaultTypeInternal {
 public:
  ::google::protobuf::internal::ExplicitlyConstructed<NEMGetAddress> _instance;
} _NEMGetAddress_default_instance_;
class NEMAddressDefaultTypeInternal {
 public:
  ::google::protobuf::internal::ExplicitlyConstructed<NEMAddress> _instance;
} _NEMAddress_default_instance_;
class NEMSignTx_NEMTransactionCommonDefaultTypeInternal {
 public:
  ::google::protobuf::internal::ExplicitlyConstructed<NEMSignTx_NEMTransactionCommon> _instance;
} _NEMSignTx_NEMTransactionCommon_default_instance_;
class NEMSignTx_NEMTransfer_NEMMosaicDefaultTypeInternal {
 public:
  ::google::protobuf::internal::ExplicitlyConstructed<NEMSignTx_NEMTransfer_NEMMosaic> _instance;
} _NEMSignTx_NEMTransfer_NEMMosaic_default_instance_;
class NEMSignTx_NEMTransferDefaultTypeInternal {
 public:
  ::google::protobuf::internal::ExplicitlyConstructed<NEMSignTx_NEMTransfer> _instance;
} _NEMSignTx_NEMTransfer_default_instance_;
class NEMSignTx_NEMProvisionNamespaceDefaultTypeInternal {
 public:
  ::google::protobuf::internal::ExplicitlyConstructed<NEMSignTx_NEMProvisionNamespace> _instance;
} _NEMSignTx_NEMProvisionNamespace_default_instance_;
class NEMSignTx_NEMMosaicCreation_NEMMosaicDefinitionDefaultTypeInternal {
 public:
  ::google::protobuf::internal::ExplicitlyConstructed<NEMSignTx_NEMMosaicCreation_NEMMosaicDefinition> _instance;
} _NEMSignTx_NEMMosaicCreation_NEMMosaicDefinition_default_instance_;
class NEMSignTx_NEMMosaicCreationDefaultTypeInternal {
 public:
  ::google::protobuf::internal::ExplicitlyConstructed<NEMSignTx_NEMMosaicCreation> _instance;
} _NEMSignTx_NEMMosaicCreation_default_instance_;
class NEMSignTx_NEMMosaicSupplyChangeDefaultTypeInternal {
 public:
  ::google::protobuf::internal::ExplicitlyConstructed<NEMSignTx_NEMMosaicSupplyChange> _instance;
} _NEMSignTx_NEMMosaicSupplyChange_default_instance_;
class NEMSignTx_NEMAggregateModification_NEMCosignatoryModificationDefaultTypeInternal {
 public:
  ::google::protobuf::internal::ExplicitlyConstructed<NEMSignTx_NEMAggregateModification_NEMCosignatoryModification> _instance;
} _NEMSignTx_NEMAggregateModification_NEMCosignatoryModification_default_instance_;
class NEMSignTx_NEMAggregateModificationDefaultTypeInternal {
 public:
  ::google::protobuf::internal::ExplicitlyConstructed<NEMSignTx_NEMAggregateModification> _instance;
} _NEMSignTx_NEMAggregateModification_default_instance_;
class NEMSignTx_NEMImportanceTransferDefaultTypeInternal {
 public:
  ::google::protobuf::internal::ExplicitlyConstructed<NEMSignTx_NEMImportanceTransfer> _instance;
} _NEMSignTx_NEMImportanceTransfer_default_instance_;
class NEMSignTxDefaultTypeInternal {
 public:
  ::google::protobuf::internal::ExplicitlyConstructed<NEMSignTx> _instance;
} _NEMSignTx_default_instance_;
class NEMSignedTxDefaultTypeInternal {
 public:
  ::google::protobuf::internal::ExplicitlyConstructed<NEMSignedTx> _instance;
} _NEMSignedTx_default_instance_;
class NEMDecryptMessageDefaultTypeInternal {
 public:
  ::google::protobuf::internal::ExplicitlyConstructed<NEMDecryptMessage> _instance;
} _NEMDecryptMessage_default_instance_;
class NEMDecryptedMessageDefaultTypeInternal {
 public:
  ::google::protobuf::internal::ExplicitlyConstructed<NEMDecryptedMessage> _instance;
} _NEMDecryptedMessage_default_instance_;
}  // namespace nem
}  // namespace messages
}  // namespace trezor
}  // namespace hw
static void InitDefaultsNEMGetAddress_messages_2dnem_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::hw::trezor::messages::nem::_NEMGetAddress_default_instance_;
    new (ptr) ::hw::trezor::messages::nem::NEMGetAddress();
    ::google::protobuf::internal::OnShutdownDestroyMessage(ptr);
  }
  ::hw::trezor::messages::nem::NEMGetAddress::InitAsDefaultInstance();
}

::google::protobuf::internal::SCCInfo<0> scc_info_NEMGetAddress_messages_2dnem_2eproto =
    {{ATOMIC_VAR_INIT(::google::protobuf::internal::SCCInfoBase::kUninitialized), 0, InitDefaultsNEMGetAddress_messages_2dnem_2eproto}, {}};

static void InitDefaultsNEMAddress_messages_2dnem_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::hw::trezor::messages::nem::_NEMAddress_default_instance_;
    new (ptr) ::hw::trezor::messages::nem::NEMAddress();
    ::google::protobuf::internal::OnShutdownDestroyMessage(ptr);
  }
  ::hw::trezor::messages::nem::NEMAddress::InitAsDefaultInstance();
}

::google::protobuf::internal::SCCInfo<0> scc_info_NEMAddress_messages_2dnem_2eproto =
    {{ATOMIC_VAR_INIT(::google::protobuf::internal::SCCInfoBase::kUninitialized), 0, InitDefaultsNEMAddress_messages_2dnem_2eproto}, {}};

static void InitDefaultsNEMSignTx_NEMTransactionCommon_messages_2dnem_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::hw::trezor::messages::nem::_NEMSignTx_NEMTransactionCommon_default_instance_;
    new (ptr) ::hw::trezor::messages::nem::NEMSignTx_NEMTransactionCommon();
    ::google::protobuf::internal::OnShutdownDestroyMessage(ptr);
  }
  ::hw::trezor::messages::nem::NEMSignTx_NEMTransactionCommon::InitAsDefaultInstance();
}

::google::protobuf::internal::SCCInfo<0> scc_info_NEMSignTx_NEMTransactionCommon_messages_2dnem_2eproto =
    {{ATOMIC_VAR_INIT(::google::protobuf::internal::SCCInfoBase::kUninitialized), 0, InitDefaultsNEMSignTx_NEMTransactionCommon_messages_2dnem_2eproto}, {}};

static void InitDefaultsNEMSignTx_NEMTransfer_NEMMosaic_messages_2dnem_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::hw::trezor::messages::nem::_NEMSignTx_NEMTransfer_NEMMosaic_default_instance_;
    new (ptr) ::hw::trezor::messages::nem::NEMSignTx_NEMTransfer_NEMMosaic();
    ::google::protobuf::internal::OnShutdownDestroyMessage(ptr);
  }
  ::hw::trezor::messages::nem::NEMSignTx_NEMTransfer_NEMMosaic::InitAsDefaultInstance();
}

::google::protobuf::internal::SCCInfo<0> scc_info_NEMSignTx_NEMTransfer_NEMMosaic_messages_2dnem_2eproto =
    {{ATOMIC_VAR_INIT(::google::protobuf::internal::SCCInfoBase::kUninitialized), 0, InitDefaultsNEMSignTx_NEMTransfer_NEMMosaic_messages_2dnem_2eproto}, {}};

static void InitDefaultsNEMSignTx_NEMTransfer_messages_2dnem_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::hw::trezor::messages::nem::_NEMSignTx_NEMTransfer_default_instance_;
    new (ptr) ::hw::trezor::messages::nem::NEMSignTx_NEMTransfer();
    ::google::protobuf::internal::OnShutdownDestroyMessage(ptr);
  }
  ::hw::trezor::messages::nem::NEMSignTx_NEMTransfer::InitAsDefaultInstance();
}

::google::protobuf::internal::SCCInfo<1> scc_info_NEMSignTx_NEMTransfer_messages_2dnem_2eproto =
    {{ATOMIC_VAR_INIT(::google::protobuf::internal::SCCInfoBase::kUninitialized), 1, InitDefaultsNEMSignTx_NEMTransfer_messages_2dnem_2eproto}, {
      &scc_info_NEMSignTx_NEMTransfer_NEMMosaic_messages_2dnem_2eproto.base,}};

static void InitDefaultsNEMSignTx_NEMProvisionNamespace_messages_2dnem_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::hw::trezor::messages::nem::_NEMSignTx_NEMProvisionNamespace_default_instance_;
    new (ptr) ::hw::trezor::messages::nem::NEMSignTx_NEMProvisionNamespace();
    ::google::protobuf::internal::OnShutdownDestroyMessage(ptr);
  }
  ::hw::trezor::messages::nem::NEMSignTx_NEMProvisionNamespace::InitAsDefaultInstance();
}

::google::protobuf::internal::SCCInfo<0> scc_info_NEMSignTx_NEMProvisionNamespace_messages_2dnem_2eproto =
    {{ATOMIC_VAR_INIT(::google::protobuf::internal::SCCInfoBase::kUninitialized), 0, InitDefaultsNEMSignTx_NEMProvisionNamespace_messages_2dnem_2eproto}, {}};

static void InitDefaultsNEMSignTx_NEMMosaicCreation_NEMMosaicDefinition_messages_2dnem_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::hw::trezor::messages::nem::_NEMSignTx_NEMMosaicCreation_NEMMosaicDefinition_default_instance_;
    new (ptr) ::hw::trezor::messages::nem::NEMSignTx_NEMMosaicCreation_NEMMosaicDefinition();
    ::google::protobuf::internal::OnShutdownDestroyMessage(ptr);
  }
  ::hw::trezor::messages::nem::NEMSignTx_NEMMosaicCreation_NEMMosaicDefinition::InitAsDefaultInstance();
}

::google::protobuf::internal::SCCInfo<0> scc_info_NEMSignTx_NEMMosaicCreation_NEMMosaicDefinition_messages_2dnem_2eproto =
    {{ATOMIC_VAR_INIT(::google::protobuf::internal::SCCInfoBase::kUninitialized), 0, InitDefaultsNEMSignTx_NEMMosaicCreation_NEMMosaicDefinition_messages_2dnem_2eproto}, {}};

static void InitDefaultsNEMSignTx_NEMMosaicCreation_messages_2dnem_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::hw::trezor::messages::nem::_NEMSignTx_NEMMosaicCreation_default_instance_;
    new (ptr) ::hw::trezor::messages::nem::NEMSignTx_NEMMosaicCreation();
    ::google::protobuf::internal::OnShutdownDestroyMessage(ptr);
  }
  ::hw::trezor::messages::nem::NEMSignTx_NEMMosaicCreation::InitAsDefaultInstance();
}

::google::protobuf::internal::SCCInfo<1> scc_info_NEMSignTx_NEMMosaicCreation_messages_2dnem_2eproto =
    {{ATOMIC_VAR_INIT(::google::protobuf::internal::SCCInfoBase::kUninitialized), 1, InitDefaultsNEMSignTx_NEMMosaicCreation_messages_2dnem_2eproto}, {
      &scc_info_NEMSignTx_NEMMosaicCreation_NEMMosaicDefinition_messages_2dnem_2eproto.base,}};

static void InitDefaultsNEMSignTx_NEMMosaicSupplyChange_messages_2dnem_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::hw::trezor::messages::nem::_NEMSignTx_NEMMosaicSupplyChange_default_instance_;
    new (ptr) ::hw::trezor::messages::nem::NEMSignTx_NEMMosaicSupplyChange();
    ::google::protobuf::internal::OnShutdownDestroyMessage(ptr);
  }
  ::hw::trezor::messages::nem::NEMSignTx_NEMMosaicSupplyChange::InitAsDefaultInstance();
}

::google::protobuf::internal::SCCInfo<0> scc_info_NEMSignTx_NEMMosaicSupplyChange_messages_2dnem_2eproto =
    {{ATOMIC_VAR_INIT(::google::protobuf::internal::SCCInfoBase::kUninitialized), 0, InitDefaultsNEMSignTx_NEMMosaicSupplyChange_messages_2dnem_2eproto}, {}};

static void InitDefaultsNEMSignTx_NEMAggregateModification_NEMCosignatoryModification_messages_2dnem_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::hw::trezor::messages::nem::_NEMSignTx_NEMAggregateModification_NEMCosignatoryModification_default_instance_;
    new (ptr) ::hw::trezor::messages::nem::NEMSignTx_NEMAggregateModification_NEMCosignatoryModification();
    ::google::protobuf::internal::OnShutdownDestroyMessage(ptr);
  }
  ::hw::trezor::messages::nem::NEMSignTx_NEMAggregateModification_NEMCosignatoryModification::InitAsDefaultInstance();
}

::google::protobuf::internal::SCCInfo<0> scc_info_NEMSignTx_NEMAggregateModification_NEMCosignatoryModification_messages_2dnem_2eproto =
    {{ATOMIC_VAR_INIT(::google::protobuf::internal::SCCInfoBase::kUninitialized), 0, InitDefaultsNEMSignTx_NEMAggregateModification_NEMCosignatoryModification_messages_2dnem_2eproto}, {}};

static void InitDefaultsNEMSignTx_NEMAggregateModification_messages_2dnem_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::hw::trezor::messages::nem::_NEMSignTx_NEMAggregateModification_default_instance_;
    new (ptr) ::hw::trezor::messages::nem::NEMSignTx_NEMAggregateModification();
    ::google::protobuf::internal::OnShutdownDestroyMessage(ptr);
  }
  ::hw::trezor::messages::nem::NEMSignTx_NEMAggregateModification::InitAsDefaultInstance();
}

::google::protobuf::internal::SCCInfo<1> scc_info_NEMSignTx_NEMAggregateModification_messages_2dnem_2eproto =
    {{ATOMIC_VAR_INIT(::google::protobuf::internal::SCCInfoBase::kUninitialized), 1, InitDefaultsNEMSignTx_NEMAggregateModification_messages_2dnem_2eproto}, {
      &scc_info_NEMSignTx_NEMAggregateModification_NEMCosignatoryModification_messages_2dnem_2eproto.base,}};

static void InitDefaultsNEMSignTx_NEMImportanceTransfer_messages_2dnem_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::hw::trezor::messages::nem::_NEMSignTx_NEMImportanceTransfer_default_instance_;
    new (ptr) ::hw::trezor::messages::nem::NEMSignTx_NEMImportanceTransfer();
    ::google::protobuf::internal::OnShutdownDestroyMessage(ptr);
  }
  ::hw::trezor::messages::nem::NEMSignTx_NEMImportanceTransfer::InitAsDefaultInstance();
}

::google::protobuf::internal::SCCInfo<0> scc_info_NEMSignTx_NEMImportanceTransfer_messages_2dnem_2eproto =
    {{ATOMIC_VAR_INIT(::google::protobuf::internal::SCCInfoBase::kUninitialized), 0, InitDefaultsNEMSignTx_NEMImportanceTransfer_messages_2dnem_2eproto}, {}};

static void InitDefaultsNEMSignTx_messages_2dnem_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::hw::trezor::messages::nem::_NEMSignTx_default_instance_;
    new (ptr) ::hw::trezor::messages::nem::NEMSignTx();
    ::google::protobuf::internal::OnShutdownDestroyMessage(ptr);
  }
  ::hw::trezor::messages::nem::NEMSignTx::InitAsDefaultInstance();
}

::google::protobuf::internal::SCCInfo<7> scc_info_NEMSignTx_messages_2dnem_2eproto =
    {{ATOMIC_VAR_INIT(::google::protobuf::internal::SCCInfoBase::kUninitialized), 7, InitDefaultsNEMSignTx_messages_2dnem_2eproto}, {
      &scc_info_NEMSignTx_NEMTransactionCommon_messages_2dnem_2eproto.base,
      &scc_info_NEMSignTx_NEMTransfer_messages_2dnem_2eproto.base,
      &scc_info_NEMSignTx_NEMProvisionNamespace_messages_2dnem_2eproto.base,
      &scc_info_NEMSignTx_NEMMosaicCreation_messages_2dnem_2eproto.base,
      &scc_info_NEMSignTx_NEMMosaicSupplyChange_messages_2dnem_2eproto.base,
      &scc_info_NEMSignTx_NEMAggregateModification_messages_2dnem_2eproto.base,
      &scc_info_NEMSignTx_NEMImportanceTransfer_messages_2dnem_2eproto.base,}};

static void InitDefaultsNEMSignedTx_messages_2dnem_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::hw::trezor::messages::nem::_NEMSignedTx_default_instance_;
    new (ptr) ::hw::trezor::messages::nem::NEMSignedTx();
    ::google::protobuf::internal::OnShutdownDestroyMessage(ptr);
  }
  ::hw::trezor::messages::nem::NEMSignedTx::InitAsDefaultInstance();
}

::google::protobuf::internal::SCCInfo<0> scc_info_NEMSignedTx_messages_2dnem_2eproto =
    {{ATOMIC_VAR_INIT(::google::protobuf::internal::SCCInfoBase::kUninitialized), 0, InitDefaultsNEMSignedTx_messages_2dnem_2eproto}, {}};

static void InitDefaultsNEMDecryptMessage_messages_2dnem_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::hw::trezor::messages::nem::_NEMDecryptMessage_default_instance_;
    new (ptr) ::hw::trezor::messages::nem::NEMDecryptMessage();
    ::google::protobuf::internal::OnShutdownDestroyMessage(ptr);
  }
  ::hw::trezor::messages::nem::NEMDecryptMessage::InitAsDefaultInstance();
}

::google::protobuf::internal::SCCInfo<0> scc_info_NEMDecryptMessage_messages_2dnem_2eproto =
    {{ATOMIC_VAR_INIT(::google::protobuf::internal::SCCInfoBase::kUninitialized), 0, InitDefaultsNEMDecryptMessage_messages_2dnem_2eproto}, {}};

static void InitDefaultsNEMDecryptedMessage_messages_2dnem_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::hw::trezor::messages::nem::_NEMDecryptedMessage_default_instance_;
    new (ptr) ::hw::trezor::messages::nem::NEMDecryptedMessage();
    ::google::protobuf::internal::OnShutdownDestroyMessage(ptr);
  }
  ::hw::trezor::messages::nem::NEMDecryptedMessage::InitAsDefaultInstance();
}

::google::protobuf::internal::SCCInfo<0> scc_info_NEMDecryptedMessage_messages_2dnem_2eproto =
    {{ATOMIC_VAR_INIT(::google::protobuf::internal::SCCInfoBase::kUninitialized), 0, InitDefaultsNEMDecryptedMessage_messages_2dnem_2eproto}, {}};

void InitDefaults_messages_2dnem_2eproto() {
  ::google::protobuf::internal::InitSCC(&scc_info_NEMGetAddress_messages_2dnem_2eproto.base);
  ::google::protobuf::internal::InitSCC(&scc_info_NEMAddress_messages_2dnem_2eproto.base);
  ::google::protobuf::internal::InitSCC(&scc_info_NEMSignTx_NEMTransactionCommon_messages_2dnem_2eproto.base);
  ::google::protobuf::internal::InitSCC(&scc_info_NEMSignTx_NEMTransfer_NEMMosaic_messages_2dnem_2eproto.base);
  ::google::protobuf::internal::InitSCC(&scc_info_NEMSignTx_NEMTransfer_messages_2dnem_2eproto.base);
  ::google::protobuf::internal::InitSCC(&scc_info_NEMSignTx_NEMProvisionNamespace_messages_2dnem_2eproto.base);
  ::google::protobuf::internal::InitSCC(&scc_info_NEMSignTx_NEMMosaicCreation_NEMMosaicDefinition_messages_2dnem_2eproto.base);
  ::google::protobuf::internal::InitSCC(&scc_info_NEMSignTx_NEMMosaicCreation_messages_2dnem_2eproto.base);
  ::google::protobuf::internal::InitSCC(&scc_info_NEMSignTx_NEMMosaicSupplyChange_messages_2dnem_2eproto.base);
  ::google::protobuf::internal::InitSCC(&scc_info_NEMSignTx_NEMAggregateModification_NEMCosignatoryModification_messages_2dnem_2eproto.base);
  ::google::protobuf::internal::InitSCC(&scc_info_NEMSignTx_NEMAggregateModification_messages_2dnem_2eproto.base);
  ::google::protobuf::internal::InitSCC(&scc_info_NEMSignTx_NEMImportanceTransfer_messages_2dnem_2eproto.base);
  ::google::protobuf::internal::InitSCC(&scc_info_NEMSignTx_messages_2dnem_2eproto.base);
  ::google::protobuf::internal::InitSCC(&scc_info_NEMSignedTx_messages_2dnem_2eproto.base);
  ::google::protobuf::internal::InitSCC(&scc_info_NEMDecryptMessage_messages_2dnem_2eproto.base);
  ::google::protobuf::internal::InitSCC(&scc_info_NEMDecryptedMessage_messages_2dnem_2eproto.base);
}

::google::protobuf::Metadata file_level_metadata_messages_2dnem_2eproto[16];
const ::google::protobuf::EnumDescriptor* file_level_enum_descriptors_messages_2dnem_2eproto[4];
constexpr ::google::protobuf::ServiceDescriptor const** file_level_service_descriptors_messages_2dnem_2eproto = nullptr;

const ::google::protobuf::uint32 TableStruct_messages_2dnem_2eproto::offsets[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) = {
  PROTOBUF_FIELD_OFFSET(::hw::trezor::messages::nem::NEMGetAddress, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::hw::trezor::messages::nem::NEMGetAddress, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::hw::trezor::messages::nem::NEMGetAddress, address_n_),
  PROTOBUF_FIELD_OFFSET(::hw::trezor::messages::nem::NEMGetAddress, network_),
  PROTOBUF_FIELD_OFFSET(::hw::trezor::messages::nem::NEMGetAddress, show_display_),
  ~0u,
  0,
  1,
  PROTOBUF_FIELD_OFFSET(::hw::trezor::messages::nem::NEMAddress, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::hw::trezor::messages::nem::NEMAddress, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::hw::trezor::messages::nem::NEMAddress, address_),
  0,
  PROTOBUF_FIELD_OFFSET(::hw::trezor::messages::nem::NEMSignTx_NEMTransactionCommon, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::hw::trezor::messages::nem::NEMSignTx_NEMTransactionCommon, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::hw::trezor::messages::nem::NEMSignTx_NEMTransactionCommon, address_n_),
  PROTOBUF_FIELD_OFFSET(::hw::trezor::messages::nem::NEMSignTx_NEMTransactionCommon, network_),
  PROTOBUF_FIELD_OFFSET(::hw::trezor::messages::nem::NEMSignTx_NEMTransactionCommon, timestamp_),
  PROTOBUF_FIELD_OFFSET(::hw::trezor::messages::nem::NEMSignTx_NEMTransactionCommon, fee_),
  PROTOBUF_FIELD_OFFSET(::hw::trezor::messages::nem::NEMSignTx_NEMTransactionCommon, deadline_),
  PROTOBUF_FIELD_OFFSET(::hw::trezor::messages::nem::NEMSignTx_NEMTransactionCommon, signer_),
  ~0u,
  1,
  2,
  3,
  4,
  0,
  PROTOBUF_FIELD_OFFSET(::hw::trezor::messages::nem::NEMSignTx_NEMTransfer_NEMMosaic, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::hw::trezor::messages::nem::NEMSignTx_NEMTransfer_NEMMosaic, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::hw::trezor::messages::nem::NEMSignTx_NEMTransfer_NEMMosaic, namespace__),
  PROTOBUF_FIELD_OFFSET(::hw::trezor::messages::nem::NEMSignTx_NEMTransfer_NEMMosaic, mosaic_),
  PROTOBUF_FIELD_OFFSET(::hw::trezor::messages::nem::NEMSignTx_NEMTransfer_NEMMosaic, quantity_),
  0,
  1,
  2,
  PROTOBUF_FIELD_OFFSET(::hw::trezor::messages::nem::NEMSignTx_NEMTransfer, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::hw::trezor::messages::nem::NEMSignTx_NEMTransfer, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::hw::trezor::messages::nem::NEMSignTx_NEMTransfer, recipient_),
  PROTOBUF_FIELD_OFFSET(::hw::trezor::messages::nem::NEMSignTx_NEMTransfer, amount_),
  PROTOBUF_FIELD_OFFSET(::hw::trezor::messages::nem::NEMSignTx_NEMTransfer, payload_),
  PROTOBUF_FIELD_OFFSET(::hw::trezor::messages::nem::NEMSignTx_NEMTransfer, public_key_),
  PROTOBUF_FIELD_OFFSET(::hw::trezor::messages::nem::NEMSignTx_NEMTransfer, mosaics_),
  0,
  3,
  1,
  2,
  ~0u,
  PROTOBUF_FIELD_OFFSET(::hw::trezor::messages::nem::NEMSignTx_NEMProvisionNamespace, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::hw::trezor::messages::nem::NEMSignTx_NEMProvisionNamespace, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::hw::trezor::messages::nem::NEMSignTx_NEMProvisionNamespace, namespace__),
  PROTOBUF_FIELD_OFFSET(::hw::trezor::messages::nem::NEMSignTx_NEMProvisionNamespace, parent_),
  PROTOBUF_FIELD_OFFSET(::hw::trezor::messages::nem::NEMSignTx_NEMProvisionNamespace, sink_),
  PROTOBUF_FIELD_OFFSET(::hw::trezor::messages::nem::NEMSignTx_NEMProvisionNamespace, fee_),
  0,
  1,
  2,
  3,
  PROTOBUF_FIELD_OFFSET(::hw::trezor::messages::nem::NEMSignTx_NEMMosaicCreation_NEMMosaicDefinition, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::hw::trezor::messages::nem::NEMSignTx_NEMMosaicCreation_NEMMosaicDefinition, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::hw::trezor::messages::nem::NEMSignTx_NEMMosaicCreation_NEMMosaicDefinition, name_),
  PROTOBUF_FIELD_OFFSET(::hw::trezor::messages::nem::NEMSignTx_NEMMosaicCreation_NEMMosaicDefinition, ticker_),
  PROTOBUF_FIELD_OFFSET(::hw::trezor::messages::nem::NEMSignTx_NEMMosaicCreation_NEMMosaicDefinition, namespace__),
  PROTOBUF_FIELD_OFFSET(::hw::trezor::messages::nem::NEMSignTx_NEMMosaicCreation_NEMMosaicDefinition, mosaic_),
  PROTOBUF_FIELD_OFFSET(::hw::trezor::messages::nem::NEMSignTx_NEMMosaicCreation_NEMMosaicDefinition, divisibility_),
  PROTOBUF_FIELD_OFFSET(::hw::trezor::messages::nem::NEMSignTx_NEMMosaicCreation_NEMMosaicDefinition, levy_),
  PROTOBUF_FIELD_OFFSET(::hw::trezor::messages::nem::NEMSignTx_NEMMosaicCreation_NEMMosaicDefinition, fee_),
  PROTOBUF_FIELD_OFFSET(::hw::trezor::messages::nem::NEMSignTx_NEMMosaicCreation_NEMMosaicDefinition, levy_address_),
  PROTOBUF_FIELD_OFFSET(::hw::trezor::messages::nem::NEMSignTx_NEMMosaicCreation_NEMMosaicDefinition, levy_namespace_),
  PROTOBUF_FIELD_OFFSET(::hw::trezor::messages::nem::NEMSignTx_NEMMosaicCreation_NEMMosaicDefinition, levy_mosaic_),
  PROTOBUF_FIELD_OFFSET(::hw::trezor::messages::nem::NEMSignTx_NEMMosaicCreation_NEMMosaicDefinition, supply_),
  PROTOBUF_FIELD_OFFSET(::hw::trezor::messages::nem::NEMSignTx_NEMMosaicCreation_NEMMosaicDefinition, mutable_supply_),
  PROTOBUF_FIELD_OFFSET(::hw::trezor::messages::nem::NEMSignTx_NEMMosaicCreation_NEMMosaicDefinition, transferable_),
  PROTOBUF_FIELD_OFFSET(::hw::trezor::messages::nem::NEMSignTx_NEMMosaicCreation_NEMMosaicDefinition, description_),
  PROTOBUF_FIELD_OFFSET(::hw::trezor::messages::nem::NEMSignTx_NEMMosaicCreation_NEMMosaicDefinition, networks_),
  0,
  1,
  2,
  3,
  9,
  13,
  8,
  4,
  5,
  6,
  12,
  10,
  11,
  7,
  ~0u,
  PROTOBUF_FIELD_OFFSET(::hw::trezor::messages::nem::NEMSignTx_NEMMosaicCreation, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::hw::trezor::messages::nem::NEMSignTx_NEMMosaicCreation, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::hw::trezor::messages::nem::NEMSignTx_NEMMosaicCreation, definition_),
  PROTOBUF_FIELD_OFFSET(::hw::trezor::messages::nem::NEMSignTx_NEMMosaicCreation, sink_),
  PROTOBUF_FIELD_OFFSET(::hw::trezor::messages::nem::NEMSignTx_NEMMosaicCreation, fee_),
  1,
  0,
  2,
  PROTOBUF_FIELD_OFFSET(::hw::trezor::messages::nem::NEMSignTx_NEMMosaicSupplyChange, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::hw::trezor::messages::nem::NEMSignTx_NEMMosaicSupplyChange, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::hw::trezor::messages::nem::NEMSignTx_NEMMosaicSupplyChange, namespace__),
  PROTOBUF_FIELD_OFFSET(::hw::trezor::messages::nem::NEMSignTx_NEMMosaicSupplyChange, mosaic_),
  PROTOBUF_FIELD_OFFSET(::hw::trezor::messages::nem::NEMSignTx_NEMMosaicSupplyChange, type_),
  PROTOBUF_FIELD_OFFSET(::hw::trezor::messages::nem::NEMSignTx_NEMMosaicSupplyChange, delta_),
  0,
  1,
  3,
  2,
  PROTOBUF_FIELD_OFFSET(::hw::trezor::messages::nem::NEMSignTx_NEMAggregateModification_NEMCosignatoryModification, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::hw::trezor::messages::nem::NEMSignTx_NEMAggregateModification_NEMCosignatoryModification, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::hw::trezor::messages::nem::NEMSignTx_NEMAggregateModification_NEMCosignatoryModification, type_),
  PROTOBUF_FIELD_OFFSET(::hw::trezor::messages::nem::NEMSignTx_NEMAggregateModification_NEMCosignatoryModification, public_key_),
  1,
  0,
  PROTOBUF_FIELD_OFFSET(::hw::trezor::messages::nem::NEMSignTx_NEMAggregateModification, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::hw::trezor::messages::nem::NEMSignTx_NEMAggregateModification, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::hw::trezor::messages::nem::NEMSignTx_NEMAggregateModification, modifications_),
  PROTOBUF_FIELD_OFFSET(::hw::trezor::messages::nem::NEMSignTx_NEMAggregateModification, relative_change_),
  ~0u,
  0,
  PROTOBUF_FIELD_OFFSET(::hw::trezor::messages::nem::NEMSignTx_NEMImportanceTransfer, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::hw::trezor::messages::nem::NEMSignTx_NEMImportanceTransfer, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::hw::trezor::messages::nem::NEMSignTx_NEMImportanceTransfer, mode_),
  PROTOBUF_FIELD_OFFSET(::hw::trezor::messages::nem::NEMSignTx_NEMImportanceTransfer, public_key_),
  1,
  0,
  PROTOBUF_FIELD_OFFSET(::hw::trezor::messages::nem::NEMSignTx, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::hw::trezor::messages::nem::NEMSignTx, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::hw::trezor::messages::nem::NEMSignTx, transaction_),
  PROTOBUF_FIELD_OFFSET(::hw::trezor::messages::nem::NEMSignTx, multisig_),
  PROTOBUF_FIELD_OFFSET(::hw::trezor::messages::nem::NEMSignTx, transfer_),
  PROTOBUF_FIELD_OFFSET(::hw::trezor::messages::nem::NEMSignTx, cosigning_),
  PROTOBUF_FIELD_OFFSET(::hw::trezor::messages::nem::NEMSignTx, provision_namespace_),
  PROTOBUF_FIELD_OFFSET(::hw::trezor::messages::nem::NEMSignTx, mosaic_creation_),
  PROTOBUF_FIELD_OFFSET(::hw::trezor::messages::nem::NEMSignTx, supply_change_),
  PROTOBUF_FIELD_OFFSET(::hw::trezor::messages::nem::NEMSignTx, aggregate_modification_),
  PROTOBUF_FIELD_OFFSET(::hw::trezor::messages::nem::NEMSignTx, importance_transfer_),
  0,
  1,
  2,
  8,
  3,
  4,
  5,
  6,
  7,
  PROTOBUF_FIELD_OFFSET(::hw::trezor::messages::nem::NEMSignedTx, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::hw::trezor::messages::nem::NEMSignedTx, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::hw::trezor::messages::nem::NEMSignedTx, data_),
  PROTOBUF_FIELD_OFFSET(::hw::trezor::messages::nem::NEMSignedTx, signature_),
  0,
  1,
  PROTOBUF_FIELD_OFFSET(::hw::trezor::messages::nem::NEMDecryptMessage, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::hw::trezor::messages::nem::NEMDecryptMessage, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::hw::trezor::messages::nem::NEMDecryptMessage, address_n_),
  PROTOBUF_FIELD_OFFSET(::hw::trezor::messages::nem::NEMDecryptMessage, network_),
  PROTOBUF_FIELD_OFFSET(::hw::trezor::messages::nem::NEMDecryptMessage, public_key_),
  PROTOBUF_FIELD_OFFSET(::hw::trezor::messages::nem::NEMDecryptMessage, payload_),
  ~0u,
  2,
  0,
  1,
  PROTOBUF_FIELD_OFFSET(::hw::trezor::messages::nem::NEMDecryptedMessage, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::hw::trezor::messages::nem::NEMDecryptedMessage, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::hw::trezor::messages::nem::NEMDecryptedMessage, payload_),
  0,
};
static const ::google::protobuf::internal::MigrationSchema schemas[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) = {
  { 0, 8, sizeof(::hw::trezor::messages::nem::NEMGetAddress)},
  { 11, 17, sizeof(::hw::trezor::messages::nem::NEMAddress)},
  { 18, 29, sizeof(::hw::trezor::messages::nem::NEMSignTx_NEMTransactionCommon)},
  { 35, 43, sizeof(::hw::trezor::messages::nem::NEMSignTx_NEMTransfer_NEMMosaic)},
  { 46, 56, sizeof(::hw::trezor::messages::nem::NEMSignTx_NEMTransfer)},
  { 61, 70, sizeof(::hw::trezor::messages::nem::NEMSignTx_NEMProvisionNamespace)},
  { 74, 94, sizeof(::hw::trezor::messages::nem::NEMSignTx_NEMMosaicCreation_NEMMosaicDefinition)},
  { 109, 117, sizeof(::hw::trezor::messages::nem::NEMSignTx_NEMMosaicCreation)},
  { 120, 129, sizeof(::hw::trezor::messages::nem::NEMSignTx_NEMMosaicSupplyChange)},
  { 133, 140, sizeof(::hw::trezor::messages::nem::NEMSignTx_NEMAggregateModification_NEMCosignatoryModification)},
  { 142, 149, sizeof(::hw::trezor::messages::nem::NEMSignTx_NEMAggregateModification)},
  { 151, 158, sizeof(::hw::trezor::messages::nem::NEMSignTx_NEMImportanceTransfer)},
  { 160, 174, sizeof(::hw::trezor::messages::nem::NEMSignTx)},
  { 183, 190, sizeof(::hw::trezor::messages::nem::NEMSignedTx)},
  { 192, 201, sizeof(::hw::trezor::messages::nem::NEMDecryptMessage)},
  { 205, 211, sizeof(::hw::trezor::messages::nem::NEMDecryptedMessage)},
};

static ::google::protobuf::Message const * const file_default_instances[] = {
  reinterpret_cast<const ::google::protobuf::Message*>(&::hw::trezor::messages::nem::_NEMGetAddress_default_instance_),
  reinterpret_cast<const ::google::protobuf::Message*>(&::hw::trezor::messages::nem::_NEMAddress_default_instance_),
  reinterpret_cast<const ::google::protobuf::Message*>(&::hw::trezor::messages::nem::_NEMSignTx_NEMTransactionCommon_default_instance_),
  reinterpret_cast<const ::google::protobuf::Message*>(&::hw::trezor::messages::nem::_NEMSignTx_NEMTransfer_NEMMosaic_default_instance_),
  reinterpret_cast<const ::google::protobuf::Message*>(&::hw::trezor::messages::nem::_NEMSignTx_NEMTransfer_default_instance_),
  reinterpret_cast<const ::google::protobuf::Message*>(&::hw::trezor::messages::nem::_NEMSignTx_NEMProvisionNamespace_default_instance_),
  reinterpret_cast<const ::google::protobuf::Message*>(&::hw::trezor::messages::nem::_NEMSignTx_NEMMosaicCreation_NEMMosaicDefinition_default_instance_),
  reinterpret_cast<const ::google::protobuf::Message*>(&::hw::trezor::messages::nem::_NEMSignTx_NEMMosaicCreation_default_instance_),
  reinterpret_cast<const ::google::protobuf::Message*>(&::hw::trezor::messages::nem::_NEMSignTx_NEMMosaicSupplyChange_default_instance_),
  reinterpret_cast<const ::google::protobuf::Message*>(&::hw::trezor::messages::nem::_NEMSignTx_NEMAggregateModification_NEMCosignatoryModification_default_instance_),
  reinterpret_cast<const ::google::protobuf::Message*>(&::hw::trezor::messages::nem::_NEMSignTx_NEMAggregateModification_default_instance_),
  reinterpret_cast<const ::google::protobuf::Message*>(&::hw::trezor::messages::nem::_NEMSignTx_NEMImportanceTransfer_default_instance_),
  reinterpret_cast<const ::google::protobuf::Message*>(&::hw::trezor::messages::nem::_NEMSignTx_default_instance_),
  reinterpret_cast<const ::google::protobuf::Message*>(&::hw::trezor::messages::nem::_NEMSignedTx_default_instance_),
  reinterpret_cast<const ::google::protobuf::Message*>(&::hw::trezor::messages::nem::_NEMDecryptMessage_default_instance_),
  reinterpret_cast<const ::google::protobuf::Message*>(&::hw::trezor::messages::nem::_NEMDecryptedMessage_default_instance_),
};

::google::protobuf::internal::AssignDescriptorsTable assign_descriptors_table_messages_2dnem_2eproto = {
  {}, AddDescriptors_messages_2dnem_2eproto, "messages-nem.proto", schemas,
  file_default_instances, TableStruct_messages_2dnem_2eproto::offsets,
  file_level_metadata_messages_2dnem_2eproto, 16, file_level_enum_descriptors_messages_2dnem_2eproto, file_level_service_descriptors_messages_2dnem_2eproto,
};

const char descriptor_table_protodef_messages_2dnem_2eproto[] =
  "\n\022messages-nem.proto\022\026hw.trezor.messages"
  ".nem\"I\n\rNEMGetAddress\022\021\n\taddress_n\030\001 \003(\r"
  "\022\017\n\007network\030\002 \001(\r\022\024\n\014show_display\030\003 \001(\010\""
  "\035\n\nNEMAddress\022\017\n\007address\030\001 \002(\t\"\301\024\n\tNEMSi"
  "gnTx\022K\n\013transaction\030\001 \001(\01326.hw.trezor.me"
  "ssages.nem.NEMSignTx.NEMTransactionCommo"
  "n\022H\n\010multisig\030\002 \001(\01326.hw.trezor.messages"
  ".nem.NEMSignTx.NEMTransactionCommon\022\?\n\010t"
  "ransfer\030\003 \001(\0132-.hw.trezor.messages.nem.N"
  "EMSignTx.NEMTransfer\022\021\n\tcosigning\030\004 \001(\010\022"
  "T\n\023provision_namespace\030\005 \001(\01327.hw.trezor"
  ".messages.nem.NEMSignTx.NEMProvisionName"
  "space\022L\n\017mosaic_creation\030\006 \001(\01323.hw.trez"
  "or.messages.nem.NEMSignTx.NEMMosaicCreat"
  "ion\022N\n\rsupply_change\030\007 \001(\01327.hw.trezor.m"
  "essages.nem.NEMSignTx.NEMMosaicSupplyCha"
  "nge\022Z\n\026aggregate_modification\030\010 \001(\0132:.hw"
  ".trezor.messages.nem.NEMSignTx.NEMAggreg"
  "ateModification\022T\n\023importance_transfer\030\t"
  " \001(\01327.hw.trezor.messages.nem.NEMSignTx."
  "NEMImportanceTransfer\032|\n\024NEMTransactionC"
  "ommon\022\021\n\taddress_n\030\001 \003(\r\022\017\n\007network\030\002 \001("
  "\r\022\021\n\ttimestamp\030\003 \001(\r\022\013\n\003fee\030\004 \001(\004\022\020\n\010dea"
  "dline\030\005 \001(\r\022\016\n\006signer\030\006 \001(\014\032\341\001\n\013NEMTrans"
  "fer\022\021\n\trecipient\030\001 \001(\t\022\016\n\006amount\030\002 \001(\004\022\017"
  "\n\007payload\030\003 \001(\014\022\022\n\npublic_key\030\004 \001(\014\022H\n\007m"
  "osaics\030\005 \003(\01327.hw.trezor.messages.nem.NE"
  "MSignTx.NEMTransfer.NEMMosaic\032@\n\tNEMMosa"
  "ic\022\021\n\tnamespace\030\001 \001(\t\022\016\n\006mosaic\030\002 \001(\t\022\020\n"
  "\010quantity\030\003 \001(\004\032U\n\025NEMProvisionNamespace"
  "\022\021\n\tnamespace\030\001 \001(\t\022\016\n\006parent\030\002 \001(\t\022\014\n\004s"
  "ink\030\003 \001(\t\022\013\n\003fee\030\004 \001(\004\032\331\004\n\021NEMMosaicCrea"
  "tion\022[\n\ndefinition\030\001 \001(\0132G.hw.trezor.mes"
  "sages.nem.NEMSignTx.NEMMosaicCreation.NE"
  "MMosaicDefinition\022\014\n\004sink\030\002 \001(\t\022\013\n\003fee\030\003"
  " \001(\004\032\313\003\n\023NEMMosaicDefinition\022\014\n\004name\030\001 \001"
  "(\t\022\016\n\006ticker\030\002 \001(\t\022\021\n\tnamespace\030\003 \001(\t\022\016\n"
  "\006mosaic\030\004 \001(\t\022\024\n\014divisibility\030\005 \001(\r\022c\n\004l"
  "evy\030\006 \001(\0162U.hw.trezor.messages.nem.NEMSi"
  "gnTx.NEMMosaicCreation.NEMMosaicDefiniti"
  "on.NEMMosaicLevy\022\013\n\003fee\030\007 \001(\004\022\024\n\014levy_ad"
  "dress\030\010 \001(\t\022\026\n\016levy_namespace\030\t \001(\t\022\023\n\013l"
  "evy_mosaic\030\n \001(\t\022\016\n\006supply\030\013 \001(\004\022\026\n\016muta"
  "ble_supply\030\014 \001(\010\022\024\n\014transferable\030\r \001(\010\022\023"
  "\n\013description\030\016 \001(\t\022\020\n\010networks\030\017 \003(\r\"C\n"
  "\rNEMMosaicLevy\022\027\n\023MosaicLevy_Absolute\020\001\022"
  "\031\n\025MosaicLevy_Percentile\020\002\032\361\001\n\025NEMMosaic"
  "SupplyChange\022\021\n\tnamespace\030\001 \001(\t\022\016\n\006mosai"
  "c\030\002 \001(\t\022Y\n\004type\030\003 \001(\0162K.hw.trezor.messag"
  "es.nem.NEMSignTx.NEMMosaicSupplyChange.N"
  "EMSupplyChangeType\022\r\n\005delta\030\004 \001(\004\"K\n\023NEM"
  "SupplyChangeType\022\031\n\025SupplyChange_Increas"
  "e\020\001\022\031\n\025SupplyChange_Decrease\020\002\032\251\003\n\030NEMAg"
  "gregateModification\022l\n\rmodifications\030\001 \003"
  "(\0132U.hw.trezor.messages.nem.NEMSignTx.NE"
  "MAggregateModification.NEMCosignatoryMod"
  "ification\022\027\n\017relative_change\030\002 \001(\021\032\205\002\n\032N"
  "EMCosignatoryModification\022w\n\004type\030\001 \001(\0162"
  "i.hw.trezor.messages.nem.NEMSignTx.NEMAg"
  "gregateModification.NEMCosignatoryModifi"
  "cation.NEMModificationType\022\022\n\npublic_key"
  "\030\002 \001(\014\"Z\n\023NEMModificationType\022\037\n\033Cosigna"
  "toryModification_Add\020\001\022\"\n\036CosignatoryMod"
  "ification_Delete\020\002\032\355\001\n\025NEMImportanceTran"
  "sfer\022_\n\004mode\030\001 \001(\0162Q.hw.trezor.messages."
  "nem.NEMSignTx.NEMImportanceTransfer.NEMI"
  "mportanceTransferMode\022\022\n\npublic_key\030\002 \001("
  "\014\"_\n\031NEMImportanceTransferMode\022\037\n\033Import"
  "anceTransfer_Activate\020\001\022!\n\035ImportanceTra"
  "nsfer_Deactivate\020\002\".\n\013NEMSignedTx\022\014\n\004dat"
  "a\030\001 \001(\014\022\021\n\tsignature\030\002 \001(\014\"\\\n\021NEMDecrypt"
  "Message\022\021\n\taddress_n\030\001 \003(\r\022\017\n\007network\030\002 "
  "\001(\r\022\022\n\npublic_key\030\003 \001(\014\022\017\n\007payload\030\004 \001(\014"
  "\"&\n\023NEMDecryptedMessage\022\017\n\007payload\030\001 \001(\014"
  "B7\n#com.satoshilabs.trezor.lib.protobufB"
  "\020TrezorMessageNem"
  ;
::google::protobuf::internal::DescriptorTable descriptor_table_messages_2dnem_2eproto = {
  false, InitDefaults_messages_2dnem_2eproto, 
  descriptor_table_protodef_messages_2dnem_2eproto,
  "messages-nem.proto", &assign_descriptors_table_messages_2dnem_2eproto, 3017,
};

void AddDescriptors_messages_2dnem_2eproto() {
  static constexpr ::google::protobuf::internal::InitFunc deps[1] =
  {
  };
 ::google::protobuf::internal::AddDescriptors(&descriptor_table_messages_2dnem_2eproto, deps, 0);
}

// Force running AddDescriptors() at dynamic initialization time.
static bool dynamic_init_dummy_messages_2dnem_2eproto = []() { AddDescriptors_messages_2dnem_2eproto(); return true; }();
namespace hw {
namespace trezor {
namespace messages {
namespace nem {
const ::google::protobuf::EnumDescriptor* NEMSignTx_NEMMosaicCreation_NEMMosaicDefinition_NEMMosaicLevy_descriptor() {
  ::google::protobuf::internal::AssignDescriptors(&assign_descriptors_table_messages_2dnem_2eproto);
  return file_level_enum_descriptors_messages_2dnem_2eproto[0];
}
bool NEMSignTx_NEMMosaicCreation_NEMMosaicDefinition_NEMMosaicLevy_IsValid(int value) {
  switch (value) {
    case 1:
    case 2:
      return true;
    default:
      return false;
  }
}

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const NEMSignTx_NEMMosaicCreation_NEMMosaicDefinition_NEMMosaicLevy NEMSignTx_NEMMosaicCreation_NEMMosaicDefinition::MosaicLevy_Absolute;
const NEMSignTx_NEMMosaicCreation_NEMMosaicDefinition_NEMMosaicLevy NEMSignTx_NEMMosaicCreation_NEMMosaicDefinition::MosaicLevy_Percentile;
const NEMSignTx_NEMMosaicCreation_NEMMosaicDefinition_NEMMosaicLevy NEMSignTx_NEMMosaicCreation_NEMMosaicDefinition::NEMMosaicLevy_MIN;
const NEMSignTx_NEMMosaicCreation_NEMMosaicDefinition_NEMMosaicLevy NEMSignTx_NEMMosaicCreation_NEMMosaicDefinition::NEMMosaicLevy_MAX;
const int NEMSignTx_NEMMosaicCreation_NEMMosaicDefinition::NEMMosaicLevy_ARRAYSIZE;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900
const ::google::protobuf::EnumDescriptor* NEMSignTx_NEMMosaicSupplyChange_NEMSupplyChangeType_descriptor() {
  ::google::protobuf::internal::AssignDescriptors(&assign_descriptors_table_messages_2dnem_2eproto);
  return file_level_enum_descriptors_messages_2dnem_2eproto[1];
}
bool NEMSignTx_NEMMosaicSupplyChange_NEMSupplyChangeType_IsValid(int value) {
  switch (value) {
    case 1:
    case 2:
      return true;
    default:
      return false;
  }
}

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const NEMSignTx_NEMMosaicSupplyChange_NEMSupplyChangeType NEMSignTx_NEMMosaicSupplyChange::SupplyChange_Increase;
const NEMSignTx_NEMMosaicSupplyChange_NEMSupplyChangeType NEMSignTx_NEMMosaicSupplyChange::SupplyChange_Decrease;
const NEMSignTx_NEMMosaicSupplyChange_NEMSupplyChangeType NEMSignTx_NEMMosaicSupplyChange::NEMSupplyChangeType_MIN;
const NEMSignTx_NEMMosaicSupplyChange_NEMSupplyChangeType NEMSignTx_NEMMosaicSupplyChange::NEMSupplyChangeType_MAX;
const int NEMSignTx_NEMMosaicSupplyChange::NEMSupplyChangeType_ARRAYSIZE;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900
const ::google::protobuf::EnumDescriptor* NEMSignTx_NEMAggregateModification_NEMCosignatoryModification_NEMModificationType_descriptor() {
  ::google::protobuf::internal::AssignDescriptors(&assign_descriptors_table_messages_2dnem_2eproto);
  return file_level_enum_descriptors_messages_2dnem_2eproto[2];
}
bool NEMSignTx_NEMAggregateModification_NEMCosignatoryModification_NEMModificationType_IsValid(int value) {
  switch (value) {
    case 1:
    case 2:
      return true;
    default:
      return false;
  }
}

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const NEMSignTx_NEMAggregateModification_NEMCosignatoryModification_NEMModificationType NEMSignTx_NEMAggregateModification_NEMCosignatoryModification::CosignatoryModification_Add;
const NEMSignTx_NEMAggregateModification_NEMCosignatoryModification_NEMModificationType NEMSignTx_NEMAggregateModification_NEMCosignatoryModification::CosignatoryModification_Delete;
const NEMSignTx_NEMAggregateModification_NEMCosignatoryModification_NEMModificationType NEMSignTx_NEMAggregateModification_NEMCosignatoryModification::NEMModificationType_MIN;
const NEMSignTx_NEMAggregateModification_NEMCosignatoryModification_NEMModificationType NEMSignTx_NEMAggregateModification_NEMCosignatoryModification::NEMModificationType_MAX;
const int NEMSignTx_NEMAggregateModification_NEMCosignatoryModification::NEMModificationType_ARRAYSIZE;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900
const ::google::protobuf::EnumDescriptor* NEMSignTx_NEMImportanceTransfer_NEMImportanceTransferMode_descriptor() {
  ::google::protobuf::internal::AssignDescriptors(&assign_descriptors_table_messages_2dnem_2eproto);
  return file_level_enum_descriptors_messages_2dnem_2eproto[3];
}
bool NEMSignTx_NEMImportanceTransfer_NEMImportanceTransferMode_IsValid(int value) {
  switch (value) {
    case 1:
    case 2:
      return true;
    default:
      return false;
  }
}

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const NEMSignTx_NEMImportanceTransfer_NEMImportanceTransferMode NEMSignTx_NEMImportanceTransfer::ImportanceTransfer_Activate;
const NEMSignTx_NEMImportanceTransfer_NEMImportanceTransferMode NEMSignTx_NEMImportanceTransfer::ImportanceTransfer_Deactivate;
const NEMSignTx_NEMImportanceTransfer_NEMImportanceTransferMode NEMSignTx_NEMImportanceTransfer::NEMImportanceTransferMode_MIN;
const NEMSignTx_NEMImportanceTransfer_NEMImportanceTransferMode NEMSignTx_NEMImportanceTransfer::NEMImportanceTransferMode_MAX;
const int NEMSignTx_NEMImportanceTransfer::NEMImportanceTransferMode_ARRAYSIZE;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

// ===================================================================

void NEMGetAddress::InitAsDefaultInstance() {
}
class NEMGetAddress::HasBitSetters {
 public:
  static void set_has_network(NEMGetAddress* msg) {
    msg->_has_bits_[0] |= 0x00000001u;
  }
  static void set_has_show_display(NEMGetAddress* msg) {
    msg->_has_bits_[0] |= 0x00000002u;
  }
};

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int NEMGetAddress::kAddressNFieldNumber;
const int NEMGetAddress::kNetworkFieldNumber;
const int NEMGetAddress::kShowDisplayFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

NEMGetAddress::NEMGetAddress()
  : ::google::protobuf::Message(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:hw.trezor.messages.nem.NEMGetAddress)
}
NEMGetAddress::NEMGetAddress(const NEMGetAddress& from)
  : ::google::protobuf::Message(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_),
      address_n_(from.address_n_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::memcpy(&network_, &from.network_,
    static_cast<size_t>(reinterpret_cast<char*>(&show_display_) -
    reinterpret_cast<char*>(&network_)) + sizeof(show_display_));
  // @@protoc_insertion_point(copy_constructor:hw.trezor.messages.nem.NEMGetAddress)
}

void NEMGetAddress::SharedCtor() {
  ::memset(&network_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&show_display_) -
      reinterpret_cast<char*>(&network_)) + sizeof(show_display_));
}

NEMGetAddress::~NEMGetAddress() {
  // @@protoc_insertion_point(destructor:hw.trezor.messages.nem.NEMGetAddress)
  SharedDtor();
}

void NEMGetAddress::SharedDtor() {
}

void NEMGetAddress::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const NEMGetAddress& NEMGetAddress::default_instance() {
  ::google::protobuf::internal::InitSCC(&::scc_info_NEMGetAddress_messages_2dnem_2eproto.base);
  return *internal_default_instance();
}


void NEMGetAddress::Clear() {
// @@protoc_insertion_point(message_clear_start:hw.trezor.messages.nem.NEMGetAddress)
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  address_n_.Clear();
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    ::memset(&network_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&show_display_) -
        reinterpret_cast<char*>(&network_)) + sizeof(show_display_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* NEMGetAddress::_InternalParse(const char* begin, const char* end, void* object,
                  ::google::protobuf::internal::ParseContext* ctx) {
  auto msg = static_cast<NEMGetAddress*>(object);
  ::google::protobuf::int32 size; (void)size;
  int depth; (void)depth;
  ::google::protobuf::uint32 tag;
  ::google::protobuf::internal::ParseFunc parser_till_end; (void)parser_till_end;
  auto ptr = begin;
  while (ptr < end) {
    ptr = ::google::protobuf::io::Parse32(ptr, &tag);
    GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
    switch (tag >> 3) {
      // repeated uint32 address_n = 1;
      case 1: {
        if (static_cast<::google::protobuf::uint8>(tag) == 8) {
          do {
            msg->add_address_n(::google::protobuf::internal::ReadVarint(&ptr));
            GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
            if (ptr >= end) break;
          } while ((::google::protobuf::io::UnalignedLoad<::google::protobuf::uint64>(ptr) & 255) == 8 && (ptr += 1));
          break;
        } else if (static_cast<::google::protobuf::uint8>(tag) != 10) goto handle_unusual;
        ptr = ::google::protobuf::io::ReadSize(ptr, &size);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        parser_till_end = ::google::protobuf::internal::PackedUInt32Parser;
        object = msg->mutable_address_n();
        if (size > end - ptr) goto len_delim_till_end;
        auto newend = ptr + size;
        if (size) ptr = parser_till_end(ptr, newend, object, ctx);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr == newend);
        break;
      }
      // optional uint32 network = 2;
      case 2: {
        if (static_cast<::google::protobuf::uint8>(tag) != 16) goto handle_unusual;
        msg->set_network(::google::protobuf::internal::ReadVarint(&ptr));
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        break;
      }
      // optional bool show_display = 3;
      case 3: {
        if (static_cast<::google::protobuf::uint8>(tag) != 24) goto handle_unusual;
        msg->set_show_display(::google::protobuf::internal::ReadVarint(&ptr));
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        break;
      }
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->EndGroup(tag);
          return ptr;
        }
        auto res = UnknownFieldParse(tag, {_InternalParse, msg},
          ptr, end, msg->_internal_metadata_.mutable_unknown_fields(), ctx);
        ptr = res.first;
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr != nullptr);
        if (res.second) return ptr;
      }
    }  // switch
  }  // while
  return ptr;
len_delim_till_end:
  return ctx->StoreAndTailCall(ptr, end, {_InternalParse, msg},
                               {parser_till_end, object}, size);
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool NEMGetAddress::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:hw.trezor.messages.nem.NEMGetAddress)
  for (;;) {
    ::std::pair<::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated uint32 address_n = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (8 & 0xFF)) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadRepeatedPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 1, 8u, input, this->mutable_address_n())));
        } else if (static_cast< ::google::protobuf::uint8>(tag) == (10 & 0xFF)) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPackedPrimitiveNoInline<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, this->mutable_address_n())));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional uint32 network = 2;
      case 2: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (16 & 0xFF)) {
          HasBitSetters::set_has_network(this);
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &network_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional bool show_display = 3;
      case 3: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (24 & 0xFF)) {
          HasBitSetters::set_has_show_display(this);
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &show_display_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, _internal_metadata_.mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:hw.trezor.messages.nem.NEMGetAddress)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:hw.trezor.messages.nem.NEMGetAddress)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void NEMGetAddress::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:hw.trezor.messages.nem.NEMGetAddress)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated uint32 address_n = 1;
  for (int i = 0, n = this->address_n_size(); i < n; i++) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(
      1, this->address_n(i), output);
  }

  cached_has_bits = _has_bits_[0];
  // optional uint32 network = 2;
  if (cached_has_bits & 0x00000001u) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->network(), output);
  }

  // optional bool show_display = 3;
  if (cached_has_bits & 0x00000002u) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(3, this->show_display(), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        _internal_metadata_.unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:hw.trezor.messages.nem.NEMGetAddress)
}

::google::protobuf::uint8* NEMGetAddress::InternalSerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:hw.trezor.messages.nem.NEMGetAddress)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated uint32 address_n = 1;
  target = ::google::protobuf::internal::WireFormatLite::
    WriteUInt32ToArray(1, this->address_n_, target);

  cached_has_bits = _has_bits_[0];
  // optional uint32 network = 2;
  if (cached_has_bits & 0x00000001u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(2, this->network(), target);
  }

  // optional bool show_display = 3;
  if (cached_has_bits & 0x00000002u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteBoolToArray(3, this->show_display(), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:hw.trezor.messages.nem.NEMGetAddress)
  return target;
}

size_t NEMGetAddress::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:hw.trezor.messages.nem.NEMGetAddress)
  size_t total_size = 0;

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        _internal_metadata_.unknown_fields());
  }
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated uint32 address_n = 1;
  {
    size_t data_size = ::google::protobuf::internal::WireFormatLite::
      UInt32Size(this->address_n_);
    total_size += 1 *
                  ::google::protobuf::internal::FromIntSize(this->address_n_size());
    total_size += data_size;
  }

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional uint32 network = 2;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->network());
    }

    // optional bool show_display = 3;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 + 1;
    }

  }
  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void NEMGetAddress::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:hw.trezor.messages.nem.NEMGetAddress)
  GOOGLE_DCHECK_NE(&from, this);
  const NEMGetAddress* source =
      ::google::protobuf::DynamicCastToGenerated<NEMGetAddress>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:hw.trezor.messages.nem.NEMGetAddress)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:hw.trezor.messages.nem.NEMGetAddress)
    MergeFrom(*source);
  }
}

void NEMGetAddress::MergeFrom(const NEMGetAddress& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:hw.trezor.messages.nem.NEMGetAddress)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  address_n_.MergeFrom(from.address_n_);
  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      network_ = from.network_;
    }
    if (cached_has_bits & 0x00000002u) {
      show_display_ = from.show_display_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void NEMGetAddress::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:hw.trezor.messages.nem.NEMGetAddress)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void NEMGetAddress::CopyFrom(const NEMGetAddress& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:hw.trezor.messages.nem.NEMGetAddress)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool NEMGetAddress::IsInitialized() const {
  return true;
}

void NEMGetAddress::Swap(NEMGetAddress* other) {
  if (other == this) return;
  InternalSwap(other);
}
void NEMGetAddress::InternalSwap(NEMGetAddress* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  address_n_.InternalSwap(&other->address_n_);
  swap(network_, other->network_);
  swap(show_display_, other->show_display_);
}

::google::protobuf::Metadata NEMGetAddress::GetMetadata() const {
  ::google::protobuf::internal::AssignDescriptors(&::assign_descriptors_table_messages_2dnem_2eproto);
  return ::file_level_metadata_messages_2dnem_2eproto[kIndexInFileMessages];
}


// ===================================================================

void NEMAddress::InitAsDefaultInstance() {
}
class NEMAddress::HasBitSetters {
 public:
  static void set_has_address(NEMAddress* msg) {
    msg->_has_bits_[0] |= 0x00000001u;
  }
};

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int NEMAddress::kAddressFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

NEMAddress::NEMAddress()
  : ::google::protobuf::Message(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:hw.trezor.messages.nem.NEMAddress)
}
NEMAddress::NEMAddress(const NEMAddress& from)
  : ::google::protobuf::Message(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  address_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (from.has_address()) {
    address_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.address_);
  }
  // @@protoc_insertion_point(copy_constructor:hw.trezor.messages.nem.NEMAddress)
}

void NEMAddress::SharedCtor() {
  ::google::protobuf::internal::InitSCC(
      &scc_info_NEMAddress_messages_2dnem_2eproto.base);
  address_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}

NEMAddress::~NEMAddress() {
  // @@protoc_insertion_point(destructor:hw.trezor.messages.nem.NEMAddress)
  SharedDtor();
}

void NEMAddress::SharedDtor() {
  address_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}

void NEMAddress::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const NEMAddress& NEMAddress::default_instance() {
  ::google::protobuf::internal::InitSCC(&::scc_info_NEMAddress_messages_2dnem_2eproto.base);
  return *internal_default_instance();
}


void NEMAddress::Clear() {
// @@protoc_insertion_point(message_clear_start:hw.trezor.messages.nem.NEMAddress)
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    address_.ClearNonDefaultToEmptyNoArena();
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* NEMAddress::_InternalParse(const char* begin, const char* end, void* object,
                  ::google::protobuf::internal::ParseContext* ctx) {
  auto msg = static_cast<NEMAddress*>(object);
  ::google::protobuf::int32 size; (void)size;
  int depth; (void)depth;
  ::google::protobuf::uint32 tag;
  ::google::protobuf::internal::ParseFunc parser_till_end; (void)parser_till_end;
  auto ptr = begin;
  while (ptr < end) {
    ptr = ::google::protobuf::io::Parse32(ptr, &tag);
    GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
    switch (tag >> 3) {
      // required string address = 1;
      case 1: {
        if (static_cast<::google::protobuf::uint8>(tag) != 10) goto handle_unusual;
        ptr = ::google::protobuf::io::ReadSize(ptr, &size);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        ctx->extra_parse_data().SetFieldName("hw.trezor.messages.nem.NEMAddress.address");
        object = msg->mutable_address();
        if (size > end - ptr + ::google::protobuf::internal::ParseContext::kSlopBytes) {
          parser_till_end = ::google::protobuf::internal::GreedyStringParserUTF8Verify;
          goto string_till_end;
        }
        GOOGLE_PROTOBUF_PARSER_ASSERT(::google::protobuf::internal::StringCheckUTF8Verify(ptr, size, ctx));
        ::google::protobuf::internal::InlineGreedyStringParser(object, ptr, size, ctx);
        ptr += size;
        break;
      }
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->EndGroup(tag);
          return ptr;
        }
        auto res = UnknownFieldParse(tag, {_InternalParse, msg},
          ptr, end, msg->_internal_metadata_.mutable_unknown_fields(), ctx);
        ptr = res.first;
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr != nullptr);
        if (res.second) return ptr;
      }
    }  // switch
  }  // while
  return ptr;
string_till_end:
  static_cast<::std::string*>(object)->clear();
  static_cast<::std::string*>(object)->reserve(size);
  goto len_delim_till_end;
len_delim_till_end:
  return ctx->StoreAndTailCall(ptr, end, {_InternalParse, msg},
                               {parser_till_end, object}, size);
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool NEMAddress::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:hw.trezor.messages.nem.NEMAddress)
  for (;;) {
    ::std::pair<::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required string address = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (10 & 0xFF)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_address()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->address().data(), static_cast<int>(this->address().length()),
            ::google::protobuf::internal::WireFormat::PARSE,
            "hw.trezor.messages.nem.NEMAddress.address");
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, _internal_metadata_.mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:hw.trezor.messages.nem.NEMAddress)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:hw.trezor.messages.nem.NEMAddress)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void NEMAddress::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:hw.trezor.messages.nem.NEMAddress)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required string address = 1;
  if (cached_has_bits & 0x00000001u) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->address().data(), static_cast<int>(this->address().length()),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "hw.trezor.messages.nem.NEMAddress.address");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      1, this->address(), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        _internal_metadata_.unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:hw.trezor.messages.nem.NEMAddress)
}

::google::protobuf::uint8* NEMAddress::InternalSerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:hw.trezor.messages.nem.NEMAddress)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required string address = 1;
  if (cached_has_bits & 0x00000001u) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->address().data(), static_cast<int>(this->address().length()),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "hw.trezor.messages.nem.NEMAddress.address");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        1, this->address(), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:hw.trezor.messages.nem.NEMAddress)
  return target;
}

size_t NEMAddress::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:hw.trezor.messages.nem.NEMAddress)
  size_t total_size = 0;

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        _internal_metadata_.unknown_fields());
  }
  // required string address = 1;
  if (has_address()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::StringSize(
        this->address());
  }
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void NEMAddress::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:hw.trezor.messages.nem.NEMAddress)
  GOOGLE_DCHECK_NE(&from, this);
  const NEMAddress* source =
      ::google::protobuf::DynamicCastToGenerated<NEMAddress>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:hw.trezor.messages.nem.NEMAddress)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:hw.trezor.messages.nem.NEMAddress)
    MergeFrom(*source);
  }
}

void NEMAddress::MergeFrom(const NEMAddress& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:hw.trezor.messages.nem.NEMAddress)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  if (from.has_address()) {
    _has_bits_[0] |= 0x00000001u;
    address_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.address_);
  }
}

void NEMAddress::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:hw.trezor.messages.nem.NEMAddress)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void NEMAddress::CopyFrom(const NEMAddress& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:hw.trezor.messages.nem.NEMAddress)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool NEMAddress::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;
  return true;
}

void NEMAddress::Swap(NEMAddress* other) {
  if (other == this) return;
  InternalSwap(other);
}
void NEMAddress::InternalSwap(NEMAddress* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  address_.Swap(&other->address_, &::google::protobuf::internal::GetEmptyStringAlreadyInited(),
    GetArenaNoVirtual());
}

::google::protobuf::Metadata NEMAddress::GetMetadata() const {
  ::google::protobuf::internal::AssignDescriptors(&::assign_descriptors_table_messages_2dnem_2eproto);
  return ::file_level_metadata_messages_2dnem_2eproto[kIndexInFileMessages];
}


// ===================================================================

void NEMSignTx_NEMTransactionCommon::InitAsDefaultInstance() {
}
class NEMSignTx_NEMTransactionCommon::HasBitSetters {
 public:
  static void set_has_network(NEMSignTx_NEMTransactionCommon* msg) {
    msg->_has_bits_[0] |= 0x00000002u;
  }
  static void set_has_timestamp(NEMSignTx_NEMTransactionCommon* msg) {
    msg->_has_bits_[0] |= 0x00000004u;
  }
  static void set_has_fee(NEMSignTx_NEMTransactionCommon* msg) {
    msg->_has_bits_[0] |= 0x00000008u;
  }
  static void set_has_deadline(NEMSignTx_NEMTransactionCommon* msg) {
    msg->_has_bits_[0] |= 0x00000010u;
  }
  static void set_has_signer(NEMSignTx_NEMTransactionCommon* msg) {
    msg->_has_bits_[0] |= 0x00000001u;
  }
};

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int NEMSignTx_NEMTransactionCommon::kAddressNFieldNumber;
const int NEMSignTx_NEMTransactionCommon::kNetworkFieldNumber;
const int NEMSignTx_NEMTransactionCommon::kTimestampFieldNumber;
const int NEMSignTx_NEMTransactionCommon::kFeeFieldNumber;
const int NEMSignTx_NEMTransactionCommon::kDeadlineFieldNumber;
const int NEMSignTx_NEMTransactionCommon::kSignerFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

NEMSignTx_NEMTransactionCommon::NEMSignTx_NEMTransactionCommon()
  : ::google::protobuf::Message(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:hw.trezor.messages.nem.NEMSignTx.NEMTransactionCommon)
}
NEMSignTx_NEMTransactionCommon::NEMSignTx_NEMTransactionCommon(const NEMSignTx_NEMTransactionCommon& from)
  : ::google::protobuf::Message(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_),
      address_n_(from.address_n_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  signer_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (from.has_signer()) {
    signer_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.signer_);
  }
  ::memcpy(&network_, &from.network_,
    static_cast<size_t>(reinterpret_cast<char*>(&deadline_) -
    reinterpret_cast<char*>(&network_)) + sizeof(deadline_));
  // @@protoc_insertion_point(copy_constructor:hw.trezor.messages.nem.NEMSignTx.NEMTransactionCommon)
}

void NEMSignTx_NEMTransactionCommon::SharedCtor() {
  ::google::protobuf::internal::InitSCC(
      &scc_info_NEMSignTx_NEMTransactionCommon_messages_2dnem_2eproto.base);
  signer_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  ::memset(&network_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&deadline_) -
      reinterpret_cast<char*>(&network_)) + sizeof(deadline_));
}

NEMSignTx_NEMTransactionCommon::~NEMSignTx_NEMTransactionCommon() {
  // @@protoc_insertion_point(destructor:hw.trezor.messages.nem.NEMSignTx.NEMTransactionCommon)
  SharedDtor();
}

void NEMSignTx_NEMTransactionCommon::SharedDtor() {
  signer_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}

void NEMSignTx_NEMTransactionCommon::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const NEMSignTx_NEMTransactionCommon& NEMSignTx_NEMTransactionCommon::default_instance() {
  ::google::protobuf::internal::InitSCC(&::scc_info_NEMSignTx_NEMTransactionCommon_messages_2dnem_2eproto.base);
  return *internal_default_instance();
}


void NEMSignTx_NEMTransactionCommon::Clear() {
// @@protoc_insertion_point(message_clear_start:hw.trezor.messages.nem.NEMSignTx.NEMTransactionCommon)
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  address_n_.Clear();
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    signer_.ClearNonDefaultToEmptyNoArena();
  }
  if (cached_has_bits & 0x0000001eu) {
    ::memset(&network_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&deadline_) -
        reinterpret_cast<char*>(&network_)) + sizeof(deadline_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* NEMSignTx_NEMTransactionCommon::_InternalParse(const char* begin, const char* end, void* object,
                  ::google::protobuf::internal::ParseContext* ctx) {
  auto msg = static_cast<NEMSignTx_NEMTransactionCommon*>(object);
  ::google::protobuf::int32 size; (void)size;
  int depth; (void)depth;
  ::google::protobuf::uint32 tag;
  ::google::protobuf::internal::ParseFunc parser_till_end; (void)parser_till_end;
  auto ptr = begin;
  while (ptr < end) {
    ptr = ::google::protobuf::io::Parse32(ptr, &tag);
    GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
    switch (tag >> 3) {
      // repeated uint32 address_n = 1;
      case 1: {
        if (static_cast<::google::protobuf::uint8>(tag) == 8) {
          do {
            msg->add_address_n(::google::protobuf::internal::ReadVarint(&ptr));
            GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
            if (ptr >= end) break;
          } while ((::google::protobuf::io::UnalignedLoad<::google::protobuf::uint64>(ptr) & 255) == 8 && (ptr += 1));
          break;
        } else if (static_cast<::google::protobuf::uint8>(tag) != 10) goto handle_unusual;
        ptr = ::google::protobuf::io::ReadSize(ptr, &size);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        parser_till_end = ::google::protobuf::internal::PackedUInt32Parser;
        object = msg->mutable_address_n();
        if (size > end - ptr) goto len_delim_till_end;
        auto newend = ptr + size;
        if (size) ptr = parser_till_end(ptr, newend, object, ctx);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr == newend);
        break;
      }
      // optional uint32 network = 2;
      case 2: {
        if (static_cast<::google::protobuf::uint8>(tag) != 16) goto handle_unusual;
        msg->set_network(::google::protobuf::internal::ReadVarint(&ptr));
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        break;
      }
      // optional uint32 timestamp = 3;
      case 3: {
        if (static_cast<::google::protobuf::uint8>(tag) != 24) goto handle_unusual;
        msg->set_timestamp(::google::protobuf::internal::ReadVarint(&ptr));
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        break;
      }
      // optional uint64 fee = 4;
      case 4: {
        if (static_cast<::google::protobuf::uint8>(tag) != 32) goto handle_unusual;
        msg->set_fee(::google::protobuf::internal::ReadVarint(&ptr));
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        break;
      }
      // optional uint32 deadline = 5;
      case 5: {
        if (static_cast<::google::protobuf::uint8>(tag) != 40) goto handle_unusual;
        msg->set_deadline(::google::protobuf::internal::ReadVarint(&ptr));
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        break;
      }
      // optional bytes signer = 6;
      case 6: {
        if (static_cast<::google::protobuf::uint8>(tag) != 50) goto handle_unusual;
        ptr = ::google::protobuf::io::ReadSize(ptr, &size);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        object = msg->mutable_signer();
        if (size > end - ptr + ::google::protobuf::internal::ParseContext::kSlopBytes) {
          parser_till_end = ::google::protobuf::internal::GreedyStringParser;
          goto string_till_end;
        }
        GOOGLE_PROTOBUF_PARSER_ASSERT(::google::protobuf::internal::StringCheck(ptr, size, ctx));
        ::google::protobuf::internal::InlineGreedyStringParser(object, ptr, size, ctx);
        ptr += size;
        break;
      }
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->EndGroup(tag);
          return ptr;
        }
        auto res = UnknownFieldParse(tag, {_InternalParse, msg},
          ptr, end, msg->_internal_metadata_.mutable_unknown_fields(), ctx);
        ptr = res.first;
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr != nullptr);
        if (res.second) return ptr;
      }
    }  // switch
  }  // while
  return ptr;
string_till_end:
  static_cast<::std::string*>(object)->clear();
  static_cast<::std::string*>(object)->reserve(size);
  goto len_delim_till_end;
len_delim_till_end:
  return ctx->StoreAndTailCall(ptr, end, {_InternalParse, msg},
                               {parser_till_end, object}, size);
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool NEMSignTx_NEMTransactionCommon::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:hw.trezor.messages.nem.NEMSignTx.NEMTransactionCommon)
  for (;;) {
    ::std::pair<::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated uint32 address_n = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (8 & 0xFF)) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadRepeatedPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 1, 8u, input, this->mutable_address_n())));
        } else if (static_cast< ::google::protobuf::uint8>(tag) == (10 & 0xFF)) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPackedPrimitiveNoInline<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, this->mutable_address_n())));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional uint32 network = 2;
      case 2: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (16 & 0xFF)) {
          HasBitSetters::set_has_network(this);
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &network_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional uint32 timestamp = 3;
      case 3: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (24 & 0xFF)) {
          HasBitSetters::set_has_timestamp(this);
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &timestamp_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional uint64 fee = 4;
      case 4: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (32 & 0xFF)) {
          HasBitSetters::set_has_fee(this);
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &fee_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional uint32 deadline = 5;
      case 5: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (40 & 0xFF)) {
          HasBitSetters::set_has_deadline(this);
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &deadline_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional bytes signer = 6;
      case 6: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (50 & 0xFF)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_signer()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, _internal_metadata_.mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:hw.trezor.messages.nem.NEMSignTx.NEMTransactionCommon)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:hw.trezor.messages.nem.NEMSignTx.NEMTransactionCommon)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void NEMSignTx_NEMTransactionCommon::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:hw.trezor.messages.nem.NEMSignTx.NEMTransactionCommon)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated uint32 address_n = 1;
  for (int i = 0, n = this->address_n_size(); i < n; i++) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(
      1, this->address_n(i), output);
  }

  cached_has_bits = _has_bits_[0];
  // optional uint32 network = 2;
  if (cached_has_bits & 0x00000002u) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->network(), output);
  }

  // optional uint32 timestamp = 3;
  if (cached_has_bits & 0x00000004u) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(3, this->timestamp(), output);
  }

  // optional uint64 fee = 4;
  if (cached_has_bits & 0x00000008u) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(4, this->fee(), output);
  }

  // optional uint32 deadline = 5;
  if (cached_has_bits & 0x00000010u) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(5, this->deadline(), output);
  }

  // optional bytes signer = 6;
  if (cached_has_bits & 0x00000001u) {
    ::google::protobuf::internal::WireFormatLite::WriteBytesMaybeAliased(
      6, this->signer(), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        _internal_metadata_.unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:hw.trezor.messages.nem.NEMSignTx.NEMTransactionCommon)
}

::google::protobuf::uint8* NEMSignTx_NEMTransactionCommon::InternalSerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:hw.trezor.messages.nem.NEMSignTx.NEMTransactionCommon)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated uint32 address_n = 1;
  target = ::google::protobuf::internal::WireFormatLite::
    WriteUInt32ToArray(1, this->address_n_, target);

  cached_has_bits = _has_bits_[0];
  // optional uint32 network = 2;
  if (cached_has_bits & 0x00000002u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(2, this->network(), target);
  }

  // optional uint32 timestamp = 3;
  if (cached_has_bits & 0x00000004u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(3, this->timestamp(), target);
  }

  // optional uint64 fee = 4;
  if (cached_has_bits & 0x00000008u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt64ToArray(4, this->fee(), target);
  }

  // optional uint32 deadline = 5;
  if (cached_has_bits & 0x00000010u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(5, this->deadline(), target);
  }

  // optional bytes signer = 6;
  if (cached_has_bits & 0x00000001u) {
    target =
      ::google::protobuf::internal::WireFormatLite::WriteBytesToArray(
        6, this->signer(), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:hw.trezor.messages.nem.NEMSignTx.NEMTransactionCommon)
  return target;
}

size_t NEMSignTx_NEMTransactionCommon::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:hw.trezor.messages.nem.NEMSignTx.NEMTransactionCommon)
  size_t total_size = 0;

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        _internal_metadata_.unknown_fields());
  }
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated uint32 address_n = 1;
  {
    size_t data_size = ::google::protobuf::internal::WireFormatLite::
      UInt32Size(this->address_n_);
    total_size += 1 *
                  ::google::protobuf::internal::FromIntSize(this->address_n_size());
    total_size += data_size;
  }

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    // optional bytes signer = 6;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->signer());
    }

    // optional uint32 network = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->network());
    }

    // optional uint32 timestamp = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->timestamp());
    }

    // optional uint64 fee = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->fee());
    }

    // optional uint32 deadline = 5;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->deadline());
    }

  }
  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void NEMSignTx_NEMTransactionCommon::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:hw.trezor.messages.nem.NEMSignTx.NEMTransactionCommon)
  GOOGLE_DCHECK_NE(&from, this);
  const NEMSignTx_NEMTransactionCommon* source =
      ::google::protobuf::DynamicCastToGenerated<NEMSignTx_NEMTransactionCommon>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:hw.trezor.messages.nem.NEMSignTx.NEMTransactionCommon)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:hw.trezor.messages.nem.NEMSignTx.NEMTransactionCommon)
    MergeFrom(*source);
  }
}

void NEMSignTx_NEMTransactionCommon::MergeFrom(const NEMSignTx_NEMTransactionCommon& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:hw.trezor.messages.nem.NEMSignTx.NEMTransactionCommon)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  address_n_.MergeFrom(from.address_n_);
  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      _has_bits_[0] |= 0x00000001u;
      signer_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.signer_);
    }
    if (cached_has_bits & 0x00000002u) {
      network_ = from.network_;
    }
    if (cached_has_bits & 0x00000004u) {
      timestamp_ = from.timestamp_;
    }
    if (cached_has_bits & 0x00000008u) {
      fee_ = from.fee_;
    }
    if (cached_has_bits & 0x00000010u) {
      deadline_ = from.deadline_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void NEMSignTx_NEMTransactionCommon::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:hw.trezor.messages.nem.NEMSignTx.NEMTransactionCommon)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void NEMSignTx_NEMTransactionCommon::CopyFrom(const NEMSignTx_NEMTransactionCommon& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:hw.trezor.messages.nem.NEMSignTx.NEMTransactionCommon)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool NEMSignTx_NEMTransactionCommon::IsInitialized() const {
  return true;
}

void NEMSignTx_NEMTransactionCommon::Swap(NEMSignTx_NEMTransactionCommon* other) {
  if (other == this) return;
  InternalSwap(other);
}
void NEMSignTx_NEMTransactionCommon::InternalSwap(NEMSignTx_NEMTransactionCommon* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  address_n_.InternalSwap(&other->address_n_);
  signer_.Swap(&other->signer_, &::google::protobuf::internal::GetEmptyStringAlreadyInited(),
    GetArenaNoVirtual());
  swap(network_, other->network_);
  swap(timestamp_, other->timestamp_);
  swap(fee_, other->fee_);
  swap(deadline_, other->deadline_);
}

::google::protobuf::Metadata NEMSignTx_NEMTransactionCommon::GetMetadata() const {
  ::google::protobuf::internal::AssignDescriptors(&::assign_descriptors_table_messages_2dnem_2eproto);
  return ::file_level_metadata_messages_2dnem_2eproto[kIndexInFileMessages];
}


// ===================================================================

void NEMSignTx_NEMTransfer_NEMMosaic::InitAsDefaultInstance() {
}
class NEMSignTx_NEMTransfer_NEMMosaic::HasBitSetters {
 public:
  static void set_has_namespace_(NEMSignTx_NEMTransfer_NEMMosaic* msg) {
    msg->_has_bits_[0] |= 0x00000001u;
  }
  static void set_has_mosaic(NEMSignTx_NEMTransfer_NEMMosaic* msg) {
    msg->_has_bits_[0] |= 0x00000002u;
  }
  static void set_has_quantity(NEMSignTx_NEMTransfer_NEMMosaic* msg) {
    msg->_has_bits_[0] |= 0x00000004u;
  }
};

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int NEMSignTx_NEMTransfer_NEMMosaic::kNamespaceFieldNumber;
const int NEMSignTx_NEMTransfer_NEMMosaic::kMosaicFieldNumber;
const int NEMSignTx_NEMTransfer_NEMMosaic::kQuantityFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

NEMSignTx_NEMTransfer_NEMMosaic::NEMSignTx_NEMTransfer_NEMMosaic()
  : ::google::protobuf::Message(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:hw.trezor.messages.nem.NEMSignTx.NEMTransfer.NEMMosaic)
}
NEMSignTx_NEMTransfer_NEMMosaic::NEMSignTx_NEMTransfer_NEMMosaic(const NEMSignTx_NEMTransfer_NEMMosaic& from)
  : ::google::protobuf::Message(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  namespace__.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (from.has_namespace_()) {
    namespace__.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.namespace__);
  }
  mosaic_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (from.has_mosaic()) {
    mosaic_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.mosaic_);
  }
  quantity_ = from.quantity_;
  // @@protoc_insertion_point(copy_constructor:hw.trezor.messages.nem.NEMSignTx.NEMTransfer.NEMMosaic)
}

void NEMSignTx_NEMTransfer_NEMMosaic::SharedCtor() {
  ::google::protobuf::internal::InitSCC(
      &scc_info_NEMSignTx_NEMTransfer_NEMMosaic_messages_2dnem_2eproto.base);
  namespace__.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  mosaic_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  quantity_ = PROTOBUF_ULONGLONG(0);
}

NEMSignTx_NEMTransfer_NEMMosaic::~NEMSignTx_NEMTransfer_NEMMosaic() {
  // @@protoc_insertion_point(destructor:hw.trezor.messages.nem.NEMSignTx.NEMTransfer.NEMMosaic)
  SharedDtor();
}

void NEMSignTx_NEMTransfer_NEMMosaic::SharedDtor() {
  namespace__.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  mosaic_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}

void NEMSignTx_NEMTransfer_NEMMosaic::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const NEMSignTx_NEMTransfer_NEMMosaic& NEMSignTx_NEMTransfer_NEMMosaic::default_instance() {
  ::google::protobuf::internal::InitSCC(&::scc_info_NEMSignTx_NEMTransfer_NEMMosaic_messages_2dnem_2eproto.base);
  return *internal_default_instance();
}


void NEMSignTx_NEMTransfer_NEMMosaic::Clear() {
// @@protoc_insertion_point(message_clear_start:hw.trezor.messages.nem.NEMSignTx.NEMTransfer.NEMMosaic)
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      namespace__.ClearNonDefaultToEmptyNoArena();
    }
    if (cached_has_bits & 0x00000002u) {
      mosaic_.ClearNonDefaultToEmptyNoArena();
    }
  }
  quantity_ = PROTOBUF_ULONGLONG(0);
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* NEMSignTx_NEMTransfer_NEMMosaic::_InternalParse(const char* begin, const char* end, void* object,
                  ::google::protobuf::internal::ParseContext* ctx) {
  auto msg = static_cast<NEMSignTx_NEMTransfer_NEMMosaic*>(object);
  ::google::protobuf::int32 size; (void)size;
  int depth; (void)depth;
  ::google::protobuf::uint32 tag;
  ::google::protobuf::internal::ParseFunc parser_till_end; (void)parser_till_end;
  auto ptr = begin;
  while (ptr < end) {
    ptr = ::google::protobuf::io::Parse32(ptr, &tag);
    GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
    switch (tag >> 3) {
      // optional string namespace = 1;
      case 1: {
        if (static_cast<::google::protobuf::uint8>(tag) != 10) goto handle_unusual;
        ptr = ::google::protobuf::io::ReadSize(ptr, &size);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        ctx->extra_parse_data().SetFieldName("hw.trezor.messages.nem.NEMSignTx.NEMTransfer.NEMMosaic.namespace");
        object = msg->mutable_namespace_();
        if (size > end - ptr + ::google::protobuf::internal::ParseContext::kSlopBytes) {
          parser_till_end = ::google::protobuf::internal::GreedyStringParserUTF8Verify;
          goto string_till_end;
        }
        GOOGLE_PROTOBUF_PARSER_ASSERT(::google::protobuf::internal::StringCheckUTF8Verify(ptr, size, ctx));
        ::google::protobuf::internal::InlineGreedyStringParser(object, ptr, size, ctx);
        ptr += size;
        break;
      }
      // optional string mosaic = 2;
      case 2: {
        if (static_cast<::google::protobuf::uint8>(tag) != 18) goto handle_unusual;
        ptr = ::google::protobuf::io::ReadSize(ptr, &size);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        ctx->extra_parse_data().SetFieldName("hw.trezor.messages.nem.NEMSignTx.NEMTransfer.NEMMosaic.mosaic");
        object = msg->mutable_mosaic();
        if (size > end - ptr + ::google::protobuf::internal::ParseContext::kSlopBytes) {
          parser_till_end = ::google::protobuf::internal::GreedyStringParserUTF8Verify;
          goto string_till_end;
        }
        GOOGLE_PROTOBUF_PARSER_ASSERT(::google::protobuf::internal::StringCheckUTF8Verify(ptr, size, ctx));
        ::google::protobuf::internal::InlineGreedyStringParser(object, ptr, size, ctx);
        ptr += size;
        break;
      }
      // optional uint64 quantity = 3;
      case 3: {
        if (static_cast<::google::protobuf::uint8>(tag) != 24) goto handle_unusual;
        msg->set_quantity(::google::protobuf::internal::ReadVarint(&ptr));
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        break;
      }
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->EndGroup(tag);
          return ptr;
        }
        auto res = UnknownFieldParse(tag, {_InternalParse, msg},
          ptr, end, msg->_internal_metadata_.mutable_unknown_fields(), ctx);
        ptr = res.first;
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr != nullptr);
        if (res.second) return ptr;
      }
    }  // switch
  }  // while
  return ptr;
string_till_end:
  static_cast<::std::string*>(object)->clear();
  static_cast<::std::string*>(object)->reserve(size);
  goto len_delim_till_end;
len_delim_till_end:
  return ctx->StoreAndTailCall(ptr, end, {_InternalParse, msg},
                               {parser_till_end, object}, size);
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool NEMSignTx_NEMTransfer_NEMMosaic::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:hw.trezor.messages.nem.NEMSignTx.NEMTransfer.NEMMosaic)
  for (;;) {
    ::std::pair<::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional string namespace = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (10 & 0xFF)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_namespace_()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->namespace_().data(), static_cast<int>(this->namespace_().length()),
            ::google::protobuf::internal::WireFormat::PARSE,
            "hw.trezor.messages.nem.NEMSignTx.NEMTransfer.NEMMosaic.namespace");
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional string mosaic = 2;
      case 2: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (18 & 0xFF)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_mosaic()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->mosaic().data(), static_cast<int>(this->mosaic().length()),
            ::google::protobuf::internal::WireFormat::PARSE,
            "hw.trezor.messages.nem.NEMSignTx.NEMTransfer.NEMMosaic.mosaic");
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional uint64 quantity = 3;
      case 3: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (24 & 0xFF)) {
          HasBitSetters::set_has_quantity(this);
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &quantity_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, _internal_metadata_.mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:hw.trezor.messages.nem.NEMSignTx.NEMTransfer.NEMMosaic)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:hw.trezor.messages.nem.NEMSignTx.NEMTransfer.NEMMosaic)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void NEMSignTx_NEMTransfer_NEMMosaic::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:hw.trezor.messages.nem.NEMSignTx.NEMTransfer.NEMMosaic)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional string namespace = 1;
  if (cached_has_bits & 0x00000001u) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->namespace_().data(), static_cast<int>(this->namespace_().length()),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "hw.trezor.messages.nem.NEMSignTx.NEMTransfer.NEMMosaic.namespace");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      1, this->namespace_(), output);
  }

  // optional string mosaic = 2;
  if (cached_has_bits & 0x00000002u) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->mosaic().data(), static_cast<int>(this->mosaic().length()),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "hw.trezor.messages.nem.NEMSignTx.NEMTransfer.NEMMosaic.mosaic");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      2, this->mosaic(), output);
  }

  // optional uint64 quantity = 3;
  if (cached_has_bits & 0x00000004u) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(3, this->quantity(), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        _internal_metadata_.unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:hw.trezor.messages.nem.NEMSignTx.NEMTransfer.NEMMosaic)
}

::google::protobuf::uint8* NEMSignTx_NEMTransfer_NEMMosaic::InternalSerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:hw.trezor.messages.nem.NEMSignTx.NEMTransfer.NEMMosaic)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional string namespace = 1;
  if (cached_has_bits & 0x00000001u) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->namespace_().data(), static_cast<int>(this->namespace_().length()),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "hw.trezor.messages.nem.NEMSignTx.NEMTransfer.NEMMosaic.namespace");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        1, this->namespace_(), target);
  }

  // optional string mosaic = 2;
  if (cached_has_bits & 0x00000002u) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->mosaic().data(), static_cast<int>(this->mosaic().length()),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "hw.trezor.messages.nem.NEMSignTx.NEMTransfer.NEMMosaic.mosaic");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        2, this->mosaic(), target);
  }

  // optional uint64 quantity = 3;
  if (cached_has_bits & 0x00000004u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt64ToArray(3, this->quantity(), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:hw.trezor.messages.nem.NEMSignTx.NEMTransfer.NEMMosaic)
  return target;
}

size_t NEMSignTx_NEMTransfer_NEMMosaic::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:hw.trezor.messages.nem.NEMSignTx.NEMTransfer.NEMMosaic)
  size_t total_size = 0;

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        _internal_metadata_.unknown_fields());
  }
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional string namespace = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->namespace_());
    }

    // optional string mosaic = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->mosaic());
    }

    // optional uint64 quantity = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->quantity());
    }

  }
  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void NEMSignTx_NEMTransfer_NEMMosaic::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:hw.trezor.messages.nem.NEMSignTx.NEMTransfer.NEMMosaic)
  GOOGLE_DCHECK_NE(&from, this);
  const NEMSignTx_NEMTransfer_NEMMosaic* source =
      ::google::protobuf::DynamicCastToGenerated<NEMSignTx_NEMTransfer_NEMMosaic>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:hw.trezor.messages.nem.NEMSignTx.NEMTransfer.NEMMosaic)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:hw.trezor.messages.nem.NEMSignTx.NEMTransfer.NEMMosaic)
    MergeFrom(*source);
  }
}

void NEMSignTx_NEMTransfer_NEMMosaic::MergeFrom(const NEMSignTx_NEMTransfer_NEMMosaic& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:hw.trezor.messages.nem.NEMSignTx.NEMTransfer.NEMMosaic)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _has_bits_[0] |= 0x00000001u;
      namespace__.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.namespace__);
    }
    if (cached_has_bits & 0x00000002u) {
      _has_bits_[0] |= 0x00000002u;
      mosaic_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.mosaic_);
    }
    if (cached_has_bits & 0x00000004u) {
      quantity_ = from.quantity_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void NEMSignTx_NEMTransfer_NEMMosaic::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:hw.trezor.messages.nem.NEMSignTx.NEMTransfer.NEMMosaic)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void NEMSignTx_NEMTransfer_NEMMosaic::CopyFrom(const NEMSignTx_NEMTransfer_NEMMosaic& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:hw.trezor.messages.nem.NEMSignTx.NEMTransfer.NEMMosaic)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool NEMSignTx_NEMTransfer_NEMMosaic::IsInitialized() const {
  return true;
}

void NEMSignTx_NEMTransfer_NEMMosaic::Swap(NEMSignTx_NEMTransfer_NEMMosaic* other) {
  if (other == this) return;
  InternalSwap(other);
}
void NEMSignTx_NEMTransfer_NEMMosaic::InternalSwap(NEMSignTx_NEMTransfer_NEMMosaic* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  namespace__.Swap(&other->namespace__, &::google::protobuf::internal::GetEmptyStringAlreadyInited(),
    GetArenaNoVirtual());
  mosaic_.Swap(&other->mosaic_, &::google::protobuf::internal::GetEmptyStringAlreadyInited(),
    GetArenaNoVirtual());
  swap(quantity_, other->quantity_);
}

::google::protobuf::Metadata NEMSignTx_NEMTransfer_NEMMosaic::GetMetadata() const {
  ::google::protobuf::internal::AssignDescriptors(&::assign_descriptors_table_messages_2dnem_2eproto);
  return ::file_level_metadata_messages_2dnem_2eproto[kIndexInFileMessages];
}


// ===================================================================

void NEMSignTx_NEMTransfer::InitAsDefaultInstance() {
}
class NEMSignTx_NEMTransfer::HasBitSetters {
 public:
  static void set_has_recipient(NEMSignTx_NEMTransfer* msg) {
    msg->_has_bits_[0] |= 0x00000001u;
  }
  static void set_has_amount(NEMSignTx_NEMTransfer* msg) {
    msg->_has_bits_[0] |= 0x00000008u;
  }
  static void set_has_payload(NEMSignTx_NEMTransfer* msg) {
    msg->_has_bits_[0] |= 0x00000002u;
  }
  static void set_has_public_key(NEMSignTx_NEMTransfer* msg) {
    msg->_has_bits_[0] |= 0x00000004u;
  }
};

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int NEMSignTx_NEMTransfer::kRecipientFieldNumber;
const int NEMSignTx_NEMTransfer::kAmountFieldNumber;
const int NEMSignTx_NEMTransfer::kPayloadFieldNumber;
const int NEMSignTx_NEMTransfer::kPublicKeyFieldNumber;
const int NEMSignTx_NEMTransfer::kMosaicsFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

NEMSignTx_NEMTransfer::NEMSignTx_NEMTransfer()
  : ::google::protobuf::Message(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:hw.trezor.messages.nem.NEMSignTx.NEMTransfer)
}
NEMSignTx_NEMTransfer::NEMSignTx_NEMTransfer(const NEMSignTx_NEMTransfer& from)
  : ::google::protobuf::Message(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_),
      mosaics_(from.mosaics_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  recipient_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (from.has_recipient()) {
    recipient_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.recipient_);
  }
  payload_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (from.has_payload()) {
    payload_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.payload_);
  }
  public_key_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (from.has_public_key()) {
    public_key_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.public_key_);
  }
  amount_ = from.amount_;
  // @@protoc_insertion_point(copy_constructor:hw.trezor.messages.nem.NEMSignTx.NEMTransfer)
}

void NEMSignTx_NEMTransfer::SharedCtor() {
  ::google::protobuf::internal::InitSCC(
      &scc_info_NEMSignTx_NEMTransfer_messages_2dnem_2eproto.base);
  recipient_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  payload_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  public_key_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  amount_ = PROTOBUF_ULONGLONG(0);
}

NEMSignTx_NEMTransfer::~NEMSignTx_NEMTransfer() {
  // @@protoc_insertion_point(destructor:hw.trezor.messages.nem.NEMSignTx.NEMTransfer)
  SharedDtor();
}

void NEMSignTx_NEMTransfer::SharedDtor() {
  recipient_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  payload_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  public_key_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}

void NEMSignTx_NEMTransfer::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const NEMSignTx_NEMTransfer& NEMSignTx_NEMTransfer::default_instance() {
  ::google::protobuf::internal::InitSCC(&::scc_info_NEMSignTx_NEMTransfer_messages_2dnem_2eproto.base);
  return *internal_default_instance();
}


void NEMSignTx_NEMTransfer::Clear() {
// @@protoc_insertion_point(message_clear_start:hw.trezor.messages.nem.NEMSignTx.NEMTransfer)
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  mosaics_.Clear();
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      recipient_.ClearNonDefaultToEmptyNoArena();
    }
    if (cached_has_bits & 0x00000002u) {
      payload_.ClearNonDefaultToEmptyNoArena();
    }
    if (cached_has_bits & 0x00000004u) {
      public_key_.ClearNonDefaultToEmptyNoArena();
    }
  }
  amount_ = PROTOBUF_ULONGLONG(0);
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* NEMSignTx_NEMTransfer::_InternalParse(const char* begin, const char* end, void* object,
                  ::google::protobuf::internal::ParseContext* ctx) {
  auto msg = static_cast<NEMSignTx_NEMTransfer*>(object);
  ::google::protobuf::int32 size; (void)size;
  int depth; (void)depth;
  ::google::protobuf::uint32 tag;
  ::google::protobuf::internal::ParseFunc parser_till_end; (void)parser_till_end;
  auto ptr = begin;
  while (ptr < end) {
    ptr = ::google::protobuf::io::Parse32(ptr, &tag);
    GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
    switch (tag >> 3) {
      // optional string recipient = 1;
      case 1: {
        if (static_cast<::google::protobuf::uint8>(tag) != 10) goto handle_unusual;
        ptr = ::google::protobuf::io::ReadSize(ptr, &size);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        ctx->extra_parse_data().SetFieldName("hw.trezor.messages.nem.NEMSignTx.NEMTransfer.recipient");
        object = msg->mutable_recipient();
        if (size > end - ptr + ::google::protobuf::internal::ParseContext::kSlopBytes) {
          parser_till_end = ::google::protobuf::internal::GreedyStringParserUTF8Verify;
          goto string_till_end;
        }
        GOOGLE_PROTOBUF_PARSER_ASSERT(::google::protobuf::internal::StringCheckUTF8Verify(ptr, size, ctx));
        ::google::protobuf::internal::InlineGreedyStringParser(object, ptr, size, ctx);
        ptr += size;
        break;
      }
      // optional uint64 amount = 2;
      case 2: {
        if (static_cast<::google::protobuf::uint8>(tag) != 16) goto handle_unusual;
        msg->set_amount(::google::protobuf::internal::ReadVarint(&ptr));
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        break;
      }
      // optional bytes payload = 3;
      case 3: {
        if (static_cast<::google::protobuf::uint8>(tag) != 26) goto handle_unusual;
        ptr = ::google::protobuf::io::ReadSize(ptr, &size);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        object = msg->mutable_payload();
        if (size > end - ptr + ::google::protobuf::internal::ParseContext::kSlopBytes) {
          parser_till_end = ::google::protobuf::internal::GreedyStringParser;
          goto string_till_end;
        }
        GOOGLE_PROTOBUF_PARSER_ASSERT(::google::protobuf::internal::StringCheck(ptr, size, ctx));
        ::google::protobuf::internal::InlineGreedyStringParser(object, ptr, size, ctx);
        ptr += size;
        break;
      }
      // optional bytes public_key = 4;
      case 4: {
        if (static_cast<::google::protobuf::uint8>(tag) != 34) goto handle_unusual;
        ptr = ::google::protobuf::io::ReadSize(ptr, &size);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        object = msg->mutable_public_key();
        if (size > end - ptr + ::google::protobuf::internal::ParseContext::kSlopBytes) {
          parser_till_end = ::google::protobuf::internal::GreedyStringParser;
          goto string_till_end;
        }
        GOOGLE_PROTOBUF_PARSER_ASSERT(::google::protobuf::internal::StringCheck(ptr, size, ctx));
        ::google::protobuf::internal::InlineGreedyStringParser(object, ptr, size, ctx);
        ptr += size;
        break;
      }
      // repeated .hw.trezor.messages.nem.NEMSignTx.NEMTransfer.NEMMosaic mosaics = 5;
      case 5: {
        if (static_cast<::google::protobuf::uint8>(tag) != 42) goto handle_unusual;
        do {
          ptr = ::google::protobuf::io::ReadSize(ptr, &size);
          GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
          parser_till_end = ::hw::trezor::messages::nem::NEMSignTx_NEMTransfer_NEMMosaic::_InternalParse;
          object = msg->add_mosaics();
          if (size > end - ptr) goto len_delim_till_end;
          ptr += size;
          GOOGLE_PROTOBUF_PARSER_ASSERT(ctx->ParseExactRange(
              {parser_till_end, object}, ptr - size, ptr));
          if (ptr >= end) break;
        } while ((::google::protobuf::io::UnalignedLoad<::google::protobuf::uint64>(ptr) & 255) == 42 && (ptr += 1));
        break;
      }
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->EndGroup(tag);
          return ptr;
        }
        auto res = UnknownFieldParse(tag, {_InternalParse, msg},
          ptr, end, msg->_internal_metadata_.mutable_unknown_fields(), ctx);
        ptr = res.first;
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr != nullptr);
        if (res.second) return ptr;
      }
    }  // switch
  }  // while
  return ptr;
string_till_end:
  static_cast<::std::string*>(object)->clear();
  static_cast<::std::string*>(object)->reserve(size);
  goto len_delim_till_end;
len_delim_till_end:
  return ctx->StoreAndTailCall(ptr, end, {_InternalParse, msg},
                               {parser_till_end, object}, size);
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool NEMSignTx_NEMTransfer::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:hw.trezor.messages.nem.NEMSignTx.NEMTransfer)
  for (;;) {
    ::std::pair<::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional string recipient = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (10 & 0xFF)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_recipient()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->recipient().data(), static_cast<int>(this->recipient().length()),
            ::google::protobuf::internal::WireFormat::PARSE,
            "hw.trezor.messages.nem.NEMSignTx.NEMTransfer.recipient");
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional uint64 amount = 2;
      case 2: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (16 & 0xFF)) {
          HasBitSetters::set_has_amount(this);
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &amount_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional bytes payload = 3;
      case 3: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (26 & 0xFF)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_payload()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional bytes public_key = 4;
      case 4: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (34 & 0xFF)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_public_key()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // repeated .hw.trezor.messages.nem.NEMSignTx.NEMTransfer.NEMMosaic mosaics = 5;
      case 5: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (42 & 0xFF)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessage(
                input, add_mosaics()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, _internal_metadata_.mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:hw.trezor.messages.nem.NEMSignTx.NEMTransfer)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:hw.trezor.messages.nem.NEMSignTx.NEMTransfer)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void NEMSignTx_NEMTransfer::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:hw.trezor.messages.nem.NEMSignTx.NEMTransfer)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional string recipient = 1;
  if (cached_has_bits & 0x00000001u) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->recipient().data(), static_cast<int>(this->recipient().length()),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "hw.trezor.messages.nem.NEMSignTx.NEMTransfer.recipient");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      1, this->recipient(), output);
  }

  // optional uint64 amount = 2;
  if (cached_has_bits & 0x00000008u) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(2, this->amount(), output);
  }

  // optional bytes payload = 3;
  if (cached_has_bits & 0x00000002u) {
    ::google::protobuf::internal::WireFormatLite::WriteBytesMaybeAliased(
      3, this->payload(), output);
  }

  // optional bytes public_key = 4;
  if (cached_has_bits & 0x00000004u) {
    ::google::protobuf::internal::WireFormatLite::WriteBytesMaybeAliased(
      4, this->public_key(), output);
  }

  // repeated .hw.trezor.messages.nem.NEMSignTx.NEMTransfer.NEMMosaic mosaics = 5;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->mosaics_size()); i < n; i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      5,
      this->mosaics(static_cast<int>(i)),
      output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        _internal_metadata_.unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:hw.trezor.messages.nem.NEMSignTx.NEMTransfer)
}

::google::protobuf::uint8* NEMSignTx_NEMTransfer::InternalSerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:hw.trezor.messages.nem.NEMSignTx.NEMTransfer)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional string recipient = 1;
  if (cached_has_bits & 0x00000001u) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->recipient().data(), static_cast<int>(this->recipient().length()),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "hw.trezor.messages.nem.NEMSignTx.NEMTransfer.recipient");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        1, this->recipient(), target);
  }

  // optional uint64 amount = 2;
  if (cached_has_bits & 0x00000008u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt64ToArray(2, this->amount(), target);
  }

  // optional bytes payload = 3;
  if (cached_has_bits & 0x00000002u) {
    target =
      ::google::protobuf::internal::WireFormatLite::WriteBytesToArray(
        3, this->payload(), target);
  }

  // optional bytes public_key = 4;
  if (cached_has_bits & 0x00000004u) {
    target =
      ::google::protobuf::internal::WireFormatLite::WriteBytesToArray(
        4, this->public_key(), target);
  }

  // repeated .hw.trezor.messages.nem.NEMSignTx.NEMTransfer.NEMMosaic mosaics = 5;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->mosaics_size()); i < n; i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageToArray(
        5, this->mosaics(static_cast<int>(i)), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:hw.trezor.messages.nem.NEMSignTx.NEMTransfer)
  return target;
}

size_t NEMSignTx_NEMTransfer::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:hw.trezor.messages.nem.NEMSignTx.NEMTransfer)
  size_t total_size = 0;

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        _internal_metadata_.unknown_fields());
  }
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .hw.trezor.messages.nem.NEMSignTx.NEMTransfer.NEMMosaic mosaics = 5;
  {
    unsigned int count = static_cast<unsigned int>(this->mosaics_size());
    total_size += 1UL * count;
    for (unsigned int i = 0; i < count; i++) {
      total_size +=
        ::google::protobuf::internal::WireFormatLite::MessageSize(
          this->mosaics(static_cast<int>(i)));
    }
  }

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    // optional string recipient = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->recipient());
    }

    // optional bytes payload = 3;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->payload());
    }

    // optional bytes public_key = 4;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->public_key());
    }

    // optional uint64 amount = 2;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->amount());
    }

  }
  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void NEMSignTx_NEMTransfer::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:hw.trezor.messages.nem.NEMSignTx.NEMTransfer)
  GOOGLE_DCHECK_NE(&from, this);
  const NEMSignTx_NEMTransfer* source =
      ::google::protobuf::DynamicCastToGenerated<NEMSignTx_NEMTransfer>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:hw.trezor.messages.nem.NEMSignTx.NEMTransfer)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:hw.trezor.messages.nem.NEMSignTx.NEMTransfer)
    MergeFrom(*source);
  }
}

void NEMSignTx_NEMTransfer::MergeFrom(const NEMSignTx_NEMTransfer& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:hw.trezor.messages.nem.NEMSignTx.NEMTransfer)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  mosaics_.MergeFrom(from.mosaics_);
  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      _has_bits_[0] |= 0x00000001u;
      recipient_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.recipient_);
    }
    if (cached_has_bits & 0x00000002u) {
      _has_bits_[0] |= 0x00000002u;
      payload_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.payload_);
    }
    if (cached_has_bits & 0x00000004u) {
      _has_bits_[0] |= 0x00000004u;
      public_key_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.public_key_);
    }
    if (cached_has_bits & 0x00000008u) {
      amount_ = from.amount_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void NEMSignTx_NEMTransfer::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:hw.trezor.messages.nem.NEMSignTx.NEMTransfer)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void NEMSignTx_NEMTransfer::CopyFrom(const NEMSignTx_NEMTransfer& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:hw.trezor.messages.nem.NEMSignTx.NEMTransfer)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool NEMSignTx_NEMTransfer::IsInitialized() const {
  return true;
}

void NEMSignTx_NEMTransfer::Swap(NEMSignTx_NEMTransfer* other) {
  if (other == this) return;
  InternalSwap(other);
}
void NEMSignTx_NEMTransfer::InternalSwap(NEMSignTx_NEMTransfer* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  CastToBase(&mosaics_)->InternalSwap(CastToBase(&other->mosaics_));
  recipient_.Swap(&other->recipient_, &::google::protobuf::internal::GetEmptyStringAlreadyInited(),
    GetArenaNoVirtual());
  payload_.Swap(&other->payload_, &::google::protobuf::internal::GetEmptyStringAlreadyInited(),
    GetArenaNoVirtual());
  public_key_.Swap(&other->public_key_, &::google::protobuf::internal::GetEmptyStringAlreadyInited(),
    GetArenaNoVirtual());
  swap(amount_, other->amount_);
}

::google::protobuf::Metadata NEMSignTx_NEMTransfer::GetMetadata() const {
  ::google::protobuf::internal::AssignDescriptors(&::assign_descriptors_table_messages_2dnem_2eproto);
  return ::file_level_metadata_messages_2dnem_2eproto[kIndexInFileMessages];
}


// ===================================================================

void NEMSignTx_NEMProvisionNamespace::InitAsDefaultInstance() {
}
class NEMSignTx_NEMProvisionNamespace::HasBitSetters {
 public:
  static void set_has_namespace_(NEMSignTx_NEMProvisionNamespace* msg) {
    msg->_has_bits_[0] |= 0x00000001u;
  }
  static void set_has_parent(NEMSignTx_NEMProvisionNamespace* msg) {
    msg->_has_bits_[0] |= 0x00000002u;
  }
  static void set_has_sink(NEMSignTx_NEMProvisionNamespace* msg) {
    msg->_has_bits_[0] |= 0x00000004u;
  }
  static void set_has_fee(NEMSignTx_NEMProvisionNamespace* msg) {
    msg->_has_bits_[0] |= 0x00000008u;
  }
};

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int NEMSignTx_NEMProvisionNamespace::kNamespaceFieldNumber;
const int NEMSignTx_NEMProvisionNamespace::kParentFieldNumber;
const int NEMSignTx_NEMProvisionNamespace::kSinkFieldNumber;
const int NEMSignTx_NEMProvisionNamespace::kFeeFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

NEMSignTx_NEMProvisionNamespace::NEMSignTx_NEMProvisionNamespace()
  : ::google::protobuf::Message(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:hw.trezor.messages.nem.NEMSignTx.NEMProvisionNamespace)
}
NEMSignTx_NEMProvisionNamespace::NEMSignTx_NEMProvisionNamespace(const NEMSignTx_NEMProvisionNamespace& from)
  : ::google::protobuf::Message(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  namespace__.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (from.has_namespace_()) {
    namespace__.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.namespace__);
  }
  parent_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (from.has_parent()) {
    parent_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.parent_);
  }
  sink_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (from.has_sink()) {
    sink_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.sink_);
  }
  fee_ = from.fee_;
  // @@protoc_insertion_point(copy_constructor:hw.trezor.messages.nem.NEMSignTx.NEMProvisionNamespace)
}

void NEMSignTx_NEMProvisionNamespace::SharedCtor() {
  ::google::protobuf::internal::InitSCC(
      &scc_info_NEMSignTx_NEMProvisionNamespace_messages_2dnem_2eproto.base);
  namespace__.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  parent_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  sink_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  fee_ = PROTOBUF_ULONGLONG(0);
}

NEMSignTx_NEMProvisionNamespace::~NEMSignTx_NEMProvisionNamespace() {
  // @@protoc_insertion_point(destructor:hw.trezor.messages.nem.NEMSignTx.NEMProvisionNamespace)
  SharedDtor();
}

void NEMSignTx_NEMProvisionNamespace::SharedDtor() {
  namespace__.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  parent_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  sink_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}

void NEMSignTx_NEMProvisionNamespace::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const NEMSignTx_NEMProvisionNamespace& NEMSignTx_NEMProvisionNamespace::default_instance() {
  ::google::protobuf::internal::InitSCC(&::scc_info_NEMSignTx_NEMProvisionNamespace_messages_2dnem_2eproto.base);
  return *internal_default_instance();
}


void NEMSignTx_NEMProvisionNamespace::Clear() {
// @@protoc_insertion_point(message_clear_start:hw.trezor.messages.nem.NEMSignTx.NEMProvisionNamespace)
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      namespace__.ClearNonDefaultToEmptyNoArena();
    }
    if (cached_has_bits & 0x00000002u) {
      parent_.ClearNonDefaultToEmptyNoArena();
    }
    if (cached_has_bits & 0x00000004u) {
      sink_.ClearNonDefaultToEmptyNoArena();
    }
  }
  fee_ = PROTOBUF_ULONGLONG(0);
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* NEMSignTx_NEMProvisionNamespace::_InternalParse(const char* begin, const char* end, void* object,
                  ::google::protobuf::internal::ParseContext* ctx) {
  auto msg = static_cast<NEMSignTx_NEMProvisionNamespace*>(object);
  ::google::protobuf::int32 size; (void)size;
  int depth; (void)depth;
  ::google::protobuf::uint32 tag;
  ::google::protobuf::internal::ParseFunc parser_till_end; (void)parser_till_end;
  auto ptr = begin;
  while (ptr < end) {
    ptr = ::google::protobuf::io::Parse32(ptr, &tag);
    GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
    switch (tag >> 3) {
      // optional string namespace = 1;
      case 1: {
        if (static_cast<::google::protobuf::uint8>(tag) != 10) goto handle_unusual;
        ptr = ::google::protobuf::io::ReadSize(ptr, &size);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        ctx->extra_parse_data().SetFieldName("hw.trezor.messages.nem.NEMSignTx.NEMProvisionNamespace.namespace");
        object = msg->mutable_namespace_();
        if (size > end - ptr + ::google::protobuf::internal::ParseContext::kSlopBytes) {
          parser_till_end = ::google::protobuf::internal::GreedyStringParserUTF8Verify;
          goto string_till_end;
        }
        GOOGLE_PROTOBUF_PARSER_ASSERT(::google::protobuf::internal::StringCheckUTF8Verify(ptr, size, ctx));
        ::google::protobuf::internal::InlineGreedyStringParser(object, ptr, size, ctx);
        ptr += size;
        break;
      }
      // optional string parent = 2;
      case 2: {
        if (static_cast<::google::protobuf::uint8>(tag) != 18) goto handle_unusual;
        ptr = ::google::protobuf::io::ReadSize(ptr, &size);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        ctx->extra_parse_data().SetFieldName("hw.trezor.messages.nem.NEMSignTx.NEMProvisionNamespace.parent");
        object = msg->mutable_parent();
        if (size > end - ptr + ::google::protobuf::internal::ParseContext::kSlopBytes) {
          parser_till_end = ::google::protobuf::internal::GreedyStringParserUTF8Verify;
          goto string_till_end;
        }
        GOOGLE_PROTOBUF_PARSER_ASSERT(::google::protobuf::internal::StringCheckUTF8Verify(ptr, size, ctx));
        ::google::protobuf::internal::InlineGreedyStringParser(object, ptr, size, ctx);
        ptr += size;
        break;
      }
      // optional string sink = 3;
      case 3: {
        if (static_cast<::google::protobuf::uint8>(tag) != 26) goto handle_unusual;
        ptr = ::google::protobuf::io::ReadSize(ptr, &size);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        ctx->extra_parse_data().SetFieldName("hw.trezor.messages.nem.NEMSignTx.NEMProvisionNamespace.sink");
        object = msg->mutable_sink();
        if (size > end - ptr + ::google::protobuf::internal::ParseContext::kSlopBytes) {
          parser_till_end = ::google::protobuf::internal::GreedyStringParserUTF8Verify;
          goto string_till_end;
        }
        GOOGLE_PROTOBUF_PARSER_ASSERT(::google::protobuf::internal::StringCheckUTF8Verify(ptr, size, ctx));
        ::google::protobuf::internal::InlineGreedyStringParser(object, ptr, size, ctx);
        ptr += size;
        break;
      }
      // optional uint64 fee = 4;
      case 4: {
        if (static_cast<::google::protobuf::uint8>(tag) != 32) goto handle_unusual;
        msg->set_fee(::google::protobuf::internal::ReadVarint(&ptr));
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        break;
      }
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->EndGroup(tag);
          return ptr;
        }
        auto res = UnknownFieldParse(tag, {_InternalParse, msg},
          ptr, end, msg->_internal_metadata_.mutable_unknown_fields(), ctx);
        ptr = res.first;
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr != nullptr);
        if (res.second) return ptr;
      }
    }  // switch
  }  // while
  return ptr;
string_till_end:
  static_cast<::std::string*>(object)->clear();
  static_cast<::std::string*>(object)->reserve(size);
  goto len_delim_till_end;
len_delim_till_end:
  return ctx->StoreAndTailCall(ptr, end, {_InternalParse, msg},
                               {parser_till_end, object}, size);
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool NEMSignTx_NEMProvisionNamespace::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:hw.trezor.messages.nem.NEMSignTx.NEMProvisionNamespace)
  for (;;) {
    ::std::pair<::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional string namespace = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (10 & 0xFF)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_namespace_()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->namespace_().data(), static_cast<int>(this->namespace_().length()),
            ::google::protobuf::internal::WireFormat::PARSE,
            "hw.trezor.messages.nem.NEMSignTx.NEMProvisionNamespace.namespace");
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional string parent = 2;
      case 2: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (18 & 0xFF)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_parent()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->parent().data(), static_cast<int>(this->parent().length()),
            ::google::protobuf::internal::WireFormat::PARSE,
            "hw.trezor.messages.nem.NEMSignTx.NEMProvisionNamespace.parent");
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional string sink = 3;
      case 3: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (26 & 0xFF)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_sink()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->sink().data(), static_cast<int>(this->sink().length()),
            ::google::protobuf::internal::WireFormat::PARSE,
            "hw.trezor.messages.nem.NEMSignTx.NEMProvisionNamespace.sink");
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional uint64 fee = 4;
      case 4: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (32 & 0xFF)) {
          HasBitSetters::set_has_fee(this);
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &fee_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, _internal_metadata_.mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:hw.trezor.messages.nem.NEMSignTx.NEMProvisionNamespace)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:hw.trezor.messages.nem.NEMSignTx.NEMProvisionNamespace)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void NEMSignTx_NEMProvisionNamespace::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:hw.trezor.messages.nem.NEMSignTx.NEMProvisionNamespace)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional string namespace = 1;
  if (cached_has_bits & 0x00000001u) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->namespace_().data(), static_cast<int>(this->namespace_().length()),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "hw.trezor.messages.nem.NEMSignTx.NEMProvisionNamespace.namespace");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      1, this->namespace_(), output);
  }

  // optional string parent = 2;
  if (cached_has_bits & 0x00000002u) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->parent().data(), static_cast<int>(this->parent().length()),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "hw.trezor.messages.nem.NEMSignTx.NEMProvisionNamespace.parent");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      2, this->parent(), output);
  }

  // optional string sink = 3;
  if (cached_has_bits & 0x00000004u) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->sink().data(), static_cast<int>(this->sink().length()),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "hw.trezor.messages.nem.NEMSignTx.NEMProvisionNamespace.sink");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      3, this->sink(), output);
  }

  // optional uint64 fee = 4;
  if (cached_has_bits & 0x00000008u) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(4, this->fee(), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        _internal_metadata_.unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:hw.trezor.messages.nem.NEMSignTx.NEMProvisionNamespace)
}

::google::protobuf::uint8* NEMSignTx_NEMProvisionNamespace::InternalSerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:hw.trezor.messages.nem.NEMSignTx.NEMProvisionNamespace)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional string namespace = 1;
  if (cached_has_bits & 0x00000001u) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->namespace_().data(), static_cast<int>(this->namespace_().length()),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "hw.trezor.messages.nem.NEMSignTx.NEMProvisionNamespace.namespace");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        1, this->namespace_(), target);
  }

  // optional string parent = 2;
  if (cached_has_bits & 0x00000002u) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->parent().data(), static_cast<int>(this->parent().length()),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "hw.trezor.messages.nem.NEMSignTx.NEMProvisionNamespace.parent");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        2, this->parent(), target);
  }

  // optional string sink = 3;
  if (cached_has_bits & 0x00000004u) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->sink().data(), static_cast<int>(this->sink().length()),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "hw.trezor.messages.nem.NEMSignTx.NEMProvisionNamespace.sink");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        3, this->sink(), target);
  }

  // optional uint64 fee = 4;
  if (cached_has_bits & 0x00000008u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt64ToArray(4, this->fee(), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:hw.trezor.messages.nem.NEMSignTx.NEMProvisionNamespace)
  return target;
}

size_t NEMSignTx_NEMProvisionNamespace::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:hw.trezor.messages.nem.NEMSignTx.NEMProvisionNamespace)
  size_t total_size = 0;

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        _internal_metadata_.unknown_fields());
  }
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    // optional string namespace = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->namespace_());
    }

    // optional string parent = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->parent());
    }

    // optional string sink = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->sink());
    }

    // optional uint64 fee = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->fee());
    }

  }
  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void NEMSignTx_NEMProvisionNamespace::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:hw.trezor.messages.nem.NEMSignTx.NEMProvisionNamespace)
  GOOGLE_DCHECK_NE(&from, this);
  const NEMSignTx_NEMProvisionNamespace* source =
      ::google::protobuf::DynamicCastToGenerated<NEMSignTx_NEMProvisionNamespace>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:hw.trezor.messages.nem.NEMSignTx.NEMProvisionNamespace)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:hw.trezor.messages.nem.NEMSignTx.NEMProvisionNamespace)
    MergeFrom(*source);
  }
}

void NEMSignTx_NEMProvisionNamespace::MergeFrom(const NEMSignTx_NEMProvisionNamespace& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:hw.trezor.messages.nem.NEMSignTx.NEMProvisionNamespace)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      _has_bits_[0] |= 0x00000001u;
      namespace__.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.namespace__);
    }
    if (cached_has_bits & 0x00000002u) {
      _has_bits_[0] |= 0x00000002u;
      parent_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.parent_);
    }
    if (cached_has_bits & 0x00000004u) {
      _has_bits_[0] |= 0x00000004u;
      sink_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.sink_);
    }
    if (cached_has_bits & 0x00000008u) {
      fee_ = from.fee_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void NEMSignTx_NEMProvisionNamespace::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:hw.trezor.messages.nem.NEMSignTx.NEMProvisionNamespace)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void NEMSignTx_NEMProvisionNamespace::CopyFrom(const NEMSignTx_NEMProvisionNamespace& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:hw.trezor.messages.nem.NEMSignTx.NEMProvisionNamespace)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool NEMSignTx_NEMProvisionNamespace::IsInitialized() const {
  return true;
}

void NEMSignTx_NEMProvisionNamespace::Swap(NEMSignTx_NEMProvisionNamespace* other) {
  if (other == this) return;
  InternalSwap(other);
}
void NEMSignTx_NEMProvisionNamespace::InternalSwap(NEMSignTx_NEMProvisionNamespace* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  namespace__.Swap(&other->namespace__, &::google::protobuf::internal::GetEmptyStringAlreadyInited(),
    GetArenaNoVirtual());
  parent_.Swap(&other->parent_, &::google::protobuf::internal::GetEmptyStringAlreadyInited(),
    GetArenaNoVirtual());
  sink_.Swap(&other->sink_, &::google::protobuf::internal::GetEmptyStringAlreadyInited(),
    GetArenaNoVirtual());
  swap(fee_, other->fee_);
}

::google::protobuf::Metadata NEMSignTx_NEMProvisionNamespace::GetMetadata() const {
  ::google::protobuf::internal::AssignDescriptors(&::assign_descriptors_table_messages_2dnem_2eproto);
  return ::file_level_metadata_messages_2dnem_2eproto[kIndexInFileMessages];
}


// ===================================================================

void NEMSignTx_NEMMosaicCreation_NEMMosaicDefinition::InitAsDefaultInstance() {
}
class NEMSignTx_NEMMosaicCreation_NEMMosaicDefinition::HasBitSetters {
 public:
  static void set_has_name(NEMSignTx_NEMMosaicCreation_NEMMosaicDefinition* msg) {
    msg->_has_bits_[0] |= 0x00000001u;
  }
  static void set_has_ticker(NEMSignTx_NEMMosaicCreation_NEMMosaicDefinition* msg) {
    msg->_has_bits_[0] |= 0x00000002u;
  }
  static void set_has_namespace_(NEMSignTx_NEMMosaicCreation_NEMMosaicDefinition* msg) {
    msg->_has_bits_[0] |= 0x00000004u;
  }
  static void set_has_mosaic(NEMSignTx_NEMMosaicCreation_NEMMosaicDefinition* msg) {
    msg->_has_bits_[0] |= 0x00000008u;
  }
  static void set_has_divisibility(NEMSignTx_NEMMosaicCreation_NEMMosaicDefinition* msg) {
    msg->_has_bits_[0] |= 0x00000200u;
  }
  static void set_has_levy(NEMSignTx_NEMMosaicCreation_NEMMosaicDefinition* msg) {
    msg->_has_bits_[0] |= 0x00002000u;
  }
  static void set_has_fee(NEMSignTx_NEMMosaicCreation_NEMMosaicDefinition* msg) {
    msg->_has_bits_[0] |= 0x00000100u;
  }
  static void set_has_levy_address(NEMSignTx_NEMMosaicCreation_NEMMosaicDefinition* msg) {
    msg->_has_bits_[0] |= 0x00000010u;
  }
  static void set_has_levy_namespace(NEMSignTx_NEMMosaicCreation_NEMMosaicDefinition* msg) {
    msg->_has_bits_[0] |= 0x00000020u;
  }
  static void set_has_levy_mosaic(NEMSignTx_NEMMosaicCreation_NEMMosaicDefinition* msg) {
    msg->_has_bits_[0] |= 0x00000040u;
  }
  static void set_has_supply(NEMSignTx_NEMMosaicCreation_NEMMosaicDefinition* msg) {
    msg->_has_bits_[0] |= 0x00001000u;
  }
  static void set_has_mutable_supply(NEMSignTx_NEMMosaicCreation_NEMMosaicDefinition* msg) {
    msg->_has_bits_[0] |= 0x00000400u;
  }
  static void set_has_transferable(NEMSignTx_NEMMosaicCreation_NEMMosaicDefinition* msg) {
    msg->_has_bits_[0] |= 0x00000800u;
  }
  static void set_has_description(NEMSignTx_NEMMosaicCreation_NEMMosaicDefinition* msg) {
    msg->_has_bits_[0] |= 0x00000080u;
  }
};

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int NEMSignTx_NEMMosaicCreation_NEMMosaicDefinition::kNameFieldNumber;
const int NEMSignTx_NEMMosaicCreation_NEMMosaicDefinition::kTickerFieldNumber;
const int NEMSignTx_NEMMosaicCreation_NEMMosaicDefinition::kNamespaceFieldNumber;
const int NEMSignTx_NEMMosaicCreation_NEMMosaicDefinition::kMosaicFieldNumber;
const int NEMSignTx_NEMMosaicCreation_NEMMosaicDefinition::kDivisibilityFieldNumber;
const int NEMSignTx_NEMMosaicCreation_NEMMosaicDefinition::kLevyFieldNumber;
const int NEMSignTx_NEMMosaicCreation_NEMMosaicDefinition::kFeeFieldNumber;
const int NEMSignTx_NEMMosaicCreation_NEMMosaicDefinition::kLevyAddressFieldNumber;
const int NEMSignTx_NEMMosaicCreation_NEMMosaicDefinition::kLevyNamespaceFieldNumber;
const int NEMSignTx_NEMMosaicCreation_NEMMosaicDefinition::kLevyMosaicFieldNumber;
const int NEMSignTx_NEMMosaicCreation_NEMMosaicDefinition::kSupplyFieldNumber;
const int NEMSignTx_NEMMosaicCreation_NEMMosaicDefinition::kMutableSupplyFieldNumber;
const int NEMSignTx_NEMMosaicCreation_NEMMosaicDefinition::kTransferableFieldNumber;
const int NEMSignTx_NEMMosaicCreation_NEMMosaicDefinition::kDescriptionFieldNumber;
const int NEMSignTx_NEMMosaicCreation_NEMMosaicDefinition::kNetworksFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

NEMSignTx_NEMMosaicCreation_NEMMosaicDefinition::NEMSignTx_NEMMosaicCreation_NEMMosaicDefinition()
  : ::google::protobuf::Message(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:hw.trezor.messages.nem.NEMSignTx.NEMMosaicCreation.NEMMosaicDefinition)
}
NEMSignTx_NEMMosaicCreation_NEMMosaicDefinition::NEMSignTx_NEMMosaicCreation_NEMMosaicDefinition(const NEMSignTx_NEMMosaicCreation_NEMMosaicDefinition& from)
  : ::google::protobuf::Message(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_),
      networks_(from.networks_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  name_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (from.has_name()) {
    name_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.name_);
  }
  ticker_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (from.has_ticker()) {
    ticker_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.ticker_);
  }
  namespace__.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (from.has_namespace_()) {
    namespace__.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.namespace__);
  }
  mosaic_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (from.has_mosaic()) {
    mosaic_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.mosaic_);
  }
  levy_address_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (from.has_levy_address()) {
    levy_address_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.levy_address_);
  }
  levy_namespace_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (from.has_levy_namespace()) {
    levy_namespace_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.levy_namespace_);
  }
  levy_mosaic_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (from.has_levy_mosaic()) {
    levy_mosaic_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.levy_mosaic_);
  }
  description_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (from.has_description()) {
    description_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.description_);
  }
  ::memcpy(&fee_, &from.fee_,
    static_cast<size_t>(reinterpret_cast<char*>(&levy_) -
    reinterpret_cast<char*>(&fee_)) + sizeof(levy_));
  // @@protoc_insertion_point(copy_constructor:hw.trezor.messages.nem.NEMSignTx.NEMMosaicCreation.NEMMosaicDefinition)
}

void NEMSignTx_NEMMosaicCreation_NEMMosaicDefinition::SharedCtor() {
  ::google::protobuf::internal::InitSCC(
      &scc_info_NEMSignTx_NEMMosaicCreation_NEMMosaicDefinition_messages_2dnem_2eproto.base);
  name_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  ticker_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  namespace__.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  mosaic_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  levy_address_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  levy_namespace_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  levy_mosaic_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  description_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  ::memset(&fee_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&supply_) -
      reinterpret_cast<char*>(&fee_)) + sizeof(supply_));
  levy_ = 1;
}

NEMSignTx_NEMMosaicCreation_NEMMosaicDefinition::~NEMSignTx_NEMMosaicCreation_NEMMosaicDefinition() {
  // @@protoc_insertion_point(destructor:hw.trezor.messages.nem.NEMSignTx.NEMMosaicCreation.NEMMosaicDefinition)
  SharedDtor();
}

void NEMSignTx_NEMMosaicCreation_NEMMosaicDefinition::SharedDtor() {
  name_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  ticker_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  namespace__.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  mosaic_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  levy_address_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  levy_namespace_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  levy_mosaic_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  description_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}

void NEMSignTx_NEMMosaicCreation_NEMMosaicDefinition::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const NEMSignTx_NEMMosaicCreation_NEMMosaicDefinition& NEMSignTx_NEMMosaicCreation_NEMMosaicDefinition::default_instance() {
  ::google::protobuf::internal::InitSCC(&::scc_info_NEMSignTx_NEMMosaicCreation_NEMMosaicDefinition_messages_2dnem_2eproto.base);
  return *internal_default_instance();
}


void NEMSignTx_NEMMosaicCreation_NEMMosaicDefinition::Clear() {
// @@protoc_insertion_point(message_clear_start:hw.trezor.messages.nem.NEMSignTx.NEMMosaicCreation.NEMMosaicDefinition)
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  networks_.Clear();
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      name_.ClearNonDefaultToEmptyNoArena();
    }
    if (cached_has_bits & 0x00000002u) {
      ticker_.ClearNonDefaultToEmptyNoArena();
    }
    if (cached_has_bits & 0x00000004u) {
      namespace__.ClearNonDefaultToEmptyNoArena();
    }
    if (cached_has_bits & 0x00000008u) {
      mosaic_.ClearNonDefaultToEmptyNoArena();
    }
    if (cached_has_bits & 0x00000010u) {
      levy_address_.ClearNonDefaultToEmptyNoArena();
    }
    if (cached_has_bits & 0x00000020u) {
      levy_namespace_.ClearNonDefaultToEmptyNoArena();
    }
    if (cached_has_bits & 0x00000040u) {
      levy_mosaic_.ClearNonDefaultToEmptyNoArena();
    }
    if (cached_has_bits & 0x00000080u) {
      description_.ClearNonDefaultToEmptyNoArena();
    }
  }
  if (cached_has_bits & 0x00003f00u) {
    ::memset(&fee_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&supply_) -
        reinterpret_cast<char*>(&fee_)) + sizeof(supply_));
    levy_ = 1;
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* NEMSignTx_NEMMosaicCreation_NEMMosaicDefinition::_InternalParse(const char* begin, const char* end, void* object,
                  ::google::protobuf::internal::ParseContext* ctx) {
  auto msg = static_cast<NEMSignTx_NEMMosaicCreation_NEMMosaicDefinition*>(object);
  ::google::protobuf::int32 size; (void)size;
  int depth; (void)depth;
  ::google::protobuf::uint32 tag;
  ::google::protobuf::internal::ParseFunc parser_till_end; (void)parser_till_end;
  auto ptr = begin;
  while (ptr < end) {
    ptr = ::google::protobuf::io::Parse32(ptr, &tag);
    GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
    switch (tag >> 3) {
      // optional string name = 1;
      case 1: {
        if (static_cast<::google::protobuf::uint8>(tag) != 10) goto handle_unusual;
        ptr = ::google::protobuf::io::ReadSize(ptr, &size);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        ctx->extra_parse_data().SetFieldName("hw.trezor.messages.nem.NEMSignTx.NEMMosaicCreation.NEMMosaicDefinition.name");
        object = msg->mutable_name();
        if (size > end - ptr + ::google::protobuf::internal::ParseContext::kSlopBytes) {
          parser_till_end = ::google::protobuf::internal::GreedyStringParserUTF8Verify;
          goto string_till_end;
        }
        GOOGLE_PROTOBUF_PARSER_ASSERT(::google::protobuf::internal::StringCheckUTF8Verify(ptr, size, ctx));
        ::google::protobuf::internal::InlineGreedyStringParser(object, ptr, size, ctx);
        ptr += size;
        break;
      }
      // optional string ticker = 2;
      case 2: {
        if (static_cast<::google::protobuf::uint8>(tag) != 18) goto handle_unusual;
        ptr = ::google::protobuf::io::ReadSize(ptr, &size);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        ctx->extra_parse_data().SetFieldName("hw.trezor.messages.nem.NEMSignTx.NEMMosaicCreation.NEMMosaicDefinition.ticker");
        object = msg->mutable_ticker();
        if (size > end - ptr + ::google::protobuf::internal::ParseContext::kSlopBytes) {
          parser_till_end = ::google::protobuf::internal::GreedyStringParserUTF8Verify;
          goto string_till_end;
        }
        GOOGLE_PROTOBUF_PARSER_ASSERT(::google::protobuf::internal::StringCheckUTF8Verify(ptr, size, ctx));
        ::google::protobuf::internal::InlineGreedyStringParser(object, ptr, size, ctx);
        ptr += size;
        break;
      }
      // optional string namespace = 3;
      case 3: {
        if (static_cast<::google::protobuf::uint8>(tag) != 26) goto handle_unusual;
        ptr = ::google::protobuf::io::ReadSize(ptr, &size);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        ctx->extra_parse_data().SetFieldName("hw.trezor.messages.nem.NEMSignTx.NEMMosaicCreation.NEMMosaicDefinition.namespace");
        object = msg->mutable_namespace_();
        if (size > end - ptr + ::google::protobuf::internal::ParseContext::kSlopBytes) {
          parser_till_end = ::google::protobuf::internal::GreedyStringParserUTF8Verify;
          goto string_till_end;
        }
        GOOGLE_PROTOBUF_PARSER_ASSERT(::google::protobuf::internal::StringCheckUTF8Verify(ptr, size, ctx));
        ::google::protobuf::internal::InlineGreedyStringParser(object, ptr, size, ctx);
        ptr += size;
        break;
      }
      // optional string mosaic = 4;
      case 4: {
        if (static_cast<::google::protobuf::uint8>(tag) != 34) goto handle_unusual;
        ptr = ::google::protobuf::io::ReadSize(ptr, &size);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        ctx->extra_parse_data().SetFieldName("hw.trezor.messages.nem.NEMSignTx.NEMMosaicCreation.NEMMosaicDefinition.mosaic");
        object = msg->mutable_mosaic();
        if (size > end - ptr + ::google::protobuf::internal::ParseContext::kSlopBytes) {
          parser_till_end = ::google::protobuf::internal::GreedyStringParserUTF8Verify;
          goto string_till_end;
        }
        GOOGLE_PROTOBUF_PARSER_ASSERT(::google::protobuf::internal::StringCheckUTF8Verify(ptr, size, ctx));
        ::google::protobuf::internal::InlineGreedyStringParser(object, ptr, size, ctx);
        ptr += size;
        break;
      }
      // optional uint32 divisibility = 5;
      case 5: {
        if (static_cast<::google::protobuf::uint8>(tag) != 40) goto handle_unusual;
        msg->set_divisibility(::google::protobuf::internal::ReadVarint(&ptr));
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        break;
      }
      // optional .hw.trezor.messages.nem.NEMSignTx.NEMMosaicCreation.NEMMosaicDefinition.NEMMosaicLevy levy = 6;
      case 6: {
        if (static_cast<::google::protobuf::uint8>(tag) != 48) goto handle_unusual;
        ::google::protobuf::uint64 val = ::google::protobuf::internal::ReadVarint(&ptr);
        if (!::hw::trezor::messages::nem::NEMSignTx_NEMMosaicCreation_NEMMosaicDefinition_NEMMosaicLevy_IsValid(val)) {
          ::google::protobuf::internal::WriteVarint(6, val, msg->mutable_unknown_fields());
          break;
        }
        msg->set_levy(static_cast<::hw::trezor::messages::nem::NEMSignTx_NEMMosaicCreation_NEMMosaicDefinition_NEMMosaicLevy>(val));
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        break;
      }
      // optional uint64 fee = 7;
      case 7: {
        if (static_cast<::google::protobuf::uint8>(tag) != 56) goto handle_unusual;
        msg->set_fee(::google::protobuf::internal::ReadVarint(&ptr));
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        break;
      }
      // optional string levy_address = 8;
      case 8: {
        if (static_cast<::google::protobuf::uint8>(tag) != 66) goto handle_unusual;
        ptr = ::google::protobuf::io::ReadSize(ptr, &size);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        ctx->extra_parse_data().SetFieldName("hw.trezor.messages.nem.NEMSignTx.NEMMosaicCreation.NEMMosaicDefinition.levy_address");
        object = msg->mutable_levy_address();
        if (size > end - ptr + ::google::protobuf::internal::ParseContext::kSlopBytes) {
          parser_till_end = ::google::protobuf::internal::GreedyStringParserUTF8Verify;
          goto string_till_end;
        }
        GOOGLE_PROTOBUF_PARSER_ASSERT(::google::protobuf::internal::StringCheckUTF8Verify(ptr, size, ctx));
        ::google::protobuf::internal::InlineGreedyStringParser(object, ptr, size, ctx);
        ptr += size;
        break;
      }
      // optional string levy_namespace = 9;
      case 9: {
        if (static_cast<::google::protobuf::uint8>(tag) != 74) goto handle_unusual;
        ptr = ::google::protobuf::io::ReadSize(ptr, &size);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        ctx->extra_parse_data().SetFieldName("hw.trezor.messages.nem.NEMSignTx.NEMMosaicCreation.NEMMosaicDefinition.levy_namespace");
        object = msg->mutable_levy_namespace();
        if (size > end - ptr + ::google::protobuf::internal::ParseContext::kSlopBytes) {
          parser_till_end = ::google::protobuf::internal::GreedyStringParserUTF8Verify;
          goto string_till_end;
        }
        GOOGLE_PROTOBUF_PARSER_ASSERT(::google::protobuf::internal::StringCheckUTF8Verify(ptr, size, ctx));
        ::google::protobuf::internal::InlineGreedyStringParser(object, ptr, size, ctx);
        ptr += size;
        break;
      }
      // optional string levy_mosaic = 10;
      case 10: {
        if (static_cast<::google::protobuf::uint8>(tag) != 82) goto handle_unusual;
        ptr = ::google::protobuf::io::ReadSize(ptr, &size);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        ctx->extra_parse_data().SetFieldName("hw.trezor.messages.nem.NEMSignTx.NEMMosaicCreation.NEMMosaicDefinition.levy_mosaic");
        object = msg->mutable_levy_mosaic();
        if (size > end - ptr + ::google::protobuf::internal::ParseContext::kSlopBytes) {
          parser_till_end = ::google::protobuf::internal::GreedyStringParserUTF8Verify;
          goto string_till_end;
        }
        GOOGLE_PROTOBUF_PARSER_ASSERT(::google::protobuf::internal::StringCheckUTF8Verify(ptr, size, ctx));
        ::google::protobuf::internal::InlineGreedyStringParser(object, ptr, size, ctx);
        ptr += size;
        break;
      }
      // optional uint64 supply = 11;
      case 11: {
        if (static_cast<::google::protobuf::uint8>(tag) != 88) goto handle_unusual;
        msg->set_supply(::google::protobuf::internal::ReadVarint(&ptr));
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        break;
      }
      // optional bool mutable_supply = 12;
      case 12: {
        if (static_cast<::google::protobuf::uint8>(tag) != 96) goto handle_unusual;
        msg->set_mutable_supply(::google::protobuf::internal::ReadVarint(&ptr));
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        break;
      }
      // optional bool transferable = 13;
      case 13: {
        if (static_cast<::google::protobuf::uint8>(tag) != 104) goto handle_unusual;
        msg->set_transferable(::google::protobuf::internal::ReadVarint(&ptr));
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        break;
      }
      // optional string description = 14;
      case 14: {
        if (static_cast<::google::protobuf::uint8>(tag) != 114) goto handle_unusual;
        ptr = ::google::protobuf::io::ReadSize(ptr, &size);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        ctx->extra_parse_data().SetFieldName("hw.trezor.messages.nem.NEMSignTx.NEMMosaicCreation.NEMMosaicDefinition.description");
        object = msg->mutable_description();
        if (size > end - ptr + ::google::protobuf::internal::ParseContext::kSlopBytes) {
          parser_till_end = ::google::protobuf::internal::GreedyStringParserUTF8Verify;
          goto string_till_end;
        }
        GOOGLE_PROTOBUF_PARSER_ASSERT(::google::protobuf::internal::StringCheckUTF8Verify(ptr, size, ctx));
        ::google::protobuf::internal::InlineGreedyStringParser(object, ptr, size, ctx);
        ptr += size;
        break;
      }
      // repeated uint32 networks = 15;
      case 15: {
        if (static_cast<::google::protobuf::uint8>(tag) == 120) {
          do {
            msg->add_networks(::google::protobuf::internal::ReadVarint(&ptr));
            GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
            if (ptr >= end) break;
          } while ((::google::protobuf::io::UnalignedLoad<::google::protobuf::uint64>(ptr) & 255) == 120 && (ptr += 1));
          break;
        } else if (static_cast<::google::protobuf::uint8>(tag) != 122) goto handle_unusual;
        ptr = ::google::protobuf::io::ReadSize(ptr, &size);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        parser_till_end = ::google::protobuf::internal::PackedUInt32Parser;
        object = msg->mutable_networks();
        if (size > end - ptr) goto len_delim_till_end;
        auto newend = ptr + size;
        if (size) ptr = parser_till_end(ptr, newend, object, ctx);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr == newend);
        break;
      }
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->EndGroup(tag);
          return ptr;
        }
        auto res = UnknownFieldParse(tag, {_InternalParse, msg},
          ptr, end, msg->_internal_metadata_.mutable_unknown_fields(), ctx);
        ptr = res.first;
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr != nullptr);
        if (res.second) return ptr;
      }
    }  // switch
  }  // while
  return ptr;
string_till_end:
  static_cast<::std::string*>(object)->clear();
  static_cast<::std::string*>(object)->reserve(size);
  goto len_delim_till_end;
len_delim_till_end:
  return ctx->StoreAndTailCall(ptr, end, {_InternalParse, msg},
                               {parser_till_end, object}, size);
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool NEMSignTx_NEMMosaicCreation_NEMMosaicDefinition::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:hw.trezor.messages.nem.NEMSignTx.NEMMosaicCreation.NEMMosaicDefinition)
  for (;;) {
    ::std::pair<::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional string name = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (10 & 0xFF)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_name()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->name().data(), static_cast<int>(this->name().length()),
            ::google::protobuf::internal::WireFormat::PARSE,
            "hw.trezor.messages.nem.NEMSignTx.NEMMosaicCreation.NEMMosaicDefinition.name");
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional string ticker = 2;
      case 2: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (18 & 0xFF)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_ticker()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->ticker().data(), static_cast<int>(this->ticker().length()),
            ::google::protobuf::internal::WireFormat::PARSE,
            "hw.trezor.messages.nem.NEMSignTx.NEMMosaicCreation.NEMMosaicDefinition.ticker");
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional string namespace = 3;
      case 3: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (26 & 0xFF)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_namespace_()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->namespace_().data(), static_cast<int>(this->namespace_().length()),
            ::google::protobuf::internal::WireFormat::PARSE,
            "hw.trezor.messages.nem.NEMSignTx.NEMMosaicCreation.NEMMosaicDefinition.namespace");
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional string mosaic = 4;
      case 4: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (34 & 0xFF)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_mosaic()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->mosaic().data(), static_cast<int>(this->mosaic().length()),
            ::google::protobuf::internal::WireFormat::PARSE,
            "hw.trezor.messages.nem.NEMSignTx.NEMMosaicCreation.NEMMosaicDefinition.mosaic");
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional uint32 divisibility = 5;
      case 5: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (40 & 0xFF)) {
          HasBitSetters::set_has_divisibility(this);
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &divisibility_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional .hw.trezor.messages.nem.NEMSignTx.NEMMosaicCreation.NEMMosaicDefinition.NEMMosaicLevy levy = 6;
      case 6: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (48 & 0xFF)) {
          int value = 0;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::hw::trezor::messages::nem::NEMSignTx_NEMMosaicCreation_NEMMosaicDefinition_NEMMosaicLevy_IsValid(value)) {
            set_levy(static_cast< ::hw::trezor::messages::nem::NEMSignTx_NEMMosaicCreation_NEMMosaicDefinition_NEMMosaicLevy >(value));
          } else {
            mutable_unknown_fields()->AddVarint(
                6, static_cast<::google::protobuf::uint64>(value));
          }
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional uint64 fee = 7;
      case 7: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (56 & 0xFF)) {
          HasBitSetters::set_has_fee(this);
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &fee_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional string levy_address = 8;
      case 8: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (66 & 0xFF)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_levy_address()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->levy_address().data(), static_cast<int>(this->levy_address().length()),
            ::google::protobuf::internal::WireFormat::PARSE,
            "hw.trezor.messages.nem.NEMSignTx.NEMMosaicCreation.NEMMosaicDefinition.levy_address");
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional string levy_namespace = 9;
      case 9: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (74 & 0xFF)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_levy_namespace()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->levy_namespace().data(), static_cast<int>(this->levy_namespace().length()),
            ::google::protobuf::internal::WireFormat::PARSE,
            "hw.trezor.messages.nem.NEMSignTx.NEMMosaicCreation.NEMMosaicDefinition.levy_namespace");
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional string levy_mosaic = 10;
      case 10: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (82 & 0xFF)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_levy_mosaic()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->levy_mosaic().data(), static_cast<int>(this->levy_mosaic().length()),
            ::google::protobuf::internal::WireFormat::PARSE,
            "hw.trezor.messages.nem.NEMSignTx.NEMMosaicCreation.NEMMosaicDefinition.levy_mosaic");
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional uint64 supply = 11;
      case 11: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (88 & 0xFF)) {
          HasBitSetters::set_has_supply(this);
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &supply_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional bool mutable_supply = 12;
      case 12: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (96 & 0xFF)) {
          HasBitSetters::set_has_mutable_supply(this);
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &mutable_supply_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional bool transferable = 13;
      case 13: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (104 & 0xFF)) {
          HasBitSetters::set_has_transferable(this);
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &transferable_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional string description = 14;
      case 14: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (114 & 0xFF)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_description()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->description().data(), static_cast<int>(this->description().length()),
            ::google::protobuf::internal::WireFormat::PARSE,
            "hw.trezor.messages.nem.NEMSignTx.NEMMosaicCreation.NEMMosaicDefinition.description");
        } else {
          goto handle_unusual;
        }
        break;
      }

      // repeated uint32 networks = 15;
      case 15: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (120 & 0xFF)) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadRepeatedPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 1, 120u, input, this->mutable_networks())));
        } else if (static_cast< ::google::protobuf::uint8>(tag) == (122 & 0xFF)) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPackedPrimitiveNoInline<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, this->mutable_networks())));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, _internal_metadata_.mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:hw.trezor.messages.nem.NEMSignTx.NEMMosaicCreation.NEMMosaicDefinition)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:hw.trezor.messages.nem.NEMSignTx.NEMMosaicCreation.NEMMosaicDefinition)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void NEMSignTx_NEMMosaicCreation_NEMMosaicDefinition::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:hw.trezor.messages.nem.NEMSignTx.NEMMosaicCreation.NEMMosaicDefinition)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional string name = 1;
  if (cached_has_bits & 0x00000001u) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->name().data(), static_cast<int>(this->name().length()),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "hw.trezor.messages.nem.NEMSignTx.NEMMosaicCreation.NEMMosaicDefinition.name");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      1, this->name(), output);
  }

  // optional string ticker = 2;
  if (cached_has_bits & 0x00000002u) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->ticker().data(), static_cast<int>(this->ticker().length()),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "hw.trezor.messages.nem.NEMSignTx.NEMMosaicCreation.NEMMosaicDefinition.ticker");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      2, this->ticker(), output);
  }

  // optional string namespace = 3;
  if (cached_has_bits & 0x00000004u) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->namespace_().data(), static_cast<int>(this->namespace_().length()),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "hw.trezor.messages.nem.NEMSignTx.NEMMosaicCreation.NEMMosaicDefinition.namespace");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      3, this->namespace_(), output);
  }

  // optional string mosaic = 4;
  if (cached_has_bits & 0x00000008u) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->mosaic().data(), static_cast<int>(this->mosaic().length()),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "hw.trezor.messages.nem.NEMSignTx.NEMMosaicCreation.NEMMosaicDefinition.mosaic");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      4, this->mosaic(), output);
  }

  // optional uint32 divisibility = 5;
  if (cached_has_bits & 0x00000200u) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(5, this->divisibility(), output);
  }

  // optional .hw.trezor.messages.nem.NEMSignTx.NEMMosaicCreation.NEMMosaicDefinition.NEMMosaicLevy levy = 6;
  if (cached_has_bits & 0x00002000u) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      6, this->levy(), output);
  }

  // optional uint64 fee = 7;
  if (cached_has_bits & 0x00000100u) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(7, this->fee(), output);
  }

  // optional string levy_address = 8;
  if (cached_has_bits & 0x00000010u) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->levy_address().data(), static_cast<int>(this->levy_address().length()),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "hw.trezor.messages.nem.NEMSignTx.NEMMosaicCreation.NEMMosaicDefinition.levy_address");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      8, this->levy_address(), output);
  }

  // optional string levy_namespace = 9;
  if (cached_has_bits & 0x00000020u) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->levy_namespace().data(), static_cast<int>(this->levy_namespace().length()),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "hw.trezor.messages.nem.NEMSignTx.NEMMosaicCreation.NEMMosaicDefinition.levy_namespace");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      9, this->levy_namespace(), output);
  }

  // optional string levy_mosaic = 10;
  if (cached_has_bits & 0x00000040u) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->levy_mosaic().data(), static_cast<int>(this->levy_mosaic().length()),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "hw.trezor.messages.nem.NEMSignTx.NEMMosaicCreation.NEMMosaicDefinition.levy_mosaic");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      10, this->levy_mosaic(), output);
  }

  // optional uint64 supply = 11;
  if (cached_has_bits & 0x00001000u) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(11, this->supply(), output);
  }

  // optional bool mutable_supply = 12;
  if (cached_has_bits & 0x00000400u) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(12, this->mutable_supply(), output);
  }

  // optional bool transferable = 13;
  if (cached_has_bits & 0x00000800u) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(13, this->transferable(), output);
  }

  // optional string description = 14;
  if (cached_has_bits & 0x00000080u) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->description().data(), static_cast<int>(this->description().length()),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "hw.trezor.messages.nem.NEMSignTx.NEMMosaicCreation.NEMMosaicDefinition.description");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      14, this->description(), output);
  }

  // repeated uint32 networks = 15;
  for (int i = 0, n = this->networks_size(); i < n; i++) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(
      15, this->networks(i), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        _internal_metadata_.unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:hw.trezor.messages.nem.NEMSignTx.NEMMosaicCreation.NEMMosaicDefinition)
}

::google::protobuf::uint8* NEMSignTx_NEMMosaicCreation_NEMMosaicDefinition::InternalSerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:hw.trezor.messages.nem.NEMSignTx.NEMMosaicCreation.NEMMosaicDefinition)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional string name = 1;
  if (cached_has_bits & 0x00000001u) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->name().data(), static_cast<int>(this->name().length()),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "hw.trezor.messages.nem.NEMSignTx.NEMMosaicCreation.NEMMosaicDefinition.name");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        1, this->name(), target);
  }

  // optional string ticker = 2;
  if (cached_has_bits & 0x00000002u) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->ticker().data(), static_cast<int>(this->ticker().length()),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "hw.trezor.messages.nem.NEMSignTx.NEMMosaicCreation.NEMMosaicDefinition.ticker");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        2, this->ticker(), target);
  }

  // optional string namespace = 3;
  if (cached_has_bits & 0x00000004u) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->namespace_().data(), static_cast<int>(this->namespace_().length()),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "hw.trezor.messages.nem.NEMSignTx.NEMMosaicCreation.NEMMosaicDefinition.namespace");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        3, this->namespace_(), target);
  }

  // optional string mosaic = 4;
  if (cached_has_bits & 0x00000008u) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->mosaic().data(), static_cast<int>(this->mosaic().length()),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "hw.trezor.messages.nem.NEMSignTx.NEMMosaicCreation.NEMMosaicDefinition.mosaic");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        4, this->mosaic(), target);
  }

  // optional uint32 divisibility = 5;
  if (cached_has_bits & 0x00000200u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(5, this->divisibility(), target);
  }

  // optional .hw.trezor.messages.nem.NEMSignTx.NEMMosaicCreation.NEMMosaicDefinition.NEMMosaicLevy levy = 6;
  if (cached_has_bits & 0x00002000u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      6, this->levy(), target);
  }

  // optional uint64 fee = 7;
  if (cached_has_bits & 0x00000100u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt64ToArray(7, this->fee(), target);
  }

  // optional string levy_address = 8;
  if (cached_has_bits & 0x00000010u) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->levy_address().data(), static_cast<int>(this->levy_address().length()),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "hw.trezor.messages.nem.NEMSignTx.NEMMosaicCreation.NEMMosaicDefinition.levy_address");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        8, this->levy_address(), target);
  }

  // optional string levy_namespace = 9;
  if (cached_has_bits & 0x00000020u) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->levy_namespace().data(), static_cast<int>(this->levy_namespace().length()),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "hw.trezor.messages.nem.NEMSignTx.NEMMosaicCreation.NEMMosaicDefinition.levy_namespace");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        9, this->levy_namespace(), target);
  }

  // optional string levy_mosaic = 10;
  if (cached_has_bits & 0x00000040u) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->levy_mosaic().data(), static_cast<int>(this->levy_mosaic().length()),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "hw.trezor.messages.nem.NEMSignTx.NEMMosaicCreation.NEMMosaicDefinition.levy_mosaic");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        10, this->levy_mosaic(), target);
  }

  // optional uint64 supply = 11;
  if (cached_has_bits & 0x00001000u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt64ToArray(11, this->supply(), target);
  }

  // optional bool mutable_supply = 12;
  if (cached_has_bits & 0x00000400u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteBoolToArray(12, this->mutable_supply(), target);
  }

  // optional bool transferable = 13;
  if (cached_has_bits & 0x00000800u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteBoolToArray(13, this->transferable(), target);
  }

  // optional string description = 14;
  if (cached_has_bits & 0x00000080u) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->description().data(), static_cast<int>(this->description().length()),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "hw.trezor.messages.nem.NEMSignTx.NEMMosaicCreation.NEMMosaicDefinition.description");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        14, this->description(), target);
  }

  // repeated uint32 networks = 15;
  target = ::google::protobuf::internal::WireFormatLite::
    WriteUInt32ToArray(15, this->networks_, target);

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:hw.trezor.messages.nem.NEMSignTx.NEMMosaicCreation.NEMMosaicDefinition)
  return target;
}

size_t NEMSignTx_NEMMosaicCreation_NEMMosaicDefinition::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:hw.trezor.messages.nem.NEMSignTx.NEMMosaicCreation.NEMMosaicDefinition)
  size_t total_size = 0;

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        _internal_metadata_.unknown_fields());
  }
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated uint32 networks = 15;
  {
    size_t data_size = ::google::protobuf::internal::WireFormatLite::
      UInt32Size(this->networks_);
    total_size += 1 *
                  ::google::protobuf::internal::FromIntSize(this->networks_size());
    total_size += data_size;
  }

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    // optional string name = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->name());
    }

    // optional string ticker = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->ticker());
    }

    // optional string namespace = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->namespace_());
    }

    // optional string mosaic = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->mosaic());
    }

    // optional string levy_address = 8;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->levy_address());
    }

    // optional string levy_namespace = 9;
    if (cached_has_bits & 0x00000020u) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->levy_namespace());
    }

    // optional string levy_mosaic = 10;
    if (cached_has_bits & 0x00000040u) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->levy_mosaic());
    }

    // optional string description = 14;
    if (cached_has_bits & 0x00000080u) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->description());
    }

  }
  if (cached_has_bits & 0x00003f00u) {
    // optional uint64 fee = 7;
    if (cached_has_bits & 0x00000100u) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->fee());
    }

    // optional uint32 divisibility = 5;
    if (cached_has_bits & 0x00000200u) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->divisibility());
    }

    // optional bool mutable_supply = 12;
    if (cached_has_bits & 0x00000400u) {
      total_size += 1 + 1;
    }

    // optional bool transferable = 13;
    if (cached_has_bits & 0x00000800u) {
      total_size += 1 + 1;
    }

    // optional uint64 supply = 11;
    if (cached_has_bits & 0x00001000u) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->supply());
    }

    // optional .hw.trezor.messages.nem.NEMSignTx.NEMMosaicCreation.NEMMosaicDefinition.NEMMosaicLevy levy = 6;
    if (cached_has_bits & 0x00002000u) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->levy());
    }

  }
  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void NEMSignTx_NEMMosaicCreation_NEMMosaicDefinition::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:hw.trezor.messages.nem.NEMSignTx.NEMMosaicCreation.NEMMosaicDefinition)
  GOOGLE_DCHECK_NE(&from, this);
  const NEMSignTx_NEMMosaicCreation_NEMMosaicDefinition* source =
      ::google::protobuf::DynamicCastToGenerated<NEMSignTx_NEMMosaicCreation_NEMMosaicDefinition>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:hw.trezor.messages.nem.NEMSignTx.NEMMosaicCreation.NEMMosaicDefinition)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:hw.trezor.messages.nem.NEMSignTx.NEMMosaicCreation.NEMMosaicDefinition)
    MergeFrom(*source);
  }
}

void NEMSignTx_NEMMosaicCreation_NEMMosaicDefinition::MergeFrom(const NEMSignTx_NEMMosaicCreation_NEMMosaicDefinition& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:hw.trezor.messages.nem.NEMSignTx.NEMMosaicCreation.NEMMosaicDefinition)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  networks_.MergeFrom(from.networks_);
  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      _has_bits_[0] |= 0x00000001u;
      name_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.name_);
    }
    if (cached_has_bits & 0x00000002u) {
      _has_bits_[0] |= 0x00000002u;
      ticker_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.ticker_);
    }
    if (cached_has_bits & 0x00000004u) {
      _has_bits_[0] |= 0x00000004u;
      namespace__.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.namespace__);
    }
    if (cached_has_bits & 0x00000008u) {
      _has_bits_[0] |= 0x00000008u;
      mosaic_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.mosaic_);
    }
    if (cached_has_bits & 0x00000010u) {
      _has_bits_[0] |= 0x00000010u;
      levy_address_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.levy_address_);
    }
    if (cached_has_bits & 0x00000020u) {
      _has_bits_[0] |= 0x00000020u;
      levy_namespace_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.levy_namespace_);
    }
    if (cached_has_bits & 0x00000040u) {
      _has_bits_[0] |= 0x00000040u;
      levy_mosaic_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.levy_mosaic_);
    }
    if (cached_has_bits & 0x00000080u) {
      _has_bits_[0] |= 0x00000080u;
      description_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.description_);
    }
  }
  if (cached_has_bits & 0x00003f00u) {
    if (cached_has_bits & 0x00000100u) {
      fee_ = from.fee_;
    }
    if (cached_has_bits & 0x00000200u) {
      divisibility_ = from.divisibility_;
    }
    if (cached_has_bits & 0x00000400u) {
      mutable_supply_ = from.mutable_supply_;
    }
    if (cached_has_bits & 0x00000800u) {
      transferable_ = from.transferable_;
    }
    if (cached_has_bits & 0x00001000u) {
      supply_ = from.supply_;
    }
    if (cached_has_bits & 0x00002000u) {
      levy_ = from.levy_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void NEMSignTx_NEMMosaicCreation_NEMMosaicDefinition::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:hw.trezor.messages.nem.NEMSignTx.NEMMosaicCreation.NEMMosaicDefinition)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void NEMSignTx_NEMMosaicCreation_NEMMosaicDefinition::CopyFrom(const NEMSignTx_NEMMosaicCreation_NEMMosaicDefinition& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:hw.trezor.messages.nem.NEMSignTx.NEMMosaicCreation.NEMMosaicDefinition)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool NEMSignTx_NEMMosaicCreation_NEMMosaicDefinition::IsInitialized() const {
  return true;
}

void NEMSignTx_NEMMosaicCreation_NEMMosaicDefinition::Swap(NEMSignTx_NEMMosaicCreation_NEMMosaicDefinition* other) {
  if (other == this) return;
  InternalSwap(other);
}
void NEMSignTx_NEMMosaicCreation_NEMMosaicDefinition::InternalSwap(NEMSignTx_NEMMosaicCreation_NEMMosaicDefinition* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  networks_.InternalSwap(&other->networks_);
  name_.Swap(&other->name_, &::google::protobuf::internal::GetEmptyStringAlreadyInited(),
    GetArenaNoVirtual());
  ticker_.Swap(&other->ticker_, &::google::protobuf::internal::GetEmptyStringAlreadyInited(),
    GetArenaNoVirtual());
  namespace__.Swap(&other->namespace__, &::google::protobuf::internal::GetEmptyStringAlreadyInited(),
    GetArenaNoVirtual());
  mosaic_.Swap(&other->mosaic_, &::google::protobuf::internal::GetEmptyStringAlreadyInited(),
    GetArenaNoVirtual());
  levy_address_.Swap(&other->levy_address_, &::google::protobuf::internal::GetEmptyStringAlreadyInited(),
    GetArenaNoVirtual());
  levy_namespace_.Swap(&other->levy_namespace_, &::google::protobuf::internal::GetEmptyStringAlreadyInited(),
    GetArenaNoVirtual());
  levy_mosaic_.Swap(&other->levy_mosaic_, &::google::protobuf::internal::GetEmptyStringAlreadyInited(),
    GetArenaNoVirtual());
  description_.Swap(&other->description_, &::google::protobuf::internal::GetEmptyStringAlreadyInited(),
    GetArenaNoVirtual());
  swap(fee_, other->fee_);
  swap(divisibility_, other->divisibility_);
  swap(mutable_supply_, other->mutable_supply_);
  swap(transferable_, other->transferable_);
  swap(supply_, other->supply_);
  swap(levy_, other->levy_);
}

::google::protobuf::Metadata NEMSignTx_NEMMosaicCreation_NEMMosaicDefinition::GetMetadata() const {
  ::google::protobuf::internal::AssignDescriptors(&::assign_descriptors_table_messages_2dnem_2eproto);
  return ::file_level_metadata_messages_2dnem_2eproto[kIndexInFileMessages];
}


// ===================================================================

void NEMSignTx_NEMMosaicCreation::InitAsDefaultInstance() {
  ::hw::trezor::messages::nem::_NEMSignTx_NEMMosaicCreation_default_instance_._instance.get_mutable()->definition_ = const_cast< ::hw::trezor::messages::nem::NEMSignTx_NEMMosaicCreation_NEMMosaicDefinition*>(
      ::hw::trezor::messages::nem::NEMSignTx_NEMMosaicCreation_NEMMosaicDefinition::internal_default_instance());
}
class NEMSignTx_NEMMosaicCreation::HasBitSetters {
 public:
  static const ::hw::trezor::messages::nem::NEMSignTx_NEMMosaicCreation_NEMMosaicDefinition& definition(const NEMSignTx_NEMMosaicCreation* msg);
  static void set_has_definition(NEMSignTx_NEMMosaicCreation* msg) {
    msg->_has_bits_[0] |= 0x00000002u;
  }
  static void set_has_sink(NEMSignTx_NEMMosaicCreation* msg) {
    msg->_has_bits_[0] |= 0x00000001u;
  }
  static void set_has_fee(NEMSignTx_NEMMosaicCreation* msg) {
    msg->_has_bits_[0] |= 0x00000004u;
  }
};

const ::hw::trezor::messages::nem::NEMSignTx_NEMMosaicCreation_NEMMosaicDefinition&
NEMSignTx_NEMMosaicCreation::HasBitSetters::definition(const NEMSignTx_NEMMosaicCreation* msg) {
  return *msg->definition_;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int NEMSignTx_NEMMosaicCreation::kDefinitionFieldNumber;
const int NEMSignTx_NEMMosaicCreation::kSinkFieldNumber;
const int NEMSignTx_NEMMosaicCreation::kFeeFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

NEMSignTx_NEMMosaicCreation::NEMSignTx_NEMMosaicCreation()
  : ::google::protobuf::Message(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:hw.trezor.messages.nem.NEMSignTx.NEMMosaicCreation)
}
NEMSignTx_NEMMosaicCreation::NEMSignTx_NEMMosaicCreation(const NEMSignTx_NEMMosaicCreation& from)
  : ::google::protobuf::Message(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  sink_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (from.has_sink()) {
    sink_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.sink_);
  }
  if (from.has_definition()) {
    definition_ = new ::hw::trezor::messages::nem::NEMSignTx_NEMMosaicCreation_NEMMosaicDefinition(*from.definition_);
  } else {
    definition_ = nullptr;
  }
  fee_ = from.fee_;
  // @@protoc_insertion_point(copy_constructor:hw.trezor.messages.nem.NEMSignTx.NEMMosaicCreation)
}

void NEMSignTx_NEMMosaicCreation::SharedCtor() {
  ::google::protobuf::internal::InitSCC(
      &scc_info_NEMSignTx_NEMMosaicCreation_messages_2dnem_2eproto.base);
  sink_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  ::memset(&definition_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&fee_) -
      reinterpret_cast<char*>(&definition_)) + sizeof(fee_));
}

NEMSignTx_NEMMosaicCreation::~NEMSignTx_NEMMosaicCreation() {
  // @@protoc_insertion_point(destructor:hw.trezor.messages.nem.NEMSignTx.NEMMosaicCreation)
  SharedDtor();
}

void NEMSignTx_NEMMosaicCreation::SharedDtor() {
  sink_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (this != internal_default_instance()) delete definition_;
}

void NEMSignTx_NEMMosaicCreation::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const NEMSignTx_NEMMosaicCreation& NEMSignTx_NEMMosaicCreation::default_instance() {
  ::google::protobuf::internal::InitSCC(&::scc_info_NEMSignTx_NEMMosaicCreation_messages_2dnem_2eproto.base);
  return *internal_default_instance();
}


void NEMSignTx_NEMMosaicCreation::Clear() {
// @@protoc_insertion_point(message_clear_start:hw.trezor.messages.nem.NEMSignTx.NEMMosaicCreation)
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      sink_.ClearNonDefaultToEmptyNoArena();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(definition_ != nullptr);
      definition_->Clear();
    }
  }
  fee_ = PROTOBUF_ULONGLONG(0);
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* NEMSignTx_NEMMosaicCreation::_InternalParse(const char* begin, const char* end, void* object,
                  ::google::protobuf::internal::ParseContext* ctx) {
  auto msg = static_cast<NEMSignTx_NEMMosaicCreation*>(object);
  ::google::protobuf::int32 size; (void)size;
  int depth; (void)depth;
  ::google::protobuf::uint32 tag;
  ::google::protobuf::internal::ParseFunc parser_till_end; (void)parser_till_end;
  auto ptr = begin;
  while (ptr < end) {
    ptr = ::google::protobuf::io::Parse32(ptr, &tag);
    GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
    switch (tag >> 3) {
      // optional .hw.trezor.messages.nem.NEMSignTx.NEMMosaicCreation.NEMMosaicDefinition definition = 1;
      case 1: {
        if (static_cast<::google::protobuf::uint8>(tag) != 10) goto handle_unusual;
        ptr = ::google::protobuf::io::ReadSize(ptr, &size);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        parser_till_end = ::hw::trezor::messages::nem::NEMSignTx_NEMMosaicCreation_NEMMosaicDefinition::_InternalParse;
        object = msg->mutable_definition();
        if (size > end - ptr) goto len_delim_till_end;
        ptr += size;
        GOOGLE_PROTOBUF_PARSER_ASSERT(ctx->ParseExactRange(
            {parser_till_end, object}, ptr - size, ptr));
        break;
      }
      // optional string sink = 2;
      case 2: {
        if (static_cast<::google::protobuf::uint8>(tag) != 18) goto handle_unusual;
        ptr = ::google::protobuf::io::ReadSize(ptr, &size);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        ctx->extra_parse_data().SetFieldName("hw.trezor.messages.nem.NEMSignTx.NEMMosaicCreation.sink");
        object = msg->mutable_sink();
        if (size > end - ptr + ::google::protobuf::internal::ParseContext::kSlopBytes) {
          parser_till_end = ::google::protobuf::internal::GreedyStringParserUTF8Verify;
          goto string_till_end;
        }
        GOOGLE_PROTOBUF_PARSER_ASSERT(::google::protobuf::internal::StringCheckUTF8Verify(ptr, size, ctx));
        ::google::protobuf::internal::InlineGreedyStringParser(object, ptr, size, ctx);
        ptr += size;
        break;
      }
      // optional uint64 fee = 3;
      case 3: {
        if (static_cast<::google::protobuf::uint8>(tag) != 24) goto handle_unusual;
        msg->set_fee(::google::protobuf::internal::ReadVarint(&ptr));
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        break;
      }
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->EndGroup(tag);
          return ptr;
        }
        auto res = UnknownFieldParse(tag, {_InternalParse, msg},
          ptr, end, msg->_internal_metadata_.mutable_unknown_fields(), ctx);
        ptr = res.first;
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr != nullptr);
        if (res.second) return ptr;
      }
    }  // switch
  }  // while
  return ptr;
string_till_end:
  static_cast<::std::string*>(object)->clear();
  static_cast<::std::string*>(object)->reserve(size);
  goto len_delim_till_end;
len_delim_till_end:
  return ctx->StoreAndTailCall(ptr, end, {_InternalParse, msg},
                               {parser_till_end, object}, size);
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool NEMSignTx_NEMMosaicCreation::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:hw.trezor.messages.nem.NEMSignTx.NEMMosaicCreation)
  for (;;) {
    ::std::pair<::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .hw.trezor.messages.nem.NEMSignTx.NEMMosaicCreation.NEMMosaicDefinition definition = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (10 & 0xFF)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessage(
               input, mutable_definition()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional string sink = 2;
      case 2: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (18 & 0xFF)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_sink()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->sink().data(), static_cast<int>(this->sink().length()),
            ::google::protobuf::internal::WireFormat::PARSE,
            "hw.trezor.messages.nem.NEMSignTx.NEMMosaicCreation.sink");
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional uint64 fee = 3;
      case 3: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (24 & 0xFF)) {
          HasBitSetters::set_has_fee(this);
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &fee_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, _internal_metadata_.mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:hw.trezor.messages.nem.NEMSignTx.NEMMosaicCreation)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:hw.trezor.messages.nem.NEMSignTx.NEMMosaicCreation)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void NEMSignTx_NEMMosaicCreation::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:hw.trezor.messages.nem.NEMSignTx.NEMMosaicCreation)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional .hw.trezor.messages.nem.NEMSignTx.NEMMosaicCreation.NEMMosaicDefinition definition = 1;
  if (cached_has_bits & 0x00000002u) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, HasBitSetters::definition(this), output);
  }

  // optional string sink = 2;
  if (cached_has_bits & 0x00000001u) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->sink().data(), static_cast<int>(this->sink().length()),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "hw.trezor.messages.nem.NEMSignTx.NEMMosaicCreation.sink");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      2, this->sink(), output);
  }

  // optional uint64 fee = 3;
  if (cached_has_bits & 0x00000004u) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(3, this->fee(), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        _internal_metadata_.unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:hw.trezor.messages.nem.NEMSignTx.NEMMosaicCreation)
}

::google::protobuf::uint8* NEMSignTx_NEMMosaicCreation::InternalSerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:hw.trezor.messages.nem.NEMSignTx.NEMMosaicCreation)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional .hw.trezor.messages.nem.NEMSignTx.NEMMosaicCreation.NEMMosaicDefinition definition = 1;
  if (cached_has_bits & 0x00000002u) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageToArray(
        1, HasBitSetters::definition(this), target);
  }

  // optional string sink = 2;
  if (cached_has_bits & 0x00000001u) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->sink().data(), static_cast<int>(this->sink().length()),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "hw.trezor.messages.nem.NEMSignTx.NEMMosaicCreation.sink");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        2, this->sink(), target);
  }

  // optional uint64 fee = 3;
  if (cached_has_bits & 0x00000004u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt64ToArray(3, this->fee(), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:hw.trezor.messages.nem.NEMSignTx.NEMMosaicCreation)
  return target;
}

size_t NEMSignTx_NEMMosaicCreation::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:hw.trezor.messages.nem.NEMSignTx.NEMMosaicCreation)
  size_t total_size = 0;

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        _internal_metadata_.unknown_fields());
  }
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional string sink = 2;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->sink());
    }

    // optional .hw.trezor.messages.nem.NEMSignTx.NEMMosaicCreation.NEMMosaicDefinition definition = 1;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSize(
          *definition_);
    }

    // optional uint64 fee = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->fee());
    }

  }
  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void NEMSignTx_NEMMosaicCreation::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:hw.trezor.messages.nem.NEMSignTx.NEMMosaicCreation)
  GOOGLE_DCHECK_NE(&from, this);
  const NEMSignTx_NEMMosaicCreation* source =
      ::google::protobuf::DynamicCastToGenerated<NEMSignTx_NEMMosaicCreation>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:hw.trezor.messages.nem.NEMSignTx.NEMMosaicCreation)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:hw.trezor.messages.nem.NEMSignTx.NEMMosaicCreation)
    MergeFrom(*source);
  }
}

void NEMSignTx_NEMMosaicCreation::MergeFrom(const NEMSignTx_NEMMosaicCreation& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:hw.trezor.messages.nem.NEMSignTx.NEMMosaicCreation)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _has_bits_[0] |= 0x00000001u;
      sink_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.sink_);
    }
    if (cached_has_bits & 0x00000002u) {
      mutable_definition()->::hw::trezor::messages::nem::NEMSignTx_NEMMosaicCreation_NEMMosaicDefinition::MergeFrom(from.definition());
    }
    if (cached_has_bits & 0x00000004u) {
      fee_ = from.fee_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void NEMSignTx_NEMMosaicCreation::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:hw.trezor.messages.nem.NEMSignTx.NEMMosaicCreation)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void NEMSignTx_NEMMosaicCreation::CopyFrom(const NEMSignTx_NEMMosaicCreation& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:hw.trezor.messages.nem.NEMSignTx.NEMMosaicCreation)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool NEMSignTx_NEMMosaicCreation::IsInitialized() const {
  return true;
}

void NEMSignTx_NEMMosaicCreation::Swap(NEMSignTx_NEMMosaicCreation* other) {
  if (other == this) return;
  InternalSwap(other);
}
void NEMSignTx_NEMMosaicCreation::InternalSwap(NEMSignTx_NEMMosaicCreation* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  sink_.Swap(&other->sink_, &::google::protobuf::internal::GetEmptyStringAlreadyInited(),
    GetArenaNoVirtual());
  swap(definition_, other->definition_);
  swap(fee_, other->fee_);
}

::google::protobuf::Metadata NEMSignTx_NEMMosaicCreation::GetMetadata() const {
  ::google::protobuf::internal::AssignDescriptors(&::assign_descriptors_table_messages_2dnem_2eproto);
  return ::file_level_metadata_messages_2dnem_2eproto[kIndexInFileMessages];
}


// ===================================================================

void NEMSignTx_NEMMosaicSupplyChange::InitAsDefaultInstance() {
}
class NEMSignTx_NEMMosaicSupplyChange::HasBitSetters {
 public:
  static void set_has_namespace_(NEMSignTx_NEMMosaicSupplyChange* msg) {
    msg->_has_bits_[0] |= 0x00000001u;
  }
  static void set_has_mosaic(NEMSignTx_NEMMosaicSupplyChange* msg) {
    msg->_has_bits_[0] |= 0x00000002u;
  }
  static void set_has_type(NEMSignTx_NEMMosaicSupplyChange* msg) {
    msg->_has_bits_[0] |= 0x00000008u;
  }
  static void set_has_delta(NEMSignTx_NEMMosaicSupplyChange* msg) {
    msg->_has_bits_[0] |= 0x00000004u;
  }
};

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int NEMSignTx_NEMMosaicSupplyChange::kNamespaceFieldNumber;
const int NEMSignTx_NEMMosaicSupplyChange::kMosaicFieldNumber;
const int NEMSignTx_NEMMosaicSupplyChange::kTypeFieldNumber;
const int NEMSignTx_NEMMosaicSupplyChange::kDeltaFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

NEMSignTx_NEMMosaicSupplyChange::NEMSignTx_NEMMosaicSupplyChange()
  : ::google::protobuf::Message(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:hw.trezor.messages.nem.NEMSignTx.NEMMosaicSupplyChange)
}
NEMSignTx_NEMMosaicSupplyChange::NEMSignTx_NEMMosaicSupplyChange(const NEMSignTx_NEMMosaicSupplyChange& from)
  : ::google::protobuf::Message(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  namespace__.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (from.has_namespace_()) {
    namespace__.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.namespace__);
  }
  mosaic_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (from.has_mosaic()) {
    mosaic_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.mosaic_);
  }
  ::memcpy(&delta_, &from.delta_,
    static_cast<size_t>(reinterpret_cast<char*>(&type_) -
    reinterpret_cast<char*>(&delta_)) + sizeof(type_));
  // @@protoc_insertion_point(copy_constructor:hw.trezor.messages.nem.NEMSignTx.NEMMosaicSupplyChange)
}

void NEMSignTx_NEMMosaicSupplyChange::SharedCtor() {
  ::google::protobuf::internal::InitSCC(
      &scc_info_NEMSignTx_NEMMosaicSupplyChange_messages_2dnem_2eproto.base);
  namespace__.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  mosaic_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  delta_ = PROTOBUF_ULONGLONG(0);
  type_ = 1;
}

NEMSignTx_NEMMosaicSupplyChange::~NEMSignTx_NEMMosaicSupplyChange() {
  // @@protoc_insertion_point(destructor:hw.trezor.messages.nem.NEMSignTx.NEMMosaicSupplyChange)
  SharedDtor();
}

void NEMSignTx_NEMMosaicSupplyChange::SharedDtor() {
  namespace__.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  mosaic_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}

void NEMSignTx_NEMMosaicSupplyChange::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const NEMSignTx_NEMMosaicSupplyChange& NEMSignTx_NEMMosaicSupplyChange::default_instance() {
  ::google::protobuf::internal::InitSCC(&::scc_info_NEMSignTx_NEMMosaicSupplyChange_messages_2dnem_2eproto.base);
  return *internal_default_instance();
}


void NEMSignTx_NEMMosaicSupplyChange::Clear() {
// @@protoc_insertion_point(message_clear_start:hw.trezor.messages.nem.NEMSignTx.NEMMosaicSupplyChange)
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      namespace__.ClearNonDefaultToEmptyNoArena();
    }
    if (cached_has_bits & 0x00000002u) {
      mosaic_.ClearNonDefaultToEmptyNoArena();
    }
  }
  if (cached_has_bits & 0x0000000cu) {
    delta_ = PROTOBUF_ULONGLONG(0);
    type_ = 1;
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* NEMSignTx_NEMMosaicSupplyChange::_InternalParse(const char* begin, const char* end, void* object,
                  ::google::protobuf::internal::ParseContext* ctx) {
  auto msg = static_cast<NEMSignTx_NEMMosaicSupplyChange*>(object);
  ::google::protobuf::int32 size; (void)size;
  int depth; (void)depth;
  ::google::protobuf::uint32 tag;
  ::google::protobuf::internal::ParseFunc parser_till_end; (void)parser_till_end;
  auto ptr = begin;
  while (ptr < end) {
    ptr = ::google::protobuf::io::Parse32(ptr, &tag);
    GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
    switch (tag >> 3) {
      // optional string namespace = 1;
      case 1: {
        if (static_cast<::google::protobuf::uint8>(tag) != 10) goto handle_unusual;
        ptr = ::google::protobuf::io::ReadSize(ptr, &size);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        ctx->extra_parse_data().SetFieldName("hw.trezor.messages.nem.NEMSignTx.NEMMosaicSupplyChange.namespace");
        object = msg->mutable_namespace_();
        if (size > end - ptr + ::google::protobuf::internal::ParseContext::kSlopBytes) {
          parser_till_end = ::google::protobuf::internal::GreedyStringParserUTF8Verify;
          goto string_till_end;
        }
        GOOGLE_PROTOBUF_PARSER_ASSERT(::google::protobuf::internal::StringCheckUTF8Verify(ptr, size, ctx));
        ::google::protobuf::internal::InlineGreedyStringParser(object, ptr, size, ctx);
        ptr += size;
        break;
      }
      // optional string mosaic = 2;
      case 2: {
        if (static_cast<::google::protobuf::uint8>(tag) != 18) goto handle_unusual;
        ptr = ::google::protobuf::io::ReadSize(ptr, &size);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        ctx->extra_parse_data().SetFieldName("hw.trezor.messages.nem.NEMSignTx.NEMMosaicSupplyChange.mosaic");
        object = msg->mutable_mosaic();
        if (size > end - ptr + ::google::protobuf::internal::ParseContext::kSlopBytes) {
          parser_till_end = ::google::protobuf::internal::GreedyStringParserUTF8Verify;
          goto string_till_end;
        }
        GOOGLE_PROTOBUF_PARSER_ASSERT(::google::protobuf::internal::StringCheckUTF8Verify(ptr, size, ctx));
        ::google::protobuf::internal::InlineGreedyStringParser(object, ptr, size, ctx);
        ptr += size;
        break;
      }
      // optional .hw.trezor.messages.nem.NEMSignTx.NEMMosaicSupplyChange.NEMSupplyChangeType type = 3;
      case 3: {
        if (static_cast<::google::protobuf::uint8>(tag) != 24) goto handle_unusual;
        ::google::protobuf::uint64 val = ::google::protobuf::internal::ReadVarint(&ptr);
        if (!::hw::trezor::messages::nem::NEMSignTx_NEMMosaicSupplyChange_NEMSupplyChangeType_IsValid(val)) {
          ::google::protobuf::internal::WriteVarint(3, val, msg->mutable_unknown_fields());
          break;
        }
        msg->set_type(static_cast<::hw::trezor::messages::nem::NEMSignTx_NEMMosaicSupplyChange_NEMSupplyChangeType>(val));
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        break;
      }
      // optional uint64 delta = 4;
      case 4: {
        if (static_cast<::google::protobuf::uint8>(tag) != 32) goto handle_unusual;
        msg->set_delta(::google::protobuf::internal::ReadVarint(&ptr));
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        break;
      }
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->EndGroup(tag);
          return ptr;
        }
        auto res = UnknownFieldParse(tag, {_InternalParse, msg},
          ptr, end, msg->_internal_metadata_.mutable_unknown_fields(), ctx);
        ptr = res.first;
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr != nullptr);
        if (res.second) return ptr;
      }
    }  // switch
  }  // while
  return ptr;
string_till_end:
  static_cast<::std::string*>(object)->clear();
  static_cast<::std::string*>(object)->reserve(size);
  goto len_delim_till_end;
len_delim_till_end:
  return ctx->StoreAndTailCall(ptr, end, {_InternalParse, msg},
                               {parser_till_end, object}, size);
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool NEMSignTx_NEMMosaicSupplyChange::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:hw.trezor.messages.nem.NEMSignTx.NEMMosaicSupplyChange)
  for (;;) {
    ::std::pair<::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional string namespace = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (10 & 0xFF)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_namespace_()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->namespace_().data(), static_cast<int>(this->namespace_().length()),
            ::google::protobuf::internal::WireFormat::PARSE,
            "hw.trezor.messages.nem.NEMSignTx.NEMMosaicSupplyChange.namespace");
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional string mosaic = 2;
      case 2: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (18 & 0xFF)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_mosaic()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->mosaic().data(), static_cast<int>(this->mosaic().length()),
            ::google::protobuf::internal::WireFormat::PARSE,
            "hw.trezor.messages.nem.NEMSignTx.NEMMosaicSupplyChange.mosaic");
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional .hw.trezor.messages.nem.NEMSignTx.NEMMosaicSupplyChange.NEMSupplyChangeType type = 3;
      case 3: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (24 & 0xFF)) {
          int value = 0;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::hw::trezor::messages::nem::NEMSignTx_NEMMosaicSupplyChange_NEMSupplyChangeType_IsValid(value)) {
            set_type(static_cast< ::hw::trezor::messages::nem::NEMSignTx_NEMMosaicSupplyChange_NEMSupplyChangeType >(value));
          } else {
            mutable_unknown_fields()->AddVarint(
                3, static_cast<::google::protobuf::uint64>(value));
          }
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional uint64 delta = 4;
      case 4: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (32 & 0xFF)) {
          HasBitSetters::set_has_delta(this);
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &delta_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, _internal_metadata_.mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:hw.trezor.messages.nem.NEMSignTx.NEMMosaicSupplyChange)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:hw.trezor.messages.nem.NEMSignTx.NEMMosaicSupplyChange)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void NEMSignTx_NEMMosaicSupplyChange::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:hw.trezor.messages.nem.NEMSignTx.NEMMosaicSupplyChange)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional string namespace = 1;
  if (cached_has_bits & 0x00000001u) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->namespace_().data(), static_cast<int>(this->namespace_().length()),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "hw.trezor.messages.nem.NEMSignTx.NEMMosaicSupplyChange.namespace");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      1, this->namespace_(), output);
  }

  // optional string mosaic = 2;
  if (cached_has_bits & 0x00000002u) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->mosaic().data(), static_cast<int>(this->mosaic().length()),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "hw.trezor.messages.nem.NEMSignTx.NEMMosaicSupplyChange.mosaic");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      2, this->mosaic(), output);
  }

  // optional .hw.trezor.messages.nem.NEMSignTx.NEMMosaicSupplyChange.NEMSupplyChangeType type = 3;
  if (cached_has_bits & 0x00000008u) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      3, this->type(), output);
  }

  // optional uint64 delta = 4;
  if (cached_has_bits & 0x00000004u) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(4, this->delta(), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        _internal_metadata_.unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:hw.trezor.messages.nem.NEMSignTx.NEMMosaicSupplyChange)
}

::google::protobuf::uint8* NEMSignTx_NEMMosaicSupplyChange::InternalSerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:hw.trezor.messages.nem.NEMSignTx.NEMMosaicSupplyChange)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional string namespace = 1;
  if (cached_has_bits & 0x00000001u) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->namespace_().data(), static_cast<int>(this->namespace_().length()),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "hw.trezor.messages.nem.NEMSignTx.NEMMosaicSupplyChange.namespace");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        1, this->namespace_(), target);
  }

  // optional string mosaic = 2;
  if (cached_has_bits & 0x00000002u) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->mosaic().data(), static_cast<int>(this->mosaic().length()),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "hw.trezor.messages.nem.NEMSignTx.NEMMosaicSupplyChange.mosaic");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        2, this->mosaic(), target);
  }

  // optional .hw.trezor.messages.nem.NEMSignTx.NEMMosaicSupplyChange.NEMSupplyChangeType type = 3;
  if (cached_has_bits & 0x00000008u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      3, this->type(), target);
  }

  // optional uint64 delta = 4;
  if (cached_has_bits & 0x00000004u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt64ToArray(4, this->delta(), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:hw.trezor.messages.nem.NEMSignTx.NEMMosaicSupplyChange)
  return target;
}

size_t NEMSignTx_NEMMosaicSupplyChange::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:hw.trezor.messages.nem.NEMSignTx.NEMMosaicSupplyChange)
  size_t total_size = 0;

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        _internal_metadata_.unknown_fields());
  }
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    // optional string namespace = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->namespace_());
    }

    // optional string mosaic = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->mosaic());
    }

    // optional uint64 delta = 4;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->delta());
    }

    // optional .hw.trezor.messages.nem.NEMSignTx.NEMMosaicSupplyChange.NEMSupplyChangeType type = 3;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->type());
    }

  }
  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void NEMSignTx_NEMMosaicSupplyChange::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:hw.trezor.messages.nem.NEMSignTx.NEMMosaicSupplyChange)
  GOOGLE_DCHECK_NE(&from, this);
  const NEMSignTx_NEMMosaicSupplyChange* source =
      ::google::protobuf::DynamicCastToGenerated<NEMSignTx_NEMMosaicSupplyChange>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:hw.trezor.messages.nem.NEMSignTx.NEMMosaicSupplyChange)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:hw.trezor.messages.nem.NEMSignTx.NEMMosaicSupplyChange)
    MergeFrom(*source);
  }
}

void NEMSignTx_NEMMosaicSupplyChange::MergeFrom(const NEMSignTx_NEMMosaicSupplyChange& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:hw.trezor.messages.nem.NEMSignTx.NEMMosaicSupplyChange)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      _has_bits_[0] |= 0x00000001u;
      namespace__.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.namespace__);
    }
    if (cached_has_bits & 0x00000002u) {
      _has_bits_[0] |= 0x00000002u;
      mosaic_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.mosaic_);
    }
    if (cached_has_bits & 0x00000004u) {
      delta_ = from.delta_;
    }
    if (cached_has_bits & 0x00000008u) {
      type_ = from.type_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void NEMSignTx_NEMMosaicSupplyChange::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:hw.trezor.messages.nem.NEMSignTx.NEMMosaicSupplyChange)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void NEMSignTx_NEMMosaicSupplyChange::CopyFrom(const NEMSignTx_NEMMosaicSupplyChange& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:hw.trezor.messages.nem.NEMSignTx.NEMMosaicSupplyChange)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool NEMSignTx_NEMMosaicSupplyChange::IsInitialized() const {
  return true;
}

void NEMSignTx_NEMMosaicSupplyChange::Swap(NEMSignTx_NEMMosaicSupplyChange* other) {
  if (other == this) return;
  InternalSwap(other);
}
void NEMSignTx_NEMMosaicSupplyChange::InternalSwap(NEMSignTx_NEMMosaicSupplyChange* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  namespace__.Swap(&other->namespace__, &::google::protobuf::internal::GetEmptyStringAlreadyInited(),
    GetArenaNoVirtual());
  mosaic_.Swap(&other->mosaic_, &::google::protobuf::internal::GetEmptyStringAlreadyInited(),
    GetArenaNoVirtual());
  swap(delta_, other->delta_);
  swap(type_, other->type_);
}

::google::protobuf::Metadata NEMSignTx_NEMMosaicSupplyChange::GetMetadata() const {
  ::google::protobuf::internal::AssignDescriptors(&::assign_descriptors_table_messages_2dnem_2eproto);
  return ::file_level_metadata_messages_2dnem_2eproto[kIndexInFileMessages];
}


// ===================================================================

void NEMSignTx_NEMAggregateModification_NEMCosignatoryModification::InitAsDefaultInstance() {
}
class NEMSignTx_NEMAggregateModification_NEMCosignatoryModification::HasBitSetters {
 public:
  static void set_has_type(NEMSignTx_NEMAggregateModification_NEMCosignatoryModification* msg) {
    msg->_has_bits_[0] |= 0x00000002u;
  }
  static void set_has_public_key(NEMSignTx_NEMAggregateModification_NEMCosignatoryModification* msg) {
    msg->_has_bits_[0] |= 0x00000001u;
  }
};

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int NEMSignTx_NEMAggregateModification_NEMCosignatoryModification::kTypeFieldNumber;
const int NEMSignTx_NEMAggregateModification_NEMCosignatoryModification::kPublicKeyFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

NEMSignTx_NEMAggregateModification_NEMCosignatoryModification::NEMSignTx_NEMAggregateModification_NEMCosignatoryModification()
  : ::google::protobuf::Message(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:hw.trezor.messages.nem.NEMSignTx.NEMAggregateModification.NEMCosignatoryModification)
}
NEMSignTx_NEMAggregateModification_NEMCosignatoryModification::NEMSignTx_NEMAggregateModification_NEMCosignatoryModification(const NEMSignTx_NEMAggregateModification_NEMCosignatoryModification& from)
  : ::google::protobuf::Message(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  public_key_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (from.has_public_key()) {
    public_key_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.public_key_);
  }
  type_ = from.type_;
  // @@protoc_insertion_point(copy_constructor:hw.trezor.messages.nem.NEMSignTx.NEMAggregateModification.NEMCosignatoryModification)
}

void NEMSignTx_NEMAggregateModification_NEMCosignatoryModification::SharedCtor() {
  ::google::protobuf::internal::InitSCC(
      &scc_info_NEMSignTx_NEMAggregateModification_NEMCosignatoryModification_messages_2dnem_2eproto.base);
  public_key_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  type_ = 1;
}

NEMSignTx_NEMAggregateModification_NEMCosignatoryModification::~NEMSignTx_NEMAggregateModification_NEMCosignatoryModification() {
  // @@protoc_insertion_point(destructor:hw.trezor.messages.nem.NEMSignTx.NEMAggregateModification.NEMCosignatoryModification)
  SharedDtor();
}

void NEMSignTx_NEMAggregateModification_NEMCosignatoryModification::SharedDtor() {
  public_key_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}

void NEMSignTx_NEMAggregateModification_NEMCosignatoryModification::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const NEMSignTx_NEMAggregateModification_NEMCosignatoryModification& NEMSignTx_NEMAggregateModification_NEMCosignatoryModification::default_instance() {
  ::google::protobuf::internal::InitSCC(&::scc_info_NEMSignTx_NEMAggregateModification_NEMCosignatoryModification_messages_2dnem_2eproto.base);
  return *internal_default_instance();
}


void NEMSignTx_NEMAggregateModification_NEMCosignatoryModification::Clear() {
// @@protoc_insertion_point(message_clear_start:hw.trezor.messages.nem.NEMSignTx.NEMAggregateModification.NEMCosignatoryModification)
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      public_key_.ClearNonDefaultToEmptyNoArena();
    }
    type_ = 1;
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* NEMSignTx_NEMAggregateModification_NEMCosignatoryModification::_InternalParse(const char* begin, const char* end, void* object,
                  ::google::protobuf::internal::ParseContext* ctx) {
  auto msg = static_cast<NEMSignTx_NEMAggregateModification_NEMCosignatoryModification*>(object);
  ::google::protobuf::int32 size; (void)size;
  int depth; (void)depth;
  ::google::protobuf::uint32 tag;
  ::google::protobuf::internal::ParseFunc parser_till_end; (void)parser_till_end;
  auto ptr = begin;
  while (ptr < end) {
    ptr = ::google::protobuf::io::Parse32(ptr, &tag);
    GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
    switch (tag >> 3) {
      // optional .hw.trezor.messages.nem.NEMSignTx.NEMAggregateModification.NEMCosignatoryModification.NEMModificationType type = 1;
      case 1: {
        if (static_cast<::google::protobuf::uint8>(tag) != 8) goto handle_unusual;
        ::google::protobuf::uint64 val = ::google::protobuf::internal::ReadVarint(&ptr);
        if (!::hw::trezor::messages::nem::NEMSignTx_NEMAggregateModification_NEMCosignatoryModification_NEMModificationType_IsValid(val)) {
          ::google::protobuf::internal::WriteVarint(1, val, msg->mutable_unknown_fields());
          break;
        }
        msg->set_type(static_cast<::hw::trezor::messages::nem::NEMSignTx_NEMAggregateModification_NEMCosignatoryModification_NEMModificationType>(val));
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        break;
      }
      // optional bytes public_key = 2;
      case 2: {
        if (static_cast<::google::protobuf::uint8>(tag) != 18) goto handle_unusual;
        ptr = ::google::protobuf::io::ReadSize(ptr, &size);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        object = msg->mutable_public_key();
        if (size > end - ptr + ::google::protobuf::internal::ParseContext::kSlopBytes) {
          parser_till_end = ::google::protobuf::internal::GreedyStringParser;
          goto string_till_end;
        }
        GOOGLE_PROTOBUF_PARSER_ASSERT(::google::protobuf::internal::StringCheck(ptr, size, ctx));
        ::google::protobuf::internal::InlineGreedyStringParser(object, ptr, size, ctx);
        ptr += size;
        break;
      }
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->EndGroup(tag);
          return ptr;
        }
        auto res = UnknownFieldParse(tag, {_InternalParse, msg},
          ptr, end, msg->_internal_metadata_.mutable_unknown_fields(), ctx);
        ptr = res.first;
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr != nullptr);
        if (res.second) return ptr;
      }
    }  // switch
  }  // while
  return ptr;
string_till_end:
  static_cast<::std::string*>(object)->clear();
  static_cast<::std::string*>(object)->reserve(size);
  goto len_delim_till_end;
len_delim_till_end:
  return ctx->StoreAndTailCall(ptr, end, {_InternalParse, msg},
                               {parser_till_end, object}, size);
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool NEMSignTx_NEMAggregateModification_NEMCosignatoryModification::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:hw.trezor.messages.nem.NEMSignTx.NEMAggregateModification.NEMCosignatoryModification)
  for (;;) {
    ::std::pair<::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .hw.trezor.messages.nem.NEMSignTx.NEMAggregateModification.NEMCosignatoryModification.NEMModificationType type = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (8 & 0xFF)) {
          int value = 0;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::hw::trezor::messages::nem::NEMSignTx_NEMAggregateModification_NEMCosignatoryModification_NEMModificationType_IsValid(value)) {
            set_type(static_cast< ::hw::trezor::messages::nem::NEMSignTx_NEMAggregateModification_NEMCosignatoryModification_NEMModificationType >(value));
          } else {
            mutable_unknown_fields()->AddVarint(
                1, static_cast<::google::protobuf::uint64>(value));
          }
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional bytes public_key = 2;
      case 2: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (18 & 0xFF)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_public_key()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, _internal_metadata_.mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:hw.trezor.messages.nem.NEMSignTx.NEMAggregateModification.NEMCosignatoryModification)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:hw.trezor.messages.nem.NEMSignTx.NEMAggregateModification.NEMCosignatoryModification)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void NEMSignTx_NEMAggregateModification_NEMCosignatoryModification::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:hw.trezor.messages.nem.NEMSignTx.NEMAggregateModification.NEMCosignatoryModification)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional .hw.trezor.messages.nem.NEMSignTx.NEMAggregateModification.NEMCosignatoryModification.NEMModificationType type = 1;
  if (cached_has_bits & 0x00000002u) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      1, this->type(), output);
  }

  // optional bytes public_key = 2;
  if (cached_has_bits & 0x00000001u) {
    ::google::protobuf::internal::WireFormatLite::WriteBytesMaybeAliased(
      2, this->public_key(), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        _internal_metadata_.unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:hw.trezor.messages.nem.NEMSignTx.NEMAggregateModification.NEMCosignatoryModification)
}

::google::protobuf::uint8* NEMSignTx_NEMAggregateModification_NEMCosignatoryModification::InternalSerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:hw.trezor.messages.nem.NEMSignTx.NEMAggregateModification.NEMCosignatoryModification)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional .hw.trezor.messages.nem.NEMSignTx.NEMAggregateModification.NEMCosignatoryModification.NEMModificationType type = 1;
  if (cached_has_bits & 0x00000002u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      1, this->type(), target);
  }

  // optional bytes public_key = 2;
  if (cached_has_bits & 0x00000001u) {
    target =
      ::google::protobuf::internal::WireFormatLite::WriteBytesToArray(
        2, this->public_key(), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:hw.trezor.messages.nem.NEMSignTx.NEMAggregateModification.NEMCosignatoryModification)
  return target;
}

size_t NEMSignTx_NEMAggregateModification_NEMCosignatoryModification::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:hw.trezor.messages.nem.NEMSignTx.NEMAggregateModification.NEMCosignatoryModification)
  size_t total_size = 0;

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        _internal_metadata_.unknown_fields());
  }
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional bytes public_key = 2;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->public_key());
    }

    // optional .hw.trezor.messages.nem.NEMSignTx.NEMAggregateModification.NEMCosignatoryModification.NEMModificationType type = 1;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->type());
    }

  }
  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void NEMSignTx_NEMAggregateModification_NEMCosignatoryModification::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:hw.trezor.messages.nem.NEMSignTx.NEMAggregateModification.NEMCosignatoryModification)
  GOOGLE_DCHECK_NE(&from, this);
  const NEMSignTx_NEMAggregateModification_NEMCosignatoryModification* source =
      ::google::protobuf::DynamicCastToGenerated<NEMSignTx_NEMAggregateModification_NEMCosignatoryModification>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:hw.trezor.messages.nem.NEMSignTx.NEMAggregateModification.NEMCosignatoryModification)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:hw.trezor.messages.nem.NEMSignTx.NEMAggregateModification.NEMCosignatoryModification)
    MergeFrom(*source);
  }
}

void NEMSignTx_NEMAggregateModification_NEMCosignatoryModification::MergeFrom(const NEMSignTx_NEMAggregateModification_NEMCosignatoryModification& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:hw.trezor.messages.nem.NEMSignTx.NEMAggregateModification.NEMCosignatoryModification)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _has_bits_[0] |= 0x00000001u;
      public_key_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.public_key_);
    }
    if (cached_has_bits & 0x00000002u) {
      type_ = from.type_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void NEMSignTx_NEMAggregateModification_NEMCosignatoryModification::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:hw.trezor.messages.nem.NEMSignTx.NEMAggregateModification.NEMCosignatoryModification)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void NEMSignTx_NEMAggregateModification_NEMCosignatoryModification::CopyFrom(const NEMSignTx_NEMAggregateModification_NEMCosignatoryModification& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:hw.trezor.messages.nem.NEMSignTx.NEMAggregateModification.NEMCosignatoryModification)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool NEMSignTx_NEMAggregateModification_NEMCosignatoryModification::IsInitialized() const {
  return true;
}

void NEMSignTx_NEMAggregateModification_NEMCosignatoryModification::Swap(NEMSignTx_NEMAggregateModification_NEMCosignatoryModification* other) {
  if (other == this) return;
  InternalSwap(other);
}
void NEMSignTx_NEMAggregateModification_NEMCosignatoryModification::InternalSwap(NEMSignTx_NEMAggregateModification_NEMCosignatoryModification* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  public_key_.Swap(&other->public_key_, &::google::protobuf::internal::GetEmptyStringAlreadyInited(),
    GetArenaNoVirtual());
  swap(type_, other->type_);
}

::google::protobuf::Metadata NEMSignTx_NEMAggregateModification_NEMCosignatoryModification::GetMetadata() const {
  ::google::protobuf::internal::AssignDescriptors(&::assign_descriptors_table_messages_2dnem_2eproto);
  return ::file_level_metadata_messages_2dnem_2eproto[kIndexInFileMessages];
}


// ===================================================================

void NEMSignTx_NEMAggregateModification::InitAsDefaultInstance() {
}
class NEMSignTx_NEMAggregateModification::HasBitSetters {
 public:
  static void set_has_relative_change(NEMSignTx_NEMAggregateModification* msg) {
    msg->_has_bits_[0] |= 0x00000001u;
  }
};

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int NEMSignTx_NEMAggregateModification::kModificationsFieldNumber;
const int NEMSignTx_NEMAggregateModification::kRelativeChangeFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

NEMSignTx_NEMAggregateModification::NEMSignTx_NEMAggregateModification()
  : ::google::protobuf::Message(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:hw.trezor.messages.nem.NEMSignTx.NEMAggregateModification)
}
NEMSignTx_NEMAggregateModification::NEMSignTx_NEMAggregateModification(const NEMSignTx_NEMAggregateModification& from)
  : ::google::protobuf::Message(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_),
      modifications_(from.modifications_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  relative_change_ = from.relative_change_;
  // @@protoc_insertion_point(copy_constructor:hw.trezor.messages.nem.NEMSignTx.NEMAggregateModification)
}

void NEMSignTx_NEMAggregateModification::SharedCtor() {
  ::google::protobuf::internal::InitSCC(
      &scc_info_NEMSignTx_NEMAggregateModification_messages_2dnem_2eproto.base);
  relative_change_ = 0;
}

NEMSignTx_NEMAggregateModification::~NEMSignTx_NEMAggregateModification() {
  // @@protoc_insertion_point(destructor:hw.trezor.messages.nem.NEMSignTx.NEMAggregateModification)
  SharedDtor();
}

void NEMSignTx_NEMAggregateModification::SharedDtor() {
}

void NEMSignTx_NEMAggregateModification::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const NEMSignTx_NEMAggregateModification& NEMSignTx_NEMAggregateModification::default_instance() {
  ::google::protobuf::internal::InitSCC(&::scc_info_NEMSignTx_NEMAggregateModification_messages_2dnem_2eproto.base);
  return *internal_default_instance();
}


void NEMSignTx_NEMAggregateModification::Clear() {
// @@protoc_insertion_point(message_clear_start:hw.trezor.messages.nem.NEMSignTx.NEMAggregateModification)
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  modifications_.Clear();
  relative_change_ = 0;
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* NEMSignTx_NEMAggregateModification::_InternalParse(const char* begin, const char* end, void* object,
                  ::google::protobuf::internal::ParseContext* ctx) {
  auto msg = static_cast<NEMSignTx_NEMAggregateModification*>(object);
  ::google::protobuf::int32 size; (void)size;
  int depth; (void)depth;
  ::google::protobuf::uint32 tag;
  ::google::protobuf::internal::ParseFunc parser_till_end; (void)parser_till_end;
  auto ptr = begin;
  while (ptr < end) {
    ptr = ::google::protobuf::io::Parse32(ptr, &tag);
    GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
    switch (tag >> 3) {
      // repeated .hw.trezor.messages.nem.NEMSignTx.NEMAggregateModification.NEMCosignatoryModification modifications = 1;
      case 1: {
        if (static_cast<::google::protobuf::uint8>(tag) != 10) goto handle_unusual;
        do {
          ptr = ::google::protobuf::io::ReadSize(ptr, &size);
          GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
          parser_till_end = ::hw::trezor::messages::nem::NEMSignTx_NEMAggregateModification_NEMCosignatoryModification::_InternalParse;
          object = msg->add_modifications();
          if (size > end - ptr) goto len_delim_till_end;
          ptr += size;
          GOOGLE_PROTOBUF_PARSER_ASSERT(ctx->ParseExactRange(
              {parser_till_end, object}, ptr - size, ptr));
          if (ptr >= end) break;
        } while ((::google::protobuf::io::UnalignedLoad<::google::protobuf::uint64>(ptr) & 255) == 10 && (ptr += 1));
        break;
      }
      // optional sint32 relative_change = 2;
      case 2: {
        if (static_cast<::google::protobuf::uint8>(tag) != 16) goto handle_unusual;
        msg->set_relative_change(::google::protobuf::internal::ReadVarintZigZag32(&ptr));
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        break;
      }
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->EndGroup(tag);
          return ptr;
        }
        auto res = UnknownFieldParse(tag, {_InternalParse, msg},
          ptr, end, msg->_internal_metadata_.mutable_unknown_fields(), ctx);
        ptr = res.first;
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr != nullptr);
        if (res.second) return ptr;
      }
    }  // switch
  }  // while
  return ptr;
len_delim_till_end:
  return ctx->StoreAndTailCall(ptr, end, {_InternalParse, msg},
                               {parser_till_end, object}, size);
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool NEMSignTx_NEMAggregateModification::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:hw.trezor.messages.nem.NEMSignTx.NEMAggregateModification)
  for (;;) {
    ::std::pair<::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated .hw.trezor.messages.nem.NEMSignTx.NEMAggregateModification.NEMCosignatoryModification modifications = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (10 & 0xFF)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessage(
                input, add_modifications()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional sint32 relative_change = 2;
      case 2: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (16 & 0xFF)) {
          HasBitSetters::set_has_relative_change(this);
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_SINT32>(
                 input, &relative_change_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, _internal_metadata_.mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:hw.trezor.messages.nem.NEMSignTx.NEMAggregateModification)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:hw.trezor.messages.nem.NEMSignTx.NEMAggregateModification)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void NEMSignTx_NEMAggregateModification::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:hw.trezor.messages.nem.NEMSignTx.NEMAggregateModification)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .hw.trezor.messages.nem.NEMSignTx.NEMAggregateModification.NEMCosignatoryModification modifications = 1;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->modifications_size()); i < n; i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1,
      this->modifications(static_cast<int>(i)),
      output);
  }

  cached_has_bits = _has_bits_[0];
  // optional sint32 relative_change = 2;
  if (cached_has_bits & 0x00000001u) {
    ::google::protobuf::internal::WireFormatLite::WriteSInt32(2, this->relative_change(), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        _internal_metadata_.unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:hw.trezor.messages.nem.NEMSignTx.NEMAggregateModification)
}

::google::protobuf::uint8* NEMSignTx_NEMAggregateModification::InternalSerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:hw.trezor.messages.nem.NEMSignTx.NEMAggregateModification)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .hw.trezor.messages.nem.NEMSignTx.NEMAggregateModification.NEMCosignatoryModification modifications = 1;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->modifications_size()); i < n; i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageToArray(
        1, this->modifications(static_cast<int>(i)), target);
  }

  cached_has_bits = _has_bits_[0];
  // optional sint32 relative_change = 2;
  if (cached_has_bits & 0x00000001u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteSInt32ToArray(2, this->relative_change(), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:hw.trezor.messages.nem.NEMSignTx.NEMAggregateModification)
  return target;
}

size_t NEMSignTx_NEMAggregateModification::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:hw.trezor.messages.nem.NEMSignTx.NEMAggregateModification)
  size_t total_size = 0;

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        _internal_metadata_.unknown_fields());
  }
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .hw.trezor.messages.nem.NEMSignTx.NEMAggregateModification.NEMCosignatoryModification modifications = 1;
  {
    unsigned int count = static_cast<unsigned int>(this->modifications_size());
    total_size += 1UL * count;
    for (unsigned int i = 0; i < count; i++) {
      total_size +=
        ::google::protobuf::internal::WireFormatLite::MessageSize(
          this->modifications(static_cast<int>(i)));
    }
  }

  // optional sint32 relative_change = 2;
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::SInt32Size(
        this->relative_change());
  }

  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void NEMSignTx_NEMAggregateModification::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:hw.trezor.messages.nem.NEMSignTx.NEMAggregateModification)
  GOOGLE_DCHECK_NE(&from, this);
  const NEMSignTx_NEMAggregateModification* source =
      ::google::protobuf::DynamicCastToGenerated<NEMSignTx_NEMAggregateModification>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:hw.trezor.messages.nem.NEMSignTx.NEMAggregateModification)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:hw.trezor.messages.nem.NEMSignTx.NEMAggregateModification)
    MergeFrom(*source);
  }
}

void NEMSignTx_NEMAggregateModification::MergeFrom(const NEMSignTx_NEMAggregateModification& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:hw.trezor.messages.nem.NEMSignTx.NEMAggregateModification)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  modifications_.MergeFrom(from.modifications_);
  if (from.has_relative_change()) {
    set_relative_change(from.relative_change());
  }
}

void NEMSignTx_NEMAggregateModification::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:hw.trezor.messages.nem.NEMSignTx.NEMAggregateModification)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void NEMSignTx_NEMAggregateModification::CopyFrom(const NEMSignTx_NEMAggregateModification& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:hw.trezor.messages.nem.NEMSignTx.NEMAggregateModification)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool NEMSignTx_NEMAggregateModification::IsInitialized() const {
  return true;
}

void NEMSignTx_NEMAggregateModification::Swap(NEMSignTx_NEMAggregateModification* other) {
  if (other == this) return;
  InternalSwap(other);
}
void NEMSignTx_NEMAggregateModification::InternalSwap(NEMSignTx_NEMAggregateModification* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  CastToBase(&modifications_)->InternalSwap(CastToBase(&other->modifications_));
  swap(relative_change_, other->relative_change_);
}

::google::protobuf::Metadata NEMSignTx_NEMAggregateModification::GetMetadata() const {
  ::google::protobuf::internal::AssignDescriptors(&::assign_descriptors_table_messages_2dnem_2eproto);
  return ::file_level_metadata_messages_2dnem_2eproto[kIndexInFileMessages];
}


// ===================================================================

void NEMSignTx_NEMImportanceTransfer::InitAsDefaultInstance() {
}
class NEMSignTx_NEMImportanceTransfer::HasBitSetters {
 public:
  static void set_has_mode(NEMSignTx_NEMImportanceTransfer* msg) {
    msg->_has_bits_[0] |= 0x00000002u;
  }
  static void set_has_public_key(NEMSignTx_NEMImportanceTransfer* msg) {
    msg->_has_bits_[0] |= 0x00000001u;
  }
};

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int NEMSignTx_NEMImportanceTransfer::kModeFieldNumber;
const int NEMSignTx_NEMImportanceTransfer::kPublicKeyFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

NEMSignTx_NEMImportanceTransfer::NEMSignTx_NEMImportanceTransfer()
  : ::google::protobuf::Message(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:hw.trezor.messages.nem.NEMSignTx.NEMImportanceTransfer)
}
NEMSignTx_NEMImportanceTransfer::NEMSignTx_NEMImportanceTransfer(const NEMSignTx_NEMImportanceTransfer& from)
  : ::google::protobuf::Message(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  public_key_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (from.has_public_key()) {
    public_key_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.public_key_);
  }
  mode_ = from.mode_;
  // @@protoc_insertion_point(copy_constructor:hw.trezor.messages.nem.NEMSignTx.NEMImportanceTransfer)
}

void NEMSignTx_NEMImportanceTransfer::SharedCtor() {
  ::google::protobuf::internal::InitSCC(
      &scc_info_NEMSignTx_NEMImportanceTransfer_messages_2dnem_2eproto.base);
  public_key_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  mode_ = 1;
}

NEMSignTx_NEMImportanceTransfer::~NEMSignTx_NEMImportanceTransfer() {
  // @@protoc_insertion_point(destructor:hw.trezor.messages.nem.NEMSignTx.NEMImportanceTransfer)
  SharedDtor();
}

void NEMSignTx_NEMImportanceTransfer::SharedDtor() {
  public_key_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}

void NEMSignTx_NEMImportanceTransfer::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const NEMSignTx_NEMImportanceTransfer& NEMSignTx_NEMImportanceTransfer::default_instance() {
  ::google::protobuf::internal::InitSCC(&::scc_info_NEMSignTx_NEMImportanceTransfer_messages_2dnem_2eproto.base);
  return *internal_default_instance();
}


void NEMSignTx_NEMImportanceTransfer::Clear() {
// @@protoc_insertion_point(message_clear_start:hw.trezor.messages.nem.NEMSignTx.NEMImportanceTransfer)
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      public_key_.ClearNonDefaultToEmptyNoArena();
    }
    mode_ = 1;
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* NEMSignTx_NEMImportanceTransfer::_InternalParse(const char* begin, const char* end, void* object,
                  ::google::protobuf::internal::ParseContext* ctx) {
  auto msg = static_cast<NEMSignTx_NEMImportanceTransfer*>(object);
  ::google::protobuf::int32 size; (void)size;
  int depth; (void)depth;
  ::google::protobuf::uint32 tag;
  ::google::protobuf::internal::ParseFunc parser_till_end; (void)parser_till_end;
  auto ptr = begin;
  while (ptr < end) {
    ptr = ::google::protobuf::io::Parse32(ptr, &tag);
    GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
    switch (tag >> 3) {
      // optional .hw.trezor.messages.nem.NEMSignTx.NEMImportanceTransfer.NEMImportanceTransferMode mode = 1;
      case 1: {
        if (static_cast<::google::protobuf::uint8>(tag) != 8) goto handle_unusual;
        ::google::protobuf::uint64 val = ::google::protobuf::internal::ReadVarint(&ptr);
        if (!::hw::trezor::messages::nem::NEMSignTx_NEMImportanceTransfer_NEMImportanceTransferMode_IsValid(val)) {
          ::google::protobuf::internal::WriteVarint(1, val, msg->mutable_unknown_fields());
          break;
        }
        msg->set_mode(static_cast<::hw::trezor::messages::nem::NEMSignTx_NEMImportanceTransfer_NEMImportanceTransferMode>(val));
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        break;
      }
      // optional bytes public_key = 2;
      case 2: {
        if (static_cast<::google::protobuf::uint8>(tag) != 18) goto handle_unusual;
        ptr = ::google::protobuf::io::ReadSize(ptr, &size);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        object = msg->mutable_public_key();
        if (size > end - ptr + ::google::protobuf::internal::ParseContext::kSlopBytes) {
          parser_till_end = ::google::protobuf::internal::GreedyStringParser;
          goto string_till_end;
        }
        GOOGLE_PROTOBUF_PARSER_ASSERT(::google::protobuf::internal::StringCheck(ptr, size, ctx));
        ::google::protobuf::internal::InlineGreedyStringParser(object, ptr, size, ctx);
        ptr += size;
        break;
      }
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->EndGroup(tag);
          return ptr;
        }
        auto res = UnknownFieldParse(tag, {_InternalParse, msg},
          ptr, end, msg->_internal_metadata_.mutable_unknown_fields(), ctx);
        ptr = res.first;
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr != nullptr);
        if (res.second) return ptr;
      }
    }  // switch
  }  // while
  return ptr;
string_till_end:
  static_cast<::std::string*>(object)->clear();
  static_cast<::std::string*>(object)->reserve(size);
  goto len_delim_till_end;
len_delim_till_end:
  return ctx->StoreAndTailCall(ptr, end, {_InternalParse, msg},
                               {parser_till_end, object}, size);
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool NEMSignTx_NEMImportanceTransfer::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:hw.trezor.messages.nem.NEMSignTx.NEMImportanceTransfer)
  for (;;) {
    ::std::pair<::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .hw.trezor.messages.nem.NEMSignTx.NEMImportanceTransfer.NEMImportanceTransferMode mode = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (8 & 0xFF)) {
          int value = 0;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::hw::trezor::messages::nem::NEMSignTx_NEMImportanceTransfer_NEMImportanceTransferMode_IsValid(value)) {
            set_mode(static_cast< ::hw::trezor::messages::nem::NEMSignTx_NEMImportanceTransfer_NEMImportanceTransferMode >(value));
          } else {
            mutable_unknown_fields()->AddVarint(
                1, static_cast<::google::protobuf::uint64>(value));
          }
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional bytes public_key = 2;
      case 2: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (18 & 0xFF)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_public_key()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, _internal_metadata_.mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:hw.trezor.messages.nem.NEMSignTx.NEMImportanceTransfer)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:hw.trezor.messages.nem.NEMSignTx.NEMImportanceTransfer)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void NEMSignTx_NEMImportanceTransfer::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:hw.trezor.messages.nem.NEMSignTx.NEMImportanceTransfer)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional .hw.trezor.messages.nem.NEMSignTx.NEMImportanceTransfer.NEMImportanceTransferMode mode = 1;
  if (cached_has_bits & 0x00000002u) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      1, this->mode(), output);
  }

  // optional bytes public_key = 2;
  if (cached_has_bits & 0x00000001u) {
    ::google::protobuf::internal::WireFormatLite::WriteBytesMaybeAliased(
      2, this->public_key(), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        _internal_metadata_.unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:hw.trezor.messages.nem.NEMSignTx.NEMImportanceTransfer)
}

::google::protobuf::uint8* NEMSignTx_NEMImportanceTransfer::InternalSerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:hw.trezor.messages.nem.NEMSignTx.NEMImportanceTransfer)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional .hw.trezor.messages.nem.NEMSignTx.NEMImportanceTransfer.NEMImportanceTransferMode mode = 1;
  if (cached_has_bits & 0x00000002u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      1, this->mode(), target);
  }

  // optional bytes public_key = 2;
  if (cached_has_bits & 0x00000001u) {
    target =
      ::google::protobuf::internal::WireFormatLite::WriteBytesToArray(
        2, this->public_key(), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:hw.trezor.messages.nem.NEMSignTx.NEMImportanceTransfer)
  return target;
}

size_t NEMSignTx_NEMImportanceTransfer::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:hw.trezor.messages.nem.NEMSignTx.NEMImportanceTransfer)
  size_t total_size = 0;

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        _internal_metadata_.unknown_fields());
  }
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional bytes public_key = 2;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->public_key());
    }

    // optional .hw.trezor.messages.nem.NEMSignTx.NEMImportanceTransfer.NEMImportanceTransferMode mode = 1;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->mode());
    }

  }
  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void NEMSignTx_NEMImportanceTransfer::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:hw.trezor.messages.nem.NEMSignTx.NEMImportanceTransfer)
  GOOGLE_DCHECK_NE(&from, this);
  const NEMSignTx_NEMImportanceTransfer* source =
      ::google::protobuf::DynamicCastToGenerated<NEMSignTx_NEMImportanceTransfer>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:hw.trezor.messages.nem.NEMSignTx.NEMImportanceTransfer)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:hw.trezor.messages.nem.NEMSignTx.NEMImportanceTransfer)
    MergeFrom(*source);
  }
}

void NEMSignTx_NEMImportanceTransfer::MergeFrom(const NEMSignTx_NEMImportanceTransfer& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:hw.trezor.messages.nem.NEMSignTx.NEMImportanceTransfer)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _has_bits_[0] |= 0x00000001u;
      public_key_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.public_key_);
    }
    if (cached_has_bits & 0x00000002u) {
      mode_ = from.mode_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void NEMSignTx_NEMImportanceTransfer::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:hw.trezor.messages.nem.NEMSignTx.NEMImportanceTransfer)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void NEMSignTx_NEMImportanceTransfer::CopyFrom(const NEMSignTx_NEMImportanceTransfer& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:hw.trezor.messages.nem.NEMSignTx.NEMImportanceTransfer)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool NEMSignTx_NEMImportanceTransfer::IsInitialized() const {
  return true;
}

void NEMSignTx_NEMImportanceTransfer::Swap(NEMSignTx_NEMImportanceTransfer* other) {
  if (other == this) return;
  InternalSwap(other);
}
void NEMSignTx_NEMImportanceTransfer::InternalSwap(NEMSignTx_NEMImportanceTransfer* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  public_key_.Swap(&other->public_key_, &::google::protobuf::internal::GetEmptyStringAlreadyInited(),
    GetArenaNoVirtual());
  swap(mode_, other->mode_);
}

::google::protobuf::Metadata NEMSignTx_NEMImportanceTransfer::GetMetadata() const {
  ::google::protobuf::internal::AssignDescriptors(&::assign_descriptors_table_messages_2dnem_2eproto);
  return ::file_level_metadata_messages_2dnem_2eproto[kIndexInFileMessages];
}


// ===================================================================

void NEMSignTx::InitAsDefaultInstance() {
  ::hw::trezor::messages::nem::_NEMSignTx_default_instance_._instance.get_mutable()->transaction_ = const_cast< ::hw::trezor::messages::nem::NEMSignTx_NEMTransactionCommon*>(
      ::hw::trezor::messages::nem::NEMSignTx_NEMTransactionCommon::internal_default_instance());
  ::hw::trezor::messages::nem::_NEMSignTx_default_instance_._instance.get_mutable()->multisig_ = const_cast< ::hw::trezor::messages::nem::NEMSignTx_NEMTransactionCommon*>(
      ::hw::trezor::messages::nem::NEMSignTx_NEMTransactionCommon::internal_default_instance());
  ::hw::trezor::messages::nem::_NEMSignTx_default_instance_._instance.get_mutable()->transfer_ = const_cast< ::hw::trezor::messages::nem::NEMSignTx_NEMTransfer*>(
      ::hw::trezor::messages::nem::NEMSignTx_NEMTransfer::internal_default_instance());
  ::hw::trezor::messages::nem::_NEMSignTx_default_instance_._instance.get_mutable()->provision_namespace_ = const_cast< ::hw::trezor::messages::nem::NEMSignTx_NEMProvisionNamespace*>(
      ::hw::trezor::messages::nem::NEMSignTx_NEMProvisionNamespace::internal_default_instance());
  ::hw::trezor::messages::nem::_NEMSignTx_default_instance_._instance.get_mutable()->mosaic_creation_ = const_cast< ::hw::trezor::messages::nem::NEMSignTx_NEMMosaicCreation*>(
      ::hw::trezor::messages::nem::NEMSignTx_NEMMosaicCreation::internal_default_instance());
  ::hw::trezor::messages::nem::_NEMSignTx_default_instance_._instance.get_mutable()->supply_change_ = const_cast< ::hw::trezor::messages::nem::NEMSignTx_NEMMosaicSupplyChange*>(
      ::hw::trezor::messages::nem::NEMSignTx_NEMMosaicSupplyChange::internal_default_instance());
  ::hw::trezor::messages::nem::_NEMSignTx_default_instance_._instance.get_mutable()->aggregate_modification_ = const_cast< ::hw::trezor::messages::nem::NEMSignTx_NEMAggregateModification*>(
      ::hw::trezor::messages::nem::NEMSignTx_NEMAggregateModification::internal_default_instance());
  ::hw::trezor::messages::nem::_NEMSignTx_default_instance_._instance.get_mutable()->importance_transfer_ = const_cast< ::hw::trezor::messages::nem::NEMSignTx_NEMImportanceTransfer*>(
      ::hw::trezor::messages::nem::NEMSignTx_NEMImportanceTransfer::internal_default_instance());
}
class NEMSignTx::HasBitSetters {
 public:
  static const ::hw::trezor::messages::nem::NEMSignTx_NEMTransactionCommon& transaction(const NEMSignTx* msg);
  static void set_has_transaction(NEMSignTx* msg) {
    msg->_has_bits_[0] |= 0x00000001u;
  }
  static const ::hw::trezor::messages::nem::NEMSignTx_NEMTransactionCommon& multisig(const NEMSignTx* msg);
  static void set_has_multisig(NEMSignTx* msg) {
    msg->_has_bits_[0] |= 0x00000002u;
  }
  static const ::hw::trezor::messages::nem::NEMSignTx_NEMTransfer& transfer(const NEMSignTx* msg);
  static void set_has_transfer(NEMSignTx* msg) {
    msg->_has_bits_[0] |= 0x00000004u;
  }
  static void set_has_cosigning(NEMSignTx* msg) {
    msg->_has_bits_[0] |= 0x00000100u;
  }
  static const ::hw::trezor::messages::nem::NEMSignTx_NEMProvisionNamespace& provision_namespace(const NEMSignTx* msg);
  static void set_has_provision_namespace(NEMSignTx* msg) {
    msg->_has_bits_[0] |= 0x00000008u;
  }
  static const ::hw::trezor::messages::nem::NEMSignTx_NEMMosaicCreation& mosaic_creation(const NEMSignTx* msg);
  static void set_has_mosaic_creation(NEMSignTx* msg) {
    msg->_has_bits_[0] |= 0x00000010u;
  }
  static const ::hw::trezor::messages::nem::NEMSignTx_NEMMosaicSupplyChange& supply_change(const NEMSignTx* msg);
  static void set_has_supply_change(NEMSignTx* msg) {
    msg->_has_bits_[0] |= 0x00000020u;
  }
  static const ::hw::trezor::messages::nem::NEMSignTx_NEMAggregateModification& aggregate_modification(const NEMSignTx* msg);
  static void set_has_aggregate_modification(NEMSignTx* msg) {
    msg->_has_bits_[0] |= 0x00000040u;
  }
  static const ::hw::trezor::messages::nem::NEMSignTx_NEMImportanceTransfer& importance_transfer(const NEMSignTx* msg);
  static void set_has_importance_transfer(NEMSignTx* msg) {
    msg->_has_bits_[0] |= 0x00000080u;
  }
};

const ::hw::trezor::messages::nem::NEMSignTx_NEMTransactionCommon&
NEMSignTx::HasBitSetters::transaction(const NEMSignTx* msg) {
  return *msg->transaction_;
}
const ::hw::trezor::messages::nem::NEMSignTx_NEMTransactionCommon&
NEMSignTx::HasBitSetters::multisig(const NEMSignTx* msg) {
  return *msg->multisig_;
}
const ::hw::trezor::messages::nem::NEMSignTx_NEMTransfer&
NEMSignTx::HasBitSetters::transfer(const NEMSignTx* msg) {
  return *msg->transfer_;
}
const ::hw::trezor::messages::nem::NEMSignTx_NEMProvisionNamespace&
NEMSignTx::HasBitSetters::provision_namespace(const NEMSignTx* msg) {
  return *msg->provision_namespace_;
}
const ::hw::trezor::messages::nem::NEMSignTx_NEMMosaicCreation&
NEMSignTx::HasBitSetters::mosaic_creation(const NEMSignTx* msg) {
  return *msg->mosaic_creation_;
}
const ::hw::trezor::messages::nem::NEMSignTx_NEMMosaicSupplyChange&
NEMSignTx::HasBitSetters::supply_change(const NEMSignTx* msg) {
  return *msg->supply_change_;
}
const ::hw::trezor::messages::nem::NEMSignTx_NEMAggregateModification&
NEMSignTx::HasBitSetters::aggregate_modification(const NEMSignTx* msg) {
  return *msg->aggregate_modification_;
}
const ::hw::trezor::messages::nem::NEMSignTx_NEMImportanceTransfer&
NEMSignTx::HasBitSetters::importance_transfer(const NEMSignTx* msg) {
  return *msg->importance_transfer_;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int NEMSignTx::kTransactionFieldNumber;
const int NEMSignTx::kMultisigFieldNumber;
const int NEMSignTx::kTransferFieldNumber;
const int NEMSignTx::kCosigningFieldNumber;
const int NEMSignTx::kProvisionNamespaceFieldNumber;
const int NEMSignTx::kMosaicCreationFieldNumber;
const int NEMSignTx::kSupplyChangeFieldNumber;
const int NEMSignTx::kAggregateModificationFieldNumber;
const int NEMSignTx::kImportanceTransferFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

NEMSignTx::NEMSignTx()
  : ::google::protobuf::Message(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:hw.trezor.messages.nem.NEMSignTx)
}
NEMSignTx::NEMSignTx(const NEMSignTx& from)
  : ::google::protobuf::Message(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  if (from.has_transaction()) {
    transaction_ = new ::hw::trezor::messages::nem::NEMSignTx_NEMTransactionCommon(*from.transaction_);
  } else {
    transaction_ = nullptr;
  }
  if (from.has_multisig()) {
    multisig_ = new ::hw::trezor::messages::nem::NEMSignTx_NEMTransactionCommon(*from.multisig_);
  } else {
    multisig_ = nullptr;
  }
  if (from.has_transfer()) {
    transfer_ = new ::hw::trezor::messages::nem::NEMSignTx_NEMTransfer(*from.transfer_);
  } else {
    transfer_ = nullptr;
  }
  if (from.has_provision_namespace()) {
    provision_namespace_ = new ::hw::trezor::messages::nem::NEMSignTx_NEMProvisionNamespace(*from.provision_namespace_);
  } else {
    provision_namespace_ = nullptr;
  }
  if (from.has_mosaic_creation()) {
    mosaic_creation_ = new ::hw::trezor::messages::nem::NEMSignTx_NEMMosaicCreation(*from.mosaic_creation_);
  } else {
    mosaic_creation_ = nullptr;
  }
  if (from.has_supply_change()) {
    supply_change_ = new ::hw::trezor::messages::nem::NEMSignTx_NEMMosaicSupplyChange(*from.supply_change_);
  } else {
    supply_change_ = nullptr;
  }
  if (from.has_aggregate_modification()) {
    aggregate_modification_ = new ::hw::trezor::messages::nem::NEMSignTx_NEMAggregateModification(*from.aggregate_modification_);
  } else {
    aggregate_modification_ = nullptr;
  }
  if (from.has_importance_transfer()) {
    importance_transfer_ = new ::hw::trezor::messages::nem::NEMSignTx_NEMImportanceTransfer(*from.importance_transfer_);
  } else {
    importance_transfer_ = nullptr;
  }
  cosigning_ = from.cosigning_;
  // @@protoc_insertion_point(copy_constructor:hw.trezor.messages.nem.NEMSignTx)
}

void NEMSignTx::SharedCtor() {
  ::google::protobuf::internal::InitSCC(
      &scc_info_NEMSignTx_messages_2dnem_2eproto.base);
  ::memset(&transaction_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&cosigning_) -
      reinterpret_cast<char*>(&transaction_)) + sizeof(cosigning_));
}

NEMSignTx::~NEMSignTx() {
  // @@protoc_insertion_point(destructor:hw.trezor.messages.nem.NEMSignTx)
  SharedDtor();
}

void NEMSignTx::SharedDtor() {
  if (this != internal_default_instance()) delete transaction_;
  if (this != internal_default_instance()) delete multisig_;
  if (this != internal_default_instance()) delete transfer_;
  if (this != internal_default_instance()) delete provision_namespace_;
  if (this != internal_default_instance()) delete mosaic_creation_;
  if (this != internal_default_instance()) delete supply_change_;
  if (this != internal_default_instance()) delete aggregate_modification_;
  if (this != internal_default_instance()) delete importance_transfer_;
}

void NEMSignTx::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const NEMSignTx& NEMSignTx::default_instance() {
  ::google::protobuf::internal::InitSCC(&::scc_info_NEMSignTx_messages_2dnem_2eproto.base);
  return *internal_default_instance();
}


void NEMSignTx::Clear() {
// @@protoc_insertion_point(message_clear_start:hw.trezor.messages.nem.NEMSignTx)
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(transaction_ != nullptr);
      transaction_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(multisig_ != nullptr);
      multisig_->Clear();
    }
    if (cached_has_bits & 0x00000004u) {
      GOOGLE_DCHECK(transfer_ != nullptr);
      transfer_->Clear();
    }
    if (cached_has_bits & 0x00000008u) {
      GOOGLE_DCHECK(provision_namespace_ != nullptr);
      provision_namespace_->Clear();
    }
    if (cached_has_bits & 0x00000010u) {
      GOOGLE_DCHECK(mosaic_creation_ != nullptr);
      mosaic_creation_->Clear();
    }
    if (cached_has_bits & 0x00000020u) {
      GOOGLE_DCHECK(supply_change_ != nullptr);
      supply_change_->Clear();
    }
    if (cached_has_bits & 0x00000040u) {
      GOOGLE_DCHECK(aggregate_modification_ != nullptr);
      aggregate_modification_->Clear();
    }
    if (cached_has_bits & 0x00000080u) {
      GOOGLE_DCHECK(importance_transfer_ != nullptr);
      importance_transfer_->Clear();
    }
  }
  cosigning_ = false;
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* NEMSignTx::_InternalParse(const char* begin, const char* end, void* object,
                  ::google::protobuf::internal::ParseContext* ctx) {
  auto msg = static_cast<NEMSignTx*>(object);
  ::google::protobuf::int32 size; (void)size;
  int depth; (void)depth;
  ::google::protobuf::uint32 tag;
  ::google::protobuf::internal::ParseFunc parser_till_end; (void)parser_till_end;
  auto ptr = begin;
  while (ptr < end) {
    ptr = ::google::protobuf::io::Parse32(ptr, &tag);
    GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
    switch (tag >> 3) {
      // optional .hw.trezor.messages.nem.NEMSignTx.NEMTransactionCommon transaction = 1;
      case 1: {
        if (static_cast<::google::protobuf::uint8>(tag) != 10) goto handle_unusual;
        ptr = ::google::protobuf::io::ReadSize(ptr, &size);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        parser_till_end = ::hw::trezor::messages::nem::NEMSignTx_NEMTransactionCommon::_InternalParse;
        object = msg->mutable_transaction();
        if (size > end - ptr) goto len_delim_till_end;
        ptr += size;
        GOOGLE_PROTOBUF_PARSER_ASSERT(ctx->ParseExactRange(
            {parser_till_end, object}, ptr - size, ptr));
        break;
      }
      // optional .hw.trezor.messages.nem.NEMSignTx.NEMTransactionCommon multisig = 2;
      case 2: {
        if (static_cast<::google::protobuf::uint8>(tag) != 18) goto handle_unusual;
        ptr = ::google::protobuf::io::ReadSize(ptr, &size);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        parser_till_end = ::hw::trezor::messages::nem::NEMSignTx_NEMTransactionCommon::_InternalParse;
        object = msg->mutable_multisig();
        if (size > end - ptr) goto len_delim_till_end;
        ptr += size;
        GOOGLE_PROTOBUF_PARSER_ASSERT(ctx->ParseExactRange(
            {parser_till_end, object}, ptr - size, ptr));
        break;
      }
      // optional .hw.trezor.messages.nem.NEMSignTx.NEMTransfer transfer = 3;
      case 3: {
        if (static_cast<::google::protobuf::uint8>(tag) != 26) goto handle_unusual;
        ptr = ::google::protobuf::io::ReadSize(ptr, &size);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        parser_till_end = ::hw::trezor::messages::nem::NEMSignTx_NEMTransfer::_InternalParse;
        object = msg->mutable_transfer();
        if (size > end - ptr) goto len_delim_till_end;
        ptr += size;
        GOOGLE_PROTOBUF_PARSER_ASSERT(ctx->ParseExactRange(
            {parser_till_end, object}, ptr - size, ptr));
        break;
      }
      // optional bool cosigning = 4;
      case 4: {
        if (static_cast<::google::protobuf::uint8>(tag) != 32) goto handle_unusual;
        msg->set_cosigning(::google::protobuf::internal::ReadVarint(&ptr));
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        break;
      }
      // optional .hw.trezor.messages.nem.NEMSignTx.NEMProvisionNamespace provision_namespace = 5;
      case 5: {
        if (static_cast<::google::protobuf::uint8>(tag) != 42) goto handle_unusual;
        ptr = ::google::protobuf::io::ReadSize(ptr, &size);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        parser_till_end = ::hw::trezor::messages::nem::NEMSignTx_NEMProvisionNamespace::_InternalParse;
        object = msg->mutable_provision_namespace();
        if (size > end - ptr) goto len_delim_till_end;
        ptr += size;
        GOOGLE_PROTOBUF_PARSER_ASSERT(ctx->ParseExactRange(
            {parser_till_end, object}, ptr - size, ptr));
        break;
      }
      // optional .hw.trezor.messages.nem.NEMSignTx.NEMMosaicCreation mosaic_creation = 6;
      case 6: {
        if (static_cast<::google::protobuf::uint8>(tag) != 50) goto handle_unusual;
        ptr = ::google::protobuf::io::ReadSize(ptr, &size);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        parser_till_end = ::hw::trezor::messages::nem::NEMSignTx_NEMMosaicCreation::_InternalParse;
        object = msg->mutable_mosaic_creation();
        if (size > end - ptr) goto len_delim_till_end;
        ptr += size;
        GOOGLE_PROTOBUF_PARSER_ASSERT(ctx->ParseExactRange(
            {parser_till_end, object}, ptr - size, ptr));
        break;
      }
      // optional .hw.trezor.messages.nem.NEMSignTx.NEMMosaicSupplyChange supply_change = 7;
      case 7: {
        if (static_cast<::google::protobuf::uint8>(tag) != 58) goto handle_unusual;
        ptr = ::google::protobuf::io::ReadSize(ptr, &size);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        parser_till_end = ::hw::trezor::messages::nem::NEMSignTx_NEMMosaicSupplyChange::_InternalParse;
        object = msg->mutable_supply_change();
        if (size > end - ptr) goto len_delim_till_end;
        ptr += size;
        GOOGLE_PROTOBUF_PARSER_ASSERT(ctx->ParseExactRange(
            {parser_till_end, object}, ptr - size, ptr));
        break;
      }
      // optional .hw.trezor.messages.nem.NEMSignTx.NEMAggregateModification aggregate_modification = 8;
      case 8: {
        if (static_cast<::google::protobuf::uint8>(tag) != 66) goto handle_unusual;
        ptr = ::google::protobuf::io::ReadSize(ptr, &size);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        parser_till_end = ::hw::trezor::messages::nem::NEMSignTx_NEMAggregateModification::_InternalParse;
        object = msg->mutable_aggregate_modification();
        if (size > end - ptr) goto len_delim_till_end;
        ptr += size;
        GOOGLE_PROTOBUF_PARSER_ASSERT(ctx->ParseExactRange(
            {parser_till_end, object}, ptr - size, ptr));
        break;
      }
      // optional .hw.trezor.messages.nem.NEMSignTx.NEMImportanceTransfer importance_transfer = 9;
      case 9: {
        if (static_cast<::google::protobuf::uint8>(tag) != 74) goto handle_unusual;
        ptr = ::google::protobuf::io::ReadSize(ptr, &size);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        parser_till_end = ::hw::trezor::messages::nem::NEMSignTx_NEMImportanceTransfer::_InternalParse;
        object = msg->mutable_importance_transfer();
        if (size > end - ptr) goto len_delim_till_end;
        ptr += size;
        GOOGLE_PROTOBUF_PARSER_ASSERT(ctx->ParseExactRange(
            {parser_till_end, object}, ptr - size, ptr));
        break;
      }
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->EndGroup(tag);
          return ptr;
        }
        auto res = UnknownFieldParse(tag, {_InternalParse, msg},
          ptr, end, msg->_internal_metadata_.mutable_unknown_fields(), ctx);
        ptr = res.first;
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr != nullptr);
        if (res.second) return ptr;
      }
    }  // switch
  }  // while
  return ptr;
len_delim_till_end:
  return ctx->StoreAndTailCall(ptr, end, {_InternalParse, msg},
                               {parser_till_end, object}, size);
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool NEMSignTx::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:hw.trezor.messages.nem.NEMSignTx)
  for (;;) {
    ::std::pair<::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .hw.trezor.messages.nem.NEMSignTx.NEMTransactionCommon transaction = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (10 & 0xFF)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessage(
               input, mutable_transaction()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional .hw.trezor.messages.nem.NEMSignTx.NEMTransactionCommon multisig = 2;
      case 2: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (18 & 0xFF)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessage(
               input, mutable_multisig()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional .hw.trezor.messages.nem.NEMSignTx.NEMTransfer transfer = 3;
      case 3: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (26 & 0xFF)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessage(
               input, mutable_transfer()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional bool cosigning = 4;
      case 4: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (32 & 0xFF)) {
          HasBitSetters::set_has_cosigning(this);
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &cosigning_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional .hw.trezor.messages.nem.NEMSignTx.NEMProvisionNamespace provision_namespace = 5;
      case 5: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (42 & 0xFF)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessage(
               input, mutable_provision_namespace()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional .hw.trezor.messages.nem.NEMSignTx.NEMMosaicCreation mosaic_creation = 6;
      case 6: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (50 & 0xFF)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessage(
               input, mutable_mosaic_creation()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional .hw.trezor.messages.nem.NEMSignTx.NEMMosaicSupplyChange supply_change = 7;
      case 7: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (58 & 0xFF)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessage(
               input, mutable_supply_change()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional .hw.trezor.messages.nem.NEMSignTx.NEMAggregateModification aggregate_modification = 8;
      case 8: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (66 & 0xFF)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessage(
               input, mutable_aggregate_modification()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional .hw.trezor.messages.nem.NEMSignTx.NEMImportanceTransfer importance_transfer = 9;
      case 9: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (74 & 0xFF)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessage(
               input, mutable_importance_transfer()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, _internal_metadata_.mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:hw.trezor.messages.nem.NEMSignTx)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:hw.trezor.messages.nem.NEMSignTx)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void NEMSignTx::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:hw.trezor.messages.nem.NEMSignTx)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional .hw.trezor.messages.nem.NEMSignTx.NEMTransactionCommon transaction = 1;
  if (cached_has_bits & 0x00000001u) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, HasBitSetters::transaction(this), output);
  }

  // optional .hw.trezor.messages.nem.NEMSignTx.NEMTransactionCommon multisig = 2;
  if (cached_has_bits & 0x00000002u) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, HasBitSetters::multisig(this), output);
  }

  // optional .hw.trezor.messages.nem.NEMSignTx.NEMTransfer transfer = 3;
  if (cached_has_bits & 0x00000004u) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      3, HasBitSetters::transfer(this), output);
  }

  // optional bool cosigning = 4;
  if (cached_has_bits & 0x00000100u) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(4, this->cosigning(), output);
  }

  // optional .hw.trezor.messages.nem.NEMSignTx.NEMProvisionNamespace provision_namespace = 5;
  if (cached_has_bits & 0x00000008u) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      5, HasBitSetters::provision_namespace(this), output);
  }

  // optional .hw.trezor.messages.nem.NEMSignTx.NEMMosaicCreation mosaic_creation = 6;
  if (cached_has_bits & 0x00000010u) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      6, HasBitSetters::mosaic_creation(this), output);
  }

  // optional .hw.trezor.messages.nem.NEMSignTx.NEMMosaicSupplyChange supply_change = 7;
  if (cached_has_bits & 0x00000020u) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      7, HasBitSetters::supply_change(this), output);
  }

  // optional .hw.trezor.messages.nem.NEMSignTx.NEMAggregateModification aggregate_modification = 8;
  if (cached_has_bits & 0x00000040u) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      8, HasBitSetters::aggregate_modification(this), output);
  }

  // optional .hw.trezor.messages.nem.NEMSignTx.NEMImportanceTransfer importance_transfer = 9;
  if (cached_has_bits & 0x00000080u) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      9, HasBitSetters::importance_transfer(this), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        _internal_metadata_.unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:hw.trezor.messages.nem.NEMSignTx)
}

::google::protobuf::uint8* NEMSignTx::InternalSerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:hw.trezor.messages.nem.NEMSignTx)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional .hw.trezor.messages.nem.NEMSignTx.NEMTransactionCommon transaction = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageToArray(
        1, HasBitSetters::transaction(this), target);
  }

  // optional .hw.trezor.messages.nem.NEMSignTx.NEMTransactionCommon multisig = 2;
  if (cached_has_bits & 0x00000002u) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageToArray(
        2, HasBitSetters::multisig(this), target);
  }

  // optional .hw.trezor.messages.nem.NEMSignTx.NEMTransfer transfer = 3;
  if (cached_has_bits & 0x00000004u) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageToArray(
        3, HasBitSetters::transfer(this), target);
  }

  // optional bool cosigning = 4;
  if (cached_has_bits & 0x00000100u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteBoolToArray(4, this->cosigning(), target);
  }

  // optional .hw.trezor.messages.nem.NEMSignTx.NEMProvisionNamespace provision_namespace = 5;
  if (cached_has_bits & 0x00000008u) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageToArray(
        5, HasBitSetters::provision_namespace(this), target);
  }

  // optional .hw.trezor.messages.nem.NEMSignTx.NEMMosaicCreation mosaic_creation = 6;
  if (cached_has_bits & 0x00000010u) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageToArray(
        6, HasBitSetters::mosaic_creation(this), target);
  }

  // optional .hw.trezor.messages.nem.NEMSignTx.NEMMosaicSupplyChange supply_change = 7;
  if (cached_has_bits & 0x00000020u) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageToArray(
        7, HasBitSetters::supply_change(this), target);
  }

  // optional .hw.trezor.messages.nem.NEMSignTx.NEMAggregateModification aggregate_modification = 8;
  if (cached_has_bits & 0x00000040u) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageToArray(
        8, HasBitSetters::aggregate_modification(this), target);
  }

  // optional .hw.trezor.messages.nem.NEMSignTx.NEMImportanceTransfer importance_transfer = 9;
  if (cached_has_bits & 0x00000080u) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageToArray(
        9, HasBitSetters::importance_transfer(this), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:hw.trezor.messages.nem.NEMSignTx)
  return target;
}

size_t NEMSignTx::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:hw.trezor.messages.nem.NEMSignTx)
  size_t total_size = 0;

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        _internal_metadata_.unknown_fields());
  }
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    // optional .hw.trezor.messages.nem.NEMSignTx.NEMTransactionCommon transaction = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSize(
          *transaction_);
    }

    // optional .hw.trezor.messages.nem.NEMSignTx.NEMTransactionCommon multisig = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSize(
          *multisig_);
    }

    // optional .hw.trezor.messages.nem.NEMSignTx.NEMTransfer transfer = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSize(
          *transfer_);
    }

    // optional .hw.trezor.messages.nem.NEMSignTx.NEMProvisionNamespace provision_namespace = 5;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSize(
          *provision_namespace_);
    }

    // optional .hw.trezor.messages.nem.NEMSignTx.NEMMosaicCreation mosaic_creation = 6;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSize(
          *mosaic_creation_);
    }

    // optional .hw.trezor.messages.nem.NEMSignTx.NEMMosaicSupplyChange supply_change = 7;
    if (cached_has_bits & 0x00000020u) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSize(
          *supply_change_);
    }

    // optional .hw.trezor.messages.nem.NEMSignTx.NEMAggregateModification aggregate_modification = 8;
    if (cached_has_bits & 0x00000040u) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSize(
          *aggregate_modification_);
    }

    // optional .hw.trezor.messages.nem.NEMSignTx.NEMImportanceTransfer importance_transfer = 9;
    if (cached_has_bits & 0x00000080u) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSize(
          *importance_transfer_);
    }

  }
  // optional bool cosigning = 4;
  if (cached_has_bits & 0x00000100u) {
    total_size += 1 + 1;
  }

  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void NEMSignTx::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:hw.trezor.messages.nem.NEMSignTx)
  GOOGLE_DCHECK_NE(&from, this);
  const NEMSignTx* source =
      ::google::protobuf::DynamicCastToGenerated<NEMSignTx>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:hw.trezor.messages.nem.NEMSignTx)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:hw.trezor.messages.nem.NEMSignTx)
    MergeFrom(*source);
  }
}

void NEMSignTx::MergeFrom(const NEMSignTx& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:hw.trezor.messages.nem.NEMSignTx)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      mutable_transaction()->::hw::trezor::messages::nem::NEMSignTx_NEMTransactionCommon::MergeFrom(from.transaction());
    }
    if (cached_has_bits & 0x00000002u) {
      mutable_multisig()->::hw::trezor::messages::nem::NEMSignTx_NEMTransactionCommon::MergeFrom(from.multisig());
    }
    if (cached_has_bits & 0x00000004u) {
      mutable_transfer()->::hw::trezor::messages::nem::NEMSignTx_NEMTransfer::MergeFrom(from.transfer());
    }
    if (cached_has_bits & 0x00000008u) {
      mutable_provision_namespace()->::hw::trezor::messages::nem::NEMSignTx_NEMProvisionNamespace::MergeFrom(from.provision_namespace());
    }
    if (cached_has_bits & 0x00000010u) {
      mutable_mosaic_creation()->::hw::trezor::messages::nem::NEMSignTx_NEMMosaicCreation::MergeFrom(from.mosaic_creation());
    }
    if (cached_has_bits & 0x00000020u) {
      mutable_supply_change()->::hw::trezor::messages::nem::NEMSignTx_NEMMosaicSupplyChange::MergeFrom(from.supply_change());
    }
    if (cached_has_bits & 0x00000040u) {
      mutable_aggregate_modification()->::hw::trezor::messages::nem::NEMSignTx_NEMAggregateModification::MergeFrom(from.aggregate_modification());
    }
    if (cached_has_bits & 0x00000080u) {
      mutable_importance_transfer()->::hw::trezor::messages::nem::NEMSignTx_NEMImportanceTransfer::MergeFrom(from.importance_transfer());
    }
  }
  if (cached_has_bits & 0x00000100u) {
    set_cosigning(from.cosigning());
  }
}

void NEMSignTx::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:hw.trezor.messages.nem.NEMSignTx)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void NEMSignTx::CopyFrom(const NEMSignTx& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:hw.trezor.messages.nem.NEMSignTx)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool NEMSignTx::IsInitialized() const {
  return true;
}

void NEMSignTx::Swap(NEMSignTx* other) {
  if (other == this) return;
  InternalSwap(other);
}
void NEMSignTx::InternalSwap(NEMSignTx* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  swap(transaction_, other->transaction_);
  swap(multisig_, other->multisig_);
  swap(transfer_, other->transfer_);
  swap(provision_namespace_, other->provision_namespace_);
  swap(mosaic_creation_, other->mosaic_creation_);
  swap(supply_change_, other->supply_change_);
  swap(aggregate_modification_, other->aggregate_modification_);
  swap(importance_transfer_, other->importance_transfer_);
  swap(cosigning_, other->cosigning_);
}

::google::protobuf::Metadata NEMSignTx::GetMetadata() const {
  ::google::protobuf::internal::AssignDescriptors(&::assign_descriptors_table_messages_2dnem_2eproto);
  return ::file_level_metadata_messages_2dnem_2eproto[kIndexInFileMessages];
}


// ===================================================================

void NEMSignedTx::InitAsDefaultInstance() {
}
class NEMSignedTx::HasBitSetters {
 public:
  static void set_has_data(NEMSignedTx* msg) {
    msg->_has_bits_[0] |= 0x00000001u;
  }
  static void set_has_signature(NEMSignedTx* msg) {
    msg->_has_bits_[0] |= 0x00000002u;
  }
};

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int NEMSignedTx::kDataFieldNumber;
const int NEMSignedTx::kSignatureFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

NEMSignedTx::NEMSignedTx()
  : ::google::protobuf::Message(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:hw.trezor.messages.nem.NEMSignedTx)
}
NEMSignedTx::NEMSignedTx(const NEMSignedTx& from)
  : ::google::protobuf::Message(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  data_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (from.has_data()) {
    data_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.data_);
  }
  signature_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (from.has_signature()) {
    signature_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.signature_);
  }
  // @@protoc_insertion_point(copy_constructor:hw.trezor.messages.nem.NEMSignedTx)
}

void NEMSignedTx::SharedCtor() {
  ::google::protobuf::internal::InitSCC(
      &scc_info_NEMSignedTx_messages_2dnem_2eproto.base);
  data_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  signature_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}

NEMSignedTx::~NEMSignedTx() {
  // @@protoc_insertion_point(destructor:hw.trezor.messages.nem.NEMSignedTx)
  SharedDtor();
}

void NEMSignedTx::SharedDtor() {
  data_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  signature_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}

void NEMSignedTx::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const NEMSignedTx& NEMSignedTx::default_instance() {
  ::google::protobuf::internal::InitSCC(&::scc_info_NEMSignedTx_messages_2dnem_2eproto.base);
  return *internal_default_instance();
}


void NEMSignedTx::Clear() {
// @@protoc_insertion_point(message_clear_start:hw.trezor.messages.nem.NEMSignedTx)
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      data_.ClearNonDefaultToEmptyNoArena();
    }
    if (cached_has_bits & 0x00000002u) {
      signature_.ClearNonDefaultToEmptyNoArena();
    }
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* NEMSignedTx::_InternalParse(const char* begin, const char* end, void* object,
                  ::google::protobuf::internal::ParseContext* ctx) {
  auto msg = static_cast<NEMSignedTx*>(object);
  ::google::protobuf::int32 size; (void)size;
  int depth; (void)depth;
  ::google::protobuf::uint32 tag;
  ::google::protobuf::internal::ParseFunc parser_till_end; (void)parser_till_end;
  auto ptr = begin;
  while (ptr < end) {
    ptr = ::google::protobuf::io::Parse32(ptr, &tag);
    GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
    switch (tag >> 3) {
      // optional bytes data = 1;
      case 1: {
        if (static_cast<::google::protobuf::uint8>(tag) != 10) goto handle_unusual;
        ptr = ::google::protobuf::io::ReadSize(ptr, &size);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        object = msg->mutable_data();
        if (size > end - ptr + ::google::protobuf::internal::ParseContext::kSlopBytes) {
          parser_till_end = ::google::protobuf::internal::GreedyStringParser;
          goto string_till_end;
        }
        GOOGLE_PROTOBUF_PARSER_ASSERT(::google::protobuf::internal::StringCheck(ptr, size, ctx));
        ::google::protobuf::internal::InlineGreedyStringParser(object, ptr, size, ctx);
        ptr += size;
        break;
      }
      // optional bytes signature = 2;
      case 2: {
        if (static_cast<::google::protobuf::uint8>(tag) != 18) goto handle_unusual;
        ptr = ::google::protobuf::io::ReadSize(ptr, &size);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        object = msg->mutable_signature();
        if (size > end - ptr + ::google::protobuf::internal::ParseContext::kSlopBytes) {
          parser_till_end = ::google::protobuf::internal::GreedyStringParser;
          goto string_till_end;
        }
        GOOGLE_PROTOBUF_PARSER_ASSERT(::google::protobuf::internal::StringCheck(ptr, size, ctx));
        ::google::protobuf::internal::InlineGreedyStringParser(object, ptr, size, ctx);
        ptr += size;
        break;
      }
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->EndGroup(tag);
          return ptr;
        }
        auto res = UnknownFieldParse(tag, {_InternalParse, msg},
          ptr, end, msg->_internal_metadata_.mutable_unknown_fields(), ctx);
        ptr = res.first;
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr != nullptr);
        if (res.second) return ptr;
      }
    }  // switch
  }  // while
  return ptr;
string_till_end:
  static_cast<::std::string*>(object)->clear();
  static_cast<::std::string*>(object)->reserve(size);
  goto len_delim_till_end;
len_delim_till_end:
  return ctx->StoreAndTailCall(ptr, end, {_InternalParse, msg},
                               {parser_till_end, object}, size);
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool NEMSignedTx::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:hw.trezor.messages.nem.NEMSignedTx)
  for (;;) {
    ::std::pair<::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional bytes data = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (10 & 0xFF)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_data()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional bytes signature = 2;
      case 2: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (18 & 0xFF)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_signature()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, _internal_metadata_.mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:hw.trezor.messages.nem.NEMSignedTx)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:hw.trezor.messages.nem.NEMSignedTx)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void NEMSignedTx::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:hw.trezor.messages.nem.NEMSignedTx)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional bytes data = 1;
  if (cached_has_bits & 0x00000001u) {
    ::google::protobuf::internal::WireFormatLite::WriteBytesMaybeAliased(
      1, this->data(), output);
  }

  // optional bytes signature = 2;
  if (cached_has_bits & 0x00000002u) {
    ::google::protobuf::internal::WireFormatLite::WriteBytesMaybeAliased(
      2, this->signature(), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        _internal_metadata_.unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:hw.trezor.messages.nem.NEMSignedTx)
}

::google::protobuf::uint8* NEMSignedTx::InternalSerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:hw.trezor.messages.nem.NEMSignedTx)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional bytes data = 1;
  if (cached_has_bits & 0x00000001u) {
    target =
      ::google::protobuf::internal::WireFormatLite::WriteBytesToArray(
        1, this->data(), target);
  }

  // optional bytes signature = 2;
  if (cached_has_bits & 0x00000002u) {
    target =
      ::google::protobuf::internal::WireFormatLite::WriteBytesToArray(
        2, this->signature(), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:hw.trezor.messages.nem.NEMSignedTx)
  return target;
}

size_t NEMSignedTx::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:hw.trezor.messages.nem.NEMSignedTx)
  size_t total_size = 0;

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        _internal_metadata_.unknown_fields());
  }
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional bytes data = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->data());
    }

    // optional bytes signature = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->signature());
    }

  }
  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void NEMSignedTx::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:hw.trezor.messages.nem.NEMSignedTx)
  GOOGLE_DCHECK_NE(&from, this);
  const NEMSignedTx* source =
      ::google::protobuf::DynamicCastToGenerated<NEMSignedTx>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:hw.trezor.messages.nem.NEMSignedTx)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:hw.trezor.messages.nem.NEMSignedTx)
    MergeFrom(*source);
  }
}

void NEMSignedTx::MergeFrom(const NEMSignedTx& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:hw.trezor.messages.nem.NEMSignedTx)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _has_bits_[0] |= 0x00000001u;
      data_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.data_);
    }
    if (cached_has_bits & 0x00000002u) {
      _has_bits_[0] |= 0x00000002u;
      signature_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.signature_);
    }
  }
}

void NEMSignedTx::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:hw.trezor.messages.nem.NEMSignedTx)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void NEMSignedTx::CopyFrom(const NEMSignedTx& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:hw.trezor.messages.nem.NEMSignedTx)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool NEMSignedTx::IsInitialized() const {
  return true;
}

void NEMSignedTx::Swap(NEMSignedTx* other) {
  if (other == this) return;
  InternalSwap(other);
}
void NEMSignedTx::InternalSwap(NEMSignedTx* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  data_.Swap(&other->data_, &::google::protobuf::internal::GetEmptyStringAlreadyInited(),
    GetArenaNoVirtual());
  signature_.Swap(&other->signature_, &::google::protobuf::internal::GetEmptyStringAlreadyInited(),
    GetArenaNoVirtual());
}

::google::protobuf::Metadata NEMSignedTx::GetMetadata() const {
  ::google::protobuf::internal::AssignDescriptors(&::assign_descriptors_table_messages_2dnem_2eproto);
  return ::file_level_metadata_messages_2dnem_2eproto[kIndexInFileMessages];
}


// ===================================================================

void NEMDecryptMessage::InitAsDefaultInstance() {
}
class NEMDecryptMessage::HasBitSetters {
 public:
  static void set_has_network(NEMDecryptMessage* msg) {
    msg->_has_bits_[0] |= 0x00000004u;
  }
  static void set_has_public_key(NEMDecryptMessage* msg) {
    msg->_has_bits_[0] |= 0x00000001u;
  }
  static void set_has_payload(NEMDecryptMessage* msg) {
    msg->_has_bits_[0] |= 0x00000002u;
  }
};

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int NEMDecryptMessage::kAddressNFieldNumber;
const int NEMDecryptMessage::kNetworkFieldNumber;
const int NEMDecryptMessage::kPublicKeyFieldNumber;
const int NEMDecryptMessage::kPayloadFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

NEMDecryptMessage::NEMDecryptMessage()
  : ::google::protobuf::Message(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:hw.trezor.messages.nem.NEMDecryptMessage)
}
NEMDecryptMessage::NEMDecryptMessage(const NEMDecryptMessage& from)
  : ::google::protobuf::Message(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_),
      address_n_(from.address_n_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  public_key_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (from.has_public_key()) {
    public_key_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.public_key_);
  }
  payload_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (from.has_payload()) {
    payload_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.payload_);
  }
  network_ = from.network_;
  // @@protoc_insertion_point(copy_constructor:hw.trezor.messages.nem.NEMDecryptMessage)
}

void NEMDecryptMessage::SharedCtor() {
  ::google::protobuf::internal::InitSCC(
      &scc_info_NEMDecryptMessage_messages_2dnem_2eproto.base);
  public_key_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  payload_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  network_ = 0u;
}

NEMDecryptMessage::~NEMDecryptMessage() {
  // @@protoc_insertion_point(destructor:hw.trezor.messages.nem.NEMDecryptMessage)
  SharedDtor();
}

void NEMDecryptMessage::SharedDtor() {
  public_key_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  payload_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}

void NEMDecryptMessage::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const NEMDecryptMessage& NEMDecryptMessage::default_instance() {
  ::google::protobuf::internal::InitSCC(&::scc_info_NEMDecryptMessage_messages_2dnem_2eproto.base);
  return *internal_default_instance();
}


void NEMDecryptMessage::Clear() {
// @@protoc_insertion_point(message_clear_start:hw.trezor.messages.nem.NEMDecryptMessage)
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  address_n_.Clear();
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      public_key_.ClearNonDefaultToEmptyNoArena();
    }
    if (cached_has_bits & 0x00000002u) {
      payload_.ClearNonDefaultToEmptyNoArena();
    }
  }
  network_ = 0u;
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* NEMDecryptMessage::_InternalParse(const char* begin, const char* end, void* object,
                  ::google::protobuf::internal::ParseContext* ctx) {
  auto msg = static_cast<NEMDecryptMessage*>(object);
  ::google::protobuf::int32 size; (void)size;
  int depth; (void)depth;
  ::google::protobuf::uint32 tag;
  ::google::protobuf::internal::ParseFunc parser_till_end; (void)parser_till_end;
  auto ptr = begin;
  while (ptr < end) {
    ptr = ::google::protobuf::io::Parse32(ptr, &tag);
    GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
    switch (tag >> 3) {
      // repeated uint32 address_n = 1;
      case 1: {
        if (static_cast<::google::protobuf::uint8>(tag) == 8) {
          do {
            msg->add_address_n(::google::protobuf::internal::ReadVarint(&ptr));
            GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
            if (ptr >= end) break;
          } while ((::google::protobuf::io::UnalignedLoad<::google::protobuf::uint64>(ptr) & 255) == 8 && (ptr += 1));
          break;
        } else if (static_cast<::google::protobuf::uint8>(tag) != 10) goto handle_unusual;
        ptr = ::google::protobuf::io::ReadSize(ptr, &size);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        parser_till_end = ::google::protobuf::internal::PackedUInt32Parser;
        object = msg->mutable_address_n();
        if (size > end - ptr) goto len_delim_till_end;
        auto newend = ptr + size;
        if (size) ptr = parser_till_end(ptr, newend, object, ctx);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr == newend);
        break;
      }
      // optional uint32 network = 2;
      case 2: {
        if (static_cast<::google::protobuf::uint8>(tag) != 16) goto handle_unusual;
        msg->set_network(::google::protobuf::internal::ReadVarint(&ptr));
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        break;
      }
      // optional bytes public_key = 3;
      case 3: {
        if (static_cast<::google::protobuf::uint8>(tag) != 26) goto handle_unusual;
        ptr = ::google::protobuf::io::ReadSize(ptr, &size);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        object = msg->mutable_public_key();
        if (size > end - ptr + ::google::protobuf::internal::ParseContext::kSlopBytes) {
          parser_till_end = ::google::protobuf::internal::GreedyStringParser;
          goto string_till_end;
        }
        GOOGLE_PROTOBUF_PARSER_ASSERT(::google::protobuf::internal::StringCheck(ptr, size, ctx));
        ::google::protobuf::internal::InlineGreedyStringParser(object, ptr, size, ctx);
        ptr += size;
        break;
      }
      // optional bytes payload = 4;
      case 4: {
        if (static_cast<::google::protobuf::uint8>(tag) != 34) goto handle_unusual;
        ptr = ::google::protobuf::io::ReadSize(ptr, &size);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        object = msg->mutable_payload();
        if (size > end - ptr + ::google::protobuf::internal::ParseContext::kSlopBytes) {
          parser_till_end = ::google::protobuf::internal::GreedyStringParser;
          goto string_till_end;
        }
        GOOGLE_PROTOBUF_PARSER_ASSERT(::google::protobuf::internal::StringCheck(ptr, size, ctx));
        ::google::protobuf::internal::InlineGreedyStringParser(object, ptr, size, ctx);
        ptr += size;
        break;
      }
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->EndGroup(tag);
          return ptr;
        }
        auto res = UnknownFieldParse(tag, {_InternalParse, msg},
          ptr, end, msg->_internal_metadata_.mutable_unknown_fields(), ctx);
        ptr = res.first;
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr != nullptr);
        if (res.second) return ptr;
      }
    }  // switch
  }  // while
  return ptr;
string_till_end:
  static_cast<::std::string*>(object)->clear();
  static_cast<::std::string*>(object)->reserve(size);
  goto len_delim_till_end;
len_delim_till_end:
  return ctx->StoreAndTailCall(ptr, end, {_InternalParse, msg},
                               {parser_till_end, object}, size);
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool NEMDecryptMessage::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:hw.trezor.messages.nem.NEMDecryptMessage)
  for (;;) {
    ::std::pair<::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated uint32 address_n = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (8 & 0xFF)) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadRepeatedPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 1, 8u, input, this->mutable_address_n())));
        } else if (static_cast< ::google::protobuf::uint8>(tag) == (10 & 0xFF)) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPackedPrimitiveNoInline<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, this->mutable_address_n())));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional uint32 network = 2;
      case 2: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (16 & 0xFF)) {
          HasBitSetters::set_has_network(this);
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &network_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional bytes public_key = 3;
      case 3: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (26 & 0xFF)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_public_key()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional bytes payload = 4;
      case 4: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (34 & 0xFF)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_payload()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, _internal_metadata_.mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:hw.trezor.messages.nem.NEMDecryptMessage)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:hw.trezor.messages.nem.NEMDecryptMessage)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void NEMDecryptMessage::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:hw.trezor.messages.nem.NEMDecryptMessage)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated uint32 address_n = 1;
  for (int i = 0, n = this->address_n_size(); i < n; i++) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(
      1, this->address_n(i), output);
  }

  cached_has_bits = _has_bits_[0];
  // optional uint32 network = 2;
  if (cached_has_bits & 0x00000004u) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->network(), output);
  }

  // optional bytes public_key = 3;
  if (cached_has_bits & 0x00000001u) {
    ::google::protobuf::internal::WireFormatLite::WriteBytesMaybeAliased(
      3, this->public_key(), output);
  }

  // optional bytes payload = 4;
  if (cached_has_bits & 0x00000002u) {
    ::google::protobuf::internal::WireFormatLite::WriteBytesMaybeAliased(
      4, this->payload(), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        _internal_metadata_.unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:hw.trezor.messages.nem.NEMDecryptMessage)
}

::google::protobuf::uint8* NEMDecryptMessage::InternalSerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:hw.trezor.messages.nem.NEMDecryptMessage)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated uint32 address_n = 1;
  target = ::google::protobuf::internal::WireFormatLite::
    WriteUInt32ToArray(1, this->address_n_, target);

  cached_has_bits = _has_bits_[0];
  // optional uint32 network = 2;
  if (cached_has_bits & 0x00000004u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(2, this->network(), target);
  }

  // optional bytes public_key = 3;
  if (cached_has_bits & 0x00000001u) {
    target =
      ::google::protobuf::internal::WireFormatLite::WriteBytesToArray(
        3, this->public_key(), target);
  }

  // optional bytes payload = 4;
  if (cached_has_bits & 0x00000002u) {
    target =
      ::google::protobuf::internal::WireFormatLite::WriteBytesToArray(
        4, this->payload(), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:hw.trezor.messages.nem.NEMDecryptMessage)
  return target;
}

size_t NEMDecryptMessage::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:hw.trezor.messages.nem.NEMDecryptMessage)
  size_t total_size = 0;

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        _internal_metadata_.unknown_fields());
  }
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated uint32 address_n = 1;
  {
    size_t data_size = ::google::protobuf::internal::WireFormatLite::
      UInt32Size(this->address_n_);
    total_size += 1 *
                  ::google::protobuf::internal::FromIntSize(this->address_n_size());
    total_size += data_size;
  }

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional bytes public_key = 3;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->public_key());
    }

    // optional bytes payload = 4;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->payload());
    }

    // optional uint32 network = 2;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->network());
    }

  }
  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void NEMDecryptMessage::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:hw.trezor.messages.nem.NEMDecryptMessage)
  GOOGLE_DCHECK_NE(&from, this);
  const NEMDecryptMessage* source =
      ::google::protobuf::DynamicCastToGenerated<NEMDecryptMessage>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:hw.trezor.messages.nem.NEMDecryptMessage)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:hw.trezor.messages.nem.NEMDecryptMessage)
    MergeFrom(*source);
  }
}

void NEMDecryptMessage::MergeFrom(const NEMDecryptMessage& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:hw.trezor.messages.nem.NEMDecryptMessage)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  address_n_.MergeFrom(from.address_n_);
  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _has_bits_[0] |= 0x00000001u;
      public_key_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.public_key_);
    }
    if (cached_has_bits & 0x00000002u) {
      _has_bits_[0] |= 0x00000002u;
      payload_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.payload_);
    }
    if (cached_has_bits & 0x00000004u) {
      network_ = from.network_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void NEMDecryptMessage::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:hw.trezor.messages.nem.NEMDecryptMessage)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void NEMDecryptMessage::CopyFrom(const NEMDecryptMessage& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:hw.trezor.messages.nem.NEMDecryptMessage)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool NEMDecryptMessage::IsInitialized() const {
  return true;
}

void NEMDecryptMessage::Swap(NEMDecryptMessage* other) {
  if (other == this) return;
  InternalSwap(other);
}
void NEMDecryptMessage::InternalSwap(NEMDecryptMessage* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  address_n_.InternalSwap(&other->address_n_);
  public_key_.Swap(&other->public_key_, &::google::protobuf::internal::GetEmptyStringAlreadyInited(),
    GetArenaNoVirtual());
  payload_.Swap(&other->payload_, &::google::protobuf::internal::GetEmptyStringAlreadyInited(),
    GetArenaNoVirtual());
  swap(network_, other->network_);
}

::google::protobuf::Metadata NEMDecryptMessage::GetMetadata() const {
  ::google::protobuf::internal::AssignDescriptors(&::assign_descriptors_table_messages_2dnem_2eproto);
  return ::file_level_metadata_messages_2dnem_2eproto[kIndexInFileMessages];
}


// ===================================================================

void NEMDecryptedMessage::InitAsDefaultInstance() {
}
class NEMDecryptedMessage::HasBitSetters {
 public:
  static void set_has_payload(NEMDecryptedMessage* msg) {
    msg->_has_bits_[0] |= 0x00000001u;
  }
};

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int NEMDecryptedMessage::kPayloadFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

NEMDecryptedMessage::NEMDecryptedMessage()
  : ::google::protobuf::Message(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:hw.trezor.messages.nem.NEMDecryptedMessage)
}
NEMDecryptedMessage::NEMDecryptedMessage(const NEMDecryptedMessage& from)
  : ::google::protobuf::Message(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  payload_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (from.has_payload()) {
    payload_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.payload_);
  }
  // @@protoc_insertion_point(copy_constructor:hw.trezor.messages.nem.NEMDecryptedMessage)
}

void NEMDecryptedMessage::SharedCtor() {
  ::google::protobuf::internal::InitSCC(
      &scc_info_NEMDecryptedMessage_messages_2dnem_2eproto.base);
  payload_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}

NEMDecryptedMessage::~NEMDecryptedMessage() {
  // @@protoc_insertion_point(destructor:hw.trezor.messages.nem.NEMDecryptedMessage)
  SharedDtor();
}

void NEMDecryptedMessage::SharedDtor() {
  payload_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}

void NEMDecryptedMessage::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const NEMDecryptedMessage& NEMDecryptedMessage::default_instance() {
  ::google::protobuf::internal::InitSCC(&::scc_info_NEMDecryptedMessage_messages_2dnem_2eproto.base);
  return *internal_default_instance();
}


void NEMDecryptedMessage::Clear() {
// @@protoc_insertion_point(message_clear_start:hw.trezor.messages.nem.NEMDecryptedMessage)
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    payload_.ClearNonDefaultToEmptyNoArena();
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* NEMDecryptedMessage::_InternalParse(const char* begin, const char* end, void* object,
                  ::google::protobuf::internal::ParseContext* ctx) {
  auto msg = static_cast<NEMDecryptedMessage*>(object);
  ::google::protobuf::int32 size; (void)size;
  int depth; (void)depth;
  ::google::protobuf::uint32 tag;
  ::google::protobuf::internal::ParseFunc parser_till_end; (void)parser_till_end;
  auto ptr = begin;
  while (ptr < end) {
    ptr = ::google::protobuf::io::Parse32(ptr, &tag);
    GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
    switch (tag >> 3) {
      // optional bytes payload = 1;
      case 1: {
        if (static_cast<::google::protobuf::uint8>(tag) != 10) goto handle_unusual;
        ptr = ::google::protobuf::io::ReadSize(ptr, &size);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        object = msg->mutable_payload();
        if (size > end - ptr + ::google::protobuf::internal::ParseContext::kSlopBytes) {
          parser_till_end = ::google::protobuf::internal::GreedyStringParser;
          goto string_till_end;
        }
        GOOGLE_PROTOBUF_PARSER_ASSERT(::google::protobuf::internal::StringCheck(ptr, size, ctx));
        ::google::protobuf::internal::InlineGreedyStringParser(object, ptr, size, ctx);
        ptr += size;
        break;
      }
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->EndGroup(tag);
          return ptr;
        }
        auto res = UnknownFieldParse(tag, {_InternalParse, msg},
          ptr, end, msg->_internal_metadata_.mutable_unknown_fields(), ctx);
        ptr = res.first;
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr != nullptr);
        if (res.second) return ptr;
      }
    }  // switch
  }  // while
  return ptr;
string_till_end:
  static_cast<::std::string*>(object)->clear();
  static_cast<::std::string*>(object)->reserve(size);
  goto len_delim_till_end;
len_delim_till_end:
  return ctx->StoreAndTailCall(ptr, end, {_InternalParse, msg},
                               {parser_till_end, object}, size);
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool NEMDecryptedMessage::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:hw.trezor.messages.nem.NEMDecryptedMessage)
  for (;;) {
    ::std::pair<::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional bytes payload = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (10 & 0xFF)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_payload()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, _internal_metadata_.mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:hw.trezor.messages.nem.NEMDecryptedMessage)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:hw.trezor.messages.nem.NEMDecryptedMessage)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void NEMDecryptedMessage::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:hw.trezor.messages.nem.NEMDecryptedMessage)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional bytes payload = 1;
  if (cached_has_bits & 0x00000001u) {
    ::google::protobuf::internal::WireFormatLite::WriteBytesMaybeAliased(
      1, this->payload(), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        _internal_metadata_.unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:hw.trezor.messages.nem.NEMDecryptedMessage)
}

::google::protobuf::uint8* NEMDecryptedMessage::InternalSerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:hw.trezor.messages.nem.NEMDecryptedMessage)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional bytes payload = 1;
  if (cached_has_bits & 0x00000001u) {
    target =
      ::google::protobuf::internal::WireFormatLite::WriteBytesToArray(
        1, this->payload(), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:hw.trezor.messages.nem.NEMDecryptedMessage)
  return target;
}

size_t NEMDecryptedMessage::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:hw.trezor.messages.nem.NEMDecryptedMessage)
  size_t total_size = 0;

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        _internal_metadata_.unknown_fields());
  }
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional bytes payload = 1;
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::BytesSize(
        this->payload());
  }

  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void NEMDecryptedMessage::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:hw.trezor.messages.nem.NEMDecryptedMessage)
  GOOGLE_DCHECK_NE(&from, this);
  const NEMDecryptedMessage* source =
      ::google::protobuf::DynamicCastToGenerated<NEMDecryptedMessage>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:hw.trezor.messages.nem.NEMDecryptedMessage)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:hw.trezor.messages.nem.NEMDecryptedMessage)
    MergeFrom(*source);
  }
}

void NEMDecryptedMessage::MergeFrom(const NEMDecryptedMessage& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:hw.trezor.messages.nem.NEMDecryptedMessage)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  if (from.has_payload()) {
    _has_bits_[0] |= 0x00000001u;
    payload_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.payload_);
  }
}

void NEMDecryptedMessage::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:hw.trezor.messages.nem.NEMDecryptedMessage)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void NEMDecryptedMessage::CopyFrom(const NEMDecryptedMessage& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:hw.trezor.messages.nem.NEMDecryptedMessage)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool NEMDecryptedMessage::IsInitialized() const {
  return true;
}

void NEMDecryptedMessage::Swap(NEMDecryptedMessage* other) {
  if (other == this) return;
  InternalSwap(other);
}
void NEMDecryptedMessage::InternalSwap(NEMDecryptedMessage* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  payload_.Swap(&other->payload_, &::google::protobuf::internal::GetEmptyStringAlreadyInited(),
    GetArenaNoVirtual());
}

::google::protobuf::Metadata NEMDecryptedMessage::GetMetadata() const {
  ::google::protobuf::internal::AssignDescriptors(&::assign_descriptors_table_messages_2dnem_2eproto);
  return ::file_level_metadata_messages_2dnem_2eproto[kIndexInFileMessages];
}


// @@protoc_insertion_point(namespace_scope)
}  // namespace nem
}  // namespace messages
}  // namespace trezor
}  // namespace hw
namespace google {
namespace protobuf {
template<> PROTOBUF_NOINLINE ::hw::trezor::messages::nem::NEMGetAddress* Arena::CreateMaybeMessage< ::hw::trezor::messages::nem::NEMGetAddress >(Arena* arena) {
  return Arena::CreateInternal< ::hw::trezor::messages::nem::NEMGetAddress >(arena);
}
template<> PROTOBUF_NOINLINE ::hw::trezor::messages::nem::NEMAddress* Arena::CreateMaybeMessage< ::hw::trezor::messages::nem::NEMAddress >(Arena* arena) {
  return Arena::CreateInternal< ::hw::trezor::messages::nem::NEMAddress >(arena);
}
template<> PROTOBUF_NOINLINE ::hw::trezor::messages::nem::NEMSignTx_NEMTransactionCommon* Arena::CreateMaybeMessage< ::hw::trezor::messages::nem::NEMSignTx_NEMTransactionCommon >(Arena* arena) {
  return Arena::CreateInternal< ::hw::trezor::messages::nem::NEMSignTx_NEMTransactionCommon >(arena);
}
template<> PROTOBUF_NOINLINE ::hw::trezor::messages::nem::NEMSignTx_NEMTransfer_NEMMosaic* Arena::CreateMaybeMessage< ::hw::trezor::messages::nem::NEMSignTx_NEMTransfer_NEMMosaic >(Arena* arena) {
  return Arena::CreateInternal< ::hw::trezor::messages::nem::NEMSignTx_NEMTransfer_NEMMosaic >(arena);
}
template<> PROTOBUF_NOINLINE ::hw::trezor::messages::nem::NEMSignTx_NEMTransfer* Arena::CreateMaybeMessage< ::hw::trezor::messages::nem::NEMSignTx_NEMTransfer >(Arena* arena) {
  return Arena::CreateInternal< ::hw::trezor::messages::nem::NEMSignTx_NEMTransfer >(arena);
}
template<> PROTOBUF_NOINLINE ::hw::trezor::messages::nem::NEMSignTx_NEMProvisionNamespace* Arena::CreateMaybeMessage< ::hw::trezor::messages::nem::NEMSignTx_NEMProvisionNamespace >(Arena* arena) {
  return Arena::CreateInternal< ::hw::trezor::messages::nem::NEMSignTx_NEMProvisionNamespace >(arena);
}
template<> PROTOBUF_NOINLINE ::hw::trezor::messages::nem::NEMSignTx_NEMMosaicCreation_NEMMosaicDefinition* Arena::CreateMaybeMessage< ::hw::trezor::messages::nem::NEMSignTx_NEMMosaicCreation_NEMMosaicDefinition >(Arena* arena) {
  return Arena::CreateInternal< ::hw::trezor::messages::nem::NEMSignTx_NEMMosaicCreation_NEMMosaicDefinition >(arena);
}
template<> PROTOBUF_NOINLINE ::hw::trezor::messages::nem::NEMSignTx_NEMMosaicCreation* Arena::CreateMaybeMessage< ::hw::trezor::messages::nem::NEMSignTx_NEMMosaicCreation >(Arena* arena) {
  return Arena::CreateInternal< ::hw::trezor::messages::nem::NEMSignTx_NEMMosaicCreation >(arena);
}
template<> PROTOBUF_NOINLINE ::hw::trezor::messages::nem::NEMSignTx_NEMMosaicSupplyChange* Arena::CreateMaybeMessage< ::hw::trezor::messages::nem::NEMSignTx_NEMMosaicSupplyChange >(Arena* arena) {
  return Arena::CreateInternal< ::hw::trezor::messages::nem::NEMSignTx_NEMMosaicSupplyChange >(arena);
}
template<> PROTOBUF_NOINLINE ::hw::trezor::messages::nem::NEMSignTx_NEMAggregateModification_NEMCosignatoryModification* Arena::CreateMaybeMessage< ::hw::trezor::messages::nem::NEMSignTx_NEMAggregateModification_NEMCosignatoryModification >(Arena* arena) {
  return Arena::CreateInternal< ::hw::trezor::messages::nem::NEMSignTx_NEMAggregateModification_NEMCosignatoryModification >(arena);
}
template<> PROTOBUF_NOINLINE ::hw::trezor::messages::nem::NEMSignTx_NEMAggregateModification* Arena::CreateMaybeMessage< ::hw::trezor::messages::nem::NEMSignTx_NEMAggregateModification >(Arena* arena) {
  return Arena::CreateInternal< ::hw::trezor::messages::nem::NEMSignTx_NEMAggregateModification >(arena);
}
template<> PROTOBUF_NOINLINE ::hw::trezor::messages::nem::NEMSignTx_NEMImportanceTransfer* Arena::CreateMaybeMessage< ::hw::trezor::messages::nem::NEMSignTx_NEMImportanceTransfer >(Arena* arena) {
  return Arena::CreateInternal< ::hw::trezor::messages::nem::NEMSignTx_NEMImportanceTransfer >(arena);
}
template<> PROTOBUF_NOINLINE ::hw::trezor::messages::nem::NEMSignTx* Arena::CreateMaybeMessage< ::hw::trezor::messages::nem::NEMSignTx >(Arena* arena) {
  return Arena::CreateInternal< ::hw::trezor::messages::nem::NEMSignTx >(arena);
}
template<> PROTOBUF_NOINLINE ::hw::trezor::messages::nem::NEMSignedTx* Arena::CreateMaybeMessage< ::hw::trezor::messages::nem::NEMSignedTx >(Arena* arena) {
  return Arena::CreateInternal< ::hw::trezor::messages::nem::NEMSignedTx >(arena);
}
template<> PROTOBUF_NOINLINE ::hw::trezor::messages::nem::NEMDecryptMessage* Arena::CreateMaybeMessage< ::hw::trezor::messages::nem::NEMDecryptMessage >(Arena* arena) {
  return Arena::CreateInternal< ::hw::trezor::messages::nem::NEMDecryptMessage >(arena);
}
template<> PROTOBUF_NOINLINE ::hw::trezor::messages::nem::NEMDecryptedMessage* Arena::CreateMaybeMessage< ::hw::trezor::messages::nem::NEMDecryptedMessage >(Arena* arena) {
  return Arena::CreateInternal< ::hw::trezor::messages::nem::NEMDecryptedMessage >(arena);
}
}  // namespace protobuf
}  // namespace google

// @@protoc_insertion_point(global_scope)
#include <google/protobuf/port_undef.inc>
