// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: messages-ripple.proto

#ifndef PROTOBUF_INCLUDED_messages_2dripple_2eproto
#define PROTOBUF_INCLUDED_messages_2dripple_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3007000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3007000 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_messages_2dripple_2eproto

// Internal implementation detail -- do not use these members.
struct TableStruct_messages_2dripple_2eproto {
  static const ::google::protobuf::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::google::protobuf::internal::ParseTable schema[5]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::google::protobuf::internal::FieldMetadata field_metadata[];
  static const ::google::protobuf::internal::SerializationTable serialization_table[];
  static const ::google::protobuf::uint32 offsets[];
};
void AddDescriptors_messages_2dripple_2eproto();
namespace hw {
namespace trezor {
namespace messages {
namespace ripple {
class RippleAddress;
class RippleAddressDefaultTypeInternal;
extern RippleAddressDefaultTypeInternal _RippleAddress_default_instance_;
class RippleGetAddress;
class RippleGetAddressDefaultTypeInternal;
extern RippleGetAddressDefaultTypeInternal _RippleGetAddress_default_instance_;
class RippleSignTx;
class RippleSignTxDefaultTypeInternal;
extern RippleSignTxDefaultTypeInternal _RippleSignTx_default_instance_;
class RippleSignTx_RipplePayment;
class RippleSignTx_RipplePaymentDefaultTypeInternal;
extern RippleSignTx_RipplePaymentDefaultTypeInternal _RippleSignTx_RipplePayment_default_instance_;
class RippleSignedTx;
class RippleSignedTxDefaultTypeInternal;
extern RippleSignedTxDefaultTypeInternal _RippleSignedTx_default_instance_;
}  // namespace ripple
}  // namespace messages
}  // namespace trezor
}  // namespace hw
namespace google {
namespace protobuf {
template<> ::hw::trezor::messages::ripple::RippleAddress* Arena::CreateMaybeMessage<::hw::trezor::messages::ripple::RippleAddress>(Arena*);
template<> ::hw::trezor::messages::ripple::RippleGetAddress* Arena::CreateMaybeMessage<::hw::trezor::messages::ripple::RippleGetAddress>(Arena*);
template<> ::hw::trezor::messages::ripple::RippleSignTx* Arena::CreateMaybeMessage<::hw::trezor::messages::ripple::RippleSignTx>(Arena*);
template<> ::hw::trezor::messages::ripple::RippleSignTx_RipplePayment* Arena::CreateMaybeMessage<::hw::trezor::messages::ripple::RippleSignTx_RipplePayment>(Arena*);
template<> ::hw::trezor::messages::ripple::RippleSignedTx* Arena::CreateMaybeMessage<::hw::trezor::messages::ripple::RippleSignedTx>(Arena*);
}  // namespace protobuf
}  // namespace google
namespace hw {
namespace trezor {
namespace messages {
namespace ripple {

// ===================================================================

class RippleGetAddress final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:hw.trezor.messages.ripple.RippleGetAddress) */ {
 public:
  RippleGetAddress();
  virtual ~RippleGetAddress();

  RippleGetAddress(const RippleGetAddress& from);

  inline RippleGetAddress& operator=(const RippleGetAddress& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  RippleGetAddress(RippleGetAddress&& from) noexcept
    : RippleGetAddress() {
    *this = ::std::move(from);
  }

  inline RippleGetAddress& operator=(RippleGetAddress&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const RippleGetAddress& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const RippleGetAddress* internal_default_instance() {
    return reinterpret_cast<const RippleGetAddress*>(
               &_RippleGetAddress_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  void Swap(RippleGetAddress* other);
  friend void swap(RippleGetAddress& a, RippleGetAddress& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline RippleGetAddress* New() const final {
    return CreateMaybeMessage<RippleGetAddress>(nullptr);
  }

  RippleGetAddress* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<RippleGetAddress>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const RippleGetAddress& from);
  void MergeFrom(const RippleGetAddress& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RippleGetAddress* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated uint32 address_n = 1;
  int address_n_size() const;
  void clear_address_n();
  static const int kAddressNFieldNumber = 1;
  ::google::protobuf::uint32 address_n(int index) const;
  void set_address_n(int index, ::google::protobuf::uint32 value);
  void add_address_n(::google::protobuf::uint32 value);
  const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      address_n() const;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable_address_n();

  // optional bool show_display = 2;
  bool has_show_display() const;
  void clear_show_display();
  static const int kShowDisplayFieldNumber = 2;
  bool show_display() const;
  void set_show_display(bool value);

  // @@protoc_insertion_point(class_scope:hw.trezor.messages.ripple.RippleGetAddress)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > address_n_;
  bool show_display_;
  friend struct ::TableStruct_messages_2dripple_2eproto;
};
// -------------------------------------------------------------------

class RippleAddress final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:hw.trezor.messages.ripple.RippleAddress) */ {
 public:
  RippleAddress();
  virtual ~RippleAddress();

  RippleAddress(const RippleAddress& from);

  inline RippleAddress& operator=(const RippleAddress& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  RippleAddress(RippleAddress&& from) noexcept
    : RippleAddress() {
    *this = ::std::move(from);
  }

  inline RippleAddress& operator=(RippleAddress&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const RippleAddress& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const RippleAddress* internal_default_instance() {
    return reinterpret_cast<const RippleAddress*>(
               &_RippleAddress_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  void Swap(RippleAddress* other);
  friend void swap(RippleAddress& a, RippleAddress& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline RippleAddress* New() const final {
    return CreateMaybeMessage<RippleAddress>(nullptr);
  }

  RippleAddress* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<RippleAddress>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const RippleAddress& from);
  void MergeFrom(const RippleAddress& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RippleAddress* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string address = 1;
  bool has_address() const;
  void clear_address();
  static const int kAddressFieldNumber = 1;
  const ::std::string& address() const;
  void set_address(const ::std::string& value);
  #if LANG_CXX11
  void set_address(::std::string&& value);
  #endif
  void set_address(const char* value);
  void set_address(const char* value, size_t size);
  ::std::string* mutable_address();
  ::std::string* release_address();
  void set_allocated_address(::std::string* address);

  // @@protoc_insertion_point(class_scope:hw.trezor.messages.ripple.RippleAddress)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr address_;
  friend struct ::TableStruct_messages_2dripple_2eproto;
};
// -------------------------------------------------------------------

class RippleSignTx_RipplePayment final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:hw.trezor.messages.ripple.RippleSignTx.RipplePayment) */ {
 public:
  RippleSignTx_RipplePayment();
  virtual ~RippleSignTx_RipplePayment();

  RippleSignTx_RipplePayment(const RippleSignTx_RipplePayment& from);

  inline RippleSignTx_RipplePayment& operator=(const RippleSignTx_RipplePayment& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  RippleSignTx_RipplePayment(RippleSignTx_RipplePayment&& from) noexcept
    : RippleSignTx_RipplePayment() {
    *this = ::std::move(from);
  }

  inline RippleSignTx_RipplePayment& operator=(RippleSignTx_RipplePayment&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const RippleSignTx_RipplePayment& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const RippleSignTx_RipplePayment* internal_default_instance() {
    return reinterpret_cast<const RippleSignTx_RipplePayment*>(
               &_RippleSignTx_RipplePayment_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  void Swap(RippleSignTx_RipplePayment* other);
  friend void swap(RippleSignTx_RipplePayment& a, RippleSignTx_RipplePayment& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline RippleSignTx_RipplePayment* New() const final {
    return CreateMaybeMessage<RippleSignTx_RipplePayment>(nullptr);
  }

  RippleSignTx_RipplePayment* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<RippleSignTx_RipplePayment>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const RippleSignTx_RipplePayment& from);
  void MergeFrom(const RippleSignTx_RipplePayment& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RippleSignTx_RipplePayment* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string destination = 2;
  bool has_destination() const;
  void clear_destination();
  static const int kDestinationFieldNumber = 2;
  const ::std::string& destination() const;
  void set_destination(const ::std::string& value);
  #if LANG_CXX11
  void set_destination(::std::string&& value);
  #endif
  void set_destination(const char* value);
  void set_destination(const char* value, size_t size);
  ::std::string* mutable_destination();
  ::std::string* release_destination();
  void set_allocated_destination(::std::string* destination);

  // optional uint64 amount = 1;
  bool has_amount() const;
  void clear_amount();
  static const int kAmountFieldNumber = 1;
  ::google::protobuf::uint64 amount() const;
  void set_amount(::google::protobuf::uint64 value);

  // optional uint32 destination_tag = 3;
  bool has_destination_tag() const;
  void clear_destination_tag();
  static const int kDestinationTagFieldNumber = 3;
  ::google::protobuf::uint32 destination_tag() const;
  void set_destination_tag(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:hw.trezor.messages.ripple.RippleSignTx.RipplePayment)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr destination_;
  ::google::protobuf::uint64 amount_;
  ::google::protobuf::uint32 destination_tag_;
  friend struct ::TableStruct_messages_2dripple_2eproto;
};
// -------------------------------------------------------------------

class RippleSignTx final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:hw.trezor.messages.ripple.RippleSignTx) */ {
 public:
  RippleSignTx();
  virtual ~RippleSignTx();

  RippleSignTx(const RippleSignTx& from);

  inline RippleSignTx& operator=(const RippleSignTx& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  RippleSignTx(RippleSignTx&& from) noexcept
    : RippleSignTx() {
    *this = ::std::move(from);
  }

  inline RippleSignTx& operator=(RippleSignTx&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const RippleSignTx& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const RippleSignTx* internal_default_instance() {
    return reinterpret_cast<const RippleSignTx*>(
               &_RippleSignTx_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  void Swap(RippleSignTx* other);
  friend void swap(RippleSignTx& a, RippleSignTx& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline RippleSignTx* New() const final {
    return CreateMaybeMessage<RippleSignTx>(nullptr);
  }

  RippleSignTx* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<RippleSignTx>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const RippleSignTx& from);
  void MergeFrom(const RippleSignTx& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RippleSignTx* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef RippleSignTx_RipplePayment RipplePayment;

  // accessors -------------------------------------------------------

  // repeated uint32 address_n = 1;
  int address_n_size() const;
  void clear_address_n();
  static const int kAddressNFieldNumber = 1;
  ::google::protobuf::uint32 address_n(int index) const;
  void set_address_n(int index, ::google::protobuf::uint32 value);
  void add_address_n(::google::protobuf::uint32 value);
  const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      address_n() const;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable_address_n();

  // optional .hw.trezor.messages.ripple.RippleSignTx.RipplePayment payment = 6;
  bool has_payment() const;
  void clear_payment();
  static const int kPaymentFieldNumber = 6;
  const ::hw::trezor::messages::ripple::RippleSignTx_RipplePayment& payment() const;
  ::hw::trezor::messages::ripple::RippleSignTx_RipplePayment* release_payment();
  ::hw::trezor::messages::ripple::RippleSignTx_RipplePayment* mutable_payment();
  void set_allocated_payment(::hw::trezor::messages::ripple::RippleSignTx_RipplePayment* payment);

  // optional uint64 fee = 2;
  bool has_fee() const;
  void clear_fee();
  static const int kFeeFieldNumber = 2;
  ::google::protobuf::uint64 fee() const;
  void set_fee(::google::protobuf::uint64 value);

  // optional uint32 flags = 3;
  bool has_flags() const;
  void clear_flags();
  static const int kFlagsFieldNumber = 3;
  ::google::protobuf::uint32 flags() const;
  void set_flags(::google::protobuf::uint32 value);

  // optional uint32 sequence = 4;
  bool has_sequence() const;
  void clear_sequence();
  static const int kSequenceFieldNumber = 4;
  ::google::protobuf::uint32 sequence() const;
  void set_sequence(::google::protobuf::uint32 value);

  // optional uint32 last_ledger_sequence = 5;
  bool has_last_ledger_sequence() const;
  void clear_last_ledger_sequence();
  static const int kLastLedgerSequenceFieldNumber = 5;
  ::google::protobuf::uint32 last_ledger_sequence() const;
  void set_last_ledger_sequence(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:hw.trezor.messages.ripple.RippleSignTx)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > address_n_;
  ::hw::trezor::messages::ripple::RippleSignTx_RipplePayment* payment_;
  ::google::protobuf::uint64 fee_;
  ::google::protobuf::uint32 flags_;
  ::google::protobuf::uint32 sequence_;
  ::google::protobuf::uint32 last_ledger_sequence_;
  friend struct ::TableStruct_messages_2dripple_2eproto;
};
// -------------------------------------------------------------------

class RippleSignedTx final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:hw.trezor.messages.ripple.RippleSignedTx) */ {
 public:
  RippleSignedTx();
  virtual ~RippleSignedTx();

  RippleSignedTx(const RippleSignedTx& from);

  inline RippleSignedTx& operator=(const RippleSignedTx& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  RippleSignedTx(RippleSignedTx&& from) noexcept
    : RippleSignedTx() {
    *this = ::std::move(from);
  }

  inline RippleSignedTx& operator=(RippleSignedTx&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const RippleSignedTx& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const RippleSignedTx* internal_default_instance() {
    return reinterpret_cast<const RippleSignedTx*>(
               &_RippleSignedTx_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  void Swap(RippleSignedTx* other);
  friend void swap(RippleSignedTx& a, RippleSignedTx& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline RippleSignedTx* New() const final {
    return CreateMaybeMessage<RippleSignedTx>(nullptr);
  }

  RippleSignedTx* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<RippleSignedTx>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const RippleSignedTx& from);
  void MergeFrom(const RippleSignedTx& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RippleSignedTx* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bytes signature = 1;
  bool has_signature() const;
  void clear_signature();
  static const int kSignatureFieldNumber = 1;
  const ::std::string& signature() const;
  void set_signature(const ::std::string& value);
  #if LANG_CXX11
  void set_signature(::std::string&& value);
  #endif
  void set_signature(const char* value);
  void set_signature(const void* value, size_t size);
  ::std::string* mutable_signature();
  ::std::string* release_signature();
  void set_allocated_signature(::std::string* signature);

  // optional bytes serialized_tx = 2;
  bool has_serialized_tx() const;
  void clear_serialized_tx();
  static const int kSerializedTxFieldNumber = 2;
  const ::std::string& serialized_tx() const;
  void set_serialized_tx(const ::std::string& value);
  #if LANG_CXX11
  void set_serialized_tx(::std::string&& value);
  #endif
  void set_serialized_tx(const char* value);
  void set_serialized_tx(const void* value, size_t size);
  ::std::string* mutable_serialized_tx();
  ::std::string* release_serialized_tx();
  void set_allocated_serialized_tx(::std::string* serialized_tx);

  // @@protoc_insertion_point(class_scope:hw.trezor.messages.ripple.RippleSignedTx)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr signature_;
  ::google::protobuf::internal::ArenaStringPtr serialized_tx_;
  friend struct ::TableStruct_messages_2dripple_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// RippleGetAddress

// repeated uint32 address_n = 1;
inline int RippleGetAddress::address_n_size() const {
  return address_n_.size();
}
inline void RippleGetAddress::clear_address_n() {
  address_n_.Clear();
}
inline ::google::protobuf::uint32 RippleGetAddress::address_n(int index) const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.ripple.RippleGetAddress.address_n)
  return address_n_.Get(index);
}
inline void RippleGetAddress::set_address_n(int index, ::google::protobuf::uint32 value) {
  address_n_.Set(index, value);
  // @@protoc_insertion_point(field_set:hw.trezor.messages.ripple.RippleGetAddress.address_n)
}
inline void RippleGetAddress::add_address_n(::google::protobuf::uint32 value) {
  address_n_.Add(value);
  // @@protoc_insertion_point(field_add:hw.trezor.messages.ripple.RippleGetAddress.address_n)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
RippleGetAddress::address_n() const {
  // @@protoc_insertion_point(field_list:hw.trezor.messages.ripple.RippleGetAddress.address_n)
  return address_n_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
RippleGetAddress::mutable_address_n() {
  // @@protoc_insertion_point(field_mutable_list:hw.trezor.messages.ripple.RippleGetAddress.address_n)
  return &address_n_;
}

// optional bool show_display = 2;
inline bool RippleGetAddress::has_show_display() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RippleGetAddress::clear_show_display() {
  show_display_ = false;
  _has_bits_[0] &= ~0x00000001u;
}
inline bool RippleGetAddress::show_display() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.ripple.RippleGetAddress.show_display)
  return show_display_;
}
inline void RippleGetAddress::set_show_display(bool value) {
  _has_bits_[0] |= 0x00000001u;
  show_display_ = value;
  // @@protoc_insertion_point(field_set:hw.trezor.messages.ripple.RippleGetAddress.show_display)
}

// -------------------------------------------------------------------

// RippleAddress

// optional string address = 1;
inline bool RippleAddress::has_address() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RippleAddress::clear_address() {
  address_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::std::string& RippleAddress::address() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.ripple.RippleAddress.address)
  return address_.GetNoArena();
}
inline void RippleAddress::set_address(const ::std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  address_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:hw.trezor.messages.ripple.RippleAddress.address)
}
#if LANG_CXX11
inline void RippleAddress::set_address(::std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  address_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:hw.trezor.messages.ripple.RippleAddress.address)
}
#endif
inline void RippleAddress::set_address(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  address_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:hw.trezor.messages.ripple.RippleAddress.address)
}
inline void RippleAddress::set_address(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000001u;
  address_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:hw.trezor.messages.ripple.RippleAddress.address)
}
inline ::std::string* RippleAddress::mutable_address() {
  _has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_mutable:hw.trezor.messages.ripple.RippleAddress.address)
  return address_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* RippleAddress::release_address() {
  // @@protoc_insertion_point(field_release:hw.trezor.messages.ripple.RippleAddress.address)
  if (!has_address()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return address_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void RippleAddress::set_allocated_address(::std::string* address) {
  if (address != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  address_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), address);
  // @@protoc_insertion_point(field_set_allocated:hw.trezor.messages.ripple.RippleAddress.address)
}

// -------------------------------------------------------------------

// RippleSignTx_RipplePayment

// optional uint64 amount = 1;
inline bool RippleSignTx_RipplePayment::has_amount() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RippleSignTx_RipplePayment::clear_amount() {
  amount_ = PROTOBUF_ULONGLONG(0);
  _has_bits_[0] &= ~0x00000002u;
}
inline ::google::protobuf::uint64 RippleSignTx_RipplePayment::amount() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.ripple.RippleSignTx.RipplePayment.amount)
  return amount_;
}
inline void RippleSignTx_RipplePayment::set_amount(::google::protobuf::uint64 value) {
  _has_bits_[0] |= 0x00000002u;
  amount_ = value;
  // @@protoc_insertion_point(field_set:hw.trezor.messages.ripple.RippleSignTx.RipplePayment.amount)
}

// optional string destination = 2;
inline bool RippleSignTx_RipplePayment::has_destination() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RippleSignTx_RipplePayment::clear_destination() {
  destination_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::std::string& RippleSignTx_RipplePayment::destination() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.ripple.RippleSignTx.RipplePayment.destination)
  return destination_.GetNoArena();
}
inline void RippleSignTx_RipplePayment::set_destination(const ::std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  destination_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:hw.trezor.messages.ripple.RippleSignTx.RipplePayment.destination)
}
#if LANG_CXX11
inline void RippleSignTx_RipplePayment::set_destination(::std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  destination_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:hw.trezor.messages.ripple.RippleSignTx.RipplePayment.destination)
}
#endif
inline void RippleSignTx_RipplePayment::set_destination(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  destination_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:hw.trezor.messages.ripple.RippleSignTx.RipplePayment.destination)
}
inline void RippleSignTx_RipplePayment::set_destination(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000001u;
  destination_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:hw.trezor.messages.ripple.RippleSignTx.RipplePayment.destination)
}
inline ::std::string* RippleSignTx_RipplePayment::mutable_destination() {
  _has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_mutable:hw.trezor.messages.ripple.RippleSignTx.RipplePayment.destination)
  return destination_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* RippleSignTx_RipplePayment::release_destination() {
  // @@protoc_insertion_point(field_release:hw.trezor.messages.ripple.RippleSignTx.RipplePayment.destination)
  if (!has_destination()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return destination_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void RippleSignTx_RipplePayment::set_allocated_destination(::std::string* destination) {
  if (destination != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  destination_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), destination);
  // @@protoc_insertion_point(field_set_allocated:hw.trezor.messages.ripple.RippleSignTx.RipplePayment.destination)
}

// optional uint32 destination_tag = 3;
inline bool RippleSignTx_RipplePayment::has_destination_tag() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void RippleSignTx_RipplePayment::clear_destination_tag() {
  destination_tag_ = 0u;
  _has_bits_[0] &= ~0x00000004u;
}
inline ::google::protobuf::uint32 RippleSignTx_RipplePayment::destination_tag() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.ripple.RippleSignTx.RipplePayment.destination_tag)
  return destination_tag_;
}
inline void RippleSignTx_RipplePayment::set_destination_tag(::google::protobuf::uint32 value) {
  _has_bits_[0] |= 0x00000004u;
  destination_tag_ = value;
  // @@protoc_insertion_point(field_set:hw.trezor.messages.ripple.RippleSignTx.RipplePayment.destination_tag)
}

// -------------------------------------------------------------------

// RippleSignTx

// repeated uint32 address_n = 1;
inline int RippleSignTx::address_n_size() const {
  return address_n_.size();
}
inline void RippleSignTx::clear_address_n() {
  address_n_.Clear();
}
inline ::google::protobuf::uint32 RippleSignTx::address_n(int index) const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.ripple.RippleSignTx.address_n)
  return address_n_.Get(index);
}
inline void RippleSignTx::set_address_n(int index, ::google::protobuf::uint32 value) {
  address_n_.Set(index, value);
  // @@protoc_insertion_point(field_set:hw.trezor.messages.ripple.RippleSignTx.address_n)
}
inline void RippleSignTx::add_address_n(::google::protobuf::uint32 value) {
  address_n_.Add(value);
  // @@protoc_insertion_point(field_add:hw.trezor.messages.ripple.RippleSignTx.address_n)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
RippleSignTx::address_n() const {
  // @@protoc_insertion_point(field_list:hw.trezor.messages.ripple.RippleSignTx.address_n)
  return address_n_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
RippleSignTx::mutable_address_n() {
  // @@protoc_insertion_point(field_mutable_list:hw.trezor.messages.ripple.RippleSignTx.address_n)
  return &address_n_;
}

// optional uint64 fee = 2;
inline bool RippleSignTx::has_fee() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RippleSignTx::clear_fee() {
  fee_ = PROTOBUF_ULONGLONG(0);
  _has_bits_[0] &= ~0x00000002u;
}
inline ::google::protobuf::uint64 RippleSignTx::fee() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.ripple.RippleSignTx.fee)
  return fee_;
}
inline void RippleSignTx::set_fee(::google::protobuf::uint64 value) {
  _has_bits_[0] |= 0x00000002u;
  fee_ = value;
  // @@protoc_insertion_point(field_set:hw.trezor.messages.ripple.RippleSignTx.fee)
}

// optional uint32 flags = 3;
inline bool RippleSignTx::has_flags() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void RippleSignTx::clear_flags() {
  flags_ = 0u;
  _has_bits_[0] &= ~0x00000004u;
}
inline ::google::protobuf::uint32 RippleSignTx::flags() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.ripple.RippleSignTx.flags)
  return flags_;
}
inline void RippleSignTx::set_flags(::google::protobuf::uint32 value) {
  _has_bits_[0] |= 0x00000004u;
  flags_ = value;
  // @@protoc_insertion_point(field_set:hw.trezor.messages.ripple.RippleSignTx.flags)
}

// optional uint32 sequence = 4;
inline bool RippleSignTx::has_sequence() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void RippleSignTx::clear_sequence() {
  sequence_ = 0u;
  _has_bits_[0] &= ~0x00000008u;
}
inline ::google::protobuf::uint32 RippleSignTx::sequence() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.ripple.RippleSignTx.sequence)
  return sequence_;
}
inline void RippleSignTx::set_sequence(::google::protobuf::uint32 value) {
  _has_bits_[0] |= 0x00000008u;
  sequence_ = value;
  // @@protoc_insertion_point(field_set:hw.trezor.messages.ripple.RippleSignTx.sequence)
}

// optional uint32 last_ledger_sequence = 5;
inline bool RippleSignTx::has_last_ledger_sequence() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void RippleSignTx::clear_last_ledger_sequence() {
  last_ledger_sequence_ = 0u;
  _has_bits_[0] &= ~0x00000010u;
}
inline ::google::protobuf::uint32 RippleSignTx::last_ledger_sequence() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.ripple.RippleSignTx.last_ledger_sequence)
  return last_ledger_sequence_;
}
inline void RippleSignTx::set_last_ledger_sequence(::google::protobuf::uint32 value) {
  _has_bits_[0] |= 0x00000010u;
  last_ledger_sequence_ = value;
  // @@protoc_insertion_point(field_set:hw.trezor.messages.ripple.RippleSignTx.last_ledger_sequence)
}

// optional .hw.trezor.messages.ripple.RippleSignTx.RipplePayment payment = 6;
inline bool RippleSignTx::has_payment() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RippleSignTx::clear_payment() {
  if (payment_ != nullptr) payment_->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::hw::trezor::messages::ripple::RippleSignTx_RipplePayment& RippleSignTx::payment() const {
  const ::hw::trezor::messages::ripple::RippleSignTx_RipplePayment* p = payment_;
  // @@protoc_insertion_point(field_get:hw.trezor.messages.ripple.RippleSignTx.payment)
  return p != nullptr ? *p : *reinterpret_cast<const ::hw::trezor::messages::ripple::RippleSignTx_RipplePayment*>(
      &::hw::trezor::messages::ripple::_RippleSignTx_RipplePayment_default_instance_);
}
inline ::hw::trezor::messages::ripple::RippleSignTx_RipplePayment* RippleSignTx::release_payment() {
  // @@protoc_insertion_point(field_release:hw.trezor.messages.ripple.RippleSignTx.payment)
  _has_bits_[0] &= ~0x00000001u;
  ::hw::trezor::messages::ripple::RippleSignTx_RipplePayment* temp = payment_;
  payment_ = nullptr;
  return temp;
}
inline ::hw::trezor::messages::ripple::RippleSignTx_RipplePayment* RippleSignTx::mutable_payment() {
  _has_bits_[0] |= 0x00000001u;
  if (payment_ == nullptr) {
    auto* p = CreateMaybeMessage<::hw::trezor::messages::ripple::RippleSignTx_RipplePayment>(GetArenaNoVirtual());
    payment_ = p;
  }
  // @@protoc_insertion_point(field_mutable:hw.trezor.messages.ripple.RippleSignTx.payment)
  return payment_;
}
inline void RippleSignTx::set_allocated_payment(::hw::trezor::messages::ripple::RippleSignTx_RipplePayment* payment) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete payment_;
  }
  if (payment) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      payment = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, payment, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  payment_ = payment;
  // @@protoc_insertion_point(field_set_allocated:hw.trezor.messages.ripple.RippleSignTx.payment)
}

// -------------------------------------------------------------------

// RippleSignedTx

// optional bytes signature = 1;
inline bool RippleSignedTx::has_signature() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RippleSignedTx::clear_signature() {
  signature_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::std::string& RippleSignedTx::signature() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.ripple.RippleSignedTx.signature)
  return signature_.GetNoArena();
}
inline void RippleSignedTx::set_signature(const ::std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  signature_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:hw.trezor.messages.ripple.RippleSignedTx.signature)
}
#if LANG_CXX11
inline void RippleSignedTx::set_signature(::std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  signature_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:hw.trezor.messages.ripple.RippleSignedTx.signature)
}
#endif
inline void RippleSignedTx::set_signature(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  signature_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:hw.trezor.messages.ripple.RippleSignedTx.signature)
}
inline void RippleSignedTx::set_signature(const void* value, size_t size) {
  _has_bits_[0] |= 0x00000001u;
  signature_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:hw.trezor.messages.ripple.RippleSignedTx.signature)
}
inline ::std::string* RippleSignedTx::mutable_signature() {
  _has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_mutable:hw.trezor.messages.ripple.RippleSignedTx.signature)
  return signature_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* RippleSignedTx::release_signature() {
  // @@protoc_insertion_point(field_release:hw.trezor.messages.ripple.RippleSignedTx.signature)
  if (!has_signature()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return signature_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void RippleSignedTx::set_allocated_signature(::std::string* signature) {
  if (signature != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  signature_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), signature);
  // @@protoc_insertion_point(field_set_allocated:hw.trezor.messages.ripple.RippleSignedTx.signature)
}

// optional bytes serialized_tx = 2;
inline bool RippleSignedTx::has_serialized_tx() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RippleSignedTx::clear_serialized_tx() {
  serialized_tx_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000002u;
}
inline const ::std::string& RippleSignedTx::serialized_tx() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.ripple.RippleSignedTx.serialized_tx)
  return serialized_tx_.GetNoArena();
}
inline void RippleSignedTx::set_serialized_tx(const ::std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  serialized_tx_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:hw.trezor.messages.ripple.RippleSignedTx.serialized_tx)
}
#if LANG_CXX11
inline void RippleSignedTx::set_serialized_tx(::std::string&& value) {
  _has_bits_[0] |= 0x00000002u;
  serialized_tx_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:hw.trezor.messages.ripple.RippleSignedTx.serialized_tx)
}
#endif
inline void RippleSignedTx::set_serialized_tx(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000002u;
  serialized_tx_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:hw.trezor.messages.ripple.RippleSignedTx.serialized_tx)
}
inline void RippleSignedTx::set_serialized_tx(const void* value, size_t size) {
  _has_bits_[0] |= 0x00000002u;
  serialized_tx_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:hw.trezor.messages.ripple.RippleSignedTx.serialized_tx)
}
inline ::std::string* RippleSignedTx::mutable_serialized_tx() {
  _has_bits_[0] |= 0x00000002u;
  // @@protoc_insertion_point(field_mutable:hw.trezor.messages.ripple.RippleSignedTx.serialized_tx)
  return serialized_tx_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* RippleSignedTx::release_serialized_tx() {
  // @@protoc_insertion_point(field_release:hw.trezor.messages.ripple.RippleSignedTx.serialized_tx)
  if (!has_serialized_tx()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  return serialized_tx_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void RippleSignedTx::set_allocated_serialized_tx(::std::string* serialized_tx) {
  if (serialized_tx != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  serialized_tx_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), serialized_tx);
  // @@protoc_insertion_point(field_set_allocated:hw.trezor.messages.ripple.RippleSignedTx.serialized_tx)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace ripple
}  // namespace messages
}  // namespace trezor
}  // namespace hw

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // PROTOBUF_INCLUDED_messages_2dripple_2eproto
